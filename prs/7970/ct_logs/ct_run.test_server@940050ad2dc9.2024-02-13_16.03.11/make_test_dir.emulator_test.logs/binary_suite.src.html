<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/erts/emulator/make_test_dir/emulator_test/binary_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%</i>
<a name="2"/>    2: <i>%% %CopyrightBegin%</i>
<a name="3"/>    3: <i>%%</i>
<a name="4"/>    4: <i>%% Copyright Ericsson AB 1997-2023. All Rights Reserved.</i>
<a name="5"/>    5: <i>%%</i>
<a name="6"/>    6: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="7"/>    7: <i>%% you may not use this file except in compliance with the License.</i>
<a name="8"/>    8: <i>%% You may obtain a copy of the License at</i>
<a name="9"/>    9: <i>%%</i>
<a name="10"/>   10: <i>%%     http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="11"/>   11: <i>%%</i>
<a name="12"/>   12: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="13"/>   13: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="14"/>   14: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="15"/>   15: <i>%% See the License for the specific language governing permissions and</i>
<a name="16"/>   16: <i>%% limitations under the License.</i>
<a name="17"/>   17: <i>%%</i>
<a name="18"/>   18: <i>%% %CopyrightEnd%</i>
<a name="19"/>   19: <i>%%</i>
<a name="20"/>   20: 
<a name="21"/>   21: <b>-module</b>(binary_SUITE).
<a name="22"/>   22: 
<a name="23"/>   23: <i>%% Tests binaries and the BIFs:</i>
<a name="24"/>   24: <i>%%	list_to_binary/1</i>
<a name="25"/>   25: <i>%%      iolist_to_binary/1</i>
<a name="26"/>   26: <i>%%      list_to_bitstring/1</i>
<a name="27"/>   27: <i>%%	binary_to_list/1</i>
<a name="28"/>   28: <i>%%	binary_to_list/3</i>
<a name="29"/>   29: <i>%%	binary_to_term/1</i>
<a name="30"/>   30: <i>%%  	binary_to_term/2</i>
<a name="31"/>   31: <i>%%      bitstring_to_list/1</i>
<a name="32"/>   32: <i>%%	term_to_binary/1</i>
<a name="33"/>   33: <i>%%      erlang:external_size/1</i>
<a name="34"/>   34: <i>%%	size(Binary)</i>
<a name="35"/>   35: <i>%%      iolist_size/1</i>
<a name="36"/>   36: <i>%%	split_binary/2</i>
<a name="37"/>   37: <i>%%      hash(Binary, N)</i>
<a name="38"/>   38: <i>%%      phash(Binary, N)</i>
<a name="39"/>   39: <i>%%      phash2(Binary, N)</i>
<a name="40"/>   40: <i>%%</i>
<a name="41"/>   41: 
<a name="42"/>   42: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="43"/>   43: <b>-include_lib</b>(&quot;common_test/include/ct_event.hrl&quot;).
<a name="44"/>   44: 
<a name="45"/>   45: <b>-export</b>([all/0, suite/0,groups/0,init_per_suite/1, end_per_suite/1, 
<a name="46"/>   46: 	 init_per_group/2,end_per_group/2, 
<a name="47"/>   47: 	 init_per_testcase/2, end_per_testcase/2,
<a name="48"/>   48: 	 copy_terms/1, conversions/1, deep_lists/1, deep_bitstr_lists/1,
<a name="49"/>   49: 	 bad_list_to_binary/1, bad_binary_to_list/1,
<a name="50"/>   50: 	 t_split_binary/1, bad_split/1,
<a name="51"/>   51: 	 terms/1, terms_float/1, float_middle_endian/1,
<a name="52"/>   52:          b2t_used_big/1, t2b_deterministic/1,
<a name="53"/>   53:          t2b_minor_version/1,
<a name="54"/>   54: 	 external_size/1, t_iolist_size/1,
<a name="55"/>   55:          t_iolist_size_huge_list/1,
<a name="56"/>   56:          t_iolist_size_huge_bad_arg_list/1,
<a name="57"/>   57:          t_iolist_size_shallow_trapping/1,
<a name="58"/>   58:          t_iolist_size_shallow_short_lists/1,
<a name="59"/>   59:          t_iolist_size_shallow_tiny_lists/1,
<a name="60"/>   60:          t_iolist_size_deep_trapping/1,
<a name="61"/>   61:          t_iolist_size_deep_short_lists/1,
<a name="62"/>   62:          t_iolist_size_deep_tiny_lists/1,
<a name="63"/>   63: 	 t_hash/1,
<a name="64"/>   64:          sub_bin_copy/1,
<a name="65"/>   65: 	 bad_size/1,
<a name="66"/>   66:          unsorted_map_in_map/1,
<a name="67"/>   67: 	 bad_term_to_binary/1,
<a name="68"/>   68: 	 bad_binary_to_term_2/1,safe_binary_to_term2/1,
<a name="69"/>   69: 	 bad_binary_to_term/1, bad_terms/1, more_bad_terms/1,
<a name="70"/>   70:          big_binary_to_term/1,
<a name="71"/>   71: 	 otp_5484/1,otp_5933/1,
<a name="72"/>   72: 	 ordering/1,unaligned_order/1,gc_test/1,
<a name="73"/>   73: 	 bit_sized_binary_sizes/1,
<a name="74"/>   74: 	 otp_6817/1,deep/1,
<a name="75"/>   75:          robustness/1,otp_8117/1,
<a name="76"/>   76: 	 otp_8180/1, trapping/1, large/1,
<a name="77"/>   77: 	 error_after_yield/1, cmp_old_impl/1,
<a name="78"/>   78:          t2b_system_limit/1,
<a name="79"/>   79:          term_to_iovec/1,
<a name="80"/>   80:          is_binary_test/1,
<a name="81"/>   81:          local_ext/1]).
<a name="82"/>   82: 
<a name="83"/>   83: <i>%% Internal exports.</i>
<a name="84"/>   84: <b>-export</b>([sleeper/0,trapping_loop/4]).
<a name="85"/>   85: 
<a name="suite-0"/><a name="suite-last_expr"/><a name="86"/>   86: <b>suite</b>() -&gt; [{ct_hooks,[ts_install_cth]},
<a name="87"/>   87: 	    {timetrap,{minutes,4}}].
<a name="88"/>   88: 
<a name="all-0"/><a name="89"/>   89: <b>all</b>() -&gt;
<a name="all-last_expr"/><a name="90"/>   90:     [copy_terms, conversions, deep_lists, deep_bitstr_lists,
<a name="91"/>   91:      t_split_binary, bad_split,
<a name="92"/>   92:      bad_list_to_binary, bad_binary_to_list, terms,
<a name="93"/>   93:      terms_float, float_middle_endian, external_size, t_iolist_size,
<a name="94"/>   94:      t_iolist_size_huge_list,
<a name="95"/>   95:      t_iolist_size_huge_bad_arg_list,
<a name="96"/>   96:      {group, iolist_size_benchmarks},
<a name="97"/>   97:      b2t_used_big, t2b_deterministic,
<a name="98"/>   98:      t2b_minor_version,
<a name="99"/>   99:      bad_binary_to_term_2, safe_binary_to_term2,
<a name="100"/>  100:      bad_binary_to_term, bad_terms, t_hash, bad_size,
<a name="101"/>  101:      big_binary_to_term,
<a name="102"/>  102:      sub_bin_copy, bad_term_to_binary, t2b_system_limit,
<a name="103"/>  103:      term_to_iovec, more_bad_terms,
<a name="104"/>  104:      unsorted_map_in_map,
<a name="105"/>  105:      otp_5484, otp_5933,
<a name="106"/>  106:      ordering, unaligned_order, gc_test,
<a name="107"/>  107:      bit_sized_binary_sizes, otp_6817, otp_8117, deep,
<a name="108"/>  108:      robustness, otp_8180, trapping, large,
<a name="109"/>  109:      error_after_yield, cmp_old_impl,
<a name="110"/>  110:      is_binary_test,
<a name="111"/>  111:      local_ext].
<a name="112"/>  112: 
<a name="groups-0"/><a name="113"/>  113: <b>groups</b>() -&gt; 
<a name="groups-last_expr"/><a name="114"/>  114:     [
<a name="115"/>  115:      {
<a name="116"/>  116:       iolist_size_benchmarks, 
<a name="117"/>  117:       [],
<a name="118"/>  118:       [t_iolist_size_shallow_trapping,
<a name="119"/>  119:        t_iolist_size_shallow_short_lists,
<a name="120"/>  120:        t_iolist_size_shallow_tiny_lists,
<a name="121"/>  121:        t_iolist_size_deep_trapping,
<a name="122"/>  122:        t_iolist_size_deep_short_lists,
<a name="123"/>  123:        t_iolist_size_deep_tiny_lists
<a name="124"/>  124:       ]
<a name="125"/>  125:      }
<a name="126"/>  126:     ].
<a name="127"/>  127: 
<a name="init_per_suite-1"/><a name="128"/>  128: <b>init_per_suite</b>(Config) -&gt;
<a name="129"/>  129:     A0 = case application:start(sasl) of
<a name="130"/>  130: 	     ok -&gt; [sasl];
<a name="131"/>  131: 	     _ -&gt; []
<a name="132"/>  132: 	 end,
<a name="133"/>  133:     A = case application:start(os_mon) of
<a name="134"/>  134: 	     ok -&gt; [os_mon|A0];
<a name="135"/>  135: 	     _ -&gt; A0
<a name="136"/>  136: 	 end,
<a name="init_per_suite-last_expr"/><a name="137"/>  137:     [{started_apps, A}|Config].
<a name="138"/>  138: 
<a name="end_per_suite-1"/><a name="139"/>  139: <b>end_per_suite</b>(Config) -&gt;
<a name="140"/>  140:     As = proplists:get_value(started_apps, Config),
<a name="141"/>  141:     lists:foreach(fun (A) -&gt; application:stop(A) end, As),
<a name="end_per_suite-last_expr"/><a name="142"/>  142:     Config.
<a name="143"/>  143: 
<a name="144"/>  144: 
<a name="init_per_group-2"/><a name="145"/>  145: <b>init_per_group</b>(_GroupName, Config) -&gt;
<a name="init_per_group-last_expr"/><a name="146"/>  146:     Config.
<a name="147"/>  147: 
<a name="end_per_group-2"/><a name="148"/>  148: <b>end_per_group</b>(_GroupName, Config) -&gt;
<a name="end_per_group-last_expr"/><a name="149"/>  149:     Config.
<a name="150"/>  150: 
<a name="init_per_testcase-2"/><a name="151"/>  151: <b>init_per_testcase</b>(Func, Config) when is_atom(Func), is_list(Config) -&gt;
<a name="init_per_testcase-last_expr"/><a name="152"/>  152:     Config.
<a name="153"/>  153: 
<a name="end_per_testcase-2"/><a name="154"/>  154: <b>end_per_testcase</b>(_Func, _Config) -&gt;
<a name="end_per_testcase-last_expr"/><a name="155"/>  155:     ok.
<a name="156"/>  156: 
<a name="157"/>  157: <b>-define</b>(heap_binary_size, 64).
<a name="158"/>  158: 
<a name="159"/>  159: <b>-define</b>(MAP_EXT, 116).
<a name="160"/>  160: <b>-define</b>(SMALL_INTEGER_EXT, 97).
<a name="161"/>  161: <b>-define</b>(SMALL_ATOM_UTF8_EXT, 119).
<a name="162"/>  162: <b>-define</b>(ATOM_EXT, 100).
<a name="163"/>  163: <b>-define</b>(NIL, 106).
<a name="164"/>  164: <b>-define</b>(MAP_SMALL_MAP_LIMIT, 32).
<a name="165"/>  165: <b>-define</b>(FLOAT_EXT, 99).
<a name="166"/>  166: <b>-define</b>(NEW_FLOAT_EXT, 70).
<a name="167"/>  167: 
<a name="copy_terms-1"/><a name="168"/>  168: <b>copy_terms</b>(Config) when is_list(Config) -&gt;
<a name="169"/>  169:     Self = self(),
<a name="170"/>  170:     Pid = spawn_link(fun() -&gt; copy_server(Self) end),
<a name="171"/>  171:     F = fun(Term) -&gt;
<a name="172"/>  172: 		Pid ! Term,
<a name="173"/>  173: 		receive
<a name="174"/>  174: 		    Term -&gt; ok;
<a name="175"/>  175: 		    Other -&gt;
<a name="176"/>  176: 			io:format(&quot;Sent: ~P\nGot back:~P&quot;, [Term,12,Other,12]),
<a name="177"/>  177: 			ct:fail(bad_term)
<a name="178"/>  178: 		end
<a name="179"/>  179: 	end,
<a name="180"/>  180:     test_terms(F),
<a name="copy_terms-last_expr"/><a name="181"/>  181:     ok.
<a name="182"/>  182: 
<a name="copy_server-1"/><a name="183"/>  183: <b>copy_server</b>(Parent) -&gt;
<a name="copy_server-last_expr"/><a name="184"/>  184:     receive
<a name="185"/>  185: 	Term -&gt;
<a name="186"/>  186: 	    Parent ! Term,
<a name="187"/>  187: 	    copy_server(Parent)
<a name="188"/>  188:     end.
<a name="189"/>  189: 
<a name="190"/>  190: <i>%% Tests list_to_binary/1, binary_to_list/1 and size/1,</i>
<a name="191"/>  191: <i>%% using flat lists.</i>
<a name="192"/>  192: 
<a name="conversions-1"/><a name="193"/>  193: <b>conversions</b>(Config) when is_list(Config) -&gt;
<a name="194"/>  194:     test_bin([]),
<a name="195"/>  195:     test_bin([1]),
<a name="196"/>  196:     test_bin([1, 2]),
<a name="197"/>  197:     test_bin([1, 2, 3]),
<a name="198"/>  198:     test_bin(lists:seq(0, ?heap_binary_size)),
<a name="199"/>  199:     test_bin(lists:seq(0, ?heap_binary_size+1)),
<a name="200"/>  200:     test_bin(lists:seq(0, 255)),
<a name="201"/>  201:     test_bin(lists:duplicate(50000, $@)),
<a name="202"/>  202: 
<a name="203"/>  203:     %% Binary in list.
<a name="204"/>  204:     List = [1,2,3,4,5],
<a name="205"/>  205:     B1 = make_sub_binary(list_to_binary(List)),
<a name="206"/>  206:     5 = size(B1),
<a name="207"/>  207:     5 = size(make_unaligned_sub_binary(B1)),
<a name="208"/>  208:     40 = bit_size(B1),
<a name="209"/>  209:     40 = bit_size(make_unaligned_sub_binary(B1)),
<a name="210"/>  210:     B2 = list_to_binary([42,B1,19]),
<a name="211"/>  211:     B2 = list_to_binary([42,make_unaligned_sub_binary(B1),19]),
<a name="212"/>  212:     B2 = iolist_to_binary(B2),
<a name="213"/>  213:     B2 = iolist_to_binary(make_unaligned_sub_binary(B2)),
<a name="214"/>  214:     7 = size(B2),
<a name="215"/>  215:     7 = size(make_sub_binary(B2)),
<a name="216"/>  216:     56 = bit_size(B2),
<a name="217"/>  217:     56 = bit_size(make_sub_binary(B2)),
<a name="218"/>  218:     [42,1,2,3,4,5,19] = binary_to_list(B2),
<a name="219"/>  219:     [42,1,2,3,4,5,19] = binary_to_list(make_sub_binary(B2)),
<a name="220"/>  220:     [42,1,2,3,4,5,19] = binary_to_list(make_unaligned_sub_binary(B2)),
<a name="221"/>  221:     [42,1,2,3,4,5,19] = bitstring_to_list(B2),
<a name="222"/>  222:     [42,1,2,3,4,5,19] = bitstring_to_list(make_sub_binary(B2)),
<a name="223"/>  223:     [42,1,2,3,4,5,19] = bitstring_to_list(make_unaligned_sub_binary(B2)),
<a name="224"/>  224: 
<a name="conversions-last_expr"/><a name="225"/>  225:     ok.
<a name="226"/>  226: 
<a name="test_bin-1"/><a name="227"/>  227: <b>test_bin</b>(List) -&gt;
<a name="228"/>  228:     Size = length(List),
<a name="229"/>  229:     Bin = list_to_binary(List),
<a name="230"/>  230:     Bin = iolist_to_binary(List),
<a name="231"/>  231:     Bin = list_to_bitstring(List),
<a name="232"/>  232:     Size = iolist_size(List),
<a name="233"/>  233:     Size = iolist_size(Bin),
<a name="234"/>  234:     Size = iolist_size(make_unaligned_sub_binary(Bin)),
<a name="235"/>  235:     Size = size(Bin),
<a name="236"/>  236:     Size = size(make_sub_binary(Bin)),
<a name="237"/>  237:     Size = size(make_unaligned_sub_binary(Bin)),
<a name="238"/>  238:     List = binary_to_list(Bin),
<a name="239"/>  239:     List = binary_to_list(make_sub_binary(Bin)),
<a name="240"/>  240:     List = binary_to_list(make_unaligned_sub_binary(Bin)),
<a name="241"/>  241:     List = bitstring_to_list(Bin),
<a name="test_bin-last_expr"/><a name="242"/>  242: <b>    List = bitstring_to_list</b>(make_unaligned_sub_binary(Bin)).
<a name="243"/>  243: 
<a name="244"/>  244: <i>%% Tests list_to_binary/1, iolist_to_binary/1, list_to_bitstr/1, binary_to_list/1,3,</i>
<a name="245"/>  245: <i>%% bitstr_to_list/1, and size/1, using deep lists.</i>
<a name="246"/>  246: 
<a name="deep_lists-1"/><a name="247"/>  247: <b>deep_lists</b>(Config) when is_list(Config) -&gt;
<a name="248"/>  248:     test_deep_list([&quot;abc&quot;]),
<a name="249"/>  249:     test_deep_list([[12,13,[123,15]]]),
<a name="250"/>  250:     test_deep_list([[12,13,[lists:seq(0, 255), []]]]),
<a name="deep_lists-last_expr"/><a name="251"/>  251:     ok.
<a name="252"/>  252: 
<a name="test_deep_list-1"/><a name="253"/>  253: <b>test_deep_list</b>(List) -&gt;
<a name="254"/>  254:     FlatList = lists:flatten(List),
<a name="255"/>  255:     Size = length(FlatList),
<a name="256"/>  256:     Bin = list_to_binary(List),
<a name="257"/>  257:     Bin = iolist_to_binary(List),
<a name="258"/>  258:     Bin = iolist_to_binary(Bin),
<a name="259"/>  259:     Bin = list_to_bitstring(List),
<a name="260"/>  260:     Size = size(Bin),
<a name="261"/>  261:     Size = iolist_size(List),
<a name="262"/>  262:     Size = iolist_size(FlatList),
<a name="263"/>  263:     Size = iolist_size(Bin),
<a name="264"/>  264:     Bitsize = bit_size(Bin),
<a name="265"/>  265:     Bitsize = 8*Size,
<a name="266"/>  266:     FlatList = binary_to_list(Bin),
<a name="267"/>  267:     FlatList = bitstring_to_list(Bin),
<a name="268"/>  268:     io:format(&quot;testing plain binary...&quot;),
<a name="269"/>  269:     t_binary_to_list_3(FlatList, Bin, 1, Size),
<a name="270"/>  270:     io:format(&quot;testing unaligned sub binary...&quot;),
<a name="test_deep_list-last_expr"/><a name="271"/>  271: <b>    t_binary_to_list_3</b>(FlatList, make_unaligned_sub_binary(Bin), 1, Size).
<a name="272"/>  272: 
<a name="t_binary_to_list_3-4"/><a name="273"/>  273: <b>t_binary_to_list_3</b>(List, Bin, From, To) -&gt;
<a name="274"/>  274:     going_up(List, Bin, From, To),
<a name="275"/>  275:     going_down(List, Bin, From, To),
<a name="t_binary_to_list_3-last_expr"/><a name="276"/>  276: <b>    going_center</b>(List, Bin, From, To).
<a name="277"/>  277: 
<a name="going_up-4"/><a name="278"/>  278: <b>going_up</b>(List, Bin, From, To) when From =&lt; To -&gt;
<a name="279"/>  279:     List = binary_to_list(Bin, From, To),
<a name="280"/>  280:     going_up(tl(List), Bin, From+1, To);
<a name="281"/>  281: <b>going_up</b>(_List, _Bin, From, To) when From &gt; To -&gt;
<a name="going_up-last_expr"/><a name="282"/>  282:     ok.
<a name="283"/>  283:     
<a name="going_down-4"/><a name="284"/>  284: <b>going_down</b>(List, Bin, From, To) when To &gt; 0-&gt;
<a name="285"/>  285:     compare(List, binary_to_list(Bin, From, To), To-From+1),
<a name="286"/>  286:     going_down(List, Bin, From, To-1);
<a name="287"/>  287: <b>going_down</b>(_List, _Bin, _From, _To) -&gt;
<a name="going_down-last_expr"/><a name="288"/>  288:     ok.
<a name="289"/>  289: 
<a name="going_center-4"/><a name="290"/>  290: <b>going_center</b>(List, Bin, From, To) when From &gt;= To -&gt;
<a name="291"/>  291:     compare(List, binary_to_list(Bin, From, To), To-From+1),
<a name="292"/>  292:     going_center(tl(List), Bin, From+1, To-1);
<a name="293"/>  293: <b>going_center</b>(_List, _Bin, _From, _To) -&gt;
<a name="going_center-last_expr"/><a name="294"/>  294:     ok.
<a name="295"/>  295: 
<a name="compare-3"/><a name="296"/>  296: <b>compare</b>([X|Rest1], [X|Rest2], Left) when Left &gt; 0 -&gt;
<a name="297"/>  297:     compare(Rest1, Rest2, Left-1);
<a name="298"/>  298: <b>compare</b>([_X|_], [_Y|_], _Left) -&gt;
<a name="299"/>  299:     ct:fail(&quot;compare fail&quot;);
<a name="300"/>  300: <b>compare</b>(_List, [], 0) -&gt;
<a name="compare-last_expr"/><a name="301"/>  301:     ok.
<a name="302"/>  302: 
<a name="deep_bitstr_lists-1"/><a name="303"/>  303: <b>deep_bitstr_lists</b>(Config) when is_list(Config) -&gt;
<a name="304"/>  304:     {&lt;&lt;7:3&gt;&gt;,[&lt;&lt;7:3&gt;&gt;]} = test_deep_bitstr([&lt;&lt;7:3&gt;&gt;]),
<a name="305"/>  305:     {&lt;&lt;42,5:3&gt;&gt;=Bin,[42,&lt;&lt;5:3&gt;&gt;]=List} = test_deep_bitstr([42,&lt;&lt;5:3&gt;&gt;]),
<a name="306"/>  306:     {Bin,List} = test_deep_bitstr([42|&lt;&lt;5:3&gt;&gt;]),
<a name="307"/>  307:     {Bin,List} = test_deep_bitstr([&lt;&lt;42,5:3&gt;&gt;]),
<a name="308"/>  308:     {Bin,List} = test_deep_bitstr([&lt;&lt;1:3&gt;&gt;,&lt;&lt;10:5&gt;&gt;|&lt;&lt;5:3&gt;&gt;]),
<a name="309"/>  309:     {Bin,List} = test_deep_bitstr([&lt;&lt;1:3&gt;&gt;,&lt;&lt;10:5&gt;&gt;,&lt;&lt;5:3&gt;&gt;]),
<a name="310"/>  310:     {Bin,List} = test_deep_bitstr([[&lt;&lt;1:3&gt;&gt;,&lt;&lt;10:5&gt;&gt;],[],&lt;&lt;5:3&gt;&gt;]),
<a name="311"/>  311:     {Bin,List} = test_deep_bitstr([[[&lt;&lt;1:3&gt;&gt;]|&lt;&lt;10:5&gt;&gt;],[],&lt;&lt;5:3&gt;&gt;]),
<a name="312"/>  312:     {Bin,List} = test_deep_bitstr([[&lt;&lt;0:1&gt;&gt;,&lt;&lt;0:1&gt;&gt;,[],&lt;&lt;1:1&gt;&gt;,&lt;&lt;10:5&gt;&gt;],
<a name="313"/>  313: 					 &lt;&lt;1:1&gt;&gt;,&lt;&lt;0:1&gt;&gt;,&lt;&lt;1:1&gt;&gt;]),
<a name="deep_bitstr_lists-last_expr"/><a name="314"/>  314:     ok.
<a name="315"/>  315: 
<a name="test_deep_bitstr-1"/><a name="316"/>  316: <b>test_deep_bitstr</b>(List) -&gt;
<a name="317"/>  317:     %%{'EXIT',{badarg,_}} = list_to_binary(List),
<a name="318"/>  318:     Bin = list_to_bitstring(List),
<a name="test_deep_bitstr-last_expr"/><a name="319"/>  319: <b>    {Bin,bitstring_to_list</b>(Bin)}.
<a name="320"/>  320: 
<a name="bad_list_to_binary-1"/><a name="321"/>  321: <b>bad_list_to_binary</b>(Config) when is_list(Config) -&gt;
<a name="322"/>  322:     test_bad_bin(&lt;&lt;1:1&gt;&gt;),
<a name="323"/>  323:     test_bad_bin(atom),
<a name="324"/>  324:     test_bad_bin(42),
<a name="325"/>  325:     test_bad_bin([1|2]),
<a name="326"/>  326:     test_bad_bin([256]),
<a name="327"/>  327:     test_bad_bin([255, [256]]),
<a name="328"/>  328:     test_bad_bin([-1]),
<a name="329"/>  329:     test_bad_bin([atom_in_list]),
<a name="330"/>  330:     test_bad_bin([[&lt;&lt;8&gt;&gt;]|bad_tail]),
<a name="331"/>  331: 
<a name="332"/>  332:     {'EXIT',{badarg,_}} = (catch list_to_binary(id(&lt;&lt;1,2,3&gt;&gt;))),
<a name="333"/>  333:     {'EXIT',{badarg,_}} = (catch list_to_binary(id([&lt;&lt;42:7&gt;&gt;]))),
<a name="334"/>  334:     {'EXIT',{badarg,_}} = (catch list_to_bitstring(id(&lt;&lt;1,2,3&gt;&gt;))),
<a name="335"/>  335:     
<a name="336"/>  336:     %% Funs used to be implemented as a type of binary internally.
<a name="337"/>  337:     test_bad_bin(fun(X, Y) -&gt; X*Y end),
<a name="338"/>  338:     test_bad_bin([1,fun(X) -&gt; X + 1 end,2|fun() -&gt; 0 end]),
<a name="339"/>  339:     test_bad_bin([fun(X) -&gt; X + 1 end]),
<a name="340"/>  340: 
<a name="341"/>  341:     %% Test iolists that do not fit in the address space.
<a name="342"/>  342:     %% Unfortunately, it would be too slow to test in a 64-bit emulator.
<a name="bad_list_to_binary-last_expr"/><a name="343"/>  343: <b>    case erlang:system_info</b>(wordsize) of
<a name="344"/>  344: 	4 -&gt; huge_iolists();
<a name="345"/>  345: 	_ -&gt; ok
<a name="346"/>  346:     end.
<a name="347"/>  347: 
<a name="huge_iolists-0"/><a name="348"/>  348: <b>huge_iolists</b>() -&gt;
<a name="349"/>  349:     FourGigs = 1 bsl 32,
<a name="350"/>  350:     Sizes = [FourGigs+N || N &lt;- lists:seq(0, 64)] ++
<a name="351"/>  351: 	[1 bsl N || N &lt;- lists:seq(33, 37)],
<a name="352"/>  352:     Base = &lt;&lt;0:(1 bsl 20)/unit:8&gt;&gt;,
<a name="353"/>  353:     [begin
<a name="354"/>  354: 	 L = build_iolist(Sz, Base),
<a name="355"/>  355: 	 {'EXIT',{system_limit,_}} = (catch list_to_binary([L])),
<a name="356"/>  356: 	 {'EXIT',{system_limit,_}} = (catch list_to_bitstring([L])),
<a name="357"/>  357: 	 {'EXIT',{system_limit,_}} = (catch binary:list_to_bin([L])),
<a name="358"/>  358: 	 {'EXIT',{system_limit,_}} = (catch iolist_to_binary(L))
<a name="359"/>  359: 	 end || Sz &lt;- Sizes],
<a name="huge_iolists-last_expr"/><a name="360"/>  360:     ok.
<a name="361"/>  361: 
<a name="test_bad_bin-1"/><a name="362"/>  362: <b>test_bad_bin</b>(List) -&gt;
<a name="363"/>  363:     {'EXIT',{badarg,_}} = (catch list_to_binary(List)),
<a name="364"/>  364:     {'EXIT',{badarg,_}} = (catch iolist_to_binary(List)),
<a name="365"/>  365:     {'EXIT',{badarg,_}} = (catch list_to_bitstring(List)),
<a name="test_bad_bin-last_expr"/><a name="366"/>  366: <b>    {'EXIT',{badarg,_}} = </b>(catch iolist_size(List)).
<a name="367"/>  367: 
<a name="368"/>  368: <i>%% Tries binary_to_list/1,3 with bad arguments.</i>
<a name="bad_binary_to_list-1"/><a name="369"/>  369: <b>bad_binary_to_list</b>(Config) when is_list(Config) -&gt;
<a name="370"/>  370:     bad_bin_to_list(fun(X) -&gt; X * 42 end),
<a name="371"/>  371: 
<a name="372"/>  372:     GoodBin = list_to_binary(lists:seq(1, 10)),
<a name="373"/>  373:     bad_bin_to_list(fun(X) -&gt; X * 44 end, 1, 2),
<a name="374"/>  374:     bad_bin_to_list(GoodBin, 0, 1),
<a name="375"/>  375:     bad_bin_to_list(GoodBin, 2, 1),
<a name="376"/>  376:     bad_bin_to_list(GoodBin, 11, 11),
<a name="377"/>  377:     {'EXIT',{badarg,_}} = (catch binary_to_list(id(&lt;&lt;42:7&gt;&gt;))),
<a name="bad_binary_to_list-last_expr"/><a name="378"/>  378:     ok.
<a name="379"/>  379: 
<a name="bad_bin_to_list-1"/><a name="380"/>  380: <b>bad_bin_to_list</b>(BadBin) -&gt;
<a name="381"/>  381:     {'EXIT',{badarg,_}} = (catch binary_to_list(BadBin)),
<a name="bad_bin_to_list-last_expr"/><a name="382"/>  382: <b>    {'EXIT',{badarg,_}} = </b>(catch bitstring_to_list(BadBin)).
<a name="383"/>  383: 
<a name="bad_bin_to_list-3"/><a name="384"/>  384: <b>bad_bin_to_list</b>(Bin, First, Last) -&gt;
<a name="bad_bin_to_list-last_expr"/><a name="385"/>  385: <b>    {'EXIT',{badarg,_}} = </b>(catch binary_to_list(Bin, First, Last)).
<a name="386"/>  386:     
<a name="387"/>  387:     
<a name="388"/>  388: <i>%% Tries to split a binary at all possible positions.</i>
<a name="389"/>  389: 
<a name="t_split_binary-1"/><a name="390"/>  390: <b>t_split_binary</b>(Config) when is_list(Config) -&gt;
<a name="391"/>  391:     L = lists:seq(0, ?heap_binary_size-5), %Heap binary.
<a name="392"/>  392:     B = list_to_binary(L),
<a name="393"/>  393:     split(L, B, size(B)),
<a name="394"/>  394: 
<a name="395"/>  395:     %% Sub binary of heap binary.
<a name="396"/>  396:     split(L, make_sub_binary(B), size(B)),
<a name="397"/>  397:     {X,Y} = split_binary(B, size(B) div 2),
<a name="398"/>  398:     split(binary_to_list(X), X, size(X)),
<a name="399"/>  399: 
<a name="400"/>  400:     %% Unaligned sub binary of heap binary.
<a name="401"/>  401:     split(L, make_unaligned_sub_binary(B), size(B)),
<a name="402"/>  402:     {X,Y} = split_binary(B, size(B) div 2),
<a name="403"/>  403:     split(binary_to_list(X), X, size(X)),
<a name="404"/>  404:     
<a name="405"/>  405:     %% Reference-counted binary.
<a name="406"/>  406:     L2 = lists:seq(0, ?heap_binary_size+1),
<a name="407"/>  407:     B2 = list_to_binary(L2),
<a name="408"/>  408:     split(L2, B2, size(B2)),
<a name="409"/>  409: 
<a name="410"/>  410:     %% Sub binary of reference-counted binary.
<a name="411"/>  411:     split(L2, make_sub_binary(B2), size(B2)),
<a name="412"/>  412:     {X2,Y2} = split_binary(B2, size(B2) div 2),
<a name="413"/>  413:     split(binary_to_list(X2), X2, size(X2)),
<a name="414"/>  414: 
<a name="415"/>  415:     %% Unaligned sub binary of reference-counted binary.
<a name="416"/>  416:     split(L2, make_unaligned_sub_binary(B2), size(B2)),
<a name="417"/>  417:     {X2,Y2} = split_binary(B2, size(B2) div 2),
<a name="418"/>  418:     split(binary_to_list(X2), X2, size(X2)),
<a name="419"/>  419: 
<a name="t_split_binary-last_expr"/><a name="420"/>  420:     ok.
<a name="421"/>  421: 
<a name="split-3"/><a name="422"/>  422: <b>split</b>(L, B, Pos) when Pos &gt; 0 -&gt;
<a name="423"/>  423:     {B1, B2} = split_binary(B, Pos),
<a name="424"/>  424:     B1 = list_to_binary(lists:sublist(L, 1, Pos)),
<a name="425"/>  425:     B2 = list_to_binary(lists:nthtail(Pos, L)),
<a name="426"/>  426:     split(L, B, Pos-1);
<a name="427"/>  427: <b>split</b>(_L, _B, 0) -&gt;
<a name="split-last_expr"/><a name="428"/>  428:     ok.
<a name="429"/>  429: 
<a name="430"/>  430: <i>%% Tries split_binary/2 with bad arguments.</i>
<a name="bad_split-1"/><a name="431"/>  431: <b>bad_split</b>(Config) when is_list(Config) -&gt;
<a name="432"/>  432:     GoodBin = list_to_binary([1,2,3]),
<a name="433"/>  433:     bad_split(GoodBin, -1),
<a name="434"/>  434:     bad_split(GoodBin, 4),
<a name="435"/>  435:     bad_split(GoodBin, a),
<a name="436"/>  436: 
<a name="437"/>  437:     %% Funs are a kind of binaries.
<a name="438"/>  438:     bad_split(fun(_X) -&gt; 1 end, 1),
<a name="bad_split-last_expr"/><a name="439"/>  439:     ok.
<a name="440"/>  440:     
<a name="bad_split-2"/><a name="441"/>  441: <b>bad_split</b>(Bin, Pos) -&gt;
<a name="bad_split-last_expr"/><a name="442"/>  442: <b>    {'EXIT',{badarg,_}} = </b>(catch split_binary(Bin, Pos)).
<a name="443"/>  443: 
<a name="444"/>  444: <i>%% Test hash/2 with different type of binaries.</i>
<a name="t_hash-1"/><a name="445"/>  445: <b>t_hash</b>(Config) when is_list(Config) -&gt;
<a name="446"/>  446:     test_hash([]),
<a name="447"/>  447:     test_hash([253]),
<a name="448"/>  448:     test_hash(lists:seq(1, ?heap_binary_size)),
<a name="449"/>  449:     test_hash(lists:seq(1, ?heap_binary_size+1)),
<a name="450"/>  450:     test_hash([X rem 256 || X &lt;- lists:seq(1, 312)]),
<a name="t_hash-last_expr"/><a name="451"/>  451:     ok.
<a name="452"/>  452: 
<a name="test_hash-1"/><a name="453"/>  453: <b>test_hash</b>(List) -&gt;
<a name="454"/>  454:     Bin = list_to_binary(List),
<a name="455"/>  455:     Sbin = make_sub_binary(List),
<a name="456"/>  456:     Unaligned = make_unaligned_sub_binary(Sbin),
<a name="457"/>  457:     test_hash_1(Bin, Sbin, Unaligned, fun erlang:phash/2),
<a name="test_hash-last_expr"/><a name="458"/>  458: <b>    test_hash_1</b>(Bin, Sbin, Unaligned, fun erlang:phash2/2).
<a name="459"/>  459: 
<a name="test_hash_1-4"/><a name="460"/>  460: <b>test_hash_1</b>(Bin, Sbin, Unaligned, Hash) when is_function(Hash, 2) -&gt;
<a name="461"/>  461:     N = 65535,
<a name="test_hash_1-last_expr"/><a name="462"/>  462: <b>    case {Hash</b>(Bin, N),Hash(Sbin, N),Hash(Unaligned, N)} of
<a name="463"/>  463: 	{H,H,H} -&gt; ok;
<a name="464"/>  464: 	{H1,H2,H3} -&gt;
<a name="465"/>  465: 	    ct:fail(&quot;Different hash values: ~p, ~p, ~p\n&quot;, [H1,H2,H3])
<a name="466"/>  466:     end.
<a name="467"/>  467: 
<a name="468"/>  468: <i>%% Try bad arguments to size/1.</i>
<a name="bad_size-1"/><a name="469"/>  469: <b>bad_size</b>(Config) when is_list(Config) -&gt;
<a name="470"/>  470:     {'EXIT',{badarg,_}} = (catch size(fun(X) -&gt; X + 33 end)),
<a name="bad_size-last_expr"/><a name="471"/>  471:     ok.
<a name="472"/>  472: 
<a name="bad_term_to_binary-1"/><a name="473"/>  473: <b>bad_term_to_binary</b>(Config) when is_list(Config) -&gt;
<a name="474"/>  474:     T = id({a,b,c}),
<a name="475"/>  475:     {'EXIT',{badarg,_}} = (catch term_to_binary(T, not_a_list)),
<a name="476"/>  476:     {'EXIT',{badarg,_}} = (catch term_to_binary(T, [blurf])),
<a name="477"/>  477:     {'EXIT',{badarg,_}} = (catch term_to_binary(T, [iovec])),
<a name="478"/>  478:     {'EXIT',{badarg,_}} = (catch term_to_binary(T, [{compressed,-1}])),
<a name="479"/>  479:     {'EXIT',{badarg,_}} = (catch term_to_binary(T, [{compressed,10}])),
<a name="480"/>  480:     {'EXIT',{badarg,_}} = (catch term_to_binary(T, [{compressed,cucumber}])),
<a name="481"/>  481:     {'EXIT',{badarg,_}} = (catch term_to_binary(T, [{compressed}])),
<a name="482"/>  482:     {'EXIT',{badarg,_}} = (catch term_to_binary(T, [{version,1}|bad_tail])),
<a name="483"/>  483:     {'EXIT',{badarg,_}} = (catch term_to_binary(T, [{minor_version,-1}])),
<a name="484"/>  484:     {'EXIT',{badarg,_}} = (catch term_to_binary(T, [{minor_version,x}])),
<a name="485"/>  485: 
<a name="bad_term_to_binary-last_expr"/><a name="486"/>  486:     ok.
<a name="487"/>  487: 
<a name="t2b_system_limit-1"/><a name="488"/>  488: <b>t2b_system_limit</b>(Config) when is_list(Config) -&gt;
<a name="t2b_system_limit-last_expr"/><a name="489"/>  489: <b>    case erlang:system_info</b>(wordsize) of
<a name="490"/>  490:         8 -&gt;
<a name="491"/>  491:             case total_memory() of
<a name="492"/>  492:                 Memory when is_integer(Memory), Memory &gt; 6 -&gt;
<a name="493"/>  493:                     do_t2b_system_limit();
<a name="494"/>  494:                 _ -&gt;
<a name="495"/>  495:                     {skipped, &quot;Not enough memory on this machine&quot;}
<a name="496"/>  496:             end;
<a name="497"/>  497:         4 -&gt;
<a name="498"/>  498:             {skipped, &quot;Only interesting on 64-bit builds&quot;}
<a name="499"/>  499:     end.
<a name="500"/>  500: 
<a name="do_t2b_system_limit-0"/><a name="501"/>  501: <b>do_t2b_system_limit</b>() -&gt;
<a name="502"/>  502:     F = fun() -&gt;
<a name="503"/>  503:                 io:format(&quot;Creating HugeBin~n&quot;, []),
<a name="504"/>  504:                 Bits = (1 bsl 32) + 1,
<a name="505"/>  505:                 HugeBin = &lt;&lt;0:Bits/unit:8&gt;&gt;,
<a name="506"/>  506:                 test_t2b_system_limit(HugeBin, term_to_binary,
<a name="507"/>  507:                                       fun erlang:term_to_binary/1,
<a name="508"/>  508:                                       fun erlang:term_to_binary/2),
<a name="509"/>  509:                 test_t2b_system_limit(HugeBin, term_to_iovec,
<a name="510"/>  510:                                       fun erlang:term_to_iovec/1,
<a name="511"/>  511:                                       fun erlang:term_to_iovec/2),
<a name="512"/>  512:                 garbage_collect(),
<a name="513"/>  513:                 ok
<a name="514"/>  514:         end,
<a name="515"/>  515:     {ok, Peer, Node} = ?CT_PEER(),
<a name="516"/>  516:     erpc:call(Node, F),
<a name="do_t2b_system_limit-last_expr"/><a name="517"/>  517: <b>    peer:stop</b>(Peer).
<a name="518"/>  518: 
<a name="test_t2b_system_limit-4"/><a name="519"/>  519: <b>test_t2b_system_limit</b>(HugeBin, Name, F1, F2) -&gt;
<a name="520"/>  520:     io:format(&quot;Testing ~p(HugeBin)~n&quot;, [Name]),
<a name="521"/>  521:     {'EXIT',{system_limit,[{erlang,Name,[HugeBin],_}|_]}} =
<a name="522"/>  522:         t2b_eval(fun() -&gt; F1(HugeBin) end),
<a name="523"/>  523: 
<a name="524"/>  524:     io:format(&quot;Testing ~p(HugeBin, [compressed])~n&quot;, [Name]),
<a name="525"/>  525:     {'EXIT',{system_limit,[{erlang,Name,[HugeBin,[compressed]],_}|_]}} =
<a name="526"/>  526:         t2b_eval(fun() -&gt; F2(HugeBin, [compressed]) end),
<a name="527"/>  527: 
<a name="528"/>  528:     %% Check that it works also after we have trapped...
<a name="529"/>  529:     io:format(&quot;Creating HugeListBin~n&quot;, []),
<a name="530"/>  530:     HugeListBin = [lists:duplicate(2000000, 2000000), HugeBin],
<a name="531"/>  531: 
<a name="532"/>  532:     io:format(&quot;Testing ~p(HugeListBin)~n&quot;, [Name]),
<a name="533"/>  533:     {'EXIT',{system_limit,[{erlang,Name,[HugeListBin],_}|_]}} =
<a name="534"/>  534:         t2b_eval(fun() -&gt; F1(HugeListBin) end),
<a name="535"/>  535: 
<a name="536"/>  536:     io:format(&quot;Testing ~p(HugeListBin, [compressed])~n&quot;, [Name]),
<a name="537"/>  537:     {'EXIT',{system_limit,[{erlang,Name,[HugeListBin,[compressed]],_}|_]}} =
<a name="538"/>  538:         t2b_eval(fun() -&gt; F2(HugeListBin, [compressed]) end),
<a name="539"/>  539: 
<a name="test_t2b_system_limit-last_expr"/><a name="540"/>  540:     ok.
<a name="541"/>  541: 
<a name="t2b_eval-1"/><a name="542"/>  542: <b>t2b_eval</b>(F) -&gt;
<a name="543"/>  543:     Result = (catch F()),
<a name="544"/>  544:     io:put_chars(io_lib:format(&quot;~P\n&quot;, [Result,100])),
<a name="t2b_eval-last_expr"/><a name="545"/>  545:     Result.
<a name="546"/>  546: 
<a name="term_to_iovec-1"/><a name="547"/>  547: <b>term_to_iovec</b>(Config) when is_list(Config) -&gt;
<a name="548"/>  548:     Bin = list_to_binary(lists:duplicate(1000,100)),
<a name="549"/>  549:     Bin2 = list_to_binary(lists:duplicate(65,100)),
<a name="550"/>  550:     check_term_to_iovec({[Bin, atom, Bin, 1244, make_ref(), Bin]}),
<a name="551"/>  551:     check_term_to_iovec(Bin),
<a name="552"/>  552:     check_term_to_iovec([Bin,Bin,Bin,Bin]),
<a name="553"/>  553:     check_term_to_iovec(blipp),
<a name="554"/>  554:     check_term_to_iovec(lists:duplicate(1000,100)),
<a name="555"/>  555:     check_term_to_iovec([[Bin2]]),
<a name="556"/>  556:     check_term_to_iovec([erlang:ports(), Bin, erlang:processes()]),
<a name="term_to_iovec-last_expr"/><a name="557"/>  557:     ok.
<a name="558"/>  558: 
<a name="check_term_to_iovec-1"/><a name="559"/>  559: <b>check_term_to_iovec</b>(Term) -&gt;
<a name="560"/>  560:     IoVec1 = erlang:term_to_iovec(Term),
<a name="561"/>  561:     ok = check_is_iovec(IoVec1),
<a name="562"/>  562:     IoVec2 = erlang:term_to_iovec(Term, []),
<a name="563"/>  563:     ok = check_is_iovec(IoVec2),
<a name="564"/>  564:     B = erlang:term_to_binary(Term),
<a name="565"/>  565:     IoVec1Bin = erlang:iolist_to_binary(IoVec1),
<a name="566"/>  566:     IoVec2Bin = erlang:iolist_to_binary(IoVec2),
<a name="567"/>  567:     try
<a name="568"/>  568:         B = IoVec1Bin
<a name="569"/>  569:     catch
<a name="570"/>  570:         _:_ -&gt;
<a name="571"/>  571:             io:format(&quot;Binary: ~p~n&quot;, [B]),
<a name="572"/>  572:             io:format(&quot;I/O vec1 binary: ~p~n&quot;, [IoVec1Bin]),
<a name="573"/>  573:             io:format(&quot;I/O vec1: ~p~n&quot;, [IoVec1]),
<a name="574"/>  574:             ct:fail(not_same_result)
<a name="575"/>  575:     end,
<a name="check_term_to_iovec-last_expr"/><a name="576"/>  576:     try
<a name="577"/>  577:         B = IoVec2Bin
<a name="578"/>  578:     catch
<a name="579"/>  579:         _:_ -&gt;
<a name="580"/>  580:             io:format(&quot;Binary: ~p~n&quot;, [B]),
<a name="581"/>  581:             io:format(&quot;I/O vec2 binary: ~p~n&quot;, [IoVec2Bin]),
<a name="582"/>  582:             io:format(&quot;I/O vec2: ~p~n&quot;, [IoVec2]),
<a name="583"/>  583:             ct:fail(not_same_result)
<a name="584"/>  584:     end.
<a name="585"/>  585:     
<a name="check_is_iovec-1"/><a name="586"/>  586: <b>check_is_iovec</b>([]) -&gt;
<a name="587"/>  587:     ok;
<a name="588"/>  588: <b>check_is_iovec</b>([B|Bs]) when is_binary(B) -&gt;
<a name="check_is_iovec-last_expr"/><a name="589"/>  589: <b>    check_is_iovec</b>(Bs).
<a name="590"/>  590: 
<a name="591"/>  591: <i>%% Tests binary_to_term/1 and term_to_binary/1.</i>
<a name="592"/>  592: 
<a name="terms-1"/><a name="593"/>  593: <b>terms</b>(Config) when is_list(Config) -&gt;
<a name="594"/>  594:     TestFun = fun(Term) -&gt;
<a name="595"/>  595:                       S = io_lib:format(&quot;~p&quot;, [Term]),
<a name="596"/>  596:                       io:put_chars(S),
<a name="597"/>  597: 
<a name="598"/>  598: 		      Bin = term_to_binary(Term),
<a name="599"/>  599: 		      case erlang:external_size(Bin) of
<a name="600"/>  600: 			  Sz when is_integer(Sz), size(Bin) =&lt; Sz -&gt;
<a name="601"/>  601: 			      ok
<a name="602"/>  602: 		      end,
<a name="603"/>  603: 
<a name="604"/>  604:                       Bin1 = term_to_binary(Term, [{minor_version, 1}]),
<a name="605"/>  605:                       case erlang:external_size(Bin1, [{minor_version, 1}]) of
<a name="606"/>  606:                           Sz1 when is_integer(Sz1), size(Bin1) =&lt; Sz1 -&gt;
<a name="607"/>  607:                               ok
<a name="608"/>  608:                       end,
<a name="609"/>  609: 
<a name="610"/>  610:                       BinDet = term_to_binary(Term, [deterministic]),
<a name="611"/>  611:                       case erlang:external_size(Bin) of
<a name="612"/>  612:                           DetSz when is_integer(DetSz), byte_size(Bin) =&lt; DetSz -&gt;
<a name="613"/>  613:                               ok
<a name="614"/>  614:                       end,
<a name="615"/>  615: 
<a name="616"/>  616: 		      Term = binary_to_term_stress(Bin),
<a name="617"/>  617: 		      Term = binary_to_term_stress(Bin, [safe]),
<a name="618"/>  618: 		      Term = binary_to_term_stress(BinDet),
<a name="619"/>  619:                       Bin_sz = byte_size(Bin),
<a name="620"/>  620: 		      {Term,Bin_sz} = binary_to_term_stress(Bin, [used]),
<a name="621"/>  621: 
<a name="622"/>  622:                       BinE = &lt;&lt;Bin/binary, 1, 2, 3&gt;&gt;,
<a name="623"/>  623: 		      {Term,Bin_sz} = binary_to_term_stress(BinE, [used]),
<a name="624"/>  624: 
<a name="625"/>  625: 		      BinU = make_unaligned_sub_binary(Bin),
<a name="626"/>  626: 		      Term = binary_to_term_stress(BinU),
<a name="627"/>  627: 		      Term = binary_to_term_stress(BinU, []),
<a name="628"/>  628: 		      Term = binary_to_term_stress(BinU, [safe]),
<a name="629"/>  629: 		      {Term,Bin_sz} = binary_to_term_stress(BinU, [used]),
<a name="630"/>  630: 
<a name="631"/>  631:                       BinUE = make_unaligned_sub_binary(BinE),
<a name="632"/>  632: 		      {Term,Bin_sz} = binary_to_term_stress(BinUE, [used]),
<a name="633"/>  633: 
<a name="634"/>  634: 		      BinC = erlang:term_to_binary(Term, [compressed]),
<a name="635"/>  635:                       BinC_sz = byte_size(BinC),
<a name="636"/>  636: 		      true = BinC_sz =&lt; size(Bin),
<a name="637"/>  637: 		      Term = binary_to_term_stress(BinC),
<a name="638"/>  638: 		      {Term, BinC_sz} = binary_to_term_stress(BinC, [used]),
<a name="639"/>  639: 
<a name="640"/>  640: 		      Bin = term_to_binary(Term, [{compressed,0}]),
<a name="641"/>  641: 		      terms_compression_levels(Term, size(Bin), 1),
<a name="642"/>  642: 
<a name="643"/>  643: 		      BinUC = make_unaligned_sub_binary(BinC),
<a name="644"/>  644: 		      Term = binary_to_term_stress(BinUC),
<a name="645"/>  645:                       {Term,BinC_sz} = binary_to_term_stress(BinUC, [used]),
<a name="646"/>  646: 
<a name="647"/>  647:                       BinCE = &lt;&lt;BinC/binary, 1, 2, 3&gt;&gt;,
<a name="648"/>  648: 		      {Term,BinC_sz} = binary_to_term_stress(BinCE, [used]),
<a name="649"/>  649: 
<a name="650"/>  650: 		      BinUCE = make_unaligned_sub_binary(BinCE),
<a name="651"/>  651: 		      Term = binary_to_term_stress(BinUCE),
<a name="652"/>  652:                       {Term,BinC_sz} = binary_to_term_stress(BinUCE, [used])
<a name="653"/>  653: 	      end,
<a name="654"/>  654:     test_terms(TestFun),
<a name="terms-last_expr"/><a name="655"/>  655:     ok.
<a name="656"/>  656: 
<a name="657"/>  657: <i>%% Test binary_to_term(_, [used]) returning a big Used integer.</i>
<a name="b2t_used_big-1"/><a name="658"/>  658: <b>b2t_used_big</b>(_Config) -&gt;
<a name="b2t_used_big-last_expr"/><a name="659"/>  659: <b>    case erlang:system_info</b>(wordsize) of
<a name="660"/>  660:         8 -&gt;
<a name="661"/>  661:             {skipped, &quot;This is not a 32-bit machine&quot;};
<a name="662"/>  662:         4 -&gt;
<a name="663"/>  663:             %% Use a long utf8 atom for large external format but compact on heap.
<a name="664"/>  664:             BigAtom = binary_to_atom(&lt;&lt; &lt;&lt;16#F0908D88:32&gt;&gt; || _ &lt;- lists:seq(1,255) &gt;&gt;,
<a name="665"/>  665:                                      utf8),
<a name="666"/>  666:             Atoms = (1 bsl 17) + (1 bsl 9),
<a name="667"/>  667:             BigAtomList = lists:duplicate(Atoms, BigAtom),
<a name="668"/>  668:             BigBin = term_to_binary(BigAtomList),
<a name="669"/>  669:             {BigAtomList, Used} = binary_to_term(BigBin, [used]),
<a name="670"/>  670:             2 = erts_debug:size(Used),
<a name="671"/>  671:             Used = byte_size(BigBin),
<a name="672"/>  672:             Used = 1 + 1 + 4 + Atoms*(1+2+4*255) + 1,
<a name="673"/>  673:             ok
<a name="674"/>  674:     end.
<a name="675"/>  675: 
<a name="terms_compression_levels-3"/><a name="676"/>  676: <b>terms_compression_levels</b>(Term, UncompressedSz, Level) when Level &lt; 10 -&gt;
<a name="677"/>  677:     BinC = erlang:term_to_binary(Term, [{compressed,Level}]),
<a name="678"/>  678:     Term = binary_to_term_stress(BinC),
<a name="679"/>  679:     Sz = byte_size(BinC),
<a name="680"/>  680:     true = Sz =&lt; UncompressedSz,
<a name="681"/>  681:     terms_compression_levels(Term, UncompressedSz, Level+1);
<a name="terms_compression_levels-last_expr"/><a name="682"/>  682: <b>terms_compression_levels</b>(_, _, _) -&gt; ok.
<a name="683"/>  683: 
<a name="terms_float-1"/><a name="684"/>  684: <b>terms_float</b>(Config) when is_list(Config) -&gt;
<a name="terms_float-last_expr"/><a name="685"/>  685: <b>    test_floats</b>(fun(Term) -&gt;
<a name="686"/>  686: 			      Bin0 = term_to_binary(Term, [{minor_version,0}]),
<a name="687"/>  687: 			      Term = binary_to_term_stress(Bin0),
<a name="688"/>  688: 			      Bin1 = term_to_binary(Term),
<a name="689"/>  689: 			      Bin1 = term_to_binary(Term, [{minor_version,1}]),
<a name="690"/>  690: 			      Term = binary_to_term_stress(Bin1),
<a name="691"/>  691: 			      true = size(Bin1) &lt; size(Bin0),
<a name="692"/>  692:                   Size0 = erlang:external_size(Term, [{minor_version, 0}]),
<a name="693"/>  693:                   Size1 = erlang:external_size(Term),
<a name="694"/>  694:                   Size11 = erlang:external_size(Term, [{minor_version, 1}]),
<a name="695"/>  695:                   true = (Size1 =:= Size11),
<a name="696"/>  696:                   true = Size1 &lt; Size0
<a name="697"/>  697: 		      end).
<a name="698"/>  698: 
<a name="float_middle_endian-1"/><a name="699"/>  699: <b>float_middle_endian</b>(Config) when is_list(Config) -&gt;
<a name="700"/>  700:     %% Testing for roundtrip is not enough.
<a name="701"/>  701:     &lt;&lt;131,70,63,240,0,0,0,0,0,0&gt;&gt; = term_to_binary(1.0, [{minor_version,1}]),
<a name="float_middle_endian-last_expr"/><a name="702"/>  702: <b>    1.0 = binary_to_term_stress</b>(&lt;&lt;131,70,63,240,0,0,0,0,0,0&gt;&gt;).
<a name="703"/>  703: 
<a name="t2b_minor_version-1"/><a name="704"/>  704: <b>t2b_minor_version</b>(_Config) -&gt;
<a name="705"/>  705:     Umlaut = &quot;ätöm&quot;,
<a name="706"/>  706:     UmlautLatin1 = unicode:characters_to_binary(Umlaut, latin1, latin1),
<a name="707"/>  707:     UmlautUtf8   = unicode:characters_to_binary(Umlaut, latin1, utf8),
<a name="708"/>  708:     UmlautAtom = binary_to_atom(UmlautLatin1, latin1),
<a name="709"/>  709:     UmlautAtom = binary_to_atom(UmlautUtf8, utf8),
<a name="710"/>  710:     ExoticBin = &lt;&lt;&quot;こんにちは&quot;/utf8&gt;&gt;,
<a name="711"/>  711:     ExoticAtom = binary_to_atom(ExoticBin, utf8),
<a name="712"/>  712: 
<a name="713"/>  713:     &lt;&lt;131, ?SMALL_ATOM_UTF8_EXT, 4, &quot;atom&quot;&gt;&gt; = term_to_binary(atom),
<a name="714"/>  714:     &lt;&lt;131, ?SMALL_ATOM_UTF8_EXT, 6, UmlautUtf8/binary&gt;&gt; =
<a name="715"/>  715:         term_to_binary(UmlautAtom),
<a name="716"/>  716:     &lt;&lt;131, ?SMALL_ATOM_UTF8_EXT, 15, ExoticBin/binary&gt;&gt; =
<a name="717"/>  717:         term_to_binary(ExoticAtom),
<a name="718"/>  718: 
<a name="719"/>  719:     &lt;&lt;131, ?SMALL_ATOM_UTF8_EXT, 4, &quot;atom&quot;&gt;&gt; =
<a name="720"/>  720:         term_to_binary(atom, [{minor_version,2}]),
<a name="721"/>  721:     &lt;&lt;131, ?SMALL_ATOM_UTF8_EXT, 6, UmlautUtf8/binary&gt;&gt; =
<a name="722"/>  722:         term_to_binary(UmlautAtom, [{minor_version,2}]),
<a name="723"/>  723:     &lt;&lt;131, ?SMALL_ATOM_UTF8_EXT, 15, ExoticBin/binary&gt;&gt; =
<a name="724"/>  724:         term_to_binary(ExoticAtom, [{minor_version,2}]),
<a name="725"/>  725: 
<a name="726"/>  726:     &lt;&lt;131, ?ATOM_EXT, 4:16, &quot;atom&quot;&gt;&gt; =
<a name="727"/>  727:         term_to_binary(atom, [{minor_version,1}]),
<a name="728"/>  728:     &lt;&lt;131, ?ATOM_EXT, 4:16, UmlautLatin1/binary&gt;&gt; =
<a name="729"/>  729:         term_to_binary(UmlautAtom, [{minor_version,1}]),
<a name="730"/>  730:     &lt;&lt;131, ?SMALL_ATOM_UTF8_EXT, 15, ExoticBin/binary&gt;&gt; =
<a name="731"/>  731:         term_to_binary(ExoticAtom, [{minor_version,1}]),
<a name="732"/>  732: 
<a name="733"/>  733:     &lt;&lt;131, ?ATOM_EXT, 4:16, &quot;atom&quot;&gt;&gt; =
<a name="734"/>  734:         term_to_binary(atom, [{minor_version,0}]),
<a name="735"/>  735:     &lt;&lt;131, ?ATOM_EXT, 4:16, UmlautLatin1/binary&gt;&gt; =
<a name="736"/>  736:         term_to_binary(UmlautAtom, [{minor_version,0}]),
<a name="737"/>  737:     &lt;&lt;131, ?SMALL_ATOM_UTF8_EXT, 15, ExoticBin/binary&gt;&gt; =
<a name="738"/>  738:         term_to_binary(ExoticAtom, [{minor_version,0}]),
<a name="739"/>  739: 
<a name="740"/>  740:     &lt;&lt;131,?NEW_FLOAT_EXT,64,9,30,184,81,235,133,31&gt;&gt; =
<a name="741"/>  741:         term_to_binary(3.14),
<a name="742"/>  742:     &lt;&lt;131,?NEW_FLOAT_EXT,64,9,30,184,81,235,133,31&gt;&gt; =
<a name="743"/>  743:         term_to_binary(3.14, [{minor_version, 2}]),
<a name="744"/>  744:     &lt;&lt;131,?NEW_FLOAT_EXT,64,9,30,184,81,235,133,31&gt;&gt; =
<a name="745"/>  745:         term_to_binary(3.14, [{minor_version, 1}]),
<a name="746"/>  746:     &lt;&lt;131,?FLOAT_EXT,FloatStr:31/binary&gt;&gt; =
<a name="747"/>  747:         term_to_binary(3.14, [{minor_version, 0}]),
<a name="748"/>  748:     3.14 = binary_to_float(FloatStr),
<a name="t2b_minor_version-last_expr"/><a name="749"/>  749:     ok.
<a name="750"/>  750: 
<a name="751"/>  751: <i>%% Test term_to_binary(Term, [deterministic]).</i>
<a name="t2b_deterministic-1"/><a name="752"/>  752: <b>t2b_deterministic</b>(_Config) -&gt;
<a name="753"/>  753:     _ = rand:uniform(),				%Seed generator
<a name="754"/>  754:     io:format(&quot;Seed: ~p&quot;, [rand:export_seed()]),
<a name="755"/>  755:     Map0 = t2b_deterministic_1(100, #{1 =&gt; a, 1.0 =&gt; b}),
<a name="756"/>  756: 
<a name="757"/>  757:     Map1 = maps:merge(make_map(10000), Map0),
<a name="758"/>  758:     test_deterministic(Map1),
<a name="759"/>  759: 
<a name="t2b_deterministic-last_expr"/><a name="760"/>  760: <b>    case total_memory</b>() of
<a name="761"/>  761:         Amount when Amount &gt; 15 -&gt;
<a name="762"/>  762:             t2b_deterministic_heavy(Map0);
<a name="763"/>  763:         _ -&gt;
<a name="764"/>  764:             {comment,&quot;heavy tests skipped&quot;}
<a name="765"/>  765:     end.
<a name="766"/>  766: 
<a name="t2b_deterministic_heavy-1"/><a name="767"/>  767: <b>t2b_deterministic_heavy</b>(Map0) -&gt;
<a name="768"/>  768:     Map1 = maps:merge(make_map(1_000_000), Map0),
<a name="769"/>  769:     test_deterministic(Map1),
<a name="770"/>  770: 
<a name="771"/>  771:     %% If the external representation of the term to be encoded is
<a name="772"/>  772:     %% estimated to fit in a heap binary (64 bytes), the internal
<a name="773"/>  773:     %% enc_term_int() function that does the actual encoding will be
<a name="774"/>  774:     %% called without an context and thus is unable to trap. In the
<a name="775"/>  775:     %% DEBUG build of the runtime system, maps with more than 3
<a name="776"/>  776:     %% elements will be large maps, and depending on the keys and
<a name="777"/>  777:     %% values, it is possible that a large map can fit in 64
<a name="778"/>  778:     %% bytes. Therefore, the encoding code for deterministic maps must
<a name="779"/>  779:     %% cannot assume that there always exists a context.
<a name="780"/>  780: 
<a name="781"/>  781:     lists:foreach(fun(N) -&gt;
<a name="782"/>  782:                           Map = maps:from_list([{E,E} || E &lt;- lists:seq(1, N)]),
<a name="783"/>  783:                           test_deterministic(Map)
<a name="784"/>  784:                   end, lists:seq(4, 16)),
<a name="785"/>  785: 
<a name="786"/>  786:     %% Test that terminating a process that is encoding a huge map
<a name="787"/>  787:     %% will neither crash the runtime system nor leak memory. (Run the
<a name="788"/>  788:     %% test with memory sanitizer or valgrind to catch potential memory
<a name="789"/>  789:     %% leaks.)
<a name="790"/>  790:     erlang:trace_pattern({erlang, term_to_binary, 2}, true, []),
<a name="791"/>  791:     Map = huge_map(1_000_000, []),
<a name="t2b_deterministic_heavy-last_expr"/><a name="792"/>  792: <b>    rinse_and_repeat</b>(2, Map).
<a name="793"/>  793: 
<a name="rinse_and_repeat-2"/><a name="794"/>  794: <b>rinse_and_repeat</b>(Wait, Map) -&gt;
<a name="795"/>  795:     {Pid,Ref} = spawn_monitor(fun() -&gt;
<a name="796"/>  796:                                       receive go -&gt; ok end,
<a name="797"/>  797:                                       term_to_binary(Map, [deterministic])
<a name="798"/>  798:                               end),
<a name="799"/>  799:     erlang:trace(Pid, true, [call,arity]),
<a name="800"/>  800: 
<a name="801"/>  801:     Pid ! go,
<a name="802"/>  802:     receive
<a name="803"/>  803:         {trace,Pid,call,{erlang,term_to_binary,2}} -&gt;
<a name="804"/>  804:             %% Wait a short period to avoid killing term_to_binary/2 during
<a name="805"/>  805:             %% size calculation part.
<a name="806"/>  806:             receive after Wait -&gt; ok end,
<a name="807"/>  807:             exit(Pid, kill);
<a name="808"/>  808:         Other -&gt;
<a name="809"/>  809:             error(Other)
<a name="810"/>  810:     end,
<a name="811"/>  811: 
<a name="rinse_and_repeat-last_expr"/><a name="812"/>  812:     receive
<a name="813"/>  813:         {'DOWN',Ref,process,Pid,Reason} -&gt;
<a name="814"/>  814:             case Reason of
<a name="815"/>  815:                 normal -&gt;
<a name="816"/>  816:                     %% The encoding operation finished before the process
<a name="817"/>  817:                     %% was forcefully killed. Done.
<a name="818"/>  818:                     ok;
<a name="819"/>  819:                 killed -&gt;
<a name="820"/>  820:                     %% The process was killed in term_to_binary/2. We
<a name="821"/>  821:                     %% can't know whether it was killed too early, so
<a name="822"/>  822:                     %% we will try again with a slightly longer time.
<a name="823"/>  823:                     rinse_and_repeat(Wait + Wait div 2, Map)
<a name="824"/>  824:             end;
<a name="825"/>  825:         Other2 -&gt;
<a name="826"/>  826:             error(Other2)
<a name="827"/>  827:     end.
<a name="828"/>  828: 
<a name="huge_map-2"/><a name="829"/>  829: <b>huge_map</b>(0, Acc) -&gt;
<a name="830"/>  830:     maps:from_list(Acc);
<a name="831"/>  831: <b>huge_map</b>(N, Acc) -&gt;
<a name="832"/>  832:     %% Create awkward keys to slow down the sorting.
<a name="833"/>  833:     Key = &lt;&lt;N:127/big&gt;&gt;,
<a name="huge_map-last_expr"/><a name="834"/>  834: <b>    huge_map</b>(N-1, [{Key,N}|Acc]).
<a name="835"/>  835: 
<a name="t2b_deterministic_1-2"/><a name="836"/>  836: <b>t2b_deterministic_1</b>(0, Map) -&gt;
<a name="837"/>  837:     Map;
<a name="838"/>  838: <b>t2b_deterministic_1</b>(N, Map0) -&gt;
<a name="839"/>  839:     test_deterministic(Map0),
<a name="840"/>  840:     Map = Map0#{random_term() =&gt; N},
<a name="t2b_deterministic_1-last_expr"/><a name="841"/>  841: <b>    t2b_deterministic_1</b>(N - 1, Map).
<a name="842"/>  842: 
<a name="test_deterministic-1"/><a name="843"/>  843: <b>test_deterministic</b>(Map) -&gt;
<a name="844"/>  844:     Bin = term_to_binary(Map, [deterministic]),
<a name="845"/>  845:     Map = binary_to_term(Bin),
<a name="846"/>  846: 
<a name="847"/>  847:     %% Make sure that the keys for the map are ordered.
<a name="848"/>  848:     List0 = maps:to_list(Map),
<a name="849"/>  849:     List = lists:sort(fun(A, B) -&gt; erts_internal:cmp_term(A, B) =&lt; 0 end, List0),
<a name="850"/>  850:     List = decode_ext_map(Bin),
<a name="test_deterministic-last_expr"/><a name="851"/>  851:     ok.
<a name="852"/>  852: 
<a name="decode_ext_map-1"/><a name="853"/>  853: <b>decode_ext_map</b>(MapBin) -&gt;
<a name="854"/>  854:     MapTag = 116,
<a name="855"/>  855:     ListTag = 108,
<a name="856"/>  856:     NilTag = 106,
<a name="857"/>  857: 
<a name="858"/>  858:     %% Rewrite the map to a list before decoding to preserve the order
<a name="859"/>  859:     %% the map elements.
<a name="860"/>  860:     &lt;&lt;131,MapTag,Size:32,Bin0/binary&gt;&gt; = MapBin,
<a name="861"/>  861:     ListBin = &lt;&lt;131,ListTag,(2*Size):32,Bin0/binary,NilTag&gt;&gt;,
<a name="862"/>  862:     List = binary_to_term(ListBin),
<a name="decode_ext_map-last_expr"/><a name="863"/>  863: <b>    decode_ext_map_1</b>(List).
<a name="864"/>  864: 
<a name="decode_ext_map_1-1"/><a name="865"/>  865: <b>decode_ext_map_1</b>([Key,Val|T]) -&gt;
<a name="866"/>  866:     [{Key,Val}|decode_ext_map_1(T)];
<a name="decode_ext_map_1-last_expr"/><a name="867"/>  867: <b>decode_ext_map_1</b>([]) -&gt; [].
<a name="868"/>  868: 
<a name="make_map-1"/><a name="869"/>  869: <b>make_map</b>(N) -&gt;
<a name="make_map-last_expr"/><a name="870"/>  870: <b>    maps:from_list</b>([{I,I*I} || I &lt;- lists:seq(1, N)]).
<a name="871"/>  871: 
<a name="random_term-0"/><a name="872"/>  872: <b>random_term</b>() -&gt;
<a name="random_term-last_expr"/><a name="873"/>  873: <b>    case rand:uniform</b>(11) of
<a name="874"/>  874:         1 -&gt;
<a name="875"/>  875:             list_to_atom(integer_to_list(36#aaaa + rand:uniform(100) * 23, 36));
<a name="876"/>  876:         2 -&gt;
<a name="877"/>  877:             rand:uniform();
<a name="878"/>  878:         3 -&gt;
<a name="879"/>  879:             rand:uniform(10000000);
<a name="880"/>  880:         4 -&gt;
<a name="881"/>  881:             (1 bsl rand:uniform(128)) + rand:uniform(10000000);
<a name="882"/>  882:         5 -&gt;
<a name="883"/>  883:             self();
<a name="884"/>  884:         6 -&gt;
<a name="885"/>  885:             make_ref();
<a name="886"/>  886:         7 -&gt;
<a name="887"/>  887:             random_list();
<a name="888"/>  888:         8 -&gt;
<a name="889"/>  889:             list_to_tuple(random_list());
<a name="890"/>  890:         9 -&gt;
<a name="891"/>  891:             [];
<a name="892"/>  892:         10 -&gt;
<a name="893"/>  893:             make_map(33);
<a name="894"/>  894:         11 -&gt;
<a name="895"/>  895:             make_map(rand:uniform(10))
<a name="896"/>  896:     end.
<a name="897"/>  897: 
<a name="random_list-0"/><a name="898"/>  898: <b>random_list</b>() -&gt;
<a name="random_list-last_expr"/><a name="899"/>  899: <b>    [random_term</b>() || _ &lt;- lists:seq(1, rand:uniform(10)-1)].
<a name="900"/>  900: 
<a name="external_size-1"/><a name="901"/>  901: <b>external_size</b>(Config) when is_list(Config) -&gt;
<a name="902"/>  902:     %% Build a term whose external size only fits in a big num (on 32-bit CPU).
<a name="903"/>  903:     external_size_1(16#11111111111111117777777777777777888889999, 0, 16#FFFFFFF),
<a name="904"/>  904: 
<a name="905"/>  905:     %% Test that the same binary aligned and unaligned has the same external size.
<a name="906"/>  906:     Bin = iolist_to_binary([1,2,3,96]),
<a name="907"/>  907:     Unaligned = make_unaligned_sub_binary(Bin),
<a name="908"/>  908:     case {erlang:external_size(Bin),erlang:external_size(Unaligned)} of
<a name="909"/>  909: 	{X,X} -&gt; ok;
<a name="910"/>  910: 	{Sz1,Sz2} -&gt;
<a name="911"/>  911: 	    ct:fail(&quot;  Aligned size: ~p\n&quot;
<a name="912"/>  912:                     &quot;Unaligned size: ~p\n&quot;, [Sz1,Sz2])
<a name="913"/>  913:     end,
<a name="914"/>  914:     true = (erlang:external_size(Bin) =:= erlang:external_size(Bin, [{minor_version, 1}])),
<a name="external_size-last_expr"/><a name="915"/>  915: <b>    true = </b>(erlang:external_size(Unaligned) =:= erlang:external_size(Unaligned, [{minor_version, 1}])).
<a name="916"/>  916: 
<a name="external_size_1-3"/><a name="917"/>  917: <b>external_size_1</b>(Term, Size0, Limit) when Size0 &lt; Limit -&gt;
<a name="918"/>  918:     case erlang:external_size(Term) of
<a name="919"/>  919: 	Size when is_integer(Size), Size0 &lt; Size -&gt;
<a name="920"/>  920: 	    io:format(&quot;~p&quot;, [Size]),
<a name="921"/>  921: 	    external_size_1([Term|Term], Size, Limit)
<a name="922"/>  922:     end;
<a name="external_size_1-last_expr"/><a name="923"/>  923: <b>external_size_1</b>(_, _, _) -&gt; ok.
<a name="924"/>  924: 
<a name="t_iolist_size-1"/><a name="925"/>  925: <b>t_iolist_size</b>(Config) when is_list(Config) -&gt;
<a name="926"/>  926:     _ = rand:uniform(),				%Seed generator
<a name="927"/>  927:     io:format(&quot;Seed: ~p&quot;, [rand:export_seed()]),
<a name="928"/>  928: 
<a name="929"/>  929:     Base = &lt;&lt;0:(1 bsl 20)/unit:8&gt;&gt;,
<a name="930"/>  930:     Powers = [1 bsl N || N &lt;- lists:seq(2, 37)],
<a name="931"/>  931:     Sizes0 = [[N - rand:uniform(N div 2),
<a name="932"/>  932: 	       lists:seq(N-2, N+2),
<a name="933"/>  933: 	       N+N div 2,
<a name="934"/>  934: 	       N + rand:uniform(N div 2)] ||
<a name="935"/>  935: 		 N &lt;- Powers],
<a name="936"/>  936: 
<a name="937"/>  937:     %% Test sizes around 1^32 more thoroughly.
<a name="938"/>  938:     FourGigs = 1 bsl 32,
<a name="939"/>  939:     Sizes1 = [FourGigs+N || N &lt;- lists:seq(-8, 40)] ++ Sizes0,
<a name="940"/>  940:     Sizes2 = lists:flatten(Sizes1),
<a name="941"/>  941:     Sizes = lists:usort(Sizes2),
<a name="942"/>  942:     io:format(&quot;~p sizes:&quot;, [length(Sizes)]),
<a name="943"/>  943:     io:format(&quot;~p\n&quot;, [Sizes]),
<a name="944"/>  944:     _ = [Sz = iolist_size(build_iolist(Sz, Base)) || Sz &lt;- Sizes],
<a name="t_iolist_size-last_expr"/><a name="945"/>  945:     ok.
<a name="946"/>  946: 
<a name="build_iolist-2"/><a name="947"/>  947: <b>build_iolist</b>(N, Base) when N &lt; 16 -&gt;
<a name="948"/>  948:     case rand:uniform(3) of
<a name="949"/>  949: 	1 -&gt;
<a name="950"/>  950: 	    &lt;&lt;Bin:N/binary,_/binary&gt;&gt; = Base,
<a name="951"/>  951: 	    Bin;
<a name="952"/>  952: 	_ -&gt;
<a name="953"/>  953: 	    lists:seq(1, N)
<a name="954"/>  954:     end;
<a name="955"/>  955: <b>build_iolist</b>(N, Base) when N =&lt; byte_size(Base) -&gt;
<a name="956"/>  956:     case rand:uniform(3) of
<a name="957"/>  957: 	1 -&gt;
<a name="958"/>  958: 	    &lt;&lt;Bin:N/binary,_/binary&gt;&gt; = Base,
<a name="959"/>  959: 	    Bin;
<a name="960"/>  960: 	2 -&gt;
<a name="961"/>  961: 	    &lt;&lt;Bin:N/binary,_/binary&gt;&gt; = Base,
<a name="962"/>  962: 	    [Bin];
<a name="963"/>  963: 	3 -&gt;
<a name="964"/>  964: 	    case N rem 2 of
<a name="965"/>  965: 		0 -&gt;
<a name="966"/>  966: 		    L = build_iolist(N div 2, Base),
<a name="967"/>  967: 		    [L,L];
<a name="968"/>  968: 		1 -&gt;
<a name="969"/>  969: 		    L = build_iolist(N div 2, Base),
<a name="970"/>  970: 		    [L,L,45]
<a name="971"/>  971: 	    end
<a name="972"/>  972:     end;
<a name="973"/>  973: <b>build_iolist</b>(N0, Base) -&gt;
<a name="974"/>  974:     Small = rand:uniform(15),
<a name="975"/>  975:     Seq = lists:seq(1, Small),
<a name="976"/>  976:     N = N0 - Small,
<a name="build_iolist-last_expr"/><a name="977"/>  977:     case N rem 2 of
<a name="978"/>  978: 	0 -&gt;
<a name="979"/>  979: 	    L = build_iolist(N div 2, Base),
<a name="980"/>  980: 	    [L,L|Seq];
<a name="981"/>  981: 	1 -&gt;
<a name="982"/>  982: 	    L = build_iolist(N div 2, Base),
<a name="983"/>  983: 	    [47,L,L|Seq]
<a name="984"/>  984:     end.
<a name="985"/>  985: 
<a name="approx_1GB_bin-0"/><a name="986"/>  986: <b>approx_1GB_bin</b>() -&gt;
<a name="approx_1GB_bin-last_expr"/><a name="987"/>  987: <b>    iolist_to_binary</b>(lists:duplicate(281, &lt;&lt;-1:4194304/unit:8&gt;&gt;)).
<a name="988"/>  988: 
<a name="duplicate_iolist-2"/><a name="989"/>  989: <b>duplicate_iolist</b>(IOList, 0) -&gt;
<a name="990"/>  990:     IOList;
<a name="991"/>  991: <b>duplicate_iolist</b>(IOList, NrOfTimes) -&gt;
<a name="duplicate_iolist-last_expr"/><a name="992"/>  992: <b>    duplicate_iolist</b>([IOList, IOList], NrOfTimes - 1).
<a name="993"/>  993: 
<a name="t_iolist_size_huge_list-1"/><a name="994"/>  994: <b>t_iolist_size_huge_list</b>(Config)  when is_list(Config) -&gt;
<a name="t_iolist_size_huge_list-last_expr"/><a name="995"/>  995: <b>    run_when_enough_resources</b>(
<a name="996"/>  996:       fun() -&gt;
<a name="997"/>  997:               {TimeToCreateIOList, IOList} =
<a name="998"/>  998:                   timer:tc(fun() -&gt;
<a name="999"/>  999:                                    duplicate_iolist(approx_1GB_bin(), 32)
<a name="1000"/> 1000:                            end),
<a name="1001"/> 1001:               {IOListSizeTime, CalculatedSize} =
<a name="1002"/> 1002:                   timer:tc(fun() -&gt;
<a name="1003"/> 1003:                                    iolist_size(IOList)
<a name="1004"/> 1004:                            end),
<a name="1005"/> 1005:               5062045981164437504 = CalculatedSize,
<a name="1006"/> 1006:               {comment, io_lib:format(&quot;Time to create iolist: ~f s. Time to calculate size: ~f s.&quot;, 
<a name="1007"/> 1007:                                       [TimeToCreateIOList / 1000000, IOListSizeTime / 1000000])}
<a name="1008"/> 1008:       end).
<a name="1009"/> 1009: 
<a name="t_iolist_size_huge_bad_arg_list-1"/><a name="1010"/> 1010: <b>t_iolist_size_huge_bad_arg_list</b>(Config)  when is_list(Config) -&gt;
<a name="t_iolist_size_huge_bad_arg_list-last_expr"/><a name="1011"/> 1011: <b>    run_when_enough_resources</b>(
<a name="1012"/> 1012:       fun() -&gt;
<a name="1013"/> 1013:               P = self(),
<a name="1014"/> 1014:               spawn_link(fun() -&gt;
<a name="1015"/> 1015:                                  IOListTmp = duplicate_iolist(approx_1GB_bin(), 32),
<a name="1016"/> 1016:                                  IOList = [IOListTmp, [badarg]],
<a name="1017"/> 1017:                                  {'EXIT',{badarg,_}} = catch iolist_size(IOList),
<a name="1018"/> 1018:                                  P ! ok
<a name="1019"/> 1019:                          end),
<a name="1020"/> 1020:               receive ok -&gt; ok end
<a name="1021"/> 1021:          end).
<a name="1022"/> 1022: 
<a name="1023"/> 1023: <i>%% iolist_size tests for shallow lists</i>
<a name="1024"/> 1024: 
<a name="t_iolist_size_shallow_trapping-1"/><a name="1025"/> 1025: <b>t_iolist_size_shallow_trapping</b>(Config) when is_list(Config) -&gt;
<a name="1026"/> 1026:     Lengths = [2000, 20000, 200000, 200000, 2000000, 20000000],
<a name="t_iolist_size_shallow_trapping-last_expr"/><a name="1027"/> 1027: <b>    run_iolist_size_test_and_benchmark</b>(Lengths, fun make_shallow_iolist/2).
<a name="1028"/> 1028: 
<a name="t_iolist_size_shallow_short_lists-1"/><a name="1029"/> 1029: <b>t_iolist_size_shallow_short_lists</b>(Config) when is_list(Config) -&gt;
<a name="1030"/> 1030:     Lengths = lists:duplicate(15000, 300),
<a name="t_iolist_size_shallow_short_lists-last_expr"/><a name="1031"/> 1031: <b>    run_iolist_size_test_and_benchmark</b>(Lengths, fun make_shallow_iolist/2).
<a name="1032"/> 1032: 
<a name="t_iolist_size_shallow_tiny_lists-1"/><a name="1033"/> 1033: <b>t_iolist_size_shallow_tiny_lists</b>(Config) when is_list(Config) -&gt;
<a name="1034"/> 1034:     Lengths = lists:duplicate(250000, 18),
<a name="t_iolist_size_shallow_tiny_lists-last_expr"/><a name="1035"/> 1035: <b>    run_iolist_size_test_and_benchmark</b>(Lengths, fun make_shallow_iolist/2).
<a name="1036"/> 1036: 
<a name="make_shallow_iolist-2"/><a name="1037"/> 1037: <b>make_shallow_iolist</b>(SizeDiv2, LastItem) -&gt;
<a name="make_shallow_iolist-last_expr"/><a name="1038"/> 1038: <b>    lists:map</b>(
<a name="1039"/> 1039:       fun(I) -&gt; 
<a name="1040"/> 1040:               case I of
<a name="1041"/> 1041:                   SizeDiv2 -&gt; [1, LastItem];
<a name="1042"/> 1042:                   _ -&gt; [1, 1]
<a name="1043"/> 1043:               end
<a name="1044"/> 1044:       end,
<a name="1045"/> 1045:       lists:seq(1, SizeDiv2)).
<a name="1046"/> 1046: 
<a name="1047"/> 1047: <i>%% iolist_size tests for deep lists</i>
<a name="1048"/> 1048: 
<a name="t_iolist_size_deep_trapping-1"/><a name="1049"/> 1049: <b>t_iolist_size_deep_trapping</b>(Config) when is_list(Config) -&gt;
<a name="1050"/> 1050:     Lengths = [2000, 20000, 200000, 200000, 2000000, 10000000],
<a name="t_iolist_size_deep_trapping-last_expr"/><a name="1051"/> 1051: <b>    run_iolist_size_test_and_benchmark</b>(Lengths, fun make_deep_iolist/2).
<a name="1052"/> 1052: 
<a name="t_iolist_size_deep_short_lists-1"/><a name="1053"/> 1053: <b>t_iolist_size_deep_short_lists</b>(Config) when is_list(Config) -&gt;
<a name="1054"/> 1054:     Lengths = lists:duplicate(10000, 300),
<a name="t_iolist_size_deep_short_lists-last_expr"/><a name="1055"/> 1055: <b>    run_iolist_size_test_and_benchmark</b>(Lengths, fun make_deep_iolist/2).
<a name="1056"/> 1056: 
<a name="t_iolist_size_deep_tiny_lists-1"/><a name="1057"/> 1057: <b>t_iolist_size_deep_tiny_lists</b>(Config) when is_list(Config) -&gt;
<a name="1058"/> 1058:     Lengths = lists:duplicate(150000, 18),
<a name="t_iolist_size_deep_tiny_lists-last_expr"/><a name="1059"/> 1059: <b>    run_iolist_size_test_and_benchmark</b>(Lengths, fun make_deep_iolist/2).
<a name="1060"/> 1060: 
<a name="make_deep_iolist-2"/><a name="1061"/> 1061: <b>make_deep_iolist</b>(1, LastItem) -&gt;
<a name="1062"/> 1062:     [1, LastItem];
<a name="1063"/> 1063: <b>make_deep_iolist</b>(Depth, LastItem) -&gt;
<a name="make_deep_iolist-last_expr"/><a name="1064"/> 1064: <b>    [[1, 1], make_deep_iolist</b>(Depth - 1, LastItem)].
<a name="1065"/> 1065: 
<a name="1066"/> 1066: <i>% Helper functions for iolist_size tests</i>
<a name="1067"/> 1067: 
<a name="run_iolist_size_test_and_benchmark-2"/><a name="1068"/> 1068: <b>run_iolist_size_test_and_benchmark</b>(Lengths, ListGenerator) -&gt;
<a name="run_iolist_size_test_and_benchmark-last_expr"/><a name="1069"/> 1069: <b>    run_when_enough_resources</b>(
<a name="1070"/> 1070:       fun() -&gt;
<a name="1071"/> 1071:               GoodListsWithSizes =
<a name="1072"/> 1072:                   lists:map(fun(Length) -&gt; {Length*2, ListGenerator(Length, 1)} end, Lengths),
<a name="1073"/> 1073:               BadListsWithSizes =
<a name="1074"/> 1074:                   lists:map(fun(Length) -&gt; {Length*2, ListGenerator(Length, bad)} end, Lengths),
<a name="1075"/> 1075:               erlang:garbage_collect(),
<a name="1076"/> 1076:               report_throughput(
<a name="1077"/> 1077:                 fun() -&gt;
<a name="1078"/> 1078:                         lists:foreach(
<a name="1079"/> 1079:                           fun(_)-&gt;
<a name="1080"/> 1080:                                   lists:foreach(
<a name="1081"/> 1081:                                     fun({Size, List}) -&gt; Size = iolist_size(List) end,
<a name="1082"/> 1082:                                     GoodListsWithSizes),
<a name="1083"/> 1083:                                   lists:foreach(
<a name="1084"/> 1084:                                     fun({_, List}) -&gt; {'EXIT',_} = (catch (iolist_size(List))) end,
<a name="1085"/> 1085:                                     BadListsWithSizes)
<a name="1086"/> 1086:                           end,
<a name="1087"/> 1087:                           lists:seq(1,3))
<a name="1088"/> 1088:                 end,
<a name="1089"/> 1089:                 lists:sum(Lengths)*4)
<a name="1090"/> 1090:       end).
<a name="1091"/> 1091: 
<a name="report_throughput-2"/><a name="1092"/> 1092: <b>report_throughput</b>(Fun, NrOfItems) -&gt;
<a name="1093"/> 1093:     Parent = self(),
<a name="1094"/> 1094:     spawn(fun() -&gt; Parent ! timer:tc(Fun) end),
<a name="1095"/> 1095:     {Time, _} = receive D -&gt; D end,
<a name="1096"/> 1096:     ItemsPerMicrosecond = NrOfItems / Time,
<a name="1097"/> 1097:     ct_event:notify(#event{ name = benchmark_data, data = [{value, ItemsPerMicrosecond}]}),
<a name="report_throughput-last_expr"/><a name="1098"/> 1098: <b>    {comment, io_lib:format</b>(&quot;Items per microsecond: ~p, Nr of items: ~p, Benchmark time: ~p seconds)&quot;,
<a name="1099"/> 1099:                             [ItemsPerMicrosecond, NrOfItems, Time/1000000])}.
<a name="1100"/> 1100: 
<a name="total_memory-0"/><a name="1101"/> 1101: <b>total_memory</b>() -&gt;
<a name="1102"/> 1102:     %% Total memory in GB.
<a name="total_memory-last_expr"/><a name="1103"/> 1103:     try
<a name="1104"/> 1104: 	SMD = memsup:get_system_memory_data(),
<a name="1105"/> 1105:         TM = proplists:get_value(
<a name="1106"/> 1106:                available_memory, SMD,
<a name="1107"/> 1107:                proplists:get_value(
<a name="1108"/> 1108:                  total_memory, SMD,
<a name="1109"/> 1109:                  proplists:get_value(
<a name="1110"/> 1110:                    system_total_memory, SMD))),
<a name="1111"/> 1111:         TM div (1024*1024*1024)
<a name="1112"/> 1112:     catch
<a name="1113"/> 1113: 	_ : _ -&gt;
<a name="1114"/> 1114: 	    undefined
<a name="1115"/> 1115:     end.
<a name="1116"/> 1116: 
<a name="run_when_enough_resources-1"/><a name="1117"/> 1117: <b>run_when_enough_resources</b>(Fun) -&gt;
<a name="1118"/> 1118:     DemandGb = case erlang:system_info(build_type) of
<a name="1119"/> 1119:                    Gb when Gb =:= valgrind; Gb =:= asan -&gt;
<a name="1120"/> 1120:                        30;
<a name="1121"/> 1121:                    _ -&gt;
<a name="1122"/> 1122:                        15
<a name="1123"/> 1123:                end,
<a name="run_when_enough_resources-last_expr"/><a name="1124"/> 1124: <b>    case {total_memory</b>(), erlang:system_info(wordsize)} of
<a name="1125"/> 1125:         {Mem, 8} when is_integer(Mem) andalso Mem &gt;= DemandGb -&gt;
<a name="1126"/> 1126:             Fun();
<a name="1127"/> 1127:         {Mem, WordSize} -&gt;
<a name="1128"/> 1128:             {skipped, 
<a name="1129"/> 1129:              io_lib:format(&quot;Not enough resources (System Memory &gt;= ~p, Word Size = ~p)&quot;,
<a name="1130"/> 1130:                            [Mem, WordSize])}
<a name="1131"/> 1131:     end.
<a name="1132"/> 1132:     
<a name="1133"/> 1133: 
<a name="1134"/> 1134: <i>%% OTP-4053</i>
<a name="bad_binary_to_term_2-1"/><a name="1135"/> 1135: <b>bad_binary_to_term_2</b>(Config) when is_list(Config) -&gt;
<a name="1136"/> 1136:     {ok, Peer, N} = ?CT_PEER(),
<a name="1137"/> 1137:     R = rpc:call(N, erlang, binary_to_term, [&lt;&lt;131,111,255,255,255,0&gt;&gt;]),
<a name="1138"/> 1138:     case R of
<a name="1139"/> 1139: 	      {badrpc, {'EXIT', _}} -&gt;
<a name="1140"/> 1140: 		  ok;
<a name="1141"/> 1141: 	      _Other -&gt;
<a name="1142"/> 1142: 		  ct:fail({rpcresult, R})
<a name="1143"/> 1143: 	  end,
<a name="1144"/> 1144:     peer:stop(Peer),
<a name="bad_binary_to_term_2-last_expr"/><a name="1145"/> 1145:     ok.
<a name="1146"/> 1146: 
<a name="1147"/> 1147: <i>%% Try bad input to binary_to_term/1.</i>
<a name="bad_binary_to_term-1"/><a name="1148"/> 1148: <b>bad_binary_to_term</b>(Config) when is_list(Config) -&gt;
<a name="1149"/> 1149:     bad_bin_to_term(an_atom),
<a name="1150"/> 1150:     bad_bin_to_term({an,tuple}),
<a name="1151"/> 1151:     bad_bin_to_term({a,list}),
<a name="1152"/> 1152:     bad_bin_to_term(fun() -&gt; self() end),
<a name="1153"/> 1153:     bad_bin_to_term(fun(X) -&gt; 42*X end),
<a name="1154"/> 1154:     bad_bin_to_term(fun(X, Y) -&gt; {X,Y} end),
<a name="1155"/> 1155:     bad_bin_to_term(fun(X, Y, Z) -&gt; {X,Y,Z} end),
<a name="1156"/> 1156:     bad_bin_to_term(bit_sized_binary(term_to_binary({you,should,'not',see,this,term}))),
<a name="1157"/> 1157: 
<a name="1158"/> 1158:     %% Bad float.
<a name="1159"/> 1159:     bad_bin_to_term(&lt;&lt;131,70,-1:64&gt;&gt;),
<a name="1160"/> 1160: 
<a name="1161"/> 1161:     %% Truncated UTF8 character (ERL-474)
<a name="1162"/> 1162:     bad_bin_to_term(&lt;&lt;131,119,1,194,163&gt;&gt;),
<a name="bad_binary_to_term-last_expr"/><a name="1163"/> 1163:     ok.
<a name="1164"/> 1164: 
<a name="bad_bin_to_term-1"/><a name="1165"/> 1165: <b>bad_bin_to_term</b>(BadBin) -&gt;
<a name="bad_bin_to_term-last_expr"/><a name="1166"/> 1166: <b>    {'EXIT',{badarg,_}} = </b>(catch binary_to_term_stress(BadBin)).
<a name="1167"/> 1167: 
<a name="bad_bin_to_term-2"/><a name="1168"/> 1168: <b>bad_bin_to_term</b>(BadBin,Opts) -&gt;
<a name="bad_bin_to_term-last_expr"/><a name="1169"/> 1169: <b>    {'EXIT',{badarg,_}} = </b>(catch binary_to_term_stress(BadBin,Opts)).
<a name="1170"/> 1170: 
<a name="1171"/> 1171: 
<a name="1172"/> 1172: <i>%% OTP-18343: Decode unsorted flatmap as key in hashmap</i>
<a name="unsorted_map_in_map-1"/><a name="1173"/> 1173: <b>unsorted_map_in_map</b>(Config) when is_list(Config) -&gt;
<a name="1174"/> 1174:     K1 = 1,
<a name="1175"/> 1175:     K2 = 2,
<a name="1176"/> 1176:     true = K1 &lt; K2,
<a name="1177"/> 1177:     FMap = #{K1 =&gt; [], K2 =&gt; []},
<a name="1178"/> 1178:     FMapBin = &lt;&lt;?MAP_EXT, 2:32,
<a name="1179"/> 1179:                 %% unsorted list of key/value pairs
<a name="1180"/> 1180:                 ?SMALL_INTEGER_EXT, K2, ?NIL,
<a name="1181"/> 1181:                 ?SMALL_INTEGER_EXT, K1, ?NIL&gt;&gt;,
<a name="1182"/> 1182:     FMap = binary_to_term(&lt;&lt;131, FMapBin/binary&gt;&gt;),
<a name="1183"/> 1183: 
<a name="1184"/> 1184:     HKeys = lists:seq(1, ?MAP_SMALL_MAP_LIMIT+1),
<a name="1185"/> 1185:     HMap0 = maps:from_list([{K,[]} || K &lt;- HKeys]),
<a name="1186"/> 1186:     HMap0Bin = term_to_binary(HMap0),
<a name="1187"/> 1187: 
<a name="1188"/> 1188:     %% Replace last key/value pair with FMap =&gt; []
<a name="1189"/> 1189:     Prologue = binary:part(HMap0Bin, 0, byte_size(HMap0Bin)-3),
<a name="1190"/> 1190:     HMap1Bin = &lt;&lt;Prologue/binary, FMapBin/binary, ?NIL&gt;&gt;,
<a name="1191"/> 1191:     HMap1 = binary_to_term(HMap1Bin),
<a name="1192"/> 1192: 
<a name="1193"/> 1193:     %% Moment of truth, can we lookup key FMap
<a name="1194"/> 1194:     [] = maps:get(FMap, HMap1),
<a name="unsorted_map_in_map-last_expr"/><a name="1195"/> 1195:     ok.
<a name="1196"/> 1196: 
<a name="1197"/> 1197: <i>%% Test safety options for binary_to_term/2</i>
<a name="safe_binary_to_term2-1"/><a name="1198"/> 1198: <b>safe_binary_to_term2</b>(Config) when is_list(Config) -&gt;
<a name="1199"/> 1199:     bad_bin_to_term(&lt;&lt;131,100,0,14,&quot;undefined_atom&quot;&gt;&gt;, [safe]),
<a name="1200"/> 1200:     bad_bin_to_term(&lt;&lt;131,100,0,14,&quot;other_bad_atom&quot;&gt;&gt;, [safe]),
<a name="1201"/> 1201:     BadHostAtom = &lt;&lt;100,0,14,&quot;badguy@badhost&quot;&gt;&gt;,
<a name="1202"/> 1202:     Empty = &lt;&lt;0,0,0,0&gt;&gt;,
<a name="1203"/> 1203:     BadRef = &lt;&lt;131,114,0,3,BadHostAtom/binary,0,&lt;&lt;0,0,0,255&gt;&gt;/binary,
<a name="1204"/> 1204: 	      Empty/binary,Empty/binary&gt;&gt;,
<a name="1205"/> 1205:     bad_bin_to_term(BadRef, [safe]), % good ref, with a bad atom
<a name="1206"/> 1206:     fullsweep_after = binary_to_term_stress(&lt;&lt;131,100,0,15,&quot;fullsweep_after&quot;&gt;&gt;, [safe]), % should be a good atom
<a name="1207"/> 1207:     BadExtFun = &lt;&lt;131,113,100,0,4,98,108,117,101,100,0,4,109,111,111,110,97,3&gt;&gt;,
<a name="1208"/> 1208:     bad_bin_to_term(BadExtFun, [safe]),
<a name="safe_binary_to_term2-last_expr"/><a name="1209"/> 1209:     ok.
<a name="1210"/> 1210: 
<a name="1211"/> 1211: <i>%% OTP-18306 Decode binary/bitstring with size &gt;= 2Gbyte</i>
<a name="big_binary_to_term-1"/><a name="1212"/> 1212: <b>big_binary_to_term</b>(Config) -&gt;
<a name="big_binary_to_term-last_expr"/><a name="1213"/> 1213: <b>    run_when_enough_resources</b>(
<a name="1214"/> 1214:       fun() -&gt;
<a name="1215"/> 1215:               Bin = binary:copy(&lt;&lt;0&gt;&gt;, 2 * 1024 * 1024 * 1024),
<a name="1216"/> 1216:               big_binary_roundtrip(Bin),
<a name="1217"/> 1217:               erlang:garbage_collect(),
<a name="1218"/> 1218:               &lt;&lt;_:1, BitStr/bits&gt;&gt; = Bin,
<a name="1219"/> 1219:               big_binary_roundtrip(BitStr),
<a name="1220"/> 1220:               ok
<a name="1221"/> 1221:       end).
<a name="1222"/> 1222: 
<a name="big_binary_roundtrip-1"/><a name="1223"/> 1223: <b>big_binary_roundtrip</b>(Bin) -&gt;
<a name="1224"/> 1224:     Bin = erlang:binary_to_term(erlang:term_to_binary(Bin)),
<a name="big_binary_roundtrip-last_expr"/><a name="1225"/> 1225:     ok.
<a name="1226"/> 1226: 
<a name="1227"/> 1227: 
<a name="1228"/> 1228: <i>%% Tests bad input to binary_to_term/1.</i>
<a name="1229"/> 1229: 
<a name="bad_terms-1"/><a name="1230"/> 1230: <b>bad_terms</b>(Config) when is_list(Config) -&gt;
<a name="1231"/> 1231:     test_terms(fun corrupter/1),
<a name="1232"/> 1232:     {'EXIT',{badarg,_}} = (catch binary_to_term(&lt;&lt;131,$M,3:32,0,11,22,33&gt;&gt;)),
<a name="1233"/> 1233:     {'EXIT',{badarg,_}} = (catch binary_to_term(&lt;&lt;131,$M,3:32,9,11,22,33&gt;&gt;)),
<a name="1234"/> 1234:     {'EXIT',{badarg,_}} = (catch binary_to_term(&lt;&lt;131,$M,0:32,1,11,22,33&gt;&gt;)),
<a name="1235"/> 1235:     {'EXIT',{badarg,_}} = (catch binary_to_term(&lt;&lt;131,$M,-1:32,1,11,22,33&gt;&gt;)),
<a name="bad_terms-last_expr"/><a name="1236"/> 1236:     ok.
<a name="1237"/> 1237: 
<a name="corrupter-1"/><a name="1238"/> 1238: <b>corrupter</b>(Term) -&gt;
<a name="1239"/> 1239:     try
<a name="1240"/> 1240: 	      S = io_lib:format(&quot;About to corrupt: ~P&quot;, [Term,12]),
<a name="1241"/> 1241: 	      io:put_chars(S)
<a name="1242"/> 1242: 	  catch
<a name="1243"/> 1243: 	      error:badarg -&gt;
<a name="1244"/> 1244: 		  io:format(&quot;About to corrupt: &lt;&lt;bit-level-binary:~p&quot;,
<a name="1245"/> 1245: 			    [bit_size(Term)])
<a name="1246"/> 1246: 	  end,
<a name="1247"/> 1247:     Bin = term_to_binary(Term),
<a name="1248"/> 1248:     corrupter(Bin, size(Bin)-1),
<a name="1249"/> 1249:     CompressedBin = term_to_binary(Term, [compressed]),
<a name="corrupter-last_expr"/><a name="1250"/> 1250: <b>    corrupter</b>(CompressedBin, size(CompressedBin)-1).
<a name="1251"/> 1251: 
<a name="corrupter-2"/><a name="1252"/> 1252: <b>corrupter</b>(Bin, Pos) when Pos &gt;= 0 -&gt;
<a name="1253"/> 1253:     {ShorterBin, Rest} = split_binary(Bin, Pos),
<a name="1254"/> 1254:     catch binary_to_term_stress(ShorterBin), %% emulator shouldn't crash
<a name="1255"/> 1255:     MovedBin = list_to_binary([ShorterBin]),
<a name="1256"/> 1256:     catch binary_to_term_stress(MovedBin), %% emulator shouldn't crash
<a name="1257"/> 1257: 
<a name="1258"/> 1258:     %% Bit faults, shouldn't crash
<a name="1259"/> 1259:     &lt;&lt;Byte,Tail/binary&gt;&gt; = Rest,
<a name="1260"/> 1260:     Fun = fun(M) -&gt; FaultyByte = Byte bxor M,                    
<a name="1261"/> 1261: 		    catch binary_to_term_stress(&lt;&lt;ShorterBin/binary,
<a name="1262"/> 1262: 					  FaultyByte, Tail/binary&gt;&gt;) end,
<a name="1263"/> 1263:     lists:foreach(Fun,[1,2,4,8,16,32,64,128,255]),    
<a name="1264"/> 1264:     corrupter(Bin, Pos-1);
<a name="1265"/> 1265: <b>corrupter</b>(_Bin, _) -&gt;
<a name="corrupter-last_expr"/><a name="1266"/> 1266:     ok.
<a name="1267"/> 1267: 
<a name="more_bad_terms-1"/><a name="1268"/> 1268: <b>more_bad_terms</b>(Config) when is_list(Config) -&gt;
<a name="1269"/> 1269:     Data = proplists:get_value(data_dir, Config),
<a name="1270"/> 1270:     BadFile = filename:join(Data, &quot;bad_binary&quot;),
<a name="1271"/> 1271:     ok = io:format(&quot;File: ~s\n&quot;, [BadFile]),
<a name="more_bad_terms-last_expr"/><a name="1272"/> 1272: <b>    case file:read_file</b>(BadFile) of
<a name="1273"/> 1273: 	      {ok,Bin} -&gt;
<a name="1274"/> 1274: 		  {'EXIT',{badarg,_}} = (catch binary_to_term_stress(Bin)),
<a name="1275"/> 1275: 		  ok;
<a name="1276"/> 1276: 	      Other -&gt;
<a name="1277"/> 1277: 		  ct:fail(Other)
<a name="1278"/> 1278: 	  end.
<a name="1279"/> 1279: 
<a name="otp_5484-1"/><a name="1280"/> 1280: <b>otp_5484</b>(Config) when is_list(Config) -&gt;
<a name="1281"/> 1281:     {'EXIT',_} =
<a name="1282"/> 1282: 	(catch
<a name="1283"/> 1283: 	     binary_to_term_stress(
<a name="1284"/> 1284: 	       &lt;&lt;131,
<a name="1285"/> 1285: 		104,2,				%Tuple, 2 elements
<a name="1286"/> 1286: 		103,				%Pid
<a name="1287"/> 1287: 		100,0,20,&quot;wslin1427198@wslin14&quot;,
<a name="1288"/> 1288: 		%% Obviously bad values follow.
<a name="1289"/> 1289: 		255,255,255,255,
<a name="1290"/> 1290: 		255,255,255,255,
<a name="1291"/> 1291: 		255,
<a name="1292"/> 1292: 		106&gt;&gt;)),
<a name="1293"/> 1293: 
<a name="1294"/> 1294:     {'EXIT',_} =
<a name="1295"/> 1295: 	(catch
<a name="1296"/> 1296: 	     binary_to_term_stress(
<a name="1297"/> 1297: 	       &lt;&lt;131,
<a name="1298"/> 1298: 		104,2,				%Tuple, 2 elements
<a name="1299"/> 1299: 		103,				%Pid
<a name="1300"/> 1300: 		106,				%[] instead of atom.
<a name="1301"/> 1301: 		0,0,0,17,
<a name="1302"/> 1302: 		0,0,0,135,
<a name="1303"/> 1303: 		2,
<a name="1304"/> 1304: 		106&gt;&gt;)),
<a name="1305"/> 1305: 
<a name="1306"/> 1306:     {'EXIT',_} =
<a name="1307"/> 1307: 	(catch
<a name="1308"/> 1308: 	     binary_to_term_stress(
<a name="1309"/> 1309: 	       %% A old-type fun in a list containing a bad creator pid.
<a name="1310"/> 1310: 	       &lt;&lt;131,108,0,0,0,1,117,0,0,0,0,103,100,0,13,110,111,110,111,100,101,64,110,111,104,111,115,116,255,255,0,25,255,0,0,0,0,100,0,1,116,97,0,98,6,142,121,72,106&gt;&gt;)),
<a name="1311"/> 1311: 
<a name="1312"/> 1312:     {'EXIT',_} =
<a name="1313"/> 1313: 	(catch
<a name="1314"/> 1314: 	     binary_to_term_stress(
<a name="1315"/> 1315: 	       %% A new-type fun in a list containing a bad creator pid.
<a name="1316"/> 1316: 	       %% 
<a name="1317"/> 1317: 	       &lt;&lt;131,
<a name="1318"/> 1318: 		108,0,0,0,1,			%List, 1 element
<a name="1319"/> 1319: 		112,0,0,0,66,0,52,216,81,158,148,250,237,109,185,9,208,60,202,156,244,218,0,0,0,0,0,0,0,0,100,0,1,116,97,0,98,6,142,121,72,
<a name="1320"/> 1320: 		103,				%Pid.
<a name="1321"/> 1321: 		106,				%[] instead of an atom.
<a name="1322"/> 1322: 		0,0,0,27,0,0,0,0,0,106&gt;&gt;)),
<a name="1323"/> 1323: 
<a name="1324"/> 1324:     {'EXIT',_} =
<a name="1325"/> 1325: 	(catch
<a name="1326"/> 1326: 	     binary_to_term_stress(
<a name="1327"/> 1327: 	       %% A new-type fun in a list containing a bad module.
<a name="1328"/> 1328: 	       &lt;&lt;131,
<a name="1329"/> 1329: 		108,0,0,0,1,			%List, 1 element
<a name="1330"/> 1330: 		112,0,0,0,70,0,224,90,4,101,48,28,110,228,153,48,239,169,232,77,108,145,0,0,0,0,0,0,0,2,
<a name="1331"/> 1331: 		%%100,0,1,116,
<a name="1332"/> 1332: 		107,0,1,64,			%String instead of atom (same length).
<a name="1333"/> 1333: 		97,0,98,6,64,82,230,103,100,0,13,110,111,110,111,100,101,64,110,111,104,111,115,116,0,0,0,48,0,0,0,0,0,97,42,97,7,106&gt;&gt;)),
<a name="1334"/> 1334: 
<a name="1335"/> 1335:     {'EXIT',_} =
<a name="1336"/> 1336: 	(catch
<a name="1337"/> 1337: 	     binary_to_term_stress(
<a name="1338"/> 1338: 	       %% A new-type fun in a list containing a bad index.
<a name="1339"/> 1339: 	       &lt;&lt;131,
<a name="1340"/> 1340: 		108,0,0,0,1,			%List, 1 element
<a name="1341"/> 1341: 		112,0,0,0,70,0,224,90,4,101,48,28,110,228,153,48,239,169,232,77,108,145,0,0,0,0,0,0,0,2,
<a name="1342"/> 1342: 		100,0,1,116,
<a name="1343"/> 1343: 		%%97,0,				%Integer: 0.
<a name="1344"/> 1344: 		104,0,				%Tuple {} instead of integer.
<a name="1345"/> 1345: 		98,6,64,82,230,103,100,0,13,110,111,110,111,100,101,64,110,111,104,111,115,116,0,0,0,48,0,0,0,0,0,97,42,97,7,106&gt;&gt;)),
<a name="1346"/> 1346: 
<a name="1347"/> 1347:     {'EXIT',_} =
<a name="1348"/> 1348: 	(catch
<a name="1349"/> 1349: 	     binary_to_term_stress(
<a name="1350"/> 1350: 	       %% A new-type fun in a list containing a bad unique value.
<a name="1351"/> 1351: 	       &lt;&lt;131,
<a name="1352"/> 1352: 		108,0,0,0,1,			%List, 1 element
<a name="1353"/> 1353: 		112,0,0,0,70,0,224,90,4,101,48,28,110,228,153,48,239,169,232,77,108,145,0,0,0,0,0,0,0,2,
<a name="1354"/> 1354: 		100,0,1,116,
<a name="1355"/> 1355: 		97,0,				%Integer: 0.
<a name="1356"/> 1356: 		%%98,6,64,82,230,		%Integer.
<a name="1357"/> 1357: 		100,0,2,64,65,			%Atom instead of integer.
<a name="1358"/> 1358: 		103,100,0,13,110,111,110,111,100,101,64,110,111,104,111,115,116,0,0,0,48,0,0,0,0,0,97,42,97,7,106&gt;&gt;)),
<a name="1359"/> 1359: 
<a name="1360"/> 1360:     %% An absurdly large atom.
<a name="1361"/> 1361:     {'EXIT',_} = 
<a name="1362"/> 1362: 	(catch binary_to_term_stress(iolist_to_binary([&lt;&lt;131,100,65000:16&gt;&gt;|
<a name="1363"/> 1363: 						lists:duplicate(65000, 42)]))),
<a name="1364"/> 1364: 
<a name="1365"/> 1365:     %% Longer than 255 characters.
<a name="1366"/> 1366:     {'EXIT',_} = 
<a name="1367"/> 1367: 	(catch binary_to_term_stress(iolist_to_binary([&lt;&lt;131,100,256:16&gt;&gt;|
<a name="1368"/> 1368: 						lists:duplicate(256, 42)]))),
<a name="1369"/> 1369: 
<a name="1370"/> 1370:     %% OTP-7218. Thanks to Matthew Dempsky. Also make sure that we
<a name="1371"/> 1371:     %% cover the other error cases for external funs (EXPORT_EXT).
<a name="1372"/> 1372:     {'EXIT',_} = 
<a name="1373"/> 1373: 	(catch binary_to_term_stress(
<a name="1374"/> 1374: 		 &lt;&lt;131,
<a name="1375"/> 1375: 		  113,				%EXPORT_EXP
<a name="1376"/> 1376: 		  97,13,			%Integer: 13
<a name="1377"/> 1377: 		  97,13,			%Integer: 13
<a name="1378"/> 1378: 		  97,13&gt;&gt;)),			%Integer: 13
<a name="1379"/> 1379:     {'EXIT',_} = 
<a name="1380"/> 1380: 	(catch binary_to_term_stress(
<a name="1381"/> 1381: 		 &lt;&lt;131,
<a name="1382"/> 1382: 		  113,				%EXPORT_EXP
<a name="1383"/> 1383: 		  100,0,1,64,			%Atom: '@'
<a name="1384"/> 1384: 		  97,13,			%Integer: 13
<a name="1385"/> 1385: 		  97,13&gt;&gt;)),			%Integer: 13
<a name="1386"/> 1386:     {'EXIT',_} = 
<a name="1387"/> 1387: 	(catch binary_to_term_stress(
<a name="1388"/> 1388: 		 &lt;&lt;131,
<a name="1389"/> 1389: 		  113,				%EXPORT_EXP
<a name="1390"/> 1390: 		  100,0,1,64,			%Atom: '@'
<a name="1391"/> 1391: 		  100,0,1,64,			%Atom: '@'
<a name="1392"/> 1392: 		  106&gt;&gt;)),			%NIL
<a name="1393"/> 1393:     {'EXIT',_} = 
<a name="1394"/> 1394: 	(catch binary_to_term_stress(
<a name="1395"/> 1395: 		 &lt;&lt;131,
<a name="1396"/> 1396: 		  113,				%EXPORT_EXP
<a name="1397"/> 1397: 		  100,0,1,64,			%Atom: '@'
<a name="1398"/> 1398: 		  100,0,1,64,			%Atom: '@'
<a name="1399"/> 1399: 		  98,255,255,255,255&gt;&gt;)),	%Integer: -1
<a name="1400"/> 1400:     {'EXIT',_} = 
<a name="1401"/> 1401: 	(catch binary_to_term_stress(
<a name="1402"/> 1402: 		 &lt;&lt;131,
<a name="1403"/> 1403: 		  113,				%EXPORT_EXP
<a name="1404"/> 1404: 		  100,0,1,64,			%Atom: '@'
<a name="1405"/> 1405: 		  100,0,1,64,			%Atom: '@'
<a name="1406"/> 1406: 		  113,97,13,97,13,97,13&gt;&gt;)),	%fun 13:13/13
<a name="1407"/> 1407: 
<a name="1408"/> 1408:     %% Bad funs.
<a name="1409"/> 1409:     {'EXIT',_} = (catch binary_to_term_stress(fake_fun(0, lists:seq(0, 256)))),
<a name="otp_5484-last_expr"/><a name="1410"/> 1410:     ok.
<a name="1411"/> 1411: 
<a name="fake_fun-2"/><a name="1412"/> 1412: <b>fake_fun</b>(Arity, Env0) -&gt;
<a name="1413"/> 1413:     Uniq = erlang:md5([]),
<a name="1414"/> 1414:     Index = 0,
<a name="1415"/> 1415:     NumFree = length(Env0),
<a name="1416"/> 1416:     Mod = list_to_binary(?MODULE_STRING),
<a name="1417"/> 1417:     OldIndex = 0,
<a name="1418"/> 1418:     OldUniq = 16#123456,
<a name="1419"/> 1419:     &lt;&lt;131,Pid/binary&gt;&gt; = term_to_binary(self()),
<a name="1420"/> 1420:     Env1 = [term_to_binary(Term) || Term &lt;- Env0],
<a name="1421"/> 1421:     Env = &lt;&lt; &lt;&lt;Bin/binary&gt;&gt; || &lt;&lt;131,Bin/binary&gt;&gt; &lt;- Env1 &gt;&gt;,
<a name="1422"/> 1422:     B = &lt;&lt;Arity,Uniq/binary,Index:32,NumFree:32,
<a name="1423"/> 1423: 	 $d,(byte_size(Mod)):16,Mod/binary,	%Module.
<a name="1424"/> 1424: 	 $a,OldIndex:8,
<a name="1425"/> 1425: 	 $b,OldUniq:32,
<a name="1426"/> 1426: 	 Pid/binary,Env/binary&gt;&gt;,
<a name="fake_fun-last_expr"/><a name="1427"/> 1427: <b>    &lt;&lt;131,$p,</b>(byte_size(B)+4):32,B/binary&gt;&gt;.
<a name="1428"/> 1428: 
<a name="1429"/> 1429: 
<a name="1430"/> 1430: <i>%% More bad terms submitted by Matthias Lang.</i>
<a name="otp_5933-1"/><a name="1431"/> 1431: <b>otp_5933</b>(Config) when is_list(Config) -&gt;
<a name="1432"/> 1432:     try_bad_lengths(&lt;&lt;131,$m&gt;&gt;),		%binary
<a name="1433"/> 1433:     try_bad_lengths(&lt;&lt;131,$n&gt;&gt;),		%bignum
<a name="1434"/> 1434:     try_bad_lengths(&lt;&lt;131,$o&gt;&gt;),		%huge bignum
<a name="otp_5933-last_expr"/><a name="1435"/> 1435:     ok.
<a name="1436"/> 1436: 
<a name="try_bad_lengths-1"/><a name="1437"/> 1437: <b>try_bad_lengths</b>(B) -&gt;
<a name="try_bad_lengths-last_expr"/><a name="1438"/> 1438: <b>    try_bad_lengths</b>(B, 16#FFFFFFFF).
<a name="1439"/> 1439: 
<a name="try_bad_lengths-2"/><a name="1440"/> 1440: <b>try_bad_lengths</b>(B, L) when L &gt; 16#FFFFFFF0 -&gt;
<a name="1441"/> 1441:     Bin = &lt;&lt;B/binary,L:32&gt;&gt;,
<a name="1442"/> 1442:     io:format(&quot;~p\n&quot;, [Bin]),
<a name="1443"/> 1443:     {'EXIT',_} = (catch binary_to_term_stress(Bin)),
<a name="1444"/> 1444:     try_bad_lengths(B, L-1);
<a name="try_bad_lengths-last_expr"/><a name="1445"/> 1445: <b>try_bad_lengths</b>(_, _) -&gt; ok.
<a name="1446"/> 1446: 
<a name="1447"/> 1447: 
<a name="otp_6817-1"/><a name="1448"/> 1448: <b>otp_6817</b>(Config) when is_list(Config) -&gt;
<a name="1449"/> 1449:     process_flag(min_heap_size, 20000),		%Use the heap, not heap fragments.
<a name="1450"/> 1450: 
<a name="1451"/> 1451:     %% Floats are only validated when the heap fragment has been allocated.
<a name="1452"/> 1452:     BadFloat = &lt;&lt;131,99,53,46,48,$X,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,101,45,48,49,0,0,0,0,0&gt;&gt;,
<a name="1453"/> 1453:     otp_6817_try_bin(BadFloat),
<a name="1454"/> 1454: 
<a name="1455"/> 1455:     %% {Binary,BadFloat}: When the error in float is discovered, a refc-binary
<a name="1456"/> 1456:     %% has been allocated and the list of refc-binaries goes through the
<a name="1457"/> 1457:     %% limbo area between the heap top and stack.
<a name="1458"/> 1458:     BinAndFloat = 
<a name="1459"/> 1459: 	&lt;&lt;131,104,2,109,0,0,1,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,
<a name="1460"/> 1460: 	 21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,
<a name="1461"/> 1461: 	 46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,
<a name="1462"/> 1462: 	 71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,
<a name="1463"/> 1463: 	 96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,
<a name="1464"/> 1464: 	 116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,
<a name="1465"/> 1465: 	 135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,
<a name="1466"/> 1466: 	 154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,
<a name="1467"/> 1467: 	 173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
<a name="1468"/> 1468: 	 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,
<a name="1469"/> 1469: 	 211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,
<a name="1470"/> 1470: 	 230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,
<a name="1471"/> 1471: 	 249,250,251,252,253,254,255,99,51,46,49,52,$B,$l,$u,$r,$f,48,48,48,48,48,48,
<a name="1472"/> 1472: 	 48,48,49,50,52,51,52,101,43,48,48,0,0,0,0,0&gt;&gt;,
<a name="1473"/> 1473:     otp_6817_try_bin(BinAndFloat),
<a name="1474"/> 1474: 
<a name="1475"/> 1475:     %% {Fun,BadFloat}
<a name="1476"/> 1476:     FunAndFloat =
<a name="1477"/> 1477: 	&lt;&lt;131,104,2,112,0,0,0,66,0,238,239,135,138,137,216,89,57,22,111,52,126,16,84,
<a name="1478"/> 1478: 	 71,8,0,0,0,0,0,0,0,0,100,0,1,116,97,0,98,5,175,169,123,103,100,0,13,110,111,
<a name="1479"/> 1479: 	 110,111,100,101,64,110,111,104,111,115,116,0,0,0,41,0,0,0,0,0,99,50,46,55,48,
<a name="1480"/> 1480: 	 $Y,57,57,57,57,57,57,57,57,57,57,57,57,57,54,52,52,55,101,43,48,48,0,0,0,0,0&gt;&gt;,
<a name="1481"/> 1481:     otp_6817_try_bin(FunAndFloat),
<a name="1482"/> 1482: 
<a name="1483"/> 1483:     %% [ExternalPid|BadFloat]
<a name="1484"/> 1484:     ExtPidAndFloat =
<a name="1485"/> 1485: 	&lt;&lt;131,108,0,0,0,1,103,100,0,13,107,97,108,108,101,64,115,116,114,105,100,101,
<a name="1486"/> 1486: 	 114,0,0,0,36,0,0,0,0,2,99,48,46,$@,48,48,48,48,48,48,48,48,48,48,48,48,48,48,
<a name="1487"/> 1487: 	 48,48,48,48,48,101,43,48,48,0,0,0,0,0&gt;&gt;,
<a name="1488"/> 1488:     otp_6817_try_bin(ExtPidAndFloat),
<a name="otp_6817-last_expr"/><a name="1489"/> 1489:     ok.
<a name="1490"/> 1490: 
<a name="otp_6817_try_bin-1"/><a name="1491"/> 1491: <b>otp_6817_try_bin</b>(Bin) -&gt;
<a name="1492"/> 1492:     erlang:garbage_collect(),
<a name="1493"/> 1493: 
<a name="1494"/> 1494:     %% If the bug is present, the heap pointer will moved when the invalid term
<a name="1495"/> 1495:     %% is found and we will have a linked list passing through the limbo area
<a name="1496"/> 1496:     %% between the heap top and the stack pointer.
<a name="1497"/> 1497:     catch binary_to_term_stress(Bin),
<a name="1498"/> 1498: 
<a name="1499"/> 1499:     %% If the bug is present, we will overwrite the pointers in the limbo area.
<a name="1500"/> 1500:     Filler = erlang:make_tuple(1024, 16#3FA),
<a name="1501"/> 1501:     id(Filler),
<a name="1502"/> 1502: 
<a name="1503"/> 1503:     %% Will crash if the bug is present.
<a name="otp_6817_try_bin-last_expr"/><a name="1504"/> 1504: <b>    erlang:garbage_collect</b>().
<a name="1505"/> 1505: 
<a name="1506"/> 1506: <i>%% Some bugs in binary_to_term when 32-bit integers are negative.</i>
<a name="otp_8117-1"/><a name="1507"/> 1507: <b>otp_8117</b>(Config) when is_list(Config) -&gt;
<a name="1508"/> 1508:     [otp_8117_do(Op,-(1 bsl N)) || Op &lt;- ['fun',named_fun,list,tuple],
<a name="1509"/> 1509: 				   N &lt;- lists:seq(0,31)],
<a name="otp_8117-last_expr"/><a name="1510"/> 1510:     ok.
<a name="1511"/> 1511: 
<a name="otp_8117_do-2"/><a name="1512"/> 1512: <b>otp_8117_do</b>('fun',Neg) -&gt;
<a name="1513"/> 1513:     % Fun with negative num_free
<a name="1514"/> 1514:     FunBin = term_to_binary(fun() -&gt; ok end),
<a name="1515"/> 1515:     &lt;&lt;B1:27/binary,_NumFree:32,Rest/binary&gt;&gt; = FunBin,   
<a name="1516"/> 1516:     bad_bin_to_term(&lt;&lt;B1/binary,Neg:32,Rest/binary&gt;&gt;);
<a name="1517"/> 1517: <b>otp_8117_do</b>(named_fun,Neg) -&gt;
<a name="1518"/> 1518:     % Named fun with negative num_free
<a name="1519"/> 1519:     FunBin = term_to_binary(fun F() -&gt; F end),
<a name="1520"/> 1520:     &lt;&lt;B1:27/binary,_NumFree:32,Rest/binary&gt;&gt; = FunBin,
<a name="1521"/> 1521:     bad_bin_to_term(&lt;&lt;B1/binary,Neg:32,Rest/binary&gt;&gt;);
<a name="1522"/> 1522: <b>otp_8117_do</b>(list,Neg) -&gt;
<a name="1523"/> 1523:     %% List with negative length
<a name="1524"/> 1524:     bad_bin_to_term(&lt;&lt;131,104,2,108,Neg:32,97,11,104,1,97,12,97,13,106,97,14&gt;&gt;);
<a name="1525"/> 1525: <b>otp_8117_do</b>(tuple,Neg) -&gt;    
<a name="1526"/> 1526:     %% Tuple with negative arity
<a name="otp_8117_do-last_expr"/><a name="1527"/> 1527: <b>    bad_bin_to_term</b>(&lt;&lt;131,104,2,105,Neg:32,97,11,97,12,97,13,97,14&gt;&gt;).
<a name="1528"/> 1528:     
<a name="1529"/> 1529: 
<a name="1530"/> 1530: <i>%% Tests ordering of binaries.</i>
<a name="ordering-1"/><a name="1531"/> 1531: <b>ordering</b>(Config) when is_list(Config) -&gt;
<a name="1532"/> 1532:     B1 = list_to_binary([7,8,9]),
<a name="1533"/> 1533:     B2 = make_sub_binary([1,2,3,4]),
<a name="1534"/> 1534:     B3 = list_to_binary([1,2,3,5]),
<a name="1535"/> 1535:     Unaligned = make_unaligned_sub_binary(B2),
<a name="1536"/> 1536: 
<a name="1537"/> 1537:     %% From R8 binaries are compared as strings.
<a name="1538"/> 1538: 
<a name="1539"/> 1539:     false = B1 == B2,
<a name="1540"/> 1540:     false = B1 =:= B2,
<a name="1541"/> 1541:     true = B1 /= B2,
<a name="1542"/> 1542:     true = B1 =/= B2,
<a name="1543"/> 1543: 
<a name="1544"/> 1544:     true = B1 &gt; B2,
<a name="1545"/> 1545:     true = B2 &lt; B3,
<a name="1546"/> 1546:     true = B2 =&lt; B1,
<a name="1547"/> 1547:     true = B2 =&lt; B3,
<a name="1548"/> 1548: 
<a name="1549"/> 1549:     true = B2 =:= Unaligned,
<a name="1550"/> 1550:     true = B2 == Unaligned,
<a name="1551"/> 1551:     true = Unaligned &lt; B3,
<a name="1552"/> 1552:     true = Unaligned =&lt; B3,
<a name="1553"/> 1553: 
<a name="1554"/> 1554:     %% Binaries are greater than all other terms.
<a name="1555"/> 1555: 
<a name="1556"/> 1556:     true = B1 &gt; 0,
<a name="1557"/> 1557:     true = B1 &gt; 39827491247298471289473333333333333333333333333333,
<a name="1558"/> 1558:     true = B1 &gt; -3489274937438742190467869234328742398347,
<a name="1559"/> 1559:     true = B1 &gt; 3.14,
<a name="1560"/> 1560:     true = B1 &gt; [],
<a name="1561"/> 1561:     true = B1 &gt; [a],
<a name="1562"/> 1562:     true = B1 &gt; {a},
<a name="1563"/> 1563:     true = B1 &gt; self(),
<a name="1564"/> 1564:     true = B1 &gt; make_ref(),
<a name="1565"/> 1565:     true = B1 &gt; xxx,
<a name="1566"/> 1566:     true = B1 &gt; fun() -&gt; 1 end,
<a name="1567"/> 1567:     true = B1 &gt; fun erlang:send/2,
<a name="1568"/> 1568: 
<a name="1569"/> 1569:     Port = hd(erlang:ports()),
<a name="1570"/> 1570:     true = B1 &gt; Port,
<a name="1571"/> 1571: 
<a name="1572"/> 1572:     true = B1 &gt;= 0,
<a name="1573"/> 1573:     true = B1 &gt;= 39827491247298471289473333333333333333333333333333,
<a name="1574"/> 1574:     true = B1 &gt;= -3489274937438742190467869234328742398347,
<a name="1575"/> 1575:     true = B1 &gt;= 3.14,
<a name="1576"/> 1576:     true = B1 &gt;= [],
<a name="1577"/> 1577:     true = B1 &gt;= [a],
<a name="1578"/> 1578:     true = B1 &gt;= {a},
<a name="1579"/> 1579:     true = B1 &gt;= self(),
<a name="1580"/> 1580:     true = B1 &gt;= make_ref(),
<a name="1581"/> 1581:     true = B1 &gt;= xxx,
<a name="1582"/> 1582:     true = B1 &gt;= fun() -&gt; 1 end,
<a name="1583"/> 1583:     true = B1 &gt;= fun erlang:send/2,
<a name="1584"/> 1584:     true = B1 &gt;= Port,
<a name="1585"/> 1585: 
<a name="ordering-last_expr"/><a name="1586"/> 1586:     ok.
<a name="1587"/> 1587: 
<a name="1588"/> 1588: <i>%% Test that comparison between binaries with different alignment work.</i>
<a name="unaligned_order-1"/><a name="1589"/> 1589: <b>unaligned_order</b>(Config) when is_list(Config) -&gt;
<a name="1590"/> 1590:     L = lists:seq(0, 7),
<a name="1591"/> 1591:     [test_unaligned_order(I, J) || I &lt;- L, J &lt;- L], 
<a name="unaligned_order-last_expr"/><a name="1592"/> 1592:     ok.
<a name="1593"/> 1593: 
<a name="test_unaligned_order-2"/><a name="1594"/> 1594: <b>test_unaligned_order</b>(I, J) -&gt;
<a name="1595"/> 1595:     Align = {I,J},
<a name="1596"/> 1596:     io:format(&quot;~p ~p&quot;, [I,J]),
<a name="1597"/> 1597:     true = test_unaligned_order_1('=:=', &lt;&lt;1,2,3,16#AA,16#7C,4,16#5F,5,16#5A&gt;&gt;,
<a name="1598"/> 1598: 					&lt;&lt;1,2,3,16#AA,16#7C,4,16#5F,5,16#5A&gt;&gt;,
<a name="1599"/> 1599: 					Align),
<a name="1600"/> 1600:     false = test_unaligned_order_1('=/=', &lt;&lt;1,2,3&gt;&gt;, &lt;&lt;1,2,3&gt;&gt;, Align),
<a name="1601"/> 1601:     true = test_unaligned_order_1('==', &lt;&lt;4,5,6&gt;&gt;, &lt;&lt;4,5,6&gt;&gt;, Align),
<a name="1602"/> 1602:     false = test_unaligned_order_1('/=', &lt;&lt;1,2,3&gt;&gt;, &lt;&lt;1,2,3&gt;&gt;, Align),
<a name="1603"/> 1603: 
<a name="1604"/> 1604:     true = test_unaligned_order_1('&lt;', &lt;&lt;1,2&gt;&gt;, &lt;&lt;1,2,3&gt;&gt;, Align),
<a name="1605"/> 1605:     true = test_unaligned_order_1('=&lt;', &lt;&lt;1,2&gt;&gt;, &lt;&lt;1,2,3&gt;&gt;, Align),
<a name="1606"/> 1606:     true = test_unaligned_order_1('=&lt;', &lt;&lt;1,2,7,8&gt;&gt;, &lt;&lt;1,2,7,8&gt;&gt;, Align),
<a name="test_unaligned_order-last_expr"/><a name="1607"/> 1607:     ok.
<a name="1608"/> 1608: 
<a name="test_unaligned_order_1-4"/><a name="1609"/> 1609: <b>test_unaligned_order_1</b>(Op, A, B, {Aa,Ba}) -&gt;
<a name="test_unaligned_order_1-last_expr"/><a name="1610"/> 1610: <b>    erlang:Op</b>(unaligned_sub_bin(A, Aa), unaligned_sub_bin(B, Ba)).
<a name="1611"/> 1611:     
<a name="test_terms-1"/><a name="1612"/> 1612: <b>test_terms</b>(Test_Func) -&gt;
<a name="1613"/> 1613:     Test_Func(atom),
<a name="1614"/> 1614:     Test_Func(''),
<a name="1615"/> 1615:     Test_Func('a'),
<a name="1616"/> 1616:     Test_Func('ab'),
<a name="1617"/> 1617:     Test_Func('abc'),
<a name="1618"/> 1618:     Test_Func('abcd'),
<a name="1619"/> 1619:     Test_Func('abcde'),
<a name="1620"/> 1620:     Test_Func('abcdef'),
<a name="1621"/> 1621:     Test_Func('abcdefg'),
<a name="1622"/> 1622:     Test_Func('abcdefgh'),
<a name="1623"/> 1623: 
<a name="1624"/> 1624:     Test_Func(fun() -&gt; ok end),
<a name="1625"/> 1625:     X = id([a,{b,c},c]),
<a name="1626"/> 1626:     Y = id({x,y,z}),
<a name="1627"/> 1627:     Z = id(1 bsl 8*257),
<a name="1628"/> 1628:     Test_Func(fun() -&gt; X end),
<a name="1629"/> 1629:     Test_Func(fun() -&gt; {X,Y} end),
<a name="1630"/> 1630:     Test_Func([fun() -&gt; {X,Y,Z} end,
<a name="1631"/> 1631: 		     fun() -&gt; {Z,X,Y} end,
<a name="1632"/> 1632: 		     fun() -&gt; {Y,Z,X} end]),
<a name="1633"/> 1633: 
<a name="1634"/> 1634:     Test_Func({trace_ts,{even_bigger,{some_data,fun() -&gt; ok end}},{1,2,3}}),
<a name="1635"/> 1635:     Test_Func({trace_ts,{even_bigger,{some_data,&lt;&lt;1,2,3,4,5,6,7,8,9,10&gt;&gt;}},
<a name="1636"/> 1636: 		     {1,2,3}}),
<a name="1637"/> 1637: 
<a name="1638"/> 1638:     Test_Func(1),
<a name="1639"/> 1639:     Test_Func(42),
<a name="1640"/> 1640:     Test_Func(-23),
<a name="1641"/> 1641:     Test_Func(256),
<a name="1642"/> 1642:     Test_Func(25555),
<a name="1643"/> 1643:     Test_Func(-3333),
<a name="1644"/> 1644: 
<a name="1645"/> 1645:     Test_Func(1.0),
<a name="1646"/> 1646: 
<a name="1647"/> 1647:     Test_Func(183749783987483978498378478393874),
<a name="1648"/> 1648:     Test_Func(-37894183749783987483978498378478393874),
<a name="1649"/> 1649:     Very_Big = very_big_num(),
<a name="1650"/> 1650:     Test_Func(Very_Big),
<a name="1651"/> 1651:     Test_Func(-Very_Big+1),
<a name="1652"/> 1652: 
<a name="1653"/> 1653:     Test_Func([]),
<a name="1654"/> 1654:     Test_Func(&quot;abcdef&quot;),
<a name="1655"/> 1655:     Test_Func([a, b, 1, 2]),
<a name="1656"/> 1656:     Test_Func([a|b]),
<a name="1657"/> 1657:     Test_Func([make_port(), make_ref(), make_pid(), fun() -&gt; ok end,
<a name="1658"/> 1658:                Very_Big | lists:seq(1, 75)]),
<a name="1659"/> 1659: 
<a name="1660"/> 1660:     Test_Func({}),
<a name="1661"/> 1661:     Test_Func({1}),
<a name="1662"/> 1662:     Test_Func({a, b}),
<a name="1663"/> 1663:     Test_Func({a, b, c}),
<a name="1664"/> 1664:     Test_Func({make_port(), make_ref(), make_pid(), fun() -&gt; ok end}),
<a name="1665"/> 1665:     Test_Func(list_to_tuple(lists:seq(0, 255))),
<a name="1666"/> 1666:     Test_Func(list_to_tuple(lists:seq(0, 256))),
<a name="1667"/> 1667: 
<a name="1668"/> 1668:     Test_Func(make_ref()),
<a name="1669"/> 1669:     Test_Func([make_ref(), make_ref()]),
<a name="1670"/> 1670: 
<a name="1671"/> 1671:     Test_Func(make_port()),
<a name="1672"/> 1672: 
<a name="1673"/> 1673:     Test_Func(make_pid()),
<a name="1674"/> 1674: 
<a name="1675"/> 1675:     Test_Func(Bin0 = list_to_binary(lists:seq(0, 14))),
<a name="1676"/> 1676:     Test_Func(Bin1 = list_to_binary(lists:seq(0, ?heap_binary_size))),
<a name="1677"/> 1677:     Test_Func(Bin2 = list_to_binary(lists:seq(0, ?heap_binary_size+1))),
<a name="1678"/> 1678:     Test_Func(Bin3 = list_to_binary(lists:seq(0, 255))),
<a name="1679"/> 1679: 
<a name="1680"/> 1680:     Test_Func(make_unaligned_sub_binary(Bin0)),
<a name="1681"/> 1681:     Test_Func(make_unaligned_sub_binary(Bin1)),
<a name="1682"/> 1682:     Test_Func(make_unaligned_sub_binary(Bin2)),
<a name="1683"/> 1683:     Test_Func(make_unaligned_sub_binary(Bin3)),
<a name="1684"/> 1684: 
<a name="1685"/> 1685:     Test_Func(make_sub_binary(lists:seq(42, 43))),
<a name="1686"/> 1686:     Test_Func(make_sub_binary([42,43,44])),
<a name="1687"/> 1687:     Test_Func(make_sub_binary([42,43,44,45])),
<a name="1688"/> 1688:     Test_Func(make_sub_binary([42,43,44,45,46])),
<a name="1689"/> 1689:     Test_Func(make_sub_binary([42,43,44,45,46,47])),
<a name="1690"/> 1690:     Test_Func(make_sub_binary([42,43,44,45,46,47,48])),
<a name="1691"/> 1691:     Test_Func(make_sub_binary(lists:seq(42, 49))),
<a name="1692"/> 1692:     Test_Func(make_sub_binary(lists:seq(0, 14))),
<a name="1693"/> 1693:     Test_Func(make_sub_binary(lists:seq(0, ?heap_binary_size))),
<a name="1694"/> 1694:     Test_Func(make_sub_binary(lists:seq(0, ?heap_binary_size+1))),
<a name="1695"/> 1695:     Test_Func(make_sub_binary(lists:seq(0, 255))),
<a name="1696"/> 1696: 
<a name="1697"/> 1697:     Test_Func(make_unaligned_sub_binary(lists:seq(42, 43))),
<a name="1698"/> 1698:     Test_Func(make_unaligned_sub_binary([42,43,44])),
<a name="1699"/> 1699:     Test_Func(make_unaligned_sub_binary([42,43,44,45])),
<a name="1700"/> 1700:     Test_Func(make_unaligned_sub_binary([42,43,44,45,46])),
<a name="1701"/> 1701:     Test_Func(make_unaligned_sub_binary([42,43,44,45,46,47])),
<a name="1702"/> 1702:     Test_Func(make_unaligned_sub_binary([42,43,44,45,46,47,48])),
<a name="1703"/> 1703:     Test_Func(make_unaligned_sub_binary(lists:seq(42, 49))),
<a name="1704"/> 1704:     Test_Func(make_unaligned_sub_binary(lists:seq(0, 14))),
<a name="1705"/> 1705:     Test_Func(make_unaligned_sub_binary(lists:seq(0, ?heap_binary_size))),
<a name="1706"/> 1706:     Test_Func(make_unaligned_sub_binary(lists:seq(0, ?heap_binary_size+1))),
<a name="1707"/> 1707:     Test_Func(make_unaligned_sub_binary(lists:seq(0, 255))),
<a name="1708"/> 1708: 
<a name="1709"/> 1709:     %% Bit level binaries.
<a name="1710"/> 1710:     Test_Func(&lt;&lt;1:1&gt;&gt;),
<a name="1711"/> 1711:     Test_Func(&lt;&lt;2:2&gt;&gt;),
<a name="1712"/> 1712:     Test_Func(&lt;&lt;42:10&gt;&gt;),
<a name="1713"/> 1713:     Test_Func(list_to_bitstring([&lt;&lt;5:6&gt;&gt;|lists:seq(0, 255)])),
<a name="1714"/> 1714: 
<a name="1715"/> 1715:     %% Funs in a list.
<a name="1716"/> 1716:     Test_Func(F = fun(A) -&gt; 42*A end),
<a name="1717"/> 1717:     Test_Func(lists:duplicate(32, F)),
<a name="1718"/> 1718: 
<a name="1719"/> 1719:     %% External funs in a list.
<a name="1720"/> 1720:     Test_Func(FF = fun binary_SUITE:all/0),
<a name="1721"/> 1721:     Test_Func(lists:duplicate(32, FF)),
<a name="1722"/> 1722: 
<a name="1723"/> 1723:     %% Maps.
<a name="1724"/> 1724:     SmallMap = #{a =&gt; 1, b =&gt; 2, c =&gt; 3},
<a name="1725"/> 1725:     LargeMap1 = maps:from_list([{list_to_atom(integer_to_list(36#cafe+N*N*N, 36)),N} ||
<a name="1726"/> 1726:                                    N &lt;- lists:seq(1, 33)]),
<a name="1727"/> 1727:     LargeMap2 = maps:from_list([{list_to_atom(integer_to_list(36#dead+N, 36)),N} ||
<a name="1728"/> 1728:                                    N &lt;- lists:seq(1, 50)]),
<a name="1729"/> 1729:     MapWithMap = LargeMap1#{SmallMap =&gt; a, LargeMap1 =&gt; LargeMap2, LargeMap2 =&gt; LargeMap1,
<a name="1730"/> 1730:                             [LargeMap1,LargeMap2] =&gt; LargeMap1,
<a name="1731"/> 1731:                             &lt;&lt;&quot;abc&quot;&gt;&gt; =&gt; SmallMap, &lt;&lt;&quot;qrs&quot;&gt;&gt; =&gt; LargeMap1,
<a name="1732"/> 1732:                             &lt;&lt;&quot;xyz&quot;&gt;&gt; =&gt; LargeMap2 },
<a name="1733"/> 1733:     Test_Func(#{}),
<a name="1734"/> 1734:     Test_Func(SmallMap),
<a name="1735"/> 1735:     Test_Func(LargeMap1),
<a name="1736"/> 1736:     Test_Func(LargeMap2),
<a name="1737"/> 1737:     Test_Func(MapWithMap),
<a name="1738"/> 1738: 
<a name="test_terms-last_expr"/><a name="1739"/> 1739:     ok.
<a name="1740"/> 1740: 
<a name="test_floats-1"/><a name="1741"/> 1741: <b>test_floats</b>(Test_Func) -&gt;
<a name="1742"/> 1742:     Test_Func(5.5),
<a name="1743"/> 1743:     Test_Func(-15.32),
<a name="1744"/> 1744:     Test_Func(1.2435e25),
<a name="1745"/> 1745:     Test_Func(1.2333e-20),
<a name="1746"/> 1746:     Test_Func(199.0e+15),
<a name="test_floats-last_expr"/><a name="1747"/> 1747:     ok.
<a name="1748"/> 1748: 
<a name="very_big_num-0"/><a name="1749"/> 1749: <b>very_big_num</b>() -&gt;
<a name="very_big_num-last_expr"/><a name="1750"/> 1750: <b>    very_big_num</b>(33, 1).
<a name="1751"/> 1751: 
<a name="very_big_num-2"/><a name="1752"/> 1752: <b>very_big_num</b>(Left, Result) when Left &gt; 0 -&gt;
<a name="1753"/> 1753:     very_big_num(Left-1, Result*256);
<a name="1754"/> 1754: <b>very_big_num</b>(0, Result) -&gt;
<a name="very_big_num-last_expr"/><a name="1755"/> 1755:     Result.
<a name="1756"/> 1756: 
<a name="make_port-0"/><a name="1757"/> 1757: <b>make_port</b>() -&gt;
<a name="make_port-last_expr"/><a name="1758"/> 1758: <b>    hd</b>(erlang:ports()).
<a name="1759"/> 1759: 
<a name="make_pid-0"/><a name="1760"/> 1760: <b>make_pid</b>() -&gt;
<a name="make_pid-last_expr"/><a name="1761"/> 1761: <b>    spawn_link</b>(?MODULE, sleeper, []).
<a name="1762"/> 1762: 
<a name="sleeper-0"/><a name="1763"/> 1763: <b>sleeper</b>() -&gt;
<a name="sleeper-last_expr"/><a name="1764"/> 1764:     receive after infinity -&gt; ok end.
<a name="1765"/> 1765: 
<a name="1766"/> 1766: 
<a name="1767"/> 1767: <i>%% Test that binaries are garbage collected properly.</i>
<a name="gc_test-1"/><a name="1768"/> 1768: <b>gc_test</b>(Config) when is_list(Config) -&gt;
<a name="1769"/> 1769:     %% Note: This test is only relevant for REFC binaries.
<a name="1770"/> 1770:     %% Therefore, we take care that all binaries are REFC binaries.
<a name="1771"/> 1771:     true = 192 &gt; ?heap_binary_size,
<a name="1772"/> 1772:     B = list_to_binary(lists:seq(1, 192)),
<a name="1773"/> 1773:     Self = self(),
<a name="1774"/> 1774:     F1 = fun() -&gt;
<a name="1775"/> 1775: 		 gc(),
<a name="1776"/> 1776: 		 {binary,[]} = process_info(self(), binary),
<a name="1777"/> 1777: 		 Self ! {self(),done}
<a name="1778"/> 1778: 	 end,
<a name="1779"/> 1779:     F = fun() -&gt;
<a name="1780"/> 1780: 		receive go -&gt; ok end,
<a name="1781"/> 1781: 		{binary,[{_,192,1}]} = process_info(self(), binary),
<a name="1782"/> 1782: 		gc(),
<a name="1783"/> 1783: 		{B1,B2} = my_split_binary(B, 68),
<a name="1784"/> 1784: 		gc(),
<a name="1785"/> 1785: 		gc(),
<a name="1786"/> 1786: 		{binary,L1} = process_info(self(), binary),
<a name="1787"/> 1787: 		[Binfo1,Binfo2,Binfo3] = L1,
<a name="1788"/> 1788: 		{_,192,Refc} = Binfo1 = Binfo2 = Binfo3,
<a name="1789"/> 1789:                 %% This is usually 3 but sharing-preserving can bring this down
<a name="1790"/> 1790:                 %% to 2, and in theory even 1.
<a name="1791"/> 1791:                 true = Refc =&lt; 3,
<a name="1792"/> 1792: 		192 = size(B),
<a name="1793"/> 1793: 		68 = size(B1),
<a name="1794"/> 1794: 		124 = size(B2),
<a name="1795"/> 1795: 		F1()
<a name="1796"/> 1796: 	end,
<a name="1797"/> 1797:     gc(),
<a name="1798"/> 1798:     gc(),
<a name="1799"/> 1799:     192 = size(B),
<a name="gc_test-last_expr"/><a name="1800"/> 1800: <b>    gc_test1</b>(spawn_opt(erlang, apply, [F,[]], [link,{fullsweep_after,0}])).
<a name="1801"/> 1801: 
<a name="gc_test1-1"/><a name="1802"/> 1802: <b>gc_test1</b>(Pid) -&gt;
<a name="1803"/> 1803:     gc(),
<a name="1804"/> 1804:     Pid ! go,
<a name="gc_test1-last_expr"/><a name="1805"/> 1805:     receive
<a name="1806"/> 1806: 	{Pid,done} -&gt; ok
<a name="1807"/> 1807:     after 10000 -&gt;
<a name="1808"/> 1808: 	    ct:fail(&quot;timeout&quot;)
<a name="1809"/> 1809:     end.
<a name="1810"/> 1810: 
<a name="1811"/> 1811: <i>%% Like split binary, but returns REFC binaries. Only useful for gc_test/1.</i>
<a name="1812"/> 1812: 
<a name="my_split_binary-2"/><a name="1813"/> 1813: <b>my_split_binary</b>(B, Pos) -&gt;
<a name="1814"/> 1814:     %% Make sure that all references on the faraway process side are cleaned
<a name="1815"/> 1815:     %% up by receiving the response in a monitor down and waiting &quot;long enough&quot;
<a name="1816"/> 1816:     %% for it to have terminated.
<a name="1817"/> 1817:     {Pid, Mon} = spawn_monitor(fun() -&gt; exit(split_binary(B, Pos)) end),
<a name="my_split_binary-last_expr"/><a name="1818"/> 1818:     receive
<a name="1819"/> 1819:         {'DOWN', Mon, process, Pid, Result} -&gt;
<a name="1820"/> 1820:             timer:sleep(1000),
<a name="1821"/> 1821:             Result
<a name="1822"/> 1822:     end.
<a name="1823"/> 1823: 
<a name="gc-0"/><a name="1824"/> 1824: <b>gc</b>() -&gt;
<a name="1825"/> 1825:     erlang:garbage_collect(),
<a name="gc-last_expr"/><a name="1826"/> 1826: <b>    gc1</b>().
<a name="gc1-0"/><a name="gc1-last_expr"/><a name="1827"/> 1827: <b>gc1</b>() -&gt; ok.
<a name="1828"/> 1828: 
<a name="bit_sized_binary_sizes-1"/><a name="1829"/> 1829: <b>bit_sized_binary_sizes</b>(Config) when is_list(Config) -&gt;
<a name="1830"/> 1830:     [bsbs_1(A) || A &lt;- lists:seq(1, 8)],
<a name="bit_sized_binary_sizes-last_expr"/><a name="1831"/> 1831:     ok.
<a name="1832"/> 1832: 
<a name="bsbs_1-1"/><a name="1833"/> 1833: <b>bsbs_1</b>(A) -&gt;
<a name="1834"/> 1834:     BinSize = 32+A,
<a name="1835"/> 1835:     io:format(&quot;A: ~p BinSize: ~p&quot;, [A,BinSize]),
<a name="1836"/> 1836:     Bin = binary_to_term_stress(&lt;&lt;131,$M,5:32,A,0,0,0,0,0&gt;&gt;),
<a name="bsbs_1-last_expr"/><a name="1837"/> 1837: <b>    BinSize = bit_size</b>(Bin).
<a name="1838"/> 1838: 
<a name="1839"/> 1839: <i>%% lists:foldl(_,_,lists:seq(_,_)) with less heap consumption</i>
<a name="lists_foldl_seq-4"/><a name="1840"/> 1840: <b>lists_foldl_seq</b>(Fun, Acc0, N, To) when N =&lt; To -&gt;
<a name="1841"/> 1841:     Acc1 = Fun(N, Acc0),
<a name="1842"/> 1842:     lists_foldl_seq(Fun, Acc1, N+1, To);
<a name="1843"/> 1843: 
<a name="1844"/> 1844: <b>lists_foldl_seq</b>(_, Acc, _, _) -&gt;
<a name="lists_foldl_seq-last_expr"/><a name="1845"/> 1845:     Acc.
<a name="1846"/> 1846: 
<a name="deep-1"/><a name="1847"/> 1847: <b>deep</b>(Config) when is_list(Config) -&gt;
<a name="1848"/> 1848:     deep_roundtrip(lists_foldl_seq(fun(E, A) -&gt;
<a name="1849"/> 1849: 					   [E,A]
<a name="1850"/> 1850: 				   end, [], 1, 1000000)),
<a name="1851"/> 1851:     erlang:garbage_collect(),
<a name="1852"/> 1852:     deep_roundtrip(lists_foldl_seq(fun(E, A) -&gt;
<a name="1853"/> 1853: 					   {E,A}
<a name="1854"/> 1854: 				   end, [], 1, 1000000)),
<a name="1855"/> 1855:     erlang:garbage_collect(),
<a name="1856"/> 1856:     deep_roundtrip(lists_foldl_seq(fun(E, A) -&gt;
<a name="1857"/> 1857: 					   fun() -&gt; {E,A} end
<a name="1858"/> 1858: 				   end, [], 1, 1000000)),
<a name="1859"/> 1859:     erlang:garbage_collect(),
<a name="deep-last_expr"/><a name="1860"/> 1860:     ok.
<a name="1861"/> 1861: 
<a name="deep_roundtrip-1"/><a name="1862"/> 1862: <b>deep_roundtrip</b>(T) -&gt;
<a name="1863"/> 1863:     B = term_to_binary(T),
<a name="deep_roundtrip-last_expr"/><a name="1864"/> 1864: <b>    T = binary_to_term</b>(B).
<a name="1865"/> 1865: 
<a name="1866"/> 1866: <i>%% Test non-standard encodings never generated by term_to_binary/1</i>
<a name="1867"/> 1867: <i>%% but recognized by binary_to_term/1.</i>
<a name="1868"/> 1868: 
<a name="robustness-1"/><a name="1869"/> 1869: <b>robustness</b>(Config) when is_list(Config) -&gt;
<a name="1870"/> 1870:     [] = binary_to_term_stress(&lt;&lt;131,107,0,0&gt;&gt;),	%Empty string.
<a name="1871"/> 1871:     [] = binary_to_term_stress(&lt;&lt;131,108,0,0,0,0,106&gt;&gt;),	%Zero-length list.
<a name="1872"/> 1872: 
<a name="1873"/> 1873:     %% {[],a} where [] is a zero-length list.
<a name="1874"/> 1874:     {[],a} = binary_to_term_stress(&lt;&lt;131,104,2,108,0,0,0,0,106,100,0,1,97&gt;&gt;),
<a name="1875"/> 1875: 
<a name="1876"/> 1876:     %% {42,a} where 42 is a zero-length list with 42 in the tail.
<a name="1877"/> 1877:     {42,a} = binary_to_term_stress(&lt;&lt;131,104,2,108,0,0,0,0,97,42,100,0,1,97&gt;&gt;),
<a name="1878"/> 1878: 
<a name="1879"/> 1879:     %% {{x,y},a} where {x,y} is a zero-length list with {x,y} in the tail.
<a name="1880"/> 1880:     {{x,y},a} = binary_to_term_stress(&lt;&lt;131,104,2,108,0,0,0,0,
<a name="1881"/> 1881: 				      104,2,100,0,1,120,100,0,1,
<a name="1882"/> 1882: 				      121,100,0,1,97&gt;&gt;),
<a name="1883"/> 1883: 
<a name="1884"/> 1884:     %% Bignums fitting in 32 bits.
<a name="1885"/> 1885:     16#7FFFFFFF = binary_to_term_stress(&lt;&lt;131,98,127,255,255,255&gt;&gt;),
<a name="1886"/> 1886:     -1 = binary_to_term_stress(&lt;&lt;131,98,255,255,255,255&gt;&gt;),
<a name="1887"/> 1887:     
<a name="robustness-last_expr"/><a name="1888"/> 1888:     ok.
<a name="1889"/> 1889: 
<a name="1890"/> 1890: <i>%% OTP-8180: Test several terms that have been known to crash the emulator.</i>
<a name="1891"/> 1891: <i>%% (Thanks to Scott Lystig Fritchie.)</i>
<a name="otp_8180-1"/><a name="1892"/> 1892: <b>otp_8180</b>(Config) when is_list(Config) -&gt;
<a name="1893"/> 1893:     Data = proplists:get_value(data_dir, Config),
<a name="1894"/> 1894:     Wc = filename:join(Data, &quot;zzz.*&quot;),
<a name="1895"/> 1895:     Files = filelib:wildcard(Wc),
<a name="1896"/> 1896:     [run_otp_8180(F) || F &lt;- Files],
<a name="otp_8180-last_expr"/><a name="1897"/> 1897:     ok.
<a name="1898"/> 1898: 
<a name="run_otp_8180-1"/><a name="1899"/> 1899: <b>run_otp_8180</b>(Name) -&gt;
<a name="1900"/> 1900:     io:format(&quot;~s&quot;, [Name]),
<a name="1901"/> 1901:     {ok,Bins} = file:consult(Name),
<a name="1902"/> 1902:     [begin
<a name="1903"/> 1903: 	 io:format(&quot;~p\n&quot;, [Bin]),
<a name="1904"/> 1904: 	 {'EXIT',{badarg,_}} = (catch binary_to_term_stress(Bin))
<a name="1905"/> 1905:      end || Bin &lt;- Bins],
<a name="run_otp_8180-last_expr"/><a name="1906"/> 1906:     ok.
<a name="1907"/> 1907: 
<a name="1908"/> 1908: <i>%% Test that exit and GC during trapping term_to_binary and binary_to_term</i>
<a name="1909"/> 1909: <i>%% does not crash.</i>
<a name="trapping-1"/><a name="1910"/> 1910: <b>trapping</b>(Config) when is_list(Config)-&gt;
<a name="1911"/> 1911:     do_trapping(5, term_to_binary,
<a name="1912"/> 1912: 		fun() -&gt; [lists:duplicate(2000000,2000000)] end),
<a name="1913"/> 1913:     do_trapping(5, binary_to_term,
<a name="1914"/> 1914: 		fun() -&gt; [term_to_binary(lists:duplicate(2000000,2000000))] end),
<a name="1915"/> 1915:     do_trapping(5, binary_to_list,
<a name="1916"/> 1916: 		fun() -&gt; [list_to_binary(lists:duplicate(2000000,$x))] end),
<a name="1917"/> 1917:     do_trapping(5, list_to_binary,
<a name="1918"/> 1918: 		fun() -&gt; [lists:duplicate(2000000,$x)] end),
<a name="1919"/> 1919:     do_trapping(5, bitstring_to_list,
<a name="1920"/> 1920: 		fun() -&gt; [list_to_bitstring([lists:duplicate(2000000,$x),&lt;&lt;7:4&gt;&gt;])] end),
<a name="trapping-last_expr"/><a name="1921"/> 1921: <b>    do_trapping</b>(5, list_to_bitstring,
<a name="1922"/> 1922: 		fun() -&gt; [[lists:duplicate(2000000,$x),&lt;&lt;7:4&gt;&gt;]] end)
<a name="1923"/> 1923:     .
<a name="1924"/> 1924: 
<a name="do_trapping-3"/><a name="1925"/> 1925: <b>do_trapping</b>(0, _, _) -&gt;
<a name="1926"/> 1926:     ok;
<a name="1927"/> 1927: <b>do_trapping</b>(N, Bif, ArgFun) -&gt;
<a name="1928"/> 1928:     io:format(&quot;N=~p: Do ~p ~s gc.\n&quot;, [N, Bif, case N rem 2 of 0 -&gt; &quot;with&quot;; 1 -&gt; &quot;without&quot; end]),
<a name="1929"/> 1929:     Pid = spawn(?MODULE,trapping_loop,[Bif, ArgFun, 1000, self()]),
<a name="1930"/> 1930:     receive ok -&gt; ok end,
<a name="1931"/> 1931:     Ref = make_ref(),
<a name="1932"/> 1932:     case N rem 2 of
<a name="1933"/> 1933: 	0 -&gt;
<a name="1934"/> 1934:             erlang:garbage_collect(Pid, [{async,Ref}]),
<a name="1935"/> 1935:             receive after 1 -&gt; ok end;
<a name="1936"/> 1936: 	1 -&gt; void
<a name="1937"/> 1937:     end,
<a name="1938"/> 1938:     exit(Pid, kill),
<a name="1939"/> 1939:     case N rem 2 of
<a name="1940"/> 1940: 	0 -&gt;
<a name="1941"/> 1941:             receive {garbage_collect, Ref, _} -&gt; ok end;
<a name="1942"/> 1942: 	1 -&gt;
<a name="1943"/> 1943:             void
<a name="1944"/> 1944:     end,
<a name="1945"/> 1945:     receive after 1 -&gt; ok end,
<a name="do_trapping-last_expr"/><a name="1946"/> 1946: <b>    do_trapping</b>(N-1, Bif, ArgFun).
<a name="1947"/> 1947: 
<a name="trapping_loop-4"/><a name="1948"/> 1948: <b>trapping_loop</b>(Bif, ArgFun, N, Pid) -&gt;
<a name="1949"/> 1949:     Args = ArgFun(),
<a name="1950"/> 1950:     Pid ! ok,
<a name="trapping_loop-last_expr"/><a name="1951"/> 1951: <b>    trapping_loop2</b>(Bif,Args,N).
<a name="trapping_loop2-3"/><a name="1952"/> 1952: <b>trapping_loop2</b>(_,_,0) -&gt;
<a name="1953"/> 1953:     ok;
<a name="1954"/> 1954: <b>trapping_loop2</b>(Bif,Args,N) -&gt;
<a name="1955"/> 1955:     apply(erlang,Bif,Args),
<a name="trapping_loop2-last_expr"/><a name="1956"/> 1956: <b>    trapping_loop2</b>(Bif, Args, N-1).
<a name="1957"/> 1957: 
<a name="large-1"/><a name="1958"/> 1958: <b>large</b>(Config) when is_list(Config) -&gt;
<a name="1959"/> 1959:     List = lists:flatten(lists:map(fun (_) -&gt;
<a name="1960"/> 1960: 					   [0,1,2,3,4,5,6,7,8]
<a name="1961"/> 1961: 				   end,
<a name="1962"/> 1962: 				   lists:seq(1, 131072))),
<a name="1963"/> 1963:     Bin = list_to_binary(List),
<a name="1964"/> 1964:     List = binary_to_list(Bin),
<a name="1965"/> 1965:     PartList = lists:reverse(tl(tl(lists:reverse(tl(tl(List)))))),
<a name="1966"/> 1966:     PartList = binary_to_list(Bin, 3, length(List)-2),
<a name="1967"/> 1967:     ListBS = List ++ [&lt;&lt;7:4&gt;&gt;],
<a name="1968"/> 1968:     ListBS = bitstring_to_list(list_to_bitstring(ListBS)),
<a name="1969"/> 1969:     BitStr1 = list_to_bitstring(lists:duplicate(1024*1024, [&lt;&lt;1,5:3&gt;&gt;])),
<a name="1970"/> 1970:     BitStr1 = list_to_bitstring(bitstring_to_list(BitStr1)),
<a name="1971"/> 1971:     BitStr2 = list_to_bitstring([lists:duplicate(512*1024, [&lt;&lt;1,5:3&gt;&gt;]),
<a name="1972"/> 1972: 				Bin]),
<a name="1973"/> 1973:     BitStr2 = list_to_bitstring(bitstring_to_list(BitStr2)),
<a name="large-last_expr"/><a name="1974"/> 1974:     ok.
<a name="1975"/> 1975: 
<a name="error_after_yield-1"/><a name="1976"/> 1976: <b>error_after_yield</b>(Config) when is_list(Config) -&gt;
<a name="1977"/> 1977:     L2BTrap = {erts_internal, list_to_bitstring_continue, 1},
<a name="1978"/> 1978:     error_after_yield(badarg, erlang, list_to_binary, 1, fun () -&gt; [[mk_list(1000000), oops]] end, L2BTrap),
<a name="1979"/> 1979:     error_after_yield(badarg, erlang, iolist_to_binary, 1, fun () -&gt; [[list2iolist(mk_list(1000000)), oops]] end, L2BTrap),
<a name="1980"/> 1980:     error_after_yield(badarg, erlang, list_to_bitstring, 1, fun () -&gt; [[list2bitstrlist(mk_list(1000000)), oops]] end, L2BTrap),
<a name="1981"/> 1981:     error_after_yield(badarg, binary, list_to_bin, 1, fun () -&gt; [[mk_list(1000000), oops]] end, L2BTrap),
<a name="1982"/> 1982: 
<a name="1983"/> 1983:     B2TTrap = {erts_internal, binary_to_term_trap, 1},
<a name="1984"/> 1984: 
<a name="1985"/> 1985:     error_after_yield(badarg, erlang, binary_to_term, 1, fun () -&gt; [error_after_yield_bad_ext_term()] end, B2TTrap),
<a name="1986"/> 1986:     error_after_yield(badarg, erlang, binary_to_term, 2, fun () -&gt; [error_after_yield_bad_ext_term(), [safe]] end, B2TTrap),
<a name="1987"/> 1987: 
<a name="1988"/> 1988:     case erlang:system_info(wordsize) of
<a name="1989"/> 1989: 	4 -&gt;
<a name="1990"/> 1990: 	    SysLimitSz = 1 bsl 32,
<a name="1991"/> 1991: 	    error_after_yield(system_limit, erlang, list_to_binary, 1, fun () -&gt; [[huge_iolist(SysLimitSz), $x]] end, L2BTrap),
<a name="1992"/> 1992: 	    error_after_yield(system_limit, erlang, iolist_to_binary, 1, fun () -&gt; [[huge_iolist(SysLimitSz), $x]] end, L2BTrap),
<a name="1993"/> 1993: 	    error_after_yield(system_limit, erlang, list_to_bitstring, 1, fun () -&gt; [[huge_iolist(SysLimitSz), $x]] end, L2BTrap),
<a name="1994"/> 1994: 	    error_after_yield(system_limit, binary, list_to_bin, 1, fun () -&gt; [[huge_iolist(SysLimitSz), $x]] end, L2BTrap);
<a name="1995"/> 1995: 	8 -&gt;
<a name="1996"/> 1996: 	    % Takes waaaay to long time to test system_limit on 64-bit archs...
<a name="1997"/> 1997: 	    ok
<a name="1998"/> 1998:     end,
<a name="error_after_yield-last_expr"/><a name="1999"/> 1999:     ok.
<a name="2000"/> 2000: 
<a name="error_after_yield-6"/><a name="2001"/> 2001: <b>error_after_yield</b>(Type, M, F, AN, AFun, TrapFunc) -&gt;
<a name="2002"/> 2002:     io:format(&quot;Testing ~p for ~p:~p/~p~n&quot;, [Type, M, F, AN]),
<a name="2003"/> 2003:     Tracer = self(),
<a name="2004"/> 2004:     {Pid, Mon} = spawn_monitor(fun () -&gt;
<a name="2005"/> 2005: 				       A = AFun(),
<a name="2006"/> 2006: 				       try
<a name="2007"/> 2007: 					   erlang:yield(),
<a name="2008"/> 2008: 					   erlang:trace(self(),true,[running,{tracer,Tracer}]),
<a name="2009"/> 2009: 					   apply(M, F, A),
<a name="2010"/> 2010: 					   exit({unexpected_success, {M, F, A}})
<a name="2011"/> 2011: 				       catch
<a name="2012"/> 2012: 					   error:Type:Stk -&gt;
<a name="2013"/> 2013: 					       erlang:trace(self(),false,[running,{tracer,Tracer}]),
<a name="2014"/> 2014: 					       %% We threw the exception from the native
<a name="2015"/> 2015: 					       %% function we trapped to, but we want
<a name="2016"/> 2016: 					       %% the BIF that originally was called
<a name="2017"/> 2017: 					       %% to appear in the stack trace.
<a name="2018"/> 2018: 					       [{M, F, A, _} | _] = Stk
<a name="2019"/> 2019: 				       end
<a name="2020"/> 2020: 			       end),
<a name="2021"/> 2021:     receive
<a name="2022"/> 2022: 	{'DOWN', Mon, process, Pid, Reason} -&gt;
<a name="2023"/> 2023: 	    normal = Reason
<a name="2024"/> 2024:     end,
<a name="2025"/> 2025:     TD = erlang:trace_delivered(Pid),
<a name="2026"/> 2026:     receive
<a name="2027"/> 2027: 	{trace_delivered, Pid, TD} -&gt;
<a name="2028"/> 2028: 	    NoYields = error_after_yield_sched(Pid, TrapFunc, 0),
<a name="2029"/> 2029: 	    io:format(&quot;No of yields: ~p~n&quot;, [NoYields]),
<a name="2030"/> 2030: 	    true =  NoYields &gt; 2
<a name="2031"/> 2031:     end,
<a name="error_after_yield-last_expr"/><a name="2032"/> 2032:     ok.
<a name="2033"/> 2033: 
<a name="error_after_yield_sched-3"/><a name="2034"/> 2034: <b>error_after_yield_sched</b>(P, TrapFunc, N) -&gt;
<a name="error_after_yield_sched-last_expr"/><a name="2035"/> 2035:     receive
<a name="2036"/> 2036: 	{trace, P, out, TrapFunc} -&gt;
<a name="2037"/> 2037: 	    receive
<a name="2038"/> 2038: 		{trace, P, in, TrapFunc} -&gt;
<a name="2039"/> 2039: 		    error_after_yield_sched(P, TrapFunc, N+1)
<a name="2040"/> 2040: 	    after 0 -&gt;
<a name="2041"/> 2041: 		    exit(trap_sched_mismatch)
<a name="2042"/> 2042: 	    end;
<a name="2043"/> 2043: 	{trace, P, out, Func} -&gt;
<a name="2044"/> 2044: 	    receive
<a name="2045"/> 2045: 		{trace, P, in, Func} -&gt;
<a name="2046"/> 2046: 		    error_after_yield_sched(P, TrapFunc, N)
<a name="2047"/> 2047: 	    after 0 -&gt;
<a name="2048"/> 2048: 		    exit(other_sched_mismatch)
<a name="2049"/> 2049: 	    end
<a name="2050"/> 2050:     after 0 -&gt;
<a name="2051"/> 2051: 	    N
<a name="2052"/> 2052:     end.
<a name="2053"/> 2053: 
<a name="error_after_yield_bad_ext_term-0"/><a name="2054"/> 2054: <b>error_after_yield_bad_ext_term</b>() -&gt;
<a name="2055"/> 2055:     TupleSz = 2000000,
<a name="2056"/> 2056:     &lt;&lt;131, % Version magic
<a name="2057"/> 2057:       AtomExt/binary&gt;&gt; = term_to_binary(an_atom_we_use_for_this),
<a name="2058"/> 2058:     BadAtomExt = [100, %% ATOM_EXT
<a name="2059"/> 2059: 		  255, 255, % Invalid size of 65535 bytes
<a name="2060"/> 2060: 		  &quot;oops&quot;],
<a name="2061"/> 2061: 
<a name="2062"/> 2062:     %% Produce a large tuple where the last element is invalid
<a name="error_after_yield_bad_ext_term-last_expr"/><a name="2063"/> 2063: <b>    list_to_binary</b>([131, %% Version magic
<a name="2064"/> 2064: 		    105, %% LARGE_TUPLE_EXT
<a name="2065"/> 2065: 		    &lt;&lt;TupleSz:32/big&gt;&gt;, %% Tuple size
<a name="2066"/> 2066: 		    lists:duplicate(TupleSz-1, AtomExt), %% Valid atoms
<a name="2067"/> 2067: 		    BadAtomExt]). %% Invalid atom at the end
<a name="2068"/> 2068: 	    
<a name="cmp_old_impl-1"/><a name="2069"/> 2069: <b>cmp_old_impl</b>(Config) when is_list(Config) -&gt;
<a name="2070"/> 2070:     %% This test was originally a comparison with the non yielding
<a name="2071"/> 2071:     %% implementation in R16B. Since OTP 22 we can't talk distribution with such
<a name="2072"/> 2072:     %% old nodes (&lt; 19). The test case it kept but compares with previous major
<a name="2073"/> 2073:     %% version for semantic regression test.
<a name="2074"/> 2074:     Rel = integer_to_list(list_to_integer(erlang:system_info(otp_release)) - 1),
<a name="cmp_old_impl-last_expr"/><a name="2075"/> 2075: <b>    case ?CT_PEER_REL</b>([], Rel, proplists:get_value(priv_dir, Config)) of
<a name="2076"/> 2076: 	not_available -&gt;
<a name="2077"/> 2077: 	    {skipped, &quot;No OTP &quot;++Rel++&quot; available&quot;};
<a name="2078"/> 2078:         {ok, Peer, Node}  -&gt;
<a name="2079"/> 2079: 	    cmp_node(Node, {erlang, list_to_binary, [list2iolist(mk_list(1))]}),
<a name="2080"/> 2080: 	    cmp_node(Node, {erlang, list_to_binary, [list2iolist(mk_list(10))]}),
<a name="2081"/> 2081: 	    cmp_node(Node, {erlang, list_to_binary, [list2iolist(mk_list(100))]}),
<a name="2082"/> 2082: 	    cmp_node(Node, {erlang, list_to_binary, [list2iolist(mk_list(1000))]}),
<a name="2083"/> 2083: 	    cmp_node(Node, {erlang, list_to_binary, [list2iolist(mk_list(10000))]}),
<a name="2084"/> 2084: 	    cmp_node(Node, {erlang, list_to_binary, [list2iolist(mk_list(100000))]}),
<a name="2085"/> 2085: 	    cmp_node(Node, {erlang, list_to_binary, [list2iolist(mk_list(1000000))]}),
<a name="2086"/> 2086: 	    cmp_node(Node, {erlang, list_to_binary, [list2iolist(mk_list(10000000))]}),
<a name="2087"/> 2087: 	    cmp_node(Node, {erlang, list_to_binary, [list2iolist(mk_list_lb(10000000))]}),
<a name="2088"/> 2088: 
<a name="2089"/> 2089: 	    cmp_node(Node, {erlang, binary_to_list, [list_to_binary(mk_list(1))]}),
<a name="2090"/> 2090: 	    cmp_node(Node, {erlang, binary_to_list, [list_to_binary(mk_list(10))]}),
<a name="2091"/> 2091: 	    cmp_node(Node, {erlang, binary_to_list, [list_to_binary(mk_list(100))]}),
<a name="2092"/> 2092: 	    cmp_node(Node, {erlang, binary_to_list, [list_to_binary(mk_list(1000))]}),
<a name="2093"/> 2093: 	    cmp_node(Node, {erlang, binary_to_list, [list_to_binary(mk_list(10000))]}),
<a name="2094"/> 2094: 	    cmp_node(Node, {erlang, binary_to_list, [list_to_binary(mk_list(100000))]}),
<a name="2095"/> 2095: 	    cmp_node(Node, {erlang, binary_to_list, [list_to_binary(mk_list(1000000))]}),
<a name="2096"/> 2096: 	    cmp_node(Node, {erlang, binary_to_list, [list_to_binary(mk_list(10000000))]}),
<a name="2097"/> 2097: 
<a name="2098"/> 2098: 	    cmp_node(Node, {erlang, list_to_bitstring, [list2bitstrlist(mk_list(1))]}),
<a name="2099"/> 2099: 	    cmp_node(Node, {erlang, list_to_bitstring, [list2bitstrlist(mk_list(10))]}),
<a name="2100"/> 2100: 	    cmp_node(Node, {erlang, list_to_bitstring, [list2bitstrlist(mk_list(100))]}),
<a name="2101"/> 2101: 	    cmp_node(Node, {erlang, list_to_bitstring, [list2bitstrlist(mk_list(1000))]}),
<a name="2102"/> 2102: 	    cmp_node(Node, {erlang, list_to_bitstring, [list2bitstrlist(mk_list(10000))]}),
<a name="2103"/> 2103: 	    cmp_node(Node, {erlang, list_to_bitstring, [list2bitstrlist(mk_list(100000))]}),
<a name="2104"/> 2104: 	    cmp_node(Node, {erlang, list_to_bitstring, [list2bitstrlist(mk_list(1000000))]}),
<a name="2105"/> 2105: 	    cmp_node(Node, {erlang, list_to_bitstring, [list2bitstrlist(mk_list(10000000))]}),
<a name="2106"/> 2106: 
<a name="2107"/> 2107: 	    cmp_node(Node, {erlang, bitstring_to_list, [list_to_bitstring(list2bitstrlist(mk_list(1)))]}),
<a name="2108"/> 2108: 	    cmp_node(Node, {erlang, bitstring_to_list, [list_to_bitstring(list2bitstrlist(mk_list(10)))]}),
<a name="2109"/> 2109: 	    cmp_node(Node, {erlang, bitstring_to_list, [list_to_bitstring(list2bitstrlist(mk_list(100)))]}),
<a name="2110"/> 2110: 	    cmp_node(Node, {erlang, bitstring_to_list, [list_to_bitstring(list2bitstrlist(mk_list(1000)))]}),
<a name="2111"/> 2111: 	    cmp_node(Node, {erlang, bitstring_to_list, [list_to_bitstring(list2bitstrlist(mk_list(10000)))]}),
<a name="2112"/> 2112: 	    cmp_node(Node, {erlang, bitstring_to_list, [list_to_bitstring(list2bitstrlist(mk_list(100000)))]}),
<a name="2113"/> 2113: 	    cmp_node(Node, {erlang, bitstring_to_list, [list_to_bitstring(list2bitstrlist(mk_list(1000000)))]}),
<a name="2114"/> 2114: 	    cmp_node(Node, {erlang, bitstring_to_list, [list_to_bitstring(list2bitstrlist(mk_list(10000000)))]}),
<a name="2115"/> 2115: 
<a name="2116"/> 2116: 	    peer:stop(Peer),
<a name="2117"/> 2117: 
<a name="2118"/> 2118: 	    ok
<a name="2119"/> 2119:     end.
<a name="2120"/> 2120: 
<a name="2121"/> 2121: <i>%% OTP-16265</i>
<a name="2122"/> 2122: <i>%% This testcase is mainly targeted toward --enable-sharing-preserving.</i>
<a name="sub_bin_copy-1"/><a name="2123"/> 2123: <b>sub_bin_copy</b>(Config) when is_list(Config) -&gt;
<a name="2124"/> 2124:     Papa = self(),
<a name="2125"/> 2125:     Echo = spawn_link(fun() -&gt; echo(Papa) end),
<a name="2126"/> 2126:     HeapBin = list_to_binary(lists:seq(1,3)),
<a name="2127"/> 2127:     sub_bin_copy_1(HeapBin, Echo),
<a name="2128"/> 2128:     ProcBin = list_to_binary(lists:seq(1,65)),
<a name="2129"/> 2129:     sub_bin_copy_1(ProcBin, Echo),
<a name="2130"/> 2130:     unlink(Echo),
<a name="2131"/> 2131:     exit(Echo, kill),
<a name="sub_bin_copy-last_expr"/><a name="2132"/> 2132:     ok.
<a name="2133"/> 2133: 
<a name="sub_bin_copy_1-2"/><a name="2134"/> 2134: <b>sub_bin_copy_1</b>(RealBin, Echo) -&gt;
<a name="2135"/> 2135:     Bits = bit_size(RealBin) - 1,
<a name="2136"/> 2136:     &lt;&lt;SubBin:Bits/bits, _/bits&gt;&gt; = RealBin,
<a name="2137"/> 2137: 
<a name="2138"/> 2138:     %% Send (copy) messages consisting of combinations of both
<a name="2139"/> 2139:     %% the SubBin and the RealBin it refers to.
<a name="2140"/> 2140:     [begin
<a name="2141"/> 2141:          Echo ! Combo,
<a name="2142"/> 2142:          {_, Combo} = {Combo, receive M -&gt; M end}
<a name="2143"/> 2143:      end
<a name="2144"/> 2144:      || Len &lt;- lists:seq(2,5), Combo &lt;- combos([RealBin, SubBin], Len)],
<a name="sub_bin_copy_1-last_expr"/><a name="2145"/> 2145:     ok.
<a name="2146"/> 2146: 
<a name="combos-2"/><a name="2147"/> 2147: <b>combos</b>(_, 0) -&gt;
<a name="2148"/> 2148:     [[]];
<a name="2149"/> 2149: <b>combos</b>(Elements, Len) -&gt;
<a name="combos-last_expr"/><a name="2150"/> 2150: <b>    [[E | C] || E &lt;- Elements, C &lt;- combos</b>(Elements,Len-1)].
<a name="2151"/> 2151: 
<a name="echo-1"/><a name="2152"/> 2152: <b>echo</b>(Papa) -&gt;
<a name="2153"/> 2153:     receive M -&gt; Papa ! M end,
<a name="echo-last_expr"/><a name="2154"/> 2154: <b>    echo</b>(Papa).
<a name="2155"/> 2155: 
<a name="2156"/> 2156: <i>%% GH-6239.</i>
<a name="is_binary_test-1"/><a name="2157"/> 2157: <b>is_binary_test</b>(_Config) -&gt;
<a name="2158"/> 2158:     &lt;&lt;&quot;foo42&quot;&gt;&gt; = concat_stuff(foo, 42),
<a name="2159"/> 2159:     &lt;&lt;&quot;foo2749963626218098647&quot;&gt;&gt; = concat_stuff(foo, 2749963626218098647), %Bignum.
<a name="2160"/> 2160:     &lt;&lt;&quot;foobar&quot;&gt;&gt; = concat_stuff(foo, &lt;&lt;&quot;bar&quot;&gt;&gt;),
<a name="2161"/> 2161:     &lt;&lt;&quot;bar100&quot;&gt;&gt; = concat_stuff(&lt;&lt;&quot;bar&quot;&gt;&gt;, 100),
<a name="2162"/> 2162:     &lt;&lt;&quot;bar2749963626218098647&quot;&gt;&gt; = concat_stuff(&lt;&lt;&quot;bar&quot;&gt;&gt;, 2749963626218098647), %Bignum.
<a name="2163"/> 2163:     &lt;&lt;&quot;barfood&quot;&gt;&gt; = concat_stuff(&lt;&lt;&quot;bar&quot;&gt;&gt;, &lt;&lt;&quot;food&quot;&gt;&gt;),
<a name="2164"/> 2164: 
<a name="is_binary_test-last_expr"/><a name="2165"/> 2165:     ok.
<a name="2166"/> 2166: 
<a name="concat_stuff-2"/><a name="2167"/> 2167: <b>concat_stuff</b>(A, B) when is_integer(B); is_binary(B) -&gt;
<a name="concat_stuff-last_expr"/><a name="2168"/> 2168: <b>    &lt;&lt;</b>(case A of
<a name="2169"/> 2169:            X when is_binary(X) -&gt; X;
<a name="2170"/> 2170:            _ -&gt; atom_to_binary(A)
<a name="2171"/> 2171:        end)/binary,
<a name="2172"/> 2172:       (case B of
<a name="2173"/> 2173:            %% The JIT would do an unsafe simplification of the is_binary/1 test,
<a name="2174"/> 2174:            %% accepting any boxed term (such as a bignum) as a binary.
<a name="2175"/> 2175:            Y when is_binary(Y) -&gt; Y;
<a name="2176"/> 2176:            _ -&gt; integer_to_binary(B)
<a name="2177"/> 2177:        end)/binary&gt;&gt;.
<a name="2178"/> 2178: 
<a name="2179"/> 2179: <i>%% Utilities.</i>
<a name="2180"/> 2180: 
<a name="huge_iolist-1"/><a name="2181"/> 2181: <b>huge_iolist</b>(Lim) -&gt;
<a name="2182"/> 2182:     Sz = 1024,
<a name="huge_iolist-last_expr"/><a name="2183"/> 2183: <b>    huge_iolist</b>(list_to_binary(mk_list(Sz)), Sz, Lim).
<a name="2184"/> 2184: 
<a name="huge_iolist-3"/><a name="2185"/> 2185: <b>huge_iolist</b>(X, Sz, Lim) when Sz &gt;= Lim -&gt;
<a name="2186"/> 2186:     X;
<a name="2187"/> 2187: <b>huge_iolist</b>(X, Sz, Lim) -&gt;
<a name="huge_iolist-last_expr"/><a name="2188"/> 2188: <b>    huge_iolist</b>([X, X], Sz*2, Lim).
<a name="2189"/> 2189: 
<a name="cmp_node-2"/><a name="2190"/> 2190: <b>cmp_node</b>(Node, {M, F, A}) -&gt;
<a name="2191"/> 2191:     ResN = rpc:call(Node, M, F, A),
<a name="2192"/> 2192:     Res = apply(M, F, A),
<a name="cmp_node-last_expr"/><a name="2193"/> 2193:     case ResN =:= Res of
<a name="2194"/> 2194:         true -&gt;
<a name="2195"/> 2195:             ok;
<a name="2196"/> 2196:         false -&gt;
<a name="2197"/> 2197:             io:format(&quot;~p: ~p~n~p: ~p~n&quot;,
<a name="2198"/> 2198:                       [Node, ResN, node(), Res]),
<a name="2199"/> 2199:             ct:fail(different_results)
<a name="2200"/> 2200:     end.
<a name="2201"/> 2201: 
<a name="make_sub_binary-1"/><a name="2202"/> 2202: <b>make_sub_binary</b>(Bin) when is_binary(Bin) -&gt;
<a name="2203"/> 2203:     {_,B} = split_binary(list_to_binary([0,1,3,Bin]), 3),
<a name="2204"/> 2204:     B;
<a name="2205"/> 2205: <b>make_sub_binary</b>(List) -&gt;
<a name="make_sub_binary-last_expr"/><a name="2206"/> 2206: <b>    make_sub_binary</b>(list_to_binary(List)).
<a name="2207"/> 2207: 
<a name="make_unaligned_sub_binary-1"/><a name="2208"/> 2208: <b>make_unaligned_sub_binary</b>(Bin0) when is_binary(Bin0) -&gt;
<a name="2209"/> 2209:     Bin1 = &lt;&lt;0:3,Bin0/binary,31:5&gt;&gt;,
<a name="2210"/> 2210:     Sz = size(Bin0),
<a name="2211"/> 2211:     &lt;&lt;0:3,Bin:Sz/binary,31:5&gt;&gt; = id(Bin1),
<a name="2212"/> 2212:     Bin;
<a name="2213"/> 2213: <b>make_unaligned_sub_binary</b>(List) -&gt;
<a name="make_unaligned_sub_binary-last_expr"/><a name="2214"/> 2214: <b>    make_unaligned_sub_binary</b>(list_to_binary(List)).
<a name="2215"/> 2215: 
<a name="2216"/> 2216: <i>%% Add 1 bit to the size of the binary.</i>
<a name="bit_sized_binary-1"/><a name="2217"/> 2217: <b>bit_sized_binary</b>(Bin0) -&gt;
<a name="2218"/> 2218:     Bin = &lt;&lt;Bin0/binary,1:1&gt;&gt;,
<a name="2219"/> 2219:     BitSize = bit_size(Bin),
<a name="2220"/> 2220:     BitSize = 8*size(Bin) + 1,
<a name="bit_sized_binary-last_expr"/><a name="2221"/> 2221:     Bin.
<a name="2222"/> 2222: 
<a name="unaligned_sub_bin-2"/><a name="2223"/> 2223: <b>unaligned_sub_bin</b>(Bin, 0) -&gt; Bin;
<a name="2224"/> 2224: <b>unaligned_sub_bin</b>(Bin0, Offs) -&gt;
<a name="2225"/> 2225:     F = rand:uniform(256),
<a name="2226"/> 2226:     Roffs = 8-Offs,
<a name="2227"/> 2227:     Bin1 = &lt;&lt;F:Offs,Bin0/binary,F:Roffs&gt;&gt;,
<a name="2228"/> 2228:     Sz = size(Bin0),
<a name="2229"/> 2229:     &lt;&lt;_:Offs,Bin:Sz/binary,_:Roffs&gt;&gt; = id(Bin1),
<a name="unaligned_sub_bin-last_expr"/><a name="2230"/> 2230:     Bin.
<a name="2231"/> 2231: 
<a name="id-1"/><a name="id-last_expr"/><a name="2232"/> 2232: <b>id</b>(I) -&gt; I.
<a name="2233"/> 2233: 
<a name="2234"/> 2234: 
<a name="2235"/> 2235: <i>%% Stress binary_to_term with different initial reductions</i>
<a name="binary_to_term_stress-1"/><a name="2236"/> 2236: <b>binary_to_term_stress</b>(Bin) -&gt;
<a name="binary_to_term_stress-last_expr"/><a name="2237"/> 2237: <b>    binary_to_term_stress</b>(Bin, no_opts).
<a name="2238"/> 2238: 
<a name="binary_to_term_stress-2"/><a name="2239"/> 2239: <b>binary_to_term_stress</b>(Bin, Opts) -&gt;
<a name="2240"/> 2240:     Reds = get_reds(),
<a name="2241"/> 2241:     T = b2t(erlang:system_info(context_reductions),
<a name="2242"/> 2242: 	    Bin, Opts, catch_binary_to_term(Bin, Opts)),
<a name="2243"/> 2243:     set_reds(Reds),
<a name="binary_to_term_stress-last_expr"/><a name="2244"/> 2244:     T = case Opts of
<a name="2245"/> 2245: 	    no_opts -&gt; binary_to_term(Bin);
<a name="2246"/> 2246: 	    _ -&gt;       binary_to_term(Bin,Opts)
<a name="2247"/> 2247: 	end.
<a name="2248"/> 2248: 
<a name="catch_binary_to_term-2"/><a name="2249"/> 2249: <b>catch_binary_to_term</b>(Bin, no_opts) -&gt;
<a name="2250"/> 2250:     try binary_to_term(Bin)
<a name="2251"/> 2251:     catch
<a name="2252"/> 2252: 	error:badarg -&gt; binary_to_term_throws_badarg
<a name="2253"/> 2253:     end;
<a name="2254"/> 2254: <b>catch_binary_to_term</b>(Bin, Opts) -&gt;
<a name="catch_binary_to_term-last_expr"/><a name="2255"/> 2255: <b>    try binary_to_term</b>(Bin, Opts)
<a name="2256"/> 2256:     catch
<a name="2257"/> 2257: 	error:badarg -&gt; binary_to_term_throws_badarg
<a name="2258"/> 2258:     end.
<a name="2259"/> 2259: 
<a name="b2t-4"/><a name="2260"/> 2260: <b>b2t</b>(0, _Bin, _Opts, Term) -&gt;
<a name="2261"/> 2261:     Term;
<a name="2262"/> 2262: <b>b2t</b>(Reds, Bin, Opts, Term) -&gt;
<a name="2263"/> 2263:     set_reds(Reds),
<a name="2264"/> 2264:     Term = catch_binary_to_term(Bin,Opts),
<a name="b2t-last_expr"/><a name="2265"/> 2265: <b>    b2t</b>(Reds div 3, Bin, Opts, Term).
<a name="2266"/> 2266: 
<a name="set_reds-1"/><a name="2267"/> 2267: <b>set_reds</b>(Reds) -&gt;
<a name="set_reds-last_expr"/><a name="2268"/> 2268: <b>    try	erts_debug:set_internal_state</b>(reds_left, Reds)
<a name="2269"/> 2269:     catch
<a name="2270"/> 2270: 	error:undef -&gt;
<a name="2271"/> 2271: 	    erts_debug:set_internal_state(available_internal_state, true),
<a name="2272"/> 2272: 	    set_reds(Reds)
<a name="2273"/> 2273:     end.
<a name="2274"/> 2274: 
<a name="get_reds-0"/><a name="2275"/> 2275: <b>get_reds</b>() -&gt;
<a name="get_reds-last_expr"/><a name="2276"/> 2276: <b>    try	erts_debug:get_internal_state</b>(reds_left)
<a name="2277"/> 2277:     catch
<a name="2278"/> 2278: 	error:undef -&gt;
<a name="2279"/> 2279: 	    erts_debug:set_internal_state(available_internal_state, true),
<a name="2280"/> 2280: 	    get_reds()
<a name="2281"/> 2281:     end.
<a name="2282"/> 2282: 
<a name="2283"/> 2283: <b>-define</b>(LARGE_BIN, (512*1024+10)).
<a name="2284"/> 2284: <b>-define</b>(LARGE_BIN_LIM, (1024*1024)).
<a name="2285"/> 2285: 
<a name="mk_list-2"/><a name="2286"/> 2286: <b>mk_list</b>(0, Acc) -&gt;
<a name="2287"/> 2287:     Acc;
<a name="2288"/> 2288: <b>mk_list</b>(Sz, Acc) -&gt;
<a name="mk_list-last_expr"/><a name="2289"/> 2289: <b>    mk_list</b>(Sz-1, [$A+(Sz band 63) | Acc]).
<a name="2290"/> 2290: 
<a name="mk_list-1"/><a name="2291"/> 2291: <b>mk_list</b>(Sz) when Sz &gt;= ?LARGE_BIN_LIM -&gt;
<a name="2292"/> 2292:     SzLeft = Sz - ?LARGE_BIN,
<a name="2293"/> 2293:     SzHd = SzLeft div 2,
<a name="2294"/> 2294:     SzTl = SzLeft - SzHd,
<a name="2295"/> 2295:     [mk_list(SzHd, []), erlang:list_to_binary(mk_list(?LARGE_BIN, [])), mk_list(SzTl, [])];
<a name="2296"/> 2296: <b>mk_list</b>(Sz) -&gt;
<a name="mk_list-last_expr"/><a name="2297"/> 2297: <b>    mk_list</b>(Sz, []).
<a name="2298"/> 2298: 
<a name="mk_list_lb-1"/><a name="2299"/> 2299: <b>mk_list_lb</b>(Sz) when Sz &gt;= ?LARGE_BIN_LIM -&gt;
<a name="2300"/> 2300:     SzLeft = Sz - ?LARGE_BIN,
<a name="2301"/> 2301:     SzHd = SzLeft div 2,
<a name="2302"/> 2302:     SzTl = SzLeft - SzHd,
<a name="2303"/> 2303:     [mk_list(SzHd, []), erlang:list_to_binary(mk_list(?LARGE_BIN, [])), mk_list(SzTl, [])];
<a name="2304"/> 2304: <b>mk_list_lb</b>(Sz) -&gt;
<a name="mk_list_lb-last_expr"/><a name="2305"/> 2305: <b>    mk_list</b>(Sz, []).
<a name="2306"/> 2306: 
<a name="2307"/> 2307: 
<a name="list2iolist-1"/><a name="2308"/> 2308: <b>list2iolist</b>(List) -&gt;
<a name="list2iolist-last_expr"/><a name="2309"/> 2309: <b>    list2iolist</b>(List, []).
<a name="2310"/> 2310: 
<a name="list2iolist-2"/><a name="2311"/> 2311: <b>list2iolist</b>([], Acc) -&gt;
<a name="2312"/> 2312:     Acc;
<a name="2313"/> 2313: <b>list2iolist</b>([X0, X1, X2, X3, X4, X5 | Xs], Acc) when is_integer(X0), 0 =&lt; X0, X0 &lt; 256,
<a name="2314"/> 2314: 						     is_integer(X1), 0 =&lt; X1, X1 &lt; 256,
<a name="2315"/> 2315: 						     is_integer(X2), 0 =&lt; X2, X2 &lt; 256,
<a name="2316"/> 2316: 						     is_integer(X3), 0 =&lt; X3, X3 &lt; 256,
<a name="2317"/> 2317: 						     is_integer(X4), 0 =&lt; X4, X4 &lt; 256,
<a name="2318"/> 2318: 						     is_integer(X5), 0 =&lt; X5, X5 &lt; 256 -&gt;
<a name="2319"/> 2319:     NewAcc = case (X0+X1+X2+X3+X4+X5) band 3 of
<a name="2320"/> 2320: 		 0 -&gt;
<a name="2321"/> 2321: 		     [Acc, [[[[[[[[[[[[X0,[],&lt;&lt;&quot;&quot;&gt;&gt;,X1]]]]]]]]],[X2,X3]],[],[],[],[],X4],X5]];
<a name="2322"/> 2322: 		 1 -&gt;
<a name="2323"/> 2323: 		     [Acc, [], erlang:list_to_binary([X0, X1, X2, X3, X4, X5])];
<a name="2324"/> 2324: 		 2 -&gt;
<a name="2325"/> 2325: 		     [Acc, [[[[X0|erlang:list_to_binary([X1])],[X2|erlang:list_to_binary([X3])],[X4|erlang:list_to_binary([X5])]]]|&lt;&lt;&quot;&quot;&gt;&gt;]];
<a name="2326"/> 2326: 		 3 -&gt;
<a name="2327"/> 2327: 		     [Acc, X0, X1, X2, &lt;&lt;&quot;&quot;&gt;&gt;, [], X3, X4 | erlang:list_to_binary([X5])]
<a name="2328"/> 2328: 	     end,
<a name="2329"/> 2329:     list2iolist(Xs, NewAcc);
<a name="2330"/> 2330: <b>list2iolist</b>([X | Xs], Acc) -&gt;
<a name="list2iolist-last_expr"/><a name="2331"/> 2331: <b>    list2iolist</b>(Xs, [Acc,X]).
<a name="2332"/> 2332: 
<a name="list2bitstrlist-1"/><a name="2333"/> 2333: <b>list2bitstrlist</b>(List) -&gt;
<a name="list2bitstrlist-last_expr"/><a name="2334"/> 2334: <b>    [list2bitstrlist</b>(List, []), &lt;&lt;4:7&gt;&gt;].
<a name="2335"/> 2335: 
<a name="list2bitstrlist-2"/><a name="2336"/> 2336: <b>list2bitstrlist</b>([], Acc) -&gt;
<a name="2337"/> 2337:     Acc;
<a name="2338"/> 2338: <b>list2bitstrlist</b>([X0, X1, X2, X3, X4, X5 | Xs], Acc) when is_integer(X0), 0 =&lt; X0, X0 &lt; 256,
<a name="2339"/> 2339: 						     is_integer(X1), 0 =&lt; X1, X1 &lt; 256,
<a name="2340"/> 2340: 						     is_integer(X2), 0 =&lt; X2, X2 &lt; 256,
<a name="2341"/> 2341: 						     is_integer(X3), 0 =&lt; X3, X3 &lt; 256,
<a name="2342"/> 2342: 						     is_integer(X4), 0 =&lt; X4, X4 &lt; 256,
<a name="2343"/> 2343: 						     is_integer(X5), 0 =&lt; X5, X5 &lt; 256 -&gt;
<a name="2344"/> 2344:     NewAcc = case (X0+X1+X2+X3+X4+X5) band 3 of
<a name="2345"/> 2345: 		 0 -&gt;
<a name="2346"/> 2346: 		     [Acc, [[[[[[[[[[[[X0,[],&lt;&lt;&quot;&quot;&gt;&gt;,X1]]]]]]]]],[X2,X3]],[],[],[],[],X4],X5]];
<a name="2347"/> 2347: 		 1 -&gt;
<a name="2348"/> 2348: 		     [Acc, [], &lt;&lt;X0:X1&gt;&gt;, &lt;&lt;X2:X3&gt;&gt;, &lt;&lt;X4:X5&gt;&gt;];
<a name="2349"/> 2349: 		 2 -&gt;
<a name="2350"/> 2350: 		     [Acc, [[[[X0|&lt;&lt;X1:X2&gt;&gt;],X3]],[X4|erlang:list_to_binary([X5])]|&lt;&lt;&quot;&quot;&gt;&gt;]];
<a name="2351"/> 2351: 		 3 -&gt;
<a name="2352"/> 2352: 		     [Acc, X0, X1, X2, &lt;&lt;&quot;&quot;&gt;&gt;, [], X3, X4 | erlang:list_to_binary([X5])]
<a name="2353"/> 2353: 	     end,
<a name="2354"/> 2354:     list2bitstrlist(Xs, NewAcc);
<a name="2355"/> 2355: <b>list2bitstrlist</b>([X | Xs], Acc) -&gt;
<a name="list2bitstrlist-last_expr"/><a name="2356"/> 2356: <b>    list2bitstrlist</b>(Xs, [Acc,X]).
<a name="2357"/> 2357: 
<a name="local_ext-1"/><a name="2358"/> 2358: <b>local_ext</b>(Config) when is_list(Config) -&gt;
<a name="2359"/> 2359:     SDrv = send_term_local_drv,
<a name="2360"/> 2360:     CDrv = call_local_drv,
<a name="2361"/> 2361:     DataDir = proplists:get_value(data_dir, Config),
<a name="2362"/> 2362:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="2363"/> 2363:     FileName = filename:join(PrivDir, &quot;local_ext.data&quot;),
<a name="2364"/> 2364:     Args = [&quot;-setcookie&quot;, atom_to_list(erlang:get_cookie()),
<a name="2365"/> 2365:             &quot;-pa&quot;, filename:dirname(code:which(?MODULE))],
<a name="2366"/> 2366:     {ok, Peer1, _} = peer:start_link(#{connection =&gt; 0, args =&gt; Args}),
<a name="2367"/> 2367:     {ok, Peer2, _} = peer:start_link(#{connection =&gt; 0, args =&gt; Args}),
<a name="2368"/> 2368:     LongNames = net_kernel:longnames(),
<a name="2369"/> 2369:     DynStartOpts = #{name_domain =&gt; if LongNames -&gt; longnames;
<a name="2370"/> 2370:                                        true -&gt; shortnames
<a name="2371"/> 2371:                                     end},
<a name="2372"/> 2372:     ExternalPid = self(),
<a name="2373"/> 2373:     ExternalRef = make_ref(),
<a name="2374"/> 2374:     ExternalPort = hd(erlang:ports()),
<a name="2375"/> 2375:     EncDecLocal = fun () -&gt;
<a name="2376"/> 2376:                           erl_ddll:start(),
<a name="2377"/> 2377:                           ok = erl_ddll:load_driver(DataDir, SDrv),
<a name="2378"/> 2378:                           SPort = open_port({spawn, SDrv}, []),
<a name="2379"/> 2379:                           ok = erl_ddll:load_driver(DataDir, CDrv),
<a name="2380"/> 2380:                           CPort = open_port({spawn, CDrv}, []),
<a name="2381"/> 2381:                           false = erlang:is_alive(),
<a name="2382"/> 2382:                           nonode@nohost = node(),
<a name="2383"/> 2383:                           LocalPid = self(),
<a name="2384"/> 2384:                           LocalRef = make_ref(),
<a name="2385"/> 2385:                           LocalPort = hd(erlang:ports()),
<a name="2386"/> 2386:                           Bin1 = &lt;&lt;4711:800&gt;&gt;,
<a name="2387"/> 2387:                           Bin2 = &lt;&lt;4711:703&gt;&gt;,
<a name="2388"/> 2388:                           Bin3 = &lt;&lt;4711:600&gt;&gt;,
<a name="2389"/> 2389:                           Terms = [
<a name="2390"/> 2390:                                    LocalPid,
<a name="2391"/> 2391:                                    ExternalPid,
<a name="2392"/> 2392:                                    LocalRef,
<a name="2393"/> 2393:                                    ExternalRef,
<a name="2394"/> 2394:                                    LocalPort,
<a name="2395"/> 2395:                                    ExternalPort,
<a name="2396"/> 2396:                                    [LocalPid, Bin1, ExternalPid, LocalRef, Bin2,
<a name="2397"/> 2397:                                     ExternalRef, Bin3, Bin2, LocalPort,
<a name="2398"/> 2398:                                     ExternalPort],
<a name="2399"/> 2399:                                    &quot;hej&quot;,
<a name="2400"/> 2400:                                    [],
<a name="2401"/> 2401:                                    {processes(), Bin3, erlang:ports(), Bin3},
<a name="2402"/> 2402:                                    #{pid =&gt; LocalPid, ref =&gt; LocalRef, port =&gt; LocalPort}
<a name="2403"/> 2403:                                   ],
<a name="2404"/> 2404:                           {ok, FD} = file:open(FileName, [write]),
<a name="2405"/> 2405:                           ETs = lists:map(fun (Term) -&gt;
<a name="2406"/> 2406:                                                   {enc_local(FD, Term), Term}
<a name="2407"/> 2407:                                           end, Terms),
<a name="2408"/> 2408:                           ok = file:close(FD),
<a name="2409"/> 2409:                           CheckET = fun ({LExt, Term}) -&gt;
<a name="2410"/> 2410:                                             Term = binary_to_term(LExt),
<a name="2411"/> 2411:                                             SPort ! {self(), {command, LExt}},
<a name="2412"/> 2412:                                             receive
<a name="2413"/> 2413:                                                 {SPort, Reply} -&gt;
<a name="2414"/> 2414:                                                     Term = Reply
<a name="2415"/> 2415:                                             end
<a name="2416"/> 2416:                                     end,
<a name="2417"/> 2417:                           lists:foreach(CheckET, ETs),
<a name="2418"/> 2418:                           call_local_success(CPort, ETs),
<a name="2419"/> 2419:                           NodeName = peer:random_name(),
<a name="2420"/> 2420:                           {ok, _} = net_kernel:start(list_to_atom(NodeName),
<a name="2421"/> 2421:                                                      DynStartOpts),
<a name="2422"/> 2422:                           true = erlang:is_alive(),
<a name="2423"/> 2423:                           true = nonode@nohost /= node(),
<a name="2424"/> 2424:                           lists:foreach(CheckET, ETs),
<a name="2425"/> 2425:                           call_local_success(CPort, ETs),
<a name="2426"/> 2426:                           ok = net_kernel:stop(),
<a name="2427"/> 2427:                           false = erlang:is_alive(),
<a name="2428"/> 2428:                           nonode@nohost = node(),
<a name="2429"/> 2429:                           lists:foreach(CheckET, ETs),
<a name="2430"/> 2430:                           call_local_success(CPort, ETs),
<a name="2431"/> 2431:                           {ok, ExtList} = file:consult(FileName),
<a name="2432"/> 2432:                           lists:foreach(fun (Ext) when is_binary(Ext) -&gt;
<a name="2433"/> 2433:                                                 _ = binary_to_term(Ext),
<a name="2434"/> 2434:                                                 SPort ! {self(), {command, Ext}},
<a name="2435"/> 2435:                                                 receive
<a name="2436"/> 2436:                                                     {SPort, &quot;bad_term_error&quot;} -&gt;
<a name="2437"/> 2437:                                                         error(bad_term_error);
<a name="2438"/> 2438:                                                     {SPort, _} -&gt;
<a name="2439"/> 2439:                                                         ok
<a name="2440"/> 2440:                                                 end
<a name="2441"/> 2441:                                         end,
<a name="2442"/> 2442:                                         ExtList),
<a name="2443"/> 2443:                           true = port_close(SPort),
<a name="2444"/> 2444:                           true = port_close(CPort),
<a name="2445"/> 2445:                           ok
<a name="2446"/> 2446:                   end,
<a name="2447"/> 2447:     ok = peer:call(Peer1, erlang, apply, [EncDecLocal, []]),
<a name="2448"/> 2448:     DecOthersLocal = fun () -&gt;
<a name="2449"/> 2449:                              %% Verify that decoding of the terms encoded
<a name="2450"/> 2450:                              %% on local external format by the other runtime
<a name="2451"/> 2451:                              %% system instance fails on this runtime system
<a name="2452"/> 2452:                              %% instance...
<a name="2453"/> 2453:                              erl_ddll:start(),
<a name="2454"/> 2454:                              ok = erl_ddll:load_driver(DataDir, SDrv),
<a name="2455"/> 2455:                              SPort = open_port({spawn, SDrv}, []),
<a name="2456"/> 2456:                              ok = erl_ddll:load_driver(DataDir, CDrv),
<a name="2457"/> 2457:                              CPort = open_port({spawn, CDrv}, []),
<a name="2458"/> 2458:                              false = erlang:is_alive(),
<a name="2459"/> 2459:                              nonode@nohost = node(),
<a name="2460"/> 2460:                              {ok, ExtList} = file:consult(FileName),
<a name="2461"/> 2461:                              lists:foreach(fun (Ext) when is_binary(Ext) -&gt;
<a name="2462"/> 2462:                                                    try
<a name="2463"/> 2463:                                                        Term = binary_to_term(Ext),
<a name="2464"/> 2464:                                                        error({successful_decode, Term})
<a name="2465"/> 2465:                                                    catch
<a name="2466"/> 2466:                                                        error:badarg -&gt;
<a name="2467"/> 2467:                                                            ok
<a name="2468"/> 2468:                                                    end,
<a name="2469"/> 2469:                                                    SPort ! {self(), {command, Ext}},
<a name="2470"/> 2470:                                                    receive
<a name="2471"/> 2471:                                                        {SPort, Reply} -&gt;
<a name="2472"/> 2472:                                                            &quot;bad_term_error&quot; = Reply
<a name="2473"/> 2473:                                                    end
<a name="2474"/> 2474:                                            end,
<a name="2475"/> 2475:                                            ExtList),
<a name="2476"/> 2476:                              call_local_fail(CPort, ExtList),
<a name="2477"/> 2477:                              true = port_close(SPort),
<a name="2478"/> 2478:                              true = port_close(CPort),
<a name="2479"/> 2479:                              ok
<a name="2480"/> 2480:                      end,
<a name="2481"/> 2481:     ok = peer:call(Peer2, erlang, apply, [DecOthersLocal, []]),
<a name="2482"/> 2482:     peer:stop(Peer1),
<a name="2483"/> 2483:     peer:stop(Peer2),
<a name="local_ext-last_expr"/><a name="2484"/> 2484:     ok.
<a name="2485"/> 2485: 
<a name="enc_local-2"/><a name="2486"/> 2486: <b>enc_local</b>(FD, Term) -&gt;
<a name="2487"/> 2487:     Ext = term_to_binary(Term, [local]),
<a name="2488"/> 2488:     Ext = iolist_to_binary(term_to_iovec(Term, [local])),
<a name="2489"/> 2489:     Term = binary_to_term(Ext),
<a name="2490"/> 2490:     io:format(FD, &quot;~p.~n&quot;, [Ext]),
<a name="enc_local-last_expr"/><a name="2491"/> 2491:     Ext.
<a name="2492"/> 2492: 
<a name="call_local_success-2"/><a name="2493"/> 2493: <b>call_local_success</b>(Port, []) -&gt;
<a name="2494"/> 2494:     ok;
<a name="2495"/> 2495: <b>call_local_success</b>(Port, [{Lext1, T1}]) -&gt;
<a name="2496"/> 2496:     Me = self(),
<a name="2497"/> 2497:     Ref = make_ref(),
<a name="2498"/> 2498:     Term =  {term_to_binary(Me), Lext1, term_to_binary(Ref)},
<a name="2499"/> 2499:     {call_result, Me, 4711, T1, 17, Ref, &quot;end_of_data&quot;} = erlang:port_call(Port, 0, Term),
<a name="2500"/> 2500:     ok;
<a name="2501"/> 2501: <b>call_local_success</b>(Port, [{Lext1, T1}, {Lext3, T3} | Rest]) -&gt;
<a name="2502"/> 2502:     Me = self(),
<a name="2503"/> 2503:     Term =  {Lext1, term_to_binary(Me), Lext3},
<a name="2504"/> 2504:     {call_result, T1, 4711, Me, 17, T3, &quot;end_of_data&quot;} = erlang:port_call(Port, 0, Term),
<a name="call_local_success-last_expr"/><a name="2505"/> 2505: <b>    call_local_success</b>(Port, Rest).
<a name="2506"/> 2506: 
<a name="call_local_fail-2"/><a name="2507"/> 2507: <b>call_local_fail</b>(Port, []) -&gt;
<a name="2508"/> 2508:     ok;
<a name="2509"/> 2509: <b>call_local_fail</b>(Port, [Lext1]) -&gt;
<a name="2510"/> 2510:     Me = self(),
<a name="2511"/> 2511:     Ref = make_ref(),
<a name="2512"/> 2512:     Term =  {term_to_binary(Me), Lext1, term_to_binary(Ref)},
<a name="2513"/> 2513:     try
<a name="2514"/> 2514:         erlang:port_call(Port, 0, Term),
<a name="2515"/> 2515:         error(unexpected_port_call_success)
<a name="2516"/> 2516:     catch
<a name="2517"/> 2517:         error:badarg -&gt;
<a name="2518"/> 2518:             ok
<a name="2519"/> 2519:     end;
<a name="2520"/> 2520: <b>call_local_fail</b>(Port, [Lext1, Lext3 | Rest]) -&gt;
<a name="2521"/> 2521:     Me = self(),
<a name="2522"/> 2522:     Term =  {Lext1, term_to_binary(Me), Lext3},
<a name="2523"/> 2523:     try
<a name="2524"/> 2524:         erlang:port_call(Port, 0, Term),
<a name="2525"/> 2525:         error(unexpected_port_call_success)
<a name="2526"/> 2526:     catch
<a name="2527"/> 2527:         error:badarg -&gt;
<a name="2528"/> 2528:             ok
<a name="2529"/> 2529:     end,
<a name="call_local_fail-last_expr"/><a name="2530"/> 2530: <b>    call_local_fail</b>(Port, Rest).
</pre>
<script>
var hash = window.location.hash.substring(1);
var anchor = document.getElementsByName(hash);
anchor[0].style.backgroundColor="orange";
</script>
</body>
</html>
