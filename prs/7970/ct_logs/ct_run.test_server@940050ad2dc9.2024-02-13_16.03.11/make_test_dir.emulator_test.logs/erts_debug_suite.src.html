<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/erts/emulator/make_test_dir/emulator_test/erts_debug_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%</i>
<a name="2"/>    2: <i>%% %CopyrightBegin%</i>
<a name="3"/>    3: <i>%% </i>
<a name="4"/>    4: <i>%% Copyright Ericsson AB 2005-2022. All Rights Reserved.</i>
<a name="5"/>    5: <i>%% </i>
<a name="6"/>    6: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="7"/>    7: <i>%% you may not use this file except in compliance with the License.</i>
<a name="8"/>    8: <i>%% You may obtain a copy of the License at</i>
<a name="9"/>    9: <i>%%</i>
<a name="10"/>   10: <i>%%     http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="11"/>   11: <i>%%</i>
<a name="12"/>   12: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="13"/>   13: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="14"/>   14: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="15"/>   15: <i>%% See the License for the specific language governing permissions and</i>
<a name="16"/>   16: <i>%% limitations under the License.</i>
<a name="17"/>   17: <i>%% </i>
<a name="18"/>   18: <i>%% %CopyrightEnd%</i>
<a name="19"/>   19: <i>%%</i>
<a name="20"/>   20: 
<a name="21"/>   21: <b>-module</b>(erts_debug_SUITE).
<a name="22"/>   22: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="23"/>   23: <b>-include_lib</b>(&quot;common_test/include/ct_event.hrl&quot;).
<a name="24"/>   24: 
<a name="25"/>   25: <b>-export</b>([all/0, suite/0, groups/0,
<a name="26"/>   26:          init_per_testcase/2, end_per_testcase/2,
<a name="27"/>   27:          test_size/1,flat_size_big/1,df/1,term_type/1,
<a name="28"/>   28:          instructions/1, stack_check/1, alloc_blocks_size/1,
<a name="29"/>   29:          t_copy_shared/1,
<a name="30"/>   30:          interpreter_size_bench/1]).
<a name="31"/>   31: 
<a name="32"/>   32: <b>-export</b>([do_alloc_blocks_size/0]).
<a name="33"/>   33: 
<a name="34"/>   34: 
<a name="suite-0"/><a name="35"/>   35: <b>suite</b>() -&gt;
<a name="suite-last_expr"/><a name="36"/>   36:     [{ct_hooks,[ts_install_cth]},
<a name="37"/>   37:      {timetrap, {minutes, 2}}].
<a name="38"/>   38: 
<a name="all-0"/><a name="39"/>   39: <b>all</b>() -&gt; 
<a name="all-last_expr"/><a name="40"/>   40:     [test_size, flat_size_big, df, instructions, term_type,
<a name="41"/>   41:      t_copy_shared,
<a name="42"/>   42:      stack_check, alloc_blocks_size].
<a name="43"/>   43: 
<a name="groups-0"/><a name="44"/>   44: <b>groups</b>() -&gt; 
<a name="groups-last_expr"/><a name="45"/>   45:     [{interpreter_size_bench, [], [interpreter_size_bench]}].
<a name="46"/>   46: 
<a name="init_per_testcase-2"/><a name="47"/>   47: <b>init_per_testcase</b>(_TestCase, Config) -&gt;
<a name="init_per_testcase-last_expr"/><a name="48"/>   48:     Config.
<a name="end_per_testcase-2"/><a name="49"/>   49: <b>end_per_testcase</b>(_TestCase, Config) -&gt;
<a name="end_per_testcase-last_expr"/><a name="50"/>   50: <b>    erts_test_utils:ept_check_leaked_nodes</b>(Config).
<a name="51"/>   51: 
<a name="interpreter_size_bench-1"/><a name="52"/>   52: <b>interpreter_size_bench</b>(_Config) -&gt;
<a name="53"/>   53:     Size = erts_debug:interpreter_size(),
<a name="54"/>   54:     ct_event:notify(#event{name=benchmark_data,
<a name="55"/>   55:                            data=[{value,Size}]}),
<a name="interpreter_size_bench-last_expr"/><a name="56"/>   56: <b>    {comment,integer_to_list</b>(Size)++&quot; bytes&quot;}.
<a name="57"/>   57: 
<a name="58"/>   58: <i>%% White box testing of term heap sizes</i>
<a name="test_size-1"/><a name="59"/>   59: <b>test_size</b>(Config) when is_list(Config) -&gt;
<a name="60"/>   60:     ConsCell1 = id([a|b]),
<a name="61"/>   61:     ConsCell2 = id(ConsCell1),
<a name="62"/>   62:     ConsCellSz = 2,
<a name="63"/>   63: 
<a name="64"/>   64:     0 = do_test_size([]),
<a name="65"/>   65:     0 = do_test_size(42),
<a name="66"/>   66:     ConsCellSz = do_test_size(ConsCell1),
<a name="67"/>   67:     0 = do_test_size({}),
<a name="68"/>   68:     2 = do_test_size({[]}),
<a name="69"/>   69:     3 = do_test_size({a,b}),
<a name="70"/>   70:     7 = do_test_size({a,[b,c]}),
<a name="71"/>   71:     8 = do_test_size(#{b =&gt; 2,c =&gt; 3}),
<a name="72"/>   72:     3 = do_test_size(#{}),
<a name="73"/>   73:     32 = do_test_size(#{b =&gt; 2,c =&gt; 3,txt =&gt; &quot;hello world&quot;}),
<a name="74"/>   74: 
<a name="75"/>   75:     true = do_test_size(maps:from_list([{I,I}||I&lt;-lists:seq(1,256)])) &gt;= map_size_lower_bound(256),
<a name="76"/>   76:     true = do_test_size(maps:from_list([{I,I}||I&lt;-lists:seq(1,4096)])) &gt;= map_size_lower_bound(4096),
<a name="77"/>   77:     true = do_test_size(maps:from_list([{I,I}||I&lt;-lists:seq(1,254)])) &gt;= map_size_lower_bound(254),
<a name="78"/>   78:     true = do_test_size(maps:from_list([{I,I}||I&lt;-lists:seq(1,239)])) &gt;= map_size_lower_bound(239),
<a name="79"/>   79: 
<a name="80"/>   80:     Const = id(42),
<a name="81"/>   81:     AnotherConst = id(7),
<a name="82"/>   82: 
<a name="83"/>   83:     %% Fun environment size = 0 (the smallest fun possible)
<a name="84"/>   84:     SimplestFun = fun() -&gt; ok end,
<a name="85"/>   85: 
<a name="86"/>   86:     %% 2 words for the fun, 1 word to point at the off-heap reference, and
<a name="87"/>   87:     %% 3 words for the off-heap reference itself. The actual on-heap size is 3.
<a name="88"/>   88:     FunSz0 = 6,
<a name="89"/>   89:     FunSz0 = do_test_size(SimplestFun),
<a name="90"/>   90: 
<a name="91"/>   91:     %% Fun environment size = 1
<a name="92"/>   92:     FunSz1 = do_test_size(fun() -&gt; Const end),
<a name="93"/>   93:     FunSz1 = FunSz0 + 1,
<a name="94"/>   94: 
<a name="95"/>   95:     %% Fun environment size = 2
<a name="96"/>   96:     FunSz2 = do_test_size(fun() -&gt; Const+AnotherConst end),
<a name="97"/>   97:     FunSz2 = FunSz1 + 1,
<a name="98"/>   98: 
<a name="99"/>   99:     FunSz1 = do_test_size(fun() -&gt; ConsCell1 end) - do_test_size(ConsCell1),
<a name="100"/>  100: 
<a name="101"/>  101:     %% External funs are always 2 words (they're also always stored off-heap,
<a name="102"/>  102:     %% so the effective size is zero).
<a name="103"/>  103:     2 = do_test_size(fun lists:sort/1),
<a name="104"/>  104: 
<a name="105"/>  105:     Arch = 8 * erlang:system_info({wordsize, external}),
<a name="106"/>  106:     case {Arch, do_test_size(mk_ext_pid({a@b, 1}, 17, 42))} of
<a name="107"/>  107: 	{32, 5} -&gt; ok;
<a name="108"/>  108: 	{64, 4} -&gt; ok
<a name="109"/>  109:     end,
<a name="110"/>  110:     case {Arch, do_test_size(mk_ext_port({a@b, 1}, 1742))} of
<a name="111"/>  111: 	{32, 5} -&gt; ok;
<a name="112"/>  112: 	{64, 4} -&gt; ok
<a name="113"/>  113:     end,
<a name="114"/>  114:     case {Arch, do_test_size(make_ref())} of
<a name="115"/>  115: 	{32, 4} -&gt; ok;
<a name="116"/>  116: 	{64, 3} -&gt; ok
<a name="117"/>  117:     end,
<a name="118"/>  118:     case {Arch, do_test_size(mk_ext_ref({a@b, 1}, [42,43,44]))} of
<a name="119"/>  119: 	{32, 6} -&gt; ok;
<a name="120"/>  120: 	{64, 5} -&gt; ok
<a name="121"/>  121:     end,
<a name="122"/>  122:     3 = do_test_size(atomics:new(1,[])), % Magic ref
<a name="123"/>  123: 
<a name="124"/>  124:     3 = do_test_size(&lt;&lt;1,2,3&gt;&gt;),       % ErlHeapBin
<a name="125"/>  125:     case {Arch, do_test_size(&lt;&lt;0:(8*64)&gt;&gt;)} of   % ERL_ONHEAP_BIN_LIMIT
<a name="126"/>  126: 	{32, 18} -&gt; ok;
<a name="127"/>  127: 	{64, 10} -&gt; ok
<a name="128"/>  128:     end,
<a name="129"/>  129:     8 = do_test_size(&lt;&lt;0:(8*65)&gt;&gt;),    % ErlSubBits + BinRef
<a name="130"/>  130:     3 = do_test_size(&lt;&lt;5:7&gt;&gt;),         % ErlHeapBits
<a name="131"/>  131:     8 = do_test_size(&lt;&lt;0:(8*80+1)&gt;&gt;),  % ErlSubBits + BinRef
<a name="132"/>  132: 
<a name="133"/>  133:     %% Test shared data structures.
<a name="134"/>  134:     do_test_size([ConsCell1|ConsCell1],
<a name="135"/>  135:         	 3*ConsCellSz,
<a name="136"/>  136:         	 2*ConsCellSz),
<a name="137"/>  137:     do_test_size(fun() -&gt; {ConsCell1,ConsCell2} end,
<a name="138"/>  138:         	 FunSz2 + 2*ConsCellSz,
<a name="139"/>  139:         	 FunSz2 + ConsCellSz),
<a name="140"/>  140:     do_test_size({SimplestFun,SimplestFun},
<a name="141"/>  141:         	 2*FunSz0+do_test_size({a,b}),
<a name="142"/>  142:         	 FunSz0+do_test_size({a,b})),
<a name="143"/>  143: 
<a name="144"/>  144:     M = id(#{ &quot;atom&quot; =&gt; first, i =&gt; 0}),
<a name="145"/>  145:     do_test_size([M,M#{ &quot;atom&quot; := other },M#{i := 42}],54,32),
<a name="test_size-last_expr"/><a name="146"/>  146:     ok.
<a name="147"/>  147: 
<a name="do_test_size-1"/><a name="148"/>  148: <b>do_test_size</b>(Term) -&gt;
<a name="149"/>  149:     Sz = erts_debug:flat_size(Term),
<a name="do_test_size-last_expr"/><a name="150"/>  150: <b>    Sz = erts_debug:size</b>(Term).
<a name="151"/>  151: 
<a name="do_test_size-3"/><a name="152"/>  152: <b>do_test_size</b>(Term, FlatSz, Sz) -&gt;
<a name="153"/>  153:     FlatSz = erts_debug:flat_size(Term),
<a name="do_test_size-last_expr"/><a name="154"/>  154: <b>    Sz = erts_debug:size</b>(Term).
<a name="155"/>  155: 
<a name="map_size_lower_bound-1"/><a name="156"/>  156: <b>map_size_lower_bound</b>(N) -&gt;
<a name="157"/>  157:     %% this est. is a bit lower that actual lower bound
<a name="158"/>  158:     %% number of internal nodes
<a name="159"/>  159:     T = (N - 1) div 15,
<a name="160"/>  160:     %% total words
<a name="map_size_lower_bound-last_expr"/><a name="161"/>  161:     2 + 17 * T + 2 * N.
<a name="162"/>  162: 
<a name="flat_size_big-1"/><a name="163"/>  163: <b>flat_size_big</b>(Config) when is_list(Config) -&gt;
<a name="164"/>  164:     %% Build a term whose external size only fits in a big num (on 32-bit CPU).
<a name="flat_size_big-last_expr"/><a name="165"/>  165: <b>    flat_size_big_1</b>(16#11111111111111117777777777777777888889999, 0, 16#FFFFFFF).
<a name="166"/>  166: 
<a name="flat_size_big_1-3"/><a name="167"/>  167: <b>flat_size_big_1</b>(Term, Size0, Limit) when Size0 &lt; Limit -&gt;
<a name="168"/>  168:     case erts_debug:flat_size(Term) of
<a name="169"/>  169: 	Size when is_integer(Size), Size0 &lt; Size -&gt;
<a name="170"/>  170: 	    io:format(&quot;~p&quot;, [Size]),
<a name="171"/>  171: 	    flat_size_big_1([Term|Term], Size, Limit)
<a name="172"/>  172:     end;
<a name="flat_size_big_1-last_expr"/><a name="173"/>  173: <b>flat_size_big_1</b>(_, _, _) -&gt; ok.
<a name="174"/>  174: 
<a name="175"/>  175: 
<a name="term_type-1"/><a name="176"/>  176: <b>term_type</b>(Config) when is_list(Config) -&gt;
<a name="177"/>  177:     Ts = [{fixnum, 1},
<a name="178"/>  178:           {fixnum, -1},
<a name="179"/>  179:           {bignum, 1 bsl 300},
<a name="180"/>  180:           {bignum, -(1 bsl 300)},
<a name="181"/>  181:           {hfloat, 0.0},
<a name="182"/>  182:           {hfloat, 0.0/-1},
<a name="183"/>  183:           {hfloat, 1.0/(1 bsl 302)},
<a name="184"/>  184:           {hfloat, 1.0*(1 bsl 302)},
<a name="185"/>  185:           {hfloat, -1.0/(1 bsl 302)},
<a name="186"/>  186:           {hfloat, -1.0*(1 bsl 302)},
<a name="187"/>  187:           {hfloat, 3.1416},
<a name="188"/>  188:           {hfloat, 1.0e18},
<a name="189"/>  189:           {hfloat, -3.1416},
<a name="190"/>  190:           {hfloat, -1.0e18},
<a name="191"/>  191: 
<a name="192"/>  192:           {heap_binary, &lt;&lt;1,2,3&gt;&gt;},
<a name="193"/>  193:           {sub_binary, &lt;&lt;0:(8*80)&gt;&gt;},
<a name="194"/>  194:           {heap_binary, &lt;&lt;5:7&gt;&gt;},
<a name="195"/>  195: 
<a name="196"/>  196:           {flatmap, #{ a =&gt; 1}},
<a name="197"/>  197:           {hashmap, maps:from_list([{I,I}||I &lt;- lists:seq(1,76)])},
<a name="198"/>  198: 
<a name="199"/>  199:           {list, [1,2,3]},
<a name="200"/>  200:           {nil, []},
<a name="201"/>  201:           {tuple, {1,2,3}},
<a name="202"/>  202:           {tuple, {}},
<a name="203"/>  203: 
<a name="204"/>  204:           {export, fun lists:sort/1},
<a name="205"/>  205:           {'fun', fun() -&gt; ok end},
<a name="206"/>  206:           {pid, self()},
<a name="207"/>  207:           {atom, atom}],
<a name="208"/>  208:     lists:foreach(fun({E,Val}) -&gt;
<a name="209"/>  209:                           R = erts_internal:term_type(Val),
<a name="210"/>  210:                           io:format(&quot;expecting term type ~w, got ~w (~p)~n&quot;, [E,R,Val]),
<a name="211"/>  211:                           E = R
<a name="212"/>  212:                   end, Ts),
<a name="term_type-last_expr"/><a name="213"/>  213:     ok.
<a name="214"/>  214: 
<a name="215"/>  215: 
<a name="df-1"/><a name="216"/>  216: <b>df</b>(Config) when is_list(Config) -&gt;
<a name="217"/>  217:     P0 = pps(),
<a name="218"/>  218:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="219"/>  219:     ok = file:set_cwd(PrivDir),
<a name="220"/>  220: 
<a name="221"/>  221:     AllLoaded = [M || {M,_} &lt;- code:all_loaded()],
<a name="222"/>  222:     {Pid,Ref} = spawn_monitor(fun() -&gt; df_smoke(AllLoaded) end),
<a name="223"/>  223:     receive
<a name="224"/>  224: 	{'DOWN',Ref,process,Pid,Status} -&gt;
<a name="225"/>  225: 	    normal = Status
<a name="226"/>  226:     after 20*1000 -&gt;
<a name="227"/>  227: 	    %% Not finished (i.e. a slow computer). Stop now.
<a name="228"/>  228: 	    Pid ! stop,
<a name="229"/>  229: 	    receive
<a name="230"/>  230: 		{'DOWN',Ref,process,Pid,Status} -&gt;
<a name="231"/>  231: 		    normal = Status,
<a name="232"/>  232: 		    io:format(&quot;...&quot;)
<a name="233"/>  233: 	    end
<a name="234"/>  234:     end,
<a name="235"/>  235:     io:nl(),
<a name="236"/>  236:     _ = [_ = file:delete(atom_to_list(M) ++ &quot;.dis&quot;) ||
<a name="237"/>  237: 	    M &lt;- AllLoaded],
<a name="238"/>  238: 
<a name="239"/>  239:     true = (P0 == pps()),
<a name="df-last_expr"/><a name="240"/>  240:     ok.
<a name="241"/>  241: 
<a name="stack_check-1"/><a name="242"/>  242: <b>stack_check</b>(Config) when is_list(Config) -&gt;
<a name="243"/>  243:     erts_debug:set_internal_state(available_internal_state,true),
<a name="244"/>  244:     %% Recurses on the C stack until stacklimit is reached. That
<a name="245"/>  245:     %% is, tests that the stack limit functionality works (used
<a name="246"/>  246:     %% by PCRE). VM will crash if it doesn't work...
<a name="247"/>  247:     Size = erts_debug:get_internal_state(stack_check),
<a name="248"/>  248:     erts_debug:set_internal_state(available_internal_state,false),
<a name="249"/>  249:     true = (is_integer(Size) and (Size &gt; 0)),
<a name="stack_check-last_expr"/><a name="250"/>  250: <b>    {comment, &quot;Stack size: &quot;++integer_to_list</b>(Size)++&quot; bytes&quot;}.
<a name="251"/>  251: 
<a name="df_smoke-1"/><a name="252"/>  252: <b>df_smoke</b>([M|Ms]) -&gt;
<a name="253"/>  253:     io:format(&quot;~p&quot;, [M]),
<a name="254"/>  254:     erts_debug:df(M),
<a name="255"/>  255:     receive
<a name="256"/>  256: 	stop -&gt;
<a name="257"/>  257: 	    ok
<a name="258"/>  258:     after 0 -&gt;
<a name="259"/>  259: 	    df_smoke(Ms)
<a name="260"/>  260:     end;
<a name="df_smoke-last_expr"/><a name="261"/>  261: <b>df_smoke</b>([]) -&gt; ok.
<a name="262"/>  262: 
<a name="pps-0"/><a name="263"/>  263: <b>pps</b>() -&gt;
<a name="pps-last_expr"/><a name="264"/>  264: <b>    {erlang:ports</b>()}.
<a name="265"/>  265: 
<a name="instructions-1"/><a name="266"/>  266: <b>instructions</b>(Config) when is_list(Config) -&gt;
<a name="267"/>  267:     Is = erts_debug:instructions(),
<a name="268"/>  268:     _ = [list_to_atom(I) || I &lt;- Is],
<a name="instructions-last_expr"/><a name="269"/>  269:     ok.
<a name="270"/>  270: 
<a name="alloc_blocks_size-1"/><a name="271"/>  271: <b>alloc_blocks_size</b>(Config) when is_list(Config) -&gt;
<a name="272"/>  272:     F = fun(Args) -&gt;
<a name="273"/>  273:                 {ok, Peer, Node} = ?CT_PEER(Args),
<a name="274"/>  274:                 ok = rpc:call(Node, ?MODULE, do_alloc_blocks_size, []),
<a name="275"/>  275:                 peer:stop(Peer)
<a name="276"/>  276:         end,
<a name="277"/>  277:     case test_server:is_asan() of
<a name="278"/>  278: 	false -&gt; F([&quot;+Meamax&quot;]);
<a name="279"/>  279: 	true -&gt; skip
<a name="280"/>  280:     end,
<a name="281"/>  281:     F([&quot;+Meamin&quot;]),
<a name="282"/>  282:     F([]),
<a name="alloc_blocks_size-last_expr"/><a name="283"/>  283:     ok.
<a name="284"/>  284: 
<a name="do_alloc_blocks_size-0"/><a name="285"/>  285: <b>do_alloc_blocks_size</b>() -&gt;
<a name="286"/>  286:     _ = erts_debug:alloc_blocks_size(binary_alloc),
<a name="do_alloc_blocks_size-last_expr"/><a name="287"/>  287:     ok.
<a name="288"/>  288: 
<a name="id-1"/><a name="289"/>  289: <b>id</b>(I) -&gt;
<a name="id-last_expr"/><a name="290"/>  290:     I.
<a name="291"/>  291: 
<a name="mk_ext_pid-3"/><a name="292"/>  292: <b>mk_ext_pid</b>({NodeName, Creation}, Number, Serial) -&gt;
<a name="mk_ext_pid-last_expr"/><a name="293"/>  293: <b>    erts_test_utils:mk_ext_pid</b>({NodeName, Creation}, Number, Serial).
<a name="294"/>  294: 
<a name="mk_ext_port-2"/><a name="295"/>  295: <b>mk_ext_port</b>({NodeName, Creation}, Number) -&gt;
<a name="mk_ext_port-last_expr"/><a name="296"/>  296: <b>    erts_test_utils:mk_ext_port</b>({NodeName, Creation}, Number).
<a name="297"/>  297: 
<a name="mk_ext_ref-2"/><a name="298"/>  298: <b>mk_ext_ref</b>({NodeName, Creation}, Numbers) -&gt;
<a name="mk_ext_ref-last_expr"/><a name="299"/>  299: <b>    erts_test_utils:mk_ext_ref</b>({NodeName, Creation}, Numbers).
<a name="300"/>  300: 
<a name="301"/>  301: 
<a name="t_copy_shared-1"/><a name="302"/>  302: <b>t_copy_shared</b>(_Config) -&gt;
<a name="303"/>  303:     rand:seed(default),
<a name="304"/>  304:     io:format(&quot;*** SEED: ~p ***\n&quot;, [rand:export_seed()]),
<a name="305"/>  305: 
<a name="306"/>  306:     [copy_shared_term_1(N div 10, CL) || N &lt;- lists:seq(1,100),
<a name="307"/>  307:                                          CL &lt;- [false, true]],
<a name="t_copy_shared-last_expr"/><a name="308"/>  308:     ok.
<a name="309"/>  309: 
<a name="copy_shared_term_1-2"/><a name="310"/>  310: <b>copy_shared_term_1</b>(Size, CopyLit) -&gt;
<a name="311"/>  311:     Term = rand_term(Size),
<a name="312"/>  312: 
<a name="313"/>  313:     %% Note: Printing Term may suppress test failure
<a name="314"/>  314:     %%       as it sends a copy to io-server.
<a name="315"/>  315:     %%io:format(&quot;rand_term(~p): ~p\n&quot;, [Size, printable(Term)]),
<a name="316"/>  316: 
<a name="317"/>  317:     Binary = term_to_binary(Term),
<a name="318"/>  318:     Copy = erts_debug:copy_shared(Term, CopyLit),
<a name="319"/>  319:     test_eq(Term, Copy),
<a name="copy_shared_term_1-last_expr"/><a name="320"/>  320: <b>    copy_shared_term_2</b>(Copy, Binary).
<a name="321"/>  321: 
<a name="copy_shared_term_2-2"/><a name="322"/>  322: <b>copy_shared_term_2</b>(Copy, Binary) -&gt;
<a name="323"/>  323:     erlang:garbage_collect(),
<a name="324"/>  324:     BinCopy = binary_to_term(Binary),
<a name="325"/>  325:     test_eq(Copy, BinCopy),
<a name="copy_shared_term_2-last_expr"/><a name="326"/>  326:     ok.
<a name="327"/>  327: 
<a name="test_eq-2"/><a name="328"/>  328: <b>test_eq</b>(A, B) -&gt;
<a name="329"/>  329:     case A of
<a name="330"/>  330:         B -&gt; ok;
<a name="331"/>  331:         _ -&gt; test_eq_fail(&quot;FAILED MATCH&quot;, A, B)
<a name="332"/>  332:     end,
<a name="test_eq-last_expr"/><a name="333"/>  333:     case A == B of
<a name="334"/>  334:         true -&gt; ok;
<a name="335"/>  335:         false -&gt; test_eq_fail(&quot;FAILED EQUALITY&quot;, A, B)
<a name="336"/>  336:     end.
<a name="337"/>  337: 
<a name="test_eq_fail-3"/><a name="338"/>  338: <b>test_eq_fail</b>(Error, A, B) -&gt;
<a name="339"/>  339:     io:format(&quot;~s:\n\nA = ~p\n\nB = ~p\n&quot;,
<a name="340"/>  340:               [Error, printable(A), printable(B)]),
<a name="test_eq_fail-last_expr"/><a name="341"/>  341: <b>    ct:fail</b>(Error).
<a name="342"/>  342: 
<a name="rand_term-1"/><a name="343"/>  343: <b>rand_term</b>(Size) -&gt;
<a name="344"/>  344:     F = rand:uniform(100), % to produce non-literals
<a name="345"/>  345:     Big = 666_701_523_687_345_689_643 * F,
<a name="346"/>  346:     MagicRef = atomics:new(10,[]),
<a name="347"/>  347:     Leafs = {atom, 42, 42.17*F,
<a name="348"/>  348:              Big, -Big,
<a name="349"/>  349:              [], {}, #{},
<a name="350"/>  350:              &quot;literal cons&quot;,
<a name="351"/>  351:              {&quot;literal boxed&quot;},
<a name="352"/>  352:              fun lists:sort/1,
<a name="353"/>  353:              fun() -&gt; F end,
<a name="354"/>  354:              self(),
<a name="355"/>  355:              lists:last(erlang:ports()),
<a name="356"/>  356:              make_ref(),
<a name="357"/>  357:              MagicRef,
<a name="358"/>  358:              &lt;&lt;F:(8*10)&gt;&gt;,    % HeapBin
<a name="359"/>  359:              &lt;&lt;F:(8*65)&gt;&gt;,    % ProcBin
<a name="360"/>  360:              &lt;&lt;F:7&gt;&gt;,         % SubBin + HeapBin
<a name="361"/>  361:              &lt;&lt;F:(8*80+1)&gt;&gt;,  % SubBin + ProcBin
<a name="362"/>  362:              mk_ext_pid({a@b, 17}, 17, 42),
<a name="363"/>  363:              mk_ext_port({a@b, 21}, 13),
<a name="364"/>  364:              mk_ext_ref({a@b, 42}, [42, 19, 11])},
<a name="rand_term-last_expr"/><a name="365"/>  365: <b>    rand_term</b>(Leafs, Size).
<a name="366"/>  366: 
<a name="rand_term-2"/><a name="367"/>  367: <b>rand_term</b>(Leafs, Arity) when Arity &gt; 0 -&gt;
<a name="368"/>  368:     Length = rand:uniform(Arity),
<a name="369"/>  369:     List = [rand_term(Leafs, Arity-Length) || _ &lt;- lists:seq(1,Length)],
<a name="370"/>  370:     case rand:uniform(6) of
<a name="371"/>  371:         1 -&gt; List;
<a name="372"/>  372:         2 -&gt; list_to_improper_list(List);
<a name="373"/>  373:         3 -&gt; list_to_tuple(List);
<a name="374"/>  374:         4 -&gt; list_to_flatmap(List);
<a name="375"/>  375:         5 -&gt; list_to_hashmap(List);
<a name="376"/>  376:         6 -&gt; list_to_fun(List)
<a name="377"/>  377:     end;
<a name="378"/>  378: <b>rand_term</b>(Leafs, 0) -&gt;
<a name="rand_term-last_expr"/><a name="379"/>  379: <b>    element</b>(rand:uniform(size(Leafs)), Leafs).
<a name="380"/>  380: 
<a name="list_to_improper_list-1"/><a name="381"/>  381: <b>list_to_improper_list</b>([A,B|T]) -&gt;
<a name="382"/>  382:     T ++ [A|B];
<a name="383"/>  383: <b>list_to_improper_list</b>([H]) -&gt;
<a name="list_to_improper_list-last_expr"/><a name="384"/>  384:     [[]|H].
<a name="385"/>  385: 
<a name="list_to_flatmap-1"/><a name="386"/>  386: <b>list_to_flatmap</b>(List) -&gt;
<a name="list_to_flatmap-last_expr"/><a name="387"/>  387: <b>    list_to_map</b>(List, #{}).
<a name="388"/>  388: 
<a name="list_to_hashmap-1"/><a name="389"/>  389: <b>list_to_hashmap</b>(List) -&gt;
<a name="390"/>  390:     HashMap = #{1=&gt;1, 2=&gt;2, 3=&gt;3, 4=&gt;4, 5=&gt;5, 6=&gt;6, 7=&gt;7, 8=&gt;8, 9=&gt;9,10=&gt;0,
<a name="391"/>  391:                 11=&gt;1,12=&gt;2,13=&gt;3,14=&gt;4,15=&gt;5,16=&gt;6,17=&gt;7,18=&gt;8,19=&gt;9,20=&gt;0,
<a name="392"/>  392:                 21=&gt;1,22=&gt;2,23=&gt;3,24=&gt;4,25=&gt;5,26=&gt;6,27=&gt;7,28=&gt;8,29=&gt;9,30=&gt;0,
<a name="393"/>  393:                 31=&gt;1,32=&gt;2,33=&gt;3},
<a name="list_to_hashmap-last_expr"/><a name="394"/>  394: <b>    list_to_map</b>(List, HashMap).
<a name="395"/>  395: 
<a name="list_to_map-2"/><a name="396"/>  396: <b>list_to_map</b>([], Map) -&gt;
<a name="397"/>  397:     Map;
<a name="398"/>  398: <b>list_to_map</b>([K], Map) -&gt;
<a name="399"/>  399:     Map#{K =&gt; K};
<a name="400"/>  400: <b>list_to_map</b>([K,V|T], Map) -&gt;
<a name="list_to_map-last_expr"/><a name="401"/>  401: <b>    list_to_map</b>(T, Map#{K =&gt; V}).
<a name="402"/>  402: 
<a name="list_to_fun-1"/><a name="403"/>  403: <b>list_to_fun</b>([X]) -&gt;
<a name="404"/>  404:     fun(A) -&gt; A + X end;
<a name="405"/>  405: <b>list_to_fun</b>([X, Y]) -&gt;
<a name="406"/>  406:     fun(A) -&gt; A + X + Y end;
<a name="407"/>  407: <b>list_to_fun</b>([X, Y | T]) -&gt;
<a name="list_to_fun-last_expr"/><a name="408"/>  408: <b>    fun</b>(A) -&gt; [A+X+Y | T] end.
<a name="409"/>  409: 
<a name="410"/>  410: 
<a name="411"/>  411: <i>%% Convert local funs to maps to show fun environment</i>
<a name="printable-1"/><a name="412"/>  412: <b>printable</b>(Fun) when is_function(Fun) -&gt;
<a name="413"/>  413:     case erlang:fun_info(Fun, type) of
<a name="414"/>  414:         {type,local} -&gt;
<a name="415"/>  415:             {env, Env} = erlang:fun_info(Fun, env),
<a name="416"/>  416:             #{'fun' =&gt; [printable(T) || T &lt;- Env]};
<a name="417"/>  417:         {type,external} -&gt;
<a name="418"/>  418:             Fun
<a name="419"/>  419:     end;
<a name="420"/>  420: <b>printable</b>([H|T]) -&gt;
<a name="421"/>  421:     [printable(H)|printable(T)];
<a name="422"/>  422: <b>printable</b>(Tuple) when is_tuple(Tuple) -&gt;
<a name="423"/>  423:     list_to_tuple(printable(tuple_to_list(Tuple)));
<a name="424"/>  424: <b>printable</b>(Map) when is_map(Map) -&gt;
<a name="425"/>  425:     maps:from_list(printable(maps:to_list(Map)));
<a name="426"/>  426: <b>printable</b>(Leaf) -&gt;
<a name="printable-last_expr"/><a name="427"/>  427:     Leaf.
</pre>
<script>
var hash = window.location.hash.substring(1);
var anchor = document.getElementsByName(hash);
anchor[0].style.backgroundColor="orange";
</script>
</body>
</html>
