<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/erts/emulator/make_test_dir/emulator_test/z_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%</i>
<a name="2"/>    2: <i>%% %CopyrightBegin%</i>
<a name="3"/>    3: <i>%% </i>
<a name="4"/>    4: <i>%% Copyright Ericsson AB 2006-2022. All Rights Reserved.</i>
<a name="5"/>    5: <i>%% </i>
<a name="6"/>    6: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="7"/>    7: <i>%% you may not use this file except in compliance with the License.</i>
<a name="8"/>    8: <i>%% You may obtain a copy of the License at</i>
<a name="9"/>    9: <i>%%</i>
<a name="10"/>   10: <i>%%     http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="11"/>   11: <i>%%</i>
<a name="12"/>   12: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="13"/>   13: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="14"/>   14: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="15"/>   15: <i>%% See the License for the specific language governing permissions and</i>
<a name="16"/>   16: <i>%% limitations under the License.</i>
<a name="17"/>   17: <i>%% </i>
<a name="18"/>   18: <i>%% %CopyrightEnd%</i>
<a name="19"/>   19: <i>%%</i>
<a name="20"/>   20: 
<a name="21"/>   21: <i>%%%-------------------------------------------------------------------</i>
<a name="22"/>   22: <i>%%% File    : z_SUITE.erl</i>
<a name="23"/>   23: <i>%%% Author  : Rickard Green &lt;rickard.s.green@ericsson.com&gt;</i>
<a name="24"/>   24: <i>%%% Description : Misc tests that should be run last</i>
<a name="25"/>   25: <i>%%%</i>
<a name="26"/>   26: <i>%%% Created : 15 Jul 2005 by Rickard Green &lt;rickard.s.green@ericsson.com&gt;</i>
<a name="27"/>   27: <i>%%%-------------------------------------------------------------------</i>
<a name="28"/>   28: <b>-module</b>(z_SUITE).
<a name="29"/>   29: <b>-author</b>('rickard.s.green@ericsson.com').
<a name="30"/>   30: 
<a name="31"/>   31: <i>%-define(line_trace, 1).</i>
<a name="32"/>   32: 
<a name="33"/>   33: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="34"/>   34: 
<a name="35"/>   35: <b>-export</b>([all/0, suite/0, init_per_testcase/2, end_per_testcase/2]).
<a name="36"/>   36: 
<a name="37"/>   37: <b>-export</b>([used_thread_specific_events/1, schedulers_alive/1,
<a name="38"/>   38:          node_container_refc_check/1,
<a name="39"/>   39: 	 long_timers/1, pollset_size/1,
<a name="40"/>   40: 	 check_io_debug/1, get_check_io_info/0,
<a name="41"/>   41:          lc_graph/1,
<a name="42"/>   42:          leaked_processes/1,
<a name="43"/>   43:          literal_area_collector/1]).
<a name="44"/>   44: 
<a name="suite-0"/><a name="45"/>   45: <b>suite</b>() -&gt;
<a name="suite-last_expr"/><a name="46"/>   46:     [{ct_hooks,[ts_install_cth]},
<a name="47"/>   47:      {timetrap, {minutes, 5}}].
<a name="48"/>   48: 
<a name="all-0"/><a name="49"/>   49: <b>all</b>() -&gt; 
<a name="all-last_expr"/><a name="50"/>   50:     [used_thread_specific_events, schedulers_alive,
<a name="51"/>   51:      node_container_refc_check,
<a name="52"/>   52:      long_timers, pollset_size, check_io_debug,
<a name="53"/>   53:      lc_graph,
<a name="54"/>   54:      %% Make sure that the leaked_processes/1 is always
<a name="55"/>   55:      %% run last.
<a name="56"/>   56:      leaked_processes,
<a name="57"/>   57:      literal_area_collector].
<a name="58"/>   58: 
<a name="init_per_testcase-2"/><a name="59"/>   59: <b>init_per_testcase</b>(schedulers_alive, Config) -&gt;
<a name="60"/>   60:     case erlang:system_info(schedulers) of
<a name="61"/>   61:         1 -&gt;
<a name="62"/>   62:             {skip, &quot;Needs more schedulers to run&quot;};
<a name="63"/>   63:         _ -&gt;
<a name="64"/>   64:             Config
<a name="65"/>   65:     end;
<a name="66"/>   66: <b>init_per_testcase</b>(_, Config) -&gt;
<a name="init_per_testcase-last_expr"/><a name="67"/>   67:     Config.
<a name="68"/>   68: 
<a name="69"/>   69: 
<a name="end_per_testcase-2"/><a name="70"/>   70: <b>end_per_testcase</b>(_Name, Config) -&gt;
<a name="end_per_testcase-last_expr"/><a name="71"/>   71:     Config.
<a name="72"/>   72: 
<a name="73"/>   73: <i>%%%</i>
<a name="74"/>   74: <i>%%% The test cases -------------------------------------------------------------</i>
<a name="75"/>   75: <i>%%%</i>
<a name="76"/>   76: 
<a name="used_thread_specific_events-1"/><a name="77"/>   77: <b>used_thread_specific_events</b>(Config) when is_list(Config) -&gt;
<a name="78"/>   78:     Pid = whereis(used_thread_specific_events_holder),
<a name="79"/>   79:     Mon = monitor(process, Pid),
<a name="80"/>   80:     Pid ! {get_used_tse, self()},
<a name="81"/>   81:     UsedTSE = erlang:system_info(ethread_used_tse),
<a name="used_thread_specific_events-last_expr"/><a name="82"/>   82:     receive
<a name="83"/>   83:         {used_tse, InitialUsedTSE} -&gt;
<a name="84"/>   84:             io:format(&quot;InitialUsedTSE=~p UsedTSE=~p~n&quot;, [InitialUsedTSE, UsedTSE]),
<a name="85"/>   85:             case os:type() of
<a name="86"/>   86:                 {win32,_} -&gt;
<a name="87"/>   87:                     %% The windows poll implementation creates threads on demand
<a name="88"/>   88:                     %% which in turn will get thread specific events allocated.
<a name="89"/>   89:                     %% We don't know how many such threads are created, so we
<a name="90"/>   90:                     %% just have to guess and test that the amount of events is
<a name="91"/>   91:                     %% not huge.
<a name="92"/>   92:                     Extra = 100, %% Value take out of the blue...
<a name="93"/>   93:                     if UsedTSE =&lt; InitialUsedTSE+Extra -&gt; ok;
<a name="94"/>   94:                        true -&gt; ct:fail(&quot;An unexpected large amount of thread specific events used!&quot;)
<a name="95"/>   95:                     end;
<a name="96"/>   96:                 _ -&gt;
<a name="97"/>   97:                     if UsedTSE =&lt; InitialUsedTSE -&gt; ok;
<a name="98"/>   98:                        true -&gt; ct:fail(&quot;An increased amount of thread specific events used!&quot;)
<a name="99"/>   99:                     end
<a name="100"/>  100:             end,
<a name="101"/>  101:             exit(Pid, kill),
<a name="102"/>  102:             receive {'DOWN', Mon, process, Pid, _} -&gt; ok end;
<a name="103"/>  103:         {'DOWN', Mon, process, Pid, Reason} -&gt;
<a name="104"/>  104:             ct:fail({used_thread_specific_events_holder, Reason})
<a name="105"/>  105:     end.
<a name="106"/>  106: 
<a name="107"/>  107: <i>%% Tests that all schedulers are actually used</i>
<a name="schedulers_alive-1"/><a name="108"/>  108: <b>schedulers_alive</b>(Config) when is_list(Config) -&gt;
<a name="109"/>  109:     Master = self(),
<a name="110"/>  110:     NoSchedulersOnline = erlang:system_flag(
<a name="111"/>  111:                            schedulers_online,
<a name="112"/>  112:                            erlang:system_info(schedulers)),
<a name="113"/>  113:     NoSchedulers = erlang:system_info(schedulers),
<a name="114"/>  114:     UsedScheds =
<a name="115"/>  115:       try
<a name="116"/>  116:           io:format(&quot;Number of schedulers configured: ~p~n&quot;, [NoSchedulers]),
<a name="117"/>  117:           case erlang:system_info(multi_scheduling) of
<a name="118"/>  118:               blocked -&gt;
<a name="119"/>  119:                   ct:fail(multi_scheduling_blocked);
<a name="120"/>  120:               disabled -&gt;
<a name="121"/>  121:                   ok;
<a name="122"/>  122:               enabled -&gt;
<a name="123"/>  123:                   io:format(&quot;Testing blocking process exit~n&quot;),
<a name="124"/>  124:                   BF = fun () -&gt;
<a name="125"/>  125:                                blocked_normal = erlang:system_flag(multi_scheduling,
<a name="126"/>  126: 								   block_normal),
<a name="127"/>  127:                                Master ! {self(), blocking},
<a name="128"/>  128:                                receive after infinity -&gt; ok end
<a name="129"/>  129:                        end,
<a name="130"/>  130:                   Blocker = spawn_link(BF),
<a name="131"/>  131:                   Mon = erlang:monitor(process, Blocker),
<a name="132"/>  132:                   receive {Blocker, blocking} -&gt; ok end,
<a name="133"/>  133:                   [Blocker]
<a name="134"/>  134:                   = erlang:system_info(normal_multi_scheduling_blockers),
<a name="135"/>  135:                   unlink(Blocker),
<a name="136"/>  136:                   exit(Blocker, kill),
<a name="137"/>  137:                   receive {'DOWN', Mon, _, _, _} -&gt; ok end,
<a name="138"/>  138:                   enabled = erlang:system_info(multi_scheduling),
<a name="139"/>  139:                   [] = erlang:system_info(normal_multi_scheduling_blockers),
<a name="140"/>  140:                   ok
<a name="141"/>  141:           end,
<a name="142"/>  142:           io:format(&quot;Testing blocked~n&quot;),
<a name="143"/>  143:           erlang:system_flag(multi_scheduling, block_normal),
<a name="144"/>  144:           case erlang:system_info(multi_scheduling) of
<a name="145"/>  145:               enabled -&gt;
<a name="146"/>  146:                   ct:fail(multi_scheduling_enabled);
<a name="147"/>  147:               blocked_normal -&gt;
<a name="148"/>  148:                   [Master] = erlang:system_info(normal_multi_scheduling_blockers);
<a name="149"/>  149:               disabled -&gt; ok
<a name="150"/>  150:           end,
<a name="151"/>  151:           Ps = lists:map(
<a name="152"/>  152:                  fun (_) -&gt;
<a name="153"/>  153:                          spawn_link(fun () -&gt;
<a name="154"/>  154:                                             run_on_schedulers(none,
<a name="155"/>  155:                                                               [],
<a name="156"/>  156:                                                               Master)
<a name="157"/>  157:                                     end)
<a name="158"/>  158:                  end,
<a name="159"/>  159:                  lists:seq(1,NoSchedulers)),
<a name="160"/>  160:           receive after 1000 -&gt; ok end,
<a name="161"/>  161:           {_, 1} = verify_all_schedulers_used({[],0}, 1),
<a name="162"/>  162:           lists:foreach(fun (P) -&gt;
<a name="163"/>  163:                                 unlink(P),
<a name="164"/>  164:                                 exit(P, bang)
<a name="165"/>  165:                         end, Ps),
<a name="166"/>  166:           case erlang:system_flag(multi_scheduling, unblock_normal) of
<a name="167"/>  167:               blocked_normal -&gt; ct:fail(multi_scheduling_blocked);
<a name="168"/>  168:               disabled -&gt; ok;
<a name="169"/>  169:               enabled -&gt; ok
<a name="170"/>  170:           end,
<a name="171"/>  171:           erts_debug:set_internal_state(available_internal_state, true),
<a name="172"/>  172:           %% node_and_dist_references will use emulator internal thread blocking...
<a name="173"/>  173:           erts_debug:get_internal_state(node_and_dist_references), 
<a name="174"/>  174:           erts_debug:set_internal_state(available_internal_state, false),
<a name="175"/>  175:           io:format(&quot;Testing not blocked~n&quot;),
<a name="176"/>  176:           Ps2 = lists:map(
<a name="177"/>  177:                   fun (_) -&gt;
<a name="178"/>  178:                           spawn_link(fun () -&gt;
<a name="179"/>  179:                                              run_on_schedulers(none,
<a name="180"/>  180:                                                                [],
<a name="181"/>  181:                                                                Master)
<a name="182"/>  182:                                      end)
<a name="183"/>  183:                   end,
<a name="184"/>  184:                   lists:seq(1,NoSchedulers)),
<a name="185"/>  185:           receive after 1000 -&gt; ok end,
<a name="186"/>  186:           {_, NoSIDs} = verify_all_schedulers_used({[],0},NoSchedulers),
<a name="187"/>  187:           lists:foreach(fun (P) -&gt;
<a name="188"/>  188:                                 unlink(P),
<a name="189"/>  189:                                 exit(P, bang)
<a name="190"/>  190:                         end, Ps2),
<a name="191"/>  191:           NoSIDs
<a name="192"/>  192:       after
<a name="193"/>  193:           NoSchedulers = erlang:system_flag(schedulers_online,
<a name="194"/>  194:                                             NoSchedulersOnline),
<a name="195"/>  195:           NoSchedulersOnline = erlang:system_info(schedulers_online)
<a name="196"/>  196:       end,
<a name="schedulers_alive-last_expr"/><a name="197"/>  197: <b>        {comment, &quot;Number of schedulers &quot; ++ integer_to_list</b>(UsedScheds)}.
<a name="198"/>  198: 
<a name="199"/>  199: 
<a name="run_on_schedulers-3"/><a name="200"/>  200: <b>run_on_schedulers</b>(LastSID, SIDs, ReportTo) -&gt;
<a name="run_on_schedulers-last_expr"/><a name="201"/>  201: <b>    case erlang:system_info</b>(scheduler_id) of
<a name="202"/>  202: 	LastSID -&gt;
<a name="203"/>  203: 	    erlang:yield(),
<a name="204"/>  204: 	    run_on_schedulers(LastSID, SIDs, ReportTo);
<a name="205"/>  205: 	SID -&gt;
<a name="206"/>  206: 	    NewSIDs = case lists:member(SID, SIDs) of
<a name="207"/>  207: 			  true -&gt;
<a name="208"/>  208: 			      SIDs;
<a name="209"/>  209: 			  false -&gt;
<a name="210"/>  210: 			      ReportTo ! {scheduler_used, SID},
<a name="211"/>  211: 			      [SID | SIDs]
<a name="212"/>  212: 		      end,
<a name="213"/>  213: 	    erlang:yield(),
<a name="214"/>  214: 	    run_on_schedulers(SID, NewSIDs, ReportTo)
<a name="215"/>  215:     end.
<a name="216"/>  216: 
<a name="wait_on_used_scheduler-1"/><a name="217"/>  217: <b>wait_on_used_scheduler</b>({SIDs, SIDsLen} = State) -&gt;
<a name="wait_on_used_scheduler-last_expr"/><a name="218"/>  218:     receive
<a name="219"/>  219: 	{scheduler_used, SID} -&gt;
<a name="220"/>  220: 	    case lists:member(SID, SIDs) of
<a name="221"/>  221: 		true -&gt;
<a name="222"/>  222: 		    wait_on_used_scheduler(State);
<a name="223"/>  223: 		false -&gt;
<a name="224"/>  224: 		    io:format(&quot;Scheduler ~p used~n&quot;, [SID]),
<a name="225"/>  225: 		    {[SID|SIDs], SIDsLen+1}
<a name="226"/>  226: 	    end
<a name="227"/>  227:     end.
<a name="228"/>  228: 
<a name="verify_all_schedulers_used-2"/><a name="229"/>  229: <b>verify_all_schedulers_used</b>({UsedSIDs, UsedSIDsLen} = State, NoSchedulers) -&gt;
<a name="verify_all_schedulers_used-last_expr"/><a name="230"/>  230:     case NoSchedulers of
<a name="231"/>  231: 	      UsedSIDsLen -&gt;
<a name="232"/>  232: 		  State;
<a name="233"/>  233: 	      NoSchdlrs when NoSchdlrs &lt; UsedSIDsLen -&gt;
<a name="234"/>  234: 		  ct:fail({more_schedulers_used_than_exist,
<a name="235"/>  235: 				 {existing_schedulers, NoSchdlrs},
<a name="236"/>  236: 				 {used_schedulers, UsedSIDsLen},
<a name="237"/>  237: 				 {used_scheduler_ids, UsedSIDs}});
<a name="238"/>  238: 	      _ -&gt;
<a name="239"/>  239: 		  NewState = wait_on_used_scheduler(State),
<a name="240"/>  240: 		  verify_all_schedulers_used(NewState, NoSchedulers)
<a name="241"/>  241: 	  end.
<a name="242"/>  242: 
<a name="node_container_refc_check-1"/><a name="243"/>  243: <b>node_container_refc_check</b>(Config) when is_list(Config) -&gt;
<a name="244"/>  244:     node_container_SUITE:node_container_refc_check(node()),
<a name="node_container_refc_check-last_expr"/><a name="245"/>  245:     ok.
<a name="246"/>  246: 
<a name="long_timers-1"/><a name="247"/>  247: <b>long_timers</b>(Config) when is_list(Config) -&gt;
<a name="long_timers-last_expr"/><a name="248"/>  248: <b>    case long_timers_test:check_result</b>() of
<a name="249"/>  249: 	ok -&gt; ok;
<a name="250"/>  250: 	high_cpu -&gt; {comment, &quot;Ignored failures due to high CPU utilization&quot;};
<a name="251"/>  251: 	missing_cpu_info -&gt; {comment, &quot;Ignored failures due to missing CPU utilization information&quot;};
<a name="252"/>  252: 	Fail -&gt; ct:fail(Fail)
<a name="253"/>  253:     end.
<a name="254"/>  254: 	    
<a name="255"/>  255: 
<a name="pollset_size-1"/><a name="256"/>  256: <b>pollset_size</b>(Config) when is_list(Config) -&gt;
<a name="257"/>  257:     Name = pollset_size_testcase_initial_state_holder,
<a name="258"/>  258:     Mon = erlang:monitor(process, Name),
<a name="259"/>  259:     (catch Name ! {get_initial_check_io_result, self()}),
<a name="260"/>  260:     InitChkIo = receive
<a name="261"/>  261: 			  {initial_check_io_result, ICIO} -&gt;
<a name="262"/>  262: 			      erlang:demonitor(Mon, [flush]),
<a name="263"/>  263: 			      ICIO;
<a name="264"/>  264: 			  {'DOWN', Mon, _, _, Reason} -&gt;
<a name="265"/>  265: 			      ct:fail({non_existing, Name, Reason})
<a name="266"/>  266: 		      end,
<a name="267"/>  267:     FinChkIo = get_check_io_info(),
<a name="268"/>  268:     io:format(&quot;Initial: ~p~nFinal: ~p~n&quot;, [InitChkIo, FinChkIo]),
<a name="269"/>  269:     InitPollsetSize = lists:keysearch(total_poll_set_size, 1, InitChkIo),
<a name="270"/>  270:     FinPollsetSize = lists:keysearch(total_poll_set_size, 1, FinChkIo),
<a name="271"/>  271:     HasGethost = case has_gethost() of true -&gt; 1; _ -&gt; 0 end,
<a name="pollset_size-last_expr"/><a name="272"/>  272:     case InitPollsetSize =:= FinPollsetSize of
<a name="273"/>  273: 	      true -&gt;
<a name="274"/>  274: 		  case InitPollsetSize of
<a name="275"/>  275: 		      {value, {total_poll_set_size, Size}} -&gt;
<a name="276"/>  276: 			  {comment,
<a name="277"/>  277: 				 &quot;Pollset size: &quot; ++ integer_to_list(Size)};
<a name="278"/>  278: 		      _ -&gt;
<a name="279"/>  279: 			  {skipped,
<a name="280"/>  280: 				 &quot;Pollset size information not available&quot;}
<a name="281"/>  281: 		  end;
<a name="282"/>  282: 	      false -&gt;
<a name="283"/>  283: 		  %% Sometimes we have fewer descriptors in the
<a name="284"/>  284: 		  %% pollset at the end than when we started, but
<a name="285"/>  285: 		  %% that is ok as long as there are at least 2
<a name="286"/>  286: 		  %% descriptors (dist listen socket and
<a name="287"/>  287: 		  %% epmd socket) in the pollset.
<a name="288"/>  288: 		  {value, {total_poll_set_size, InitSize}}
<a name="289"/>  289: 		      = InitPollsetSize,
<a name="290"/>  290: 		  {value, {total_poll_set_size, FinSize}}
<a name="291"/>  291: 		      = FinPollsetSize,
<a name="292"/>  292: 		  true = FinSize &lt; (InitSize + HasGethost),
<a name="293"/>  293: 		  true = 2 =&lt; FinSize,
<a name="294"/>  294: 		  {comment,
<a name="295"/>  295: 			 &quot;Start pollset size: &quot;
<a name="296"/>  296: 			 ++ integer_to_list(InitSize)
<a name="297"/>  297: 			 ++ &quot; End pollset size: &quot;
<a name="298"/>  298: 			 ++ integer_to_list(FinSize)}
<a name="299"/>  299: 	  end.
<a name="300"/>  300: 
<a name="check_io_debug-1"/><a name="301"/>  301: <b>check_io_debug</b>(Config) when is_list(Config) -&gt;
<a name="check_io_debug-last_expr"/><a name="302"/>  302: <b>    case lists:keysearch</b>(name, 1, hd(erlang:system_info(check_io))) of
<a name="303"/>  303: 	      {value, {name, erts_poll}} -&gt; check_io_debug_test();
<a name="304"/>  304: 	      _ -&gt; {skipped, &quot;Not implemented in this emulator&quot;}
<a name="305"/>  305: 	  end.
<a name="306"/>  306: 
<a name="check_io_debug_test-0"/><a name="307"/>  307: <b>check_io_debug_test</b>() -&gt;
<a name="308"/>  308:     erlang:display(get_check_io_info()),
<a name="309"/>  309:     erts_debug:set_internal_state(available_internal_state, true),
<a name="310"/>  310:     {NoErrorFds, NoUsedFds, NoDrvSelStructs, NoDrvEvStructs} = CheckIoDebug
<a name="311"/>  311: 	= erts_debug:get_internal_state(check_io_debug),
<a name="312"/>  312:     erts_debug:set_internal_state(available_internal_state, false),
<a name="313"/>  313:     HasGetHost = has_gethost(),
<a name="314"/>  314:     ct:log(&quot;check_io_debug: ~p~n&quot;
<a name="315"/>  315:            &quot;HasGetHost: ~p&quot;,[CheckIoDebug, HasGetHost]),
<a name="316"/>  316:     0 = NoErrorFds,
<a name="317"/>  317:     if
<a name="318"/>  318:         NoUsedFds == NoDrvSelStructs -&gt;
<a name="319"/>  319:             ok;
<a name="320"/>  320:         HasGetHost andalso (NoUsedFds == (NoDrvSelStructs - 1)) -&gt;
<a name="321"/>  321:             %% If the inet_gethost port is alive, we may have
<a name="322"/>  322:             %% one extra used fd that is not selected on.
<a name="323"/>  323:             %% This happens when the initial setup of the
<a name="324"/>  324:             %% port returns an EAGAIN
<a name="325"/>  325:             ok
<a name="326"/>  326:     end,
<a name="327"/>  327:     0 = NoDrvEvStructs,
<a name="check_io_debug_test-last_expr"/><a name="328"/>  328:     ok.
<a name="329"/>  329: 
<a name="has_gethost-0"/><a name="330"/>  330: <b>has_gethost</b>() -&gt;
<a name="has_gethost-last_expr"/><a name="331"/>  331: <b>    has_gethost</b>(erlang:ports()).
<a name="has_gethost-1"/><a name="332"/>  332: <b>has_gethost</b>([P|T]) -&gt;
<a name="333"/>  333:     {name, Name} = erlang:port_info(P, name),
<a name="334"/>  334:     case filename:basename(Name) of
<a name="335"/>  335:         &quot;inet_gethost&quot;++_ -&gt;
<a name="336"/>  336:             true;
<a name="337"/>  337:         _ -&gt;
<a name="338"/>  338:             has_gethost(T)
<a name="339"/>  339:     end;
<a name="340"/>  340: <b>has_gethost</b>([]) -&gt;
<a name="has_gethost-last_expr"/><a name="341"/>  341:     false.
<a name="342"/>  342: 
<a name="lc_graph-1"/><a name="343"/>  343: <b>lc_graph</b>(Config) when is_list(Config) -&gt;
<a name="344"/>  344:     %% Create &quot;lc_graph&quot; file in current working dir
<a name="345"/>  345:     %% if lock checker is enabled
<a name="346"/>  346:     erts_debug:lc_graph(),
<a name="lc_graph-last_expr"/><a name="347"/>  347:     ok.
<a name="348"/>  348: 
<a name="leaked_processes-1"/><a name="349"/>  349: <b>leaked_processes</b>(Config) when is_list(Config) -&gt;
<a name="350"/>  350:     %% Replace the default timetrap with a timetrap with
<a name="351"/>  351:     %% known pid.
<a name="352"/>  352:     test_server:timetrap_cancel(),
<a name="353"/>  353:     Dog = test_server:timetrap(test_server:minutes(5)),
<a name="354"/>  354: 
<a name="355"/>  355:     Name = leaked_processes__process_holder,
<a name="356"/>  356:     Name ! {get_initial_processes, self()},
<a name="357"/>  357:     receive
<a name="358"/>  358:         {initial_processes, Initial0} -&gt; ok
<a name="359"/>  359:     end,
<a name="360"/>  360:     Initial = ordsets:from_list(Initial0),
<a name="361"/>  361: 
<a name="362"/>  362:     KnownPids = ordsets:from_list([self(),Dog]),
<a name="363"/>  363:     Now0 = ordsets:from_list(processes()),
<a name="364"/>  364:     Now = ordsets:subtract(Now0, KnownPids),
<a name="365"/>  365:     Leaked = ordsets:subtract(Now, Initial),
<a name="366"/>  366: 
<a name="367"/>  367:     _ = [begin
<a name="368"/>  368:              Info = process_info(P) ++ process_info(P, [current_stacktrace]),
<a name="369"/>  369:              io:format(&quot;~p: ~p\n&quot;, [P,Info])
<a name="370"/>  370:          end || P &lt;- Leaked],
<a name="371"/>  371:     Comment = lists:flatten(io_lib:format(&quot;~p process(es)&quot;,
<a name="372"/>  372:                                           [length(Leaked)])),
<a name="leaked_processes-last_expr"/><a name="373"/>  373:     {comment, Comment}.
<a name="374"/>  374: 
<a name="literal_area_collector-1"/><a name="375"/>  375: <b>literal_area_collector</b>(Config) when is_list(Config) -&gt;
<a name="literal_area_collector-last_expr"/><a name="376"/>  376: <b>    literal_area_collector_test:check_idle</b>(10000).
<a name="377"/>  377: 
<a name="378"/>  378: <i>%%</i>
<a name="379"/>  379: <i>%% Internal functions...</i>
<a name="380"/>  380: <i>%%</i>
<a name="381"/>  381: 
<a name="382"/>  382: 
<a name="display_check_io-1"/><a name="383"/>  383: <b>display_check_io</b>(ChkIo) -&gt;
<a name="384"/>  384:     catch erlang:display('--- CHECK IO INFO ---'),
<a name="385"/>  385:     catch erlang:display(ChkIo),
<a name="386"/>  386:     catch erts_debug:set_internal_state(available_internal_state, true),
<a name="387"/>  387:     NoOfErrorFds = (catch element(1, erts_debug:get_internal_state(check_io_debug))),
<a name="388"/>  388:     catch erlang:display({'NoOfErrorFds', NoOfErrorFds}),
<a name="389"/>  389:     catch erts_debug:set_internal_state(available_internal_state, false),
<a name="390"/>  390:     catch erlang:display('--- CHECK IO INFO ---'),
<a name="display_check_io-last_expr"/><a name="391"/>  391:     ok.
<a name="392"/>  392: 
<a name="get_check_io_info-0"/><a name="393"/>  393: <b>get_check_io_info</b>() -&gt;
<a name="394"/>  394:     ChkIo = driver_SUITE:get_check_io_total(erlang:system_info(check_io)),
<a name="395"/>  395:     PendUpdNo = case lists:keysearch(pending_updates, 1, ChkIo) of
<a name="396"/>  396: 		    {value, {pending_updates, PendNo}} -&gt;
<a name="397"/>  397: 			PendNo;
<a name="398"/>  398: 		    false -&gt;
<a name="399"/>  399: 			0
<a name="400"/>  400: 		end,
<a name="401"/>  401:     {value, {active_fds, ActFds}} = lists:keysearch(active_fds, 1, ChkIo),
<a name="get_check_io_info-last_expr"/><a name="402"/>  402:     case {PendUpdNo, ActFds} of
<a name="403"/>  403: 	{0, 0} -&gt;
<a name="404"/>  404: 	    display_check_io(ChkIo),
<a name="405"/>  405: 	    ChkIo;
<a name="406"/>  406: 	_ -&gt;
<a name="407"/>  407: 	    receive after 100 -&gt; ok end,
<a name="408"/>  408: 	    get_check_io_info()
<a name="409"/>  409:     end.
</pre>
<script>
var hash = window.location.hash.substring(1);
var anchor = document.getElementsByName(hash);
anchor[0].style.backgroundColor="orange";
</script>
</body>
</html>
