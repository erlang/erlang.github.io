<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.34.1">
    <meta name="project" content="Erlang System Documentation v27.1.2">


    <title>Funs — Erlang System Documentation v27.1.2</title>
    <link rel="stylesheet" href="dist/html-erlang-APNLKZCW.css" />


    <script src="dist/handlebars.runtime-NWIB6V2M.js"></script>
    <script src="dist/handlebars.templates-K7URE6B4.js"></script>
    <script src="dist/sidebar_items-4A143270.js"></script>
    <script src="docs_config.js"></script>
    <script async src="dist/html-7XSQ4GTY.js"></script>

  </head>
  <body data-type="extras" class="page-extra">
    <script>

      try {
        var settings = JSON.parse(localStorage.getItem('ex_doc:settings') || '{}');

        if (settings.theme === 'dark' ||
           ((settings.theme === 'system' || settings.theme == null) &&
             window.matchMedia('(prefers-color-scheme: dark)').matches)
           ) {
          document.body.classList.add('dark')
        }
      } catch (error) { }
    </script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="../index.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="Erlang System Documentation" />
        </a>

      <div>
        <a href="../index.html" class="sidebar-projectName" translate="no">
Erlang System Documentation
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v27.1.2
        </div>
      </div>
    </div>
    <ul id="sidebar-listNav" class="sidebar-listNav" role="tablist">
      <li>
        <button id="extras-list-tab-button" role="tab" data-type="extras" aria-controls="extras-tab-panel" aria-selected="true" tabindex="0">
Pages
        </button>
      </li>


    </ul>
  </div>

  <div id="extras-tab-panel" class="sidebar-tabpanel" role="tabpanel" aria-labelledby="extras-list-tab-button">
    <ul id="extras-full-list" class="full-list"></ul>
  </div>


</nav>

<main class="content">
  <output role="status" id="toast"></output>

  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of Erlang System Documentation</span>
            <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
          </label>
          <button type="submit" class="search-button" aria-label="Submit Search">
            <i class="ri-search-2-line ri-lg" aria-hidden="true" title="Submit search"></i>
          </button>
          <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
            <i class="ri-close-line ri-lg" title="Cancel search"></i>
          </button>
        </form>
        <div class="autocomplete">
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <h1>

      <a href="https://github.com/IngelaAndin/otp/blob/ingela/ssl/handle_terminate_alert/OTP-19311/system/doc/programming_examples/funs.md#L1" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>


    <span>Funs</span>
  </h1>

<h2 id="map" class="section-heading">
  <a href="#map" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">map</span>
</h2>
<p>The following function, <code class="inline">double</code>, doubles every element in a list:</p><pre><code class="makeup erlang" translate="no"><span class="nf">double</span><span class="p" data-group-id="8983160783-1">(</span><span class="p" data-group-id="8983160783-2">[</span><span class="n">H</span><span class="p">|</span><span class="n">T</span><span class="p" data-group-id="8983160783-2">]</span><span class="p" data-group-id="8983160783-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="8983160783-3">[</span><span class="mi">2</span><span class="o">*</span><span class="n">H</span><span class="p">|</span><span class="nf">double</span><span class="p" data-group-id="8983160783-4">(</span><span class="n">T</span><span class="p" data-group-id="8983160783-4">)</span><span class="p" data-group-id="8983160783-3">]</span><span class="p">;</span><span class="w">
</span><span class="nf">double</span><span class="p" data-group-id="8983160783-5">(</span><span class="p" data-group-id="8983160783-6">[</span><span class="p" data-group-id="8983160783-6">]</span><span class="p" data-group-id="8983160783-5">)</span><span class="w">    </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="8983160783-7">[</span><span class="p" data-group-id="8983160783-7">]</span><span class="p">.</span></code></pre><p>Hence, the argument entered as input is doubled as follows:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">&gt; </span><span class="nf">double</span><span class="p" data-group-id="2178873405-1">(</span><span class="p" data-group-id="2178873405-2">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="2178873405-2">]</span><span class="p" data-group-id="2178873405-1">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="2178873405-3">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p" data-group-id="2178873405-3">]</span></code></pre><p>The following function, <code class="inline">add_one</code>, adds one to every element in a list:</p><pre><code class="makeup erlang" translate="no"><span class="nf">add_one</span><span class="p" data-group-id="1676675891-1">(</span><span class="p" data-group-id="1676675891-2">[</span><span class="n">H</span><span class="p">|</span><span class="n">T</span><span class="p" data-group-id="1676675891-2">]</span><span class="p" data-group-id="1676675891-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="1676675891-3">[</span><span class="n">H</span><span class="o">+</span><span class="mi">1</span><span class="p">|</span><span class="nf">add_one</span><span class="p" data-group-id="1676675891-4">(</span><span class="n">T</span><span class="p" data-group-id="1676675891-4">)</span><span class="p" data-group-id="1676675891-3">]</span><span class="p">;</span><span class="w">
</span><span class="nf">add_one</span><span class="p" data-group-id="1676675891-5">(</span><span class="p" data-group-id="1676675891-6">[</span><span class="p" data-group-id="1676675891-6">]</span><span class="p" data-group-id="1676675891-5">)</span><span class="w">    </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="1676675891-7">[</span><span class="p" data-group-id="1676675891-7">]</span><span class="p">.</span></code></pre><p>The functions <code class="inline">double</code> and <code class="inline">add_one</code> have a similar structure. This can be used
by writing a function <code class="inline">map</code> that expresses this similarity:</p><pre><code class="makeup erlang" translate="no"><span class="nf">map</span><span class="p" data-group-id="4753990692-1">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4753990692-2">[</span><span class="n">H</span><span class="p">|</span><span class="n">T</span><span class="p" data-group-id="4753990692-2">]</span><span class="p" data-group-id="4753990692-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="4753990692-3">[</span><span class="n">F</span><span class="p" data-group-id="4753990692-4">(</span><span class="n">H</span><span class="p" data-group-id="4753990692-4">)</span><span class="p">|</span><span class="nf">map</span><span class="p" data-group-id="4753990692-5">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p" data-group-id="4753990692-5">)</span><span class="p" data-group-id="4753990692-3">]</span><span class="p">;</span><span class="w">
</span><span class="nf">map</span><span class="p" data-group-id="4753990692-6">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4753990692-7">[</span><span class="p" data-group-id="4753990692-7">]</span><span class="p" data-group-id="4753990692-6">)</span><span class="w">    </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="4753990692-8">[</span><span class="p" data-group-id="4753990692-8">]</span><span class="p">.</span></code></pre><p>The functions <code class="inline">double</code> and <code class="inline">add_one</code> can now be expressed in terms of <code class="inline">map</code> as
follows:</p><pre><code class="makeup erlang" translate="no"><span class="nf">double</span><span class="p" data-group-id="2167938880-1">(</span><span class="n">L</span><span class="p" data-group-id="2167938880-1">)</span><span class="w">  </span><span class="p">-&gt;</span><span class="w"> </span><span class="nf">map</span><span class="p" data-group-id="2167938880-2">(</span><span class="nf">fun</span><span class="p" data-group-id="2167938880-3">(</span><span class="n">X</span><span class="p" data-group-id="2167938880-3">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">X</span><span class="w"> </span><span class="k">end</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p" data-group-id="2167938880-2">)</span><span class="p">.</span><span class="w">
</span><span class="nf">add_one</span><span class="p" data-group-id="2167938880-4">(</span><span class="n">L</span><span class="p" data-group-id="2167938880-4">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nf">map</span><span class="p" data-group-id="2167938880-5">(</span><span class="nf">fun</span><span class="p" data-group-id="2167938880-6">(</span><span class="n">X</span><span class="p" data-group-id="2167938880-6">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="k">end</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p" data-group-id="2167938880-5">)</span><span class="p">.</span></code></pre><p><code class="inline">map(F, List)</code> is a function that takes a function <code class="inline">F</code> and a list <code class="inline">L</code> as
arguments and returns a new list, obtained by applying <code class="inline">F</code> to each of the
elements in <code class="inline">L</code>.</p><p>The process of abstracting out the common features of a number of different
programs is called <em>procedural abstraction</em>. Procedural abstraction can be used
to write several different functions that have a similar structure, but differ
in some minor detail. This is done as follows:</p><ol><li><em>Step 1.</em> Write one function that represents the common features of these
functions.</li><li><em>Step 2.</em> Parameterize the difference in terms of functions that are passed
as arguments to the common function.</li></ol><h2 id="foreach" class="section-heading">
  <a href="#foreach" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">foreach</span>
</h2>
<p>This section illustrates procedural abstraction. Initially, the following two
examples are written as conventional functions.</p><p>This function prints all elements of a list onto a stream:</p><pre><code class="makeup erlang" translate="no"><span class="nf">print_list</span><span class="p" data-group-id="1711896188-1">(</span><span class="n">Stream</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1711896188-2">[</span><span class="n">H</span><span class="p">|</span><span class="n">T</span><span class="p" data-group-id="1711896188-2">]</span><span class="p" data-group-id="1711896188-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="nc">io</span><span class="p">:</span><span class="nf">format</span><span class="p" data-group-id="1711896188-3">(</span><span class="n">Stream</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;</span><span class="si">~p</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1711896188-4">[</span><span class="n">H</span><span class="p" data-group-id="1711896188-4">]</span><span class="p" data-group-id="1711896188-3">)</span><span class="p">,</span><span class="w">
    </span><span class="nf">print_list</span><span class="p" data-group-id="1711896188-5">(</span><span class="n">Stream</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p" data-group-id="1711896188-5">)</span><span class="p">;</span><span class="w">
</span><span class="nf">print_list</span><span class="p" data-group-id="1711896188-6">(</span><span class="n">Stream</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1711896188-7">[</span><span class="p" data-group-id="1711896188-7">]</span><span class="p" data-group-id="1711896188-6">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="ss">true</span><span class="p">.</span></code></pre><p>This function broadcasts a message to a list of processes:</p><pre><code class="makeup erlang" translate="no"><span class="nf">broadcast</span><span class="p" data-group-id="2470560176-1">(</span><span class="n">Msg</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2470560176-2">[</span><span class="n">Pid</span><span class="p">|</span><span class="n">Pids</span><span class="p" data-group-id="2470560176-2">]</span><span class="p" data-group-id="2470560176-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="n">Pid</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="n">Msg</span><span class="p">,</span><span class="w">
    </span><span class="nf">broadcast</span><span class="p" data-group-id="2470560176-3">(</span><span class="n">Msg</span><span class="p">,</span><span class="w"> </span><span class="n">Pids</span><span class="p" data-group-id="2470560176-3">)</span><span class="p">;</span><span class="w">
</span><span class="nf">broadcast</span><span class="p" data-group-id="2470560176-4">(</span><span class="p">_</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2470560176-5">[</span><span class="p" data-group-id="2470560176-5">]</span><span class="p" data-group-id="2470560176-4">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="ss">true</span><span class="p">.</span></code></pre><p>These two functions have a similar structure. They both iterate over a list and
do something to each element in the list. The &quot;something&quot; is passed on as an
extra argument to the function that does this.</p><p>The function <code class="inline">foreach</code> expresses this similarity:</p><pre><code class="makeup erlang" translate="no"><span class="nf">foreach</span><span class="p" data-group-id="0985983002-1">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0985983002-2">[</span><span class="n">H</span><span class="p">|</span><span class="n">T</span><span class="p" data-group-id="0985983002-2">]</span><span class="p" data-group-id="0985983002-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="n">F</span><span class="p" data-group-id="0985983002-3">(</span><span class="n">H</span><span class="p" data-group-id="0985983002-3">)</span><span class="p">,</span><span class="w">
    </span><span class="nf">foreach</span><span class="p" data-group-id="0985983002-4">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p" data-group-id="0985983002-4">)</span><span class="p">;</span><span class="w">
</span><span class="nf">foreach</span><span class="p" data-group-id="0985983002-5">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0985983002-6">[</span><span class="p" data-group-id="0985983002-6">]</span><span class="p" data-group-id="0985983002-5">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="ss">ok</span><span class="p">.</span></code></pre><p>Using the function <code class="inline">foreach</code>, the function <code class="inline">print_list</code> becomes:</p><pre><code class="makeup erlang" translate="no"><span class="nf">foreach</span><span class="p" data-group-id="3392761088-1">(</span><span class="nf">fun</span><span class="p" data-group-id="3392761088-2">(</span><span class="n">H</span><span class="p" data-group-id="3392761088-2">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">io</span><span class="p">:</span><span class="nf">format</span><span class="p" data-group-id="3392761088-3">(</span><span class="n">S</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;</span><span class="si">~p</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">,</span><span class="p" data-group-id="3392761088-4">[</span><span class="n">H</span><span class="p" data-group-id="3392761088-4">]</span><span class="p" data-group-id="3392761088-3">)</span><span class="w"> </span><span class="k">end</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p" data-group-id="3392761088-1">)</span></code></pre><p>Using the function <code class="inline">foreach</code>, the function <code class="inline">broadcast</code> becomes:</p><pre><code class="makeup erlang" translate="no"><span class="nf">foreach</span><span class="p" data-group-id="1978096455-1">(</span><span class="nf">fun</span><span class="p" data-group-id="1978096455-2">(</span><span class="n">Pid</span><span class="p" data-group-id="1978096455-2">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="n">Pid</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="k">end</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p" data-group-id="1978096455-1">)</span></code></pre><p><code class="inline">foreach</code> is evaluated for its side-effect and not its value. <code class="inline">foreach(Fun ,L)</code>
calls <code class="inline">Fun(X)</code> for each element <code class="inline">X</code> in <code class="inline">L</code> and the processing occurs in the
order that the elements were defined in <code class="inline">L</code>. <code class="inline">map</code> does not define the order in
which its elements are processed.</p><h2 id="syntax-of-funs" class="section-heading">
  <a href="#syntax-of-funs" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Syntax of Funs</span>
</h2>
<p>Funs are written with the following syntax (see
<a href="../../doc/system/expressions.html#fun-expressions">Fun Expressions </a>for full description):</p><pre><code class="makeup erlang" translate="no"><span class="n">F</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">fun</span><span class="w"> </span><span class="p" data-group-id="3190179945-1">(</span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="n">Arg2</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="w"> </span><span class="n">ArgN</span><span class="p" data-group-id="3190179945-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="w">
    </span><span class="k">end</span></code></pre><p>This creates an anonymous function of <code class="inline">N</code> arguments and binds it to the variable
<code class="inline">F</code>.</p><p>Another function, <code class="inline">FunctionName</code>, written in the same module, can be passed as
an argument, using the following syntax:</p><pre><code class="makeup erlang" translate="no"><span class="n">F</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">fun</span><span class="w"> </span><span class="n">FunctionName</span><span class="o">/</span><span class="n">Arity</span></code></pre><p>With this form of function reference, the function that is referred to does not
need to be exported from the module.</p><p>It is also possible to refer to a function defined in a different module, with
the following syntax:</p><pre><code class="makeup erlang" translate="no"><span class="n">F</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">fun</span><span class="w"> </span><span class="n">Module</span><span class="p">:</span><span class="n">FunctionName</span><span class="o">/</span><span class="n">Arity</span></code></pre><p>In this case, the function must be exported from the module in question.</p><p>The following program illustrates the different ways of creating funs:</p><pre><code class="makeup erlang" translate="no"><span class="p">-</span><span class="na">module</span><span class="p" data-group-id="1151244103-1">(</span><span class="ss">fun_test</span><span class="p" data-group-id="1151244103-1">)</span><span class="p">.</span><span class="w">
</span><span class="p">-</span><span class="na">export</span><span class="p" data-group-id="1151244103-2">(</span><span class="p" data-group-id="1151244103-3">[</span><span class="ss">t1</span><span class="p">/</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="ss">t2</span><span class="p">/</span><span class="mi">0</span><span class="p" data-group-id="1151244103-3">]</span><span class="p" data-group-id="1151244103-2">)</span><span class="p">.</span><span class="w">
</span><span class="p">-</span><span class="na">import</span><span class="p" data-group-id="1151244103-4">(</span><span class="ss">lists</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1151244103-5">[</span><span class="ss">map</span><span class="p">/</span><span class="mi">2</span><span class="p" data-group-id="1151244103-5">]</span><span class="p" data-group-id="1151244103-4">)</span><span class="p">.</span><span class="w">

</span><span class="nf">t1</span><span class="p" data-group-id="1151244103-6">(</span><span class="p" data-group-id="1151244103-6">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nf">map</span><span class="p" data-group-id="1151244103-7">(</span><span class="nf">fun</span><span class="p" data-group-id="1151244103-8">(</span><span class="n">X</span><span class="p" data-group-id="1151244103-8">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="k">end</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1151244103-9">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="1151244103-9">]</span><span class="p" data-group-id="1151244103-7">)</span><span class="p">.</span><span class="w">

</span><span class="nf">t2</span><span class="p" data-group-id="1151244103-10">(</span><span class="p" data-group-id="1151244103-10">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nf">map</span><span class="p" data-group-id="1151244103-11">(</span><span class="k">fun</span><span class="w"> </span><span class="ss">double</span><span class="p">/</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1151244103-12">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="1151244103-12">]</span><span class="p" data-group-id="1151244103-11">)</span><span class="p">.</span><span class="w">

</span><span class="nf">double</span><span class="p" data-group-id="1151244103-13">(</span><span class="n">X</span><span class="p" data-group-id="1151244103-13">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">.</span></code></pre><p>The fun <code class="inline">F</code> can be evaluated with the following syntax:</p><pre><code class="makeup erlang" translate="no"><span class="n">F</span><span class="p" data-group-id="2862958374-1">(</span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="n">Arg2</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="w"> </span><span class="n">Argn</span><span class="p" data-group-id="2862958374-1">)</span></code></pre><p>To check whether a term is a fun, use the test
<a href="../../erts-15.1.2/doc/html/erlang.html#is_function/1"><code class="inline">is_function/1</code></a> in a guard.</p><p><em>Example:</em></p><pre><code class="makeup erlang" translate="no"><span class="nf">f</span><span class="p" data-group-id="1506489867-1">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p" data-group-id="1506489867-1">)</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="nf">is_function</span><span class="p" data-group-id="1506489867-2">(</span><span class="n">F</span><span class="p" data-group-id="1506489867-2">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
   </span><span class="nf">apply</span><span class="p" data-group-id="1506489867-3">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p" data-group-id="1506489867-3">)</span><span class="p">;</span><span class="w">
</span><span class="nf">f</span><span class="p" data-group-id="1506489867-4">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="p">_</span><span class="p" data-group-id="1506489867-4">)</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="nf">is_integer</span><span class="p" data-group-id="1506489867-5">(</span><span class="n">N</span><span class="p" data-group-id="1506489867-5">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
   </span><span class="n">N</span><span class="p">.</span></code></pre><p>Funs are a distinct type. The BIFs <code class="inline">erlang:fun_info/1,2</code> can be used to retrieve
information about a fun, and the BIF <a href="../../erts-15.1.2/doc/html/erlang.html#fun_to_list/1"><code class="inline">erlang:fun_to_list/1</code></a> returns a textual
representation of a fun. The <a href="../../erts-15.1.2/doc/html/erlang.html#check_process_code/2"><code class="inline">check_process_code/2</code></a>
BIF returns <code class="inline">true</code> if the process contains funs that depend on the old version
of a module.</p><h2 id="variable-bindings-within-a-fun" class="section-heading">
  <a href="#variable-bindings-within-a-fun" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Variable Bindings Within a Fun</span>
</h2>
<p>The scope rules for variables that occur in funs are as follows:</p><ul><li>All variables that occur in the head of a fun are assumed to be &quot;fresh&quot;
variables.</li><li>Variables that are defined before the fun, and that occur in function calls or
guard tests within the fun, have the values they had outside the fun.</li><li>Variables cannot be exported from a fun.</li></ul><p>The following examples illustrate these rules:</p><pre><code class="makeup erlang" translate="no"><span class="nf">print_list</span><span class="p" data-group-id="7743131396-1">(</span><span class="n">File</span><span class="p">,</span><span class="w"> </span><span class="n">List</span><span class="p" data-group-id="7743131396-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="p" data-group-id="7743131396-2">{</span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="n">Stream</span><span class="p" data-group-id="7743131396-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">file</span><span class="p">:</span><span class="nf">open</span><span class="p" data-group-id="7743131396-3">(</span><span class="n">File</span><span class="p">,</span><span class="w"> </span><span class="ss">write</span><span class="p" data-group-id="7743131396-3">)</span><span class="p">,</span><span class="w">
    </span><span class="nf">foreach</span><span class="p" data-group-id="7743131396-4">(</span><span class="nf">fun</span><span class="p" data-group-id="7743131396-5">(</span><span class="n">X</span><span class="p" data-group-id="7743131396-5">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">io</span><span class="p">:</span><span class="nf">format</span><span class="p" data-group-id="7743131396-6">(</span><span class="n">Stream</span><span class="p">,</span><span class="s">&quot;</span><span class="si">~p</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">,</span><span class="p" data-group-id="7743131396-7">[</span><span class="n">X</span><span class="p" data-group-id="7743131396-7">]</span><span class="p" data-group-id="7743131396-6">)</span><span class="w"> </span><span class="k">end</span><span class="p">,</span><span class="w"> </span><span class="n">List</span><span class="p" data-group-id="7743131396-4">)</span><span class="p">,</span><span class="w">
    </span><span class="nc">file</span><span class="p">:</span><span class="nf">close</span><span class="p" data-group-id="7743131396-8">(</span><span class="n">Stream</span><span class="p" data-group-id="7743131396-8">)</span><span class="p">.</span></code></pre><p>Here, the variable <code class="inline">X</code>, defined in the head of the fun, is a new variable. The
variable <code class="inline">Stream</code>, which is used within the fun, gets its value from the
<code class="inline">file:open</code> line.</p><p>As any variable that occurs in the head of a fun is considered a new variable,
it is equally valid to write as follows:</p><pre><code class="makeup erlang" translate="no"><span class="nf">print_list</span><span class="p" data-group-id="1360881536-1">(</span><span class="n">File</span><span class="p">,</span><span class="w"> </span><span class="n">List</span><span class="p" data-group-id="1360881536-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="p" data-group-id="1360881536-2">{</span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="n">Stream</span><span class="p" data-group-id="1360881536-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">file</span><span class="p">:</span><span class="nf">open</span><span class="p" data-group-id="1360881536-3">(</span><span class="n">File</span><span class="p">,</span><span class="w"> </span><span class="ss">write</span><span class="p" data-group-id="1360881536-3">)</span><span class="p">,</span><span class="w">
    </span><span class="nf">foreach</span><span class="p" data-group-id="1360881536-4">(</span><span class="nf">fun</span><span class="p" data-group-id="1360881536-5">(</span><span class="n">File</span><span class="p" data-group-id="1360881536-5">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
                </span><span class="nc">io</span><span class="p">:</span><span class="nf">format</span><span class="p" data-group-id="1360881536-6">(</span><span class="n">Stream</span><span class="p">,</span><span class="s">&quot;</span><span class="si">~p</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">,</span><span class="p" data-group-id="1360881536-7">[</span><span class="n">File</span><span class="p" data-group-id="1360881536-7">]</span><span class="p" data-group-id="1360881536-6">)</span><span class="w">
            </span><span class="k">end</span><span class="p">,</span><span class="w"> </span><span class="n">List</span><span class="p" data-group-id="1360881536-4">)</span><span class="p">,</span><span class="w">
    </span><span class="nc">file</span><span class="p">:</span><span class="nf">close</span><span class="p" data-group-id="1360881536-8">(</span><span class="n">Stream</span><span class="p" data-group-id="1360881536-8">)</span><span class="p">.</span></code></pre><p>Here, <code class="inline">File</code> is used as the new variable instead of <code class="inline">X</code>. This is not so wise
because code in the fun body cannot refer to the variable <code class="inline">File</code>, which is
defined outside of the fun. Compiling this example gives the following
diagnostic:</p><pre><code class="text">./FileName.erl:Line: Warning: variable 'File'
      shadowed in 'fun'</code></pre><p>This indicates that the variable <code class="inline">File</code>, which is defined inside the fun,
collides with the variable <code class="inline">File</code>, which is defined outside the fun.</p><p>The rules for importing variables into a fun has the consequence that certain
pattern matching operations must be moved into guard expressions and cannot be
written in the head of the fun. For example, you might write the following code
if you intend the first clause of <code class="inline">F</code> to be evaluated when the value of its
argument is <code class="inline">Y</code>:</p><pre><code class="makeup erlang" translate="no"><span class="nf">f</span><span class="p" data-group-id="1954822178-1">(</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p" data-group-id="1954822178-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="n">Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="w">
    </span><span class="nf">map</span><span class="p" data-group-id="1954822178-2">(</span><span class="nf">fun</span><span class="p" data-group-id="1954822178-3">(</span><span class="n">X</span><span class="p" data-group-id="1954822178-3">)</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
             </span><span class="p">;</span><span class="w">
           </span><span class="p" data-group-id="1954822178-4">(</span><span class="p">_</span><span class="p" data-group-id="1954822178-4">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
             </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="w">
        </span><span class="k">end</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p" data-group-id="1954822178-2">)</span><span class="w">
    </span><span class="p">.</span><span class="p">.</span><span class="p">.</span></code></pre><p>instead of writing the following code:</p><pre><code class="makeup erlang" translate="no"><span class="nf">f</span><span class="p" data-group-id="9785011751-1">(</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p" data-group-id="9785011751-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="n">Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="w">
    </span><span class="nf">map</span><span class="p" data-group-id="9785011751-2">(</span><span class="nf">fun</span><span class="p" data-group-id="9785011751-3">(</span><span class="n">Y</span><span class="p" data-group-id="9785011751-3">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
             </span><span class="p">;</span><span class="w">
           </span><span class="p" data-group-id="9785011751-4">(</span><span class="p">_</span><span class="p" data-group-id="9785011751-4">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
             </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="w">
        </span><span class="k">end</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p" data-group-id="9785011751-2">)</span><span class="w">
    </span><span class="p">.</span><span class="p">.</span><span class="p">.</span></code></pre><h2 id="funs-and-module-lists" class="section-heading">
  <a href="#funs-and-module-lists" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Funs and Module Lists</span>
</h2>
<p>The following examples show a dialogue with the Erlang shell. All the higher
order functions discussed are exported from the module <a href="../../lib/stdlib-6.1.2/doc/html/lists.html"><code class="inline">lists</code></a>.</p><h3 id="map-1" class="section-heading">
  <a href="#map-1" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">map</span>
</h3>
<p><a href="../../lib/stdlib-6.1.2/doc/html/lists.html#map/2"><code class="inline">lists:map/2</code></a> takes a function of one argument and a list of terms:</p><pre><code class="makeup erlang" translate="no"><span class="nf">map</span><span class="p" data-group-id="5005920735-1">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5005920735-2">[</span><span class="n">H</span><span class="p">|</span><span class="n">T</span><span class="p" data-group-id="5005920735-2">]</span><span class="p" data-group-id="5005920735-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="5005920735-3">[</span><span class="n">F</span><span class="p" data-group-id="5005920735-4">(</span><span class="n">H</span><span class="p" data-group-id="5005920735-4">)</span><span class="p">|</span><span class="nf">map</span><span class="p" data-group-id="5005920735-5">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p" data-group-id="5005920735-5">)</span><span class="p" data-group-id="5005920735-3">]</span><span class="p">;</span><span class="w">
</span><span class="nf">map</span><span class="p" data-group-id="5005920735-6">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5005920735-7">[</span><span class="p" data-group-id="5005920735-7">]</span><span class="p" data-group-id="5005920735-6">)</span><span class="w">    </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="5005920735-8">[</span><span class="p" data-group-id="5005920735-8">]</span><span class="p">.</span></code></pre><p>It returns the list obtained by applying the function to every argument in the
list.</p><p>When a new fun is defined in the shell, the value of the fun is printed as
<code class="inline">Fun#&lt;erl_eval&gt;</code>:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">&gt; </span><span class="n">Double</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">fun</span><span class="p" data-group-id="6274422903-1">(</span><span class="n">X</span><span class="p" data-group-id="6274422903-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="k">end</span><span class="p">.</span><span class="w">
</span><span class="p">#</span><span class="n">Fun</span><span class="o">&lt;</span><span class="ss">erl_eval</span><span class="p">.</span><span class="mf">6.72228031</span><span class="o">&gt;</span><span class="gp unselectable">
&gt; </span><span class="nc">lists</span><span class="p">:</span><span class="nf">map</span><span class="p" data-group-id="6274422903-2">(</span><span class="n">Double</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6274422903-3">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="6274422903-3">]</span><span class="p" data-group-id="6274422903-2">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="6274422903-4">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p" data-group-id="6274422903-4">]</span></code></pre><h3 id="any" class="section-heading">
  <a href="#any" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">any</span>
</h3>
<p><a href="../../lib/stdlib-6.1.2/doc/html/lists.html#any/2"><code class="inline">lists:any/2</code></a> takes a predicate <code class="inline">P</code> of one argument and a list of terms:</p><pre><code class="makeup erlang" translate="no"><span class="nf">any</span><span class="p" data-group-id="7474559165-1">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7474559165-2">[</span><span class="n">H</span><span class="p">|</span><span class="n">T</span><span class="p" data-group-id="7474559165-2">]</span><span class="p" data-group-id="7474559165-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="n">Pred</span><span class="p" data-group-id="7474559165-3">(</span><span class="n">H</span><span class="p" data-group-id="7474559165-3">)</span><span class="w"> </span><span class="k">of</span><span class="w">
        </span><span class="ss">true</span><span class="w">  </span><span class="p">-&gt;</span><span class="w">  </span><span class="ss">true</span><span class="p">;</span><span class="w">
        </span><span class="ss">false</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">  </span><span class="nf">any</span><span class="p" data-group-id="7474559165-4">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p" data-group-id="7474559165-4">)</span><span class="w">
    </span><span class="k">end</span><span class="p">;</span><span class="w">
</span><span class="nf">any</span><span class="p" data-group-id="7474559165-5">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7474559165-6">[</span><span class="p" data-group-id="7474559165-6">]</span><span class="p" data-group-id="7474559165-5">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="ss">false</span><span class="p">.</span></code></pre><p>A predicate is a function that returns <code class="inline">true</code> or <code class="inline">false</code>. <code class="inline">any</code> is <code class="inline">true</code> if
there is a term <code class="inline">X</code> in the list such that <code class="inline">P(X)</code> is <code class="inline">true</code>.</p><p>A predicate <code class="inline">Big(X)</code> is defined, which is <code class="inline">true</code> if its argument is greater that
10:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">&gt; </span><span class="n">Big</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="nf">fun</span><span class="p" data-group-id="8623247581-1">(</span><span class="n">X</span><span class="p" data-group-id="8623247581-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="ss">true</span><span class="p">;</span><span class="w"> </span><span class="ss">true</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="ss">false</span><span class="w"> </span><span class="k">end</span><span class="w"> </span><span class="k">end</span><span class="p">.</span><span class="w">
</span><span class="p">#</span><span class="n">Fun</span><span class="o">&lt;</span><span class="ss">erl_eval</span><span class="p">.</span><span class="mf">6.72228031</span><span class="o">&gt;</span><span class="gp unselectable">
&gt; </span><span class="nc">lists</span><span class="p">:</span><span class="nf">any</span><span class="p" data-group-id="8623247581-2">(</span><span class="n">Big</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8623247581-3">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="8623247581-3">]</span><span class="p" data-group-id="8623247581-2">)</span><span class="p">.</span><span class="w">
</span><span class="ss">false</span><span class="gp unselectable">
&gt; </span><span class="nc">lists</span><span class="p">:</span><span class="nf">any</span><span class="p" data-group-id="8623247581-4">(</span><span class="n">Big</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8623247581-5">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="8623247581-5">]</span><span class="p" data-group-id="8623247581-4">)</span><span class="p">.</span><span class="w">
</span><span class="ss">true</span></code></pre><h3 id="all" class="section-heading">
  <a href="#all" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">all</span>
</h3>
<p><a href="../../lib/stdlib-6.1.2/doc/html/lists.html#all/2"><code class="inline">lists:all/2</code></a> has the same arguments as <code class="inline">any</code>:</p><pre><code class="makeup erlang" translate="no"><span class="nf">all</span><span class="p" data-group-id="0834250083-1">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0834250083-2">[</span><span class="n">H</span><span class="p">|</span><span class="n">T</span><span class="p" data-group-id="0834250083-2">]</span><span class="p" data-group-id="0834250083-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="n">Pred</span><span class="p" data-group-id="0834250083-3">(</span><span class="n">H</span><span class="p" data-group-id="0834250083-3">)</span><span class="w"> </span><span class="k">of</span><span class="w">
        </span><span class="ss">true</span><span class="w">  </span><span class="p">-&gt;</span><span class="w">  </span><span class="nf">all</span><span class="p" data-group-id="0834250083-4">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p" data-group-id="0834250083-4">)</span><span class="p">;</span><span class="w">
        </span><span class="ss">false</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">  </span><span class="ss">false</span><span class="w">
    </span><span class="k">end</span><span class="p">;</span><span class="w">
</span><span class="nf">all</span><span class="p" data-group-id="0834250083-5">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0834250083-6">[</span><span class="p" data-group-id="0834250083-6">]</span><span class="p" data-group-id="0834250083-5">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="ss">true</span><span class="p">.</span></code></pre><p>It is <code class="inline">true</code> if the predicate applied to all elements in the list is <code class="inline">true</code>.</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">&gt; </span><span class="nc">lists</span><span class="p">:</span><span class="nf">all</span><span class="p" data-group-id="9055910221-1">(</span><span class="n">Big</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9055910221-2">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">6</span><span class="p" data-group-id="9055910221-2">]</span><span class="p" data-group-id="9055910221-1">)</span><span class="p">.</span><span class="w">
</span><span class="ss">false</span><span class="gp unselectable">
&gt; </span><span class="nc">lists</span><span class="p">:</span><span class="nf">all</span><span class="p" data-group-id="9055910221-3">(</span><span class="n">Big</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9055910221-4">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p" data-group-id="9055910221-4">]</span><span class="p" data-group-id="9055910221-3">)</span><span class="p">.</span><span class="w">
</span><span class="ss">true</span></code></pre><h3 id="foreach-1" class="section-heading">
  <a href="#foreach-1" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">foreach</span>
</h3>
<p><a href="../../lib/stdlib-6.1.2/doc/html/lists.html#foreach/2"><code class="inline">lists:foreach/2</code></a> takes a function of one argument and a list of terms:</p><pre><code class="makeup erlang" translate="no"><span class="nf">foreach</span><span class="p" data-group-id="2491265949-1">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2491265949-2">[</span><span class="n">H</span><span class="p">|</span><span class="n">T</span><span class="p" data-group-id="2491265949-2">]</span><span class="p" data-group-id="2491265949-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="n">F</span><span class="p" data-group-id="2491265949-3">(</span><span class="n">H</span><span class="p" data-group-id="2491265949-3">)</span><span class="p">,</span><span class="w">
    </span><span class="nf">foreach</span><span class="p" data-group-id="2491265949-4">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p" data-group-id="2491265949-4">)</span><span class="p">;</span><span class="w">
</span><span class="nf">foreach</span><span class="p" data-group-id="2491265949-5">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2491265949-6">[</span><span class="p" data-group-id="2491265949-6">]</span><span class="p" data-group-id="2491265949-5">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="ss">ok</span><span class="p">.</span></code></pre><p>The function is applied to each argument in the list. <code class="inline">foreach</code> returns <code class="inline">ok</code>. It
is only used for its side-effect:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">&gt; </span><span class="nc">lists</span><span class="p">:</span><span class="nf">foreach</span><span class="p" data-group-id="3280504408-1">(</span><span class="nf">fun</span><span class="p" data-group-id="3280504408-2">(</span><span class="n">X</span><span class="p" data-group-id="3280504408-2">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">io</span><span class="p">:</span><span class="nf">format</span><span class="p" data-group-id="3280504408-3">(</span><span class="s">&quot;</span><span class="si">~w</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">,</span><span class="p" data-group-id="3280504408-4">[</span><span class="n">X</span><span class="p" data-group-id="3280504408-4">]</span><span class="p" data-group-id="3280504408-3">)</span><span class="w"> </span><span class="k">end</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3280504408-5">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="3280504408-5">]</span><span class="p" data-group-id="3280504408-1">)</span><span class="p">.</span><span class="w">
</span><span class="mi">1</span><span class="w">
</span><span class="mi">2</span><span class="w">
</span><span class="mi">3</span><span class="w">
</span><span class="mi">4</span><span class="w">
</span><span class="ss">ok</span></code></pre><h3 id="foldl" class="section-heading">
  <a href="#foldl" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">foldl</span>
</h3>
<p><a href="../../lib/stdlib-6.1.2/doc/html/lists.html#foldl/3"><code class="inline">lists:foldl/3</code></a> takes a function of two arguments, an accumulator and a list:</p><pre><code class="makeup erlang" translate="no"><span class="nf">foldl</span><span class="p" data-group-id="0079123088-1">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">Accu</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0079123088-2">[</span><span class="n">Hd</span><span class="p">|</span><span class="n">Tail</span><span class="p" data-group-id="0079123088-2">]</span><span class="p" data-group-id="0079123088-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="nf">foldl</span><span class="p" data-group-id="0079123088-3">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p" data-group-id="0079123088-4">(</span><span class="n">Hd</span><span class="p">,</span><span class="w"> </span><span class="n">Accu</span><span class="p" data-group-id="0079123088-4">)</span><span class="p">,</span><span class="w"> </span><span class="n">Tail</span><span class="p" data-group-id="0079123088-3">)</span><span class="p">;</span><span class="w">
</span><span class="nf">foldl</span><span class="p" data-group-id="0079123088-5">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">Accu</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0079123088-6">[</span><span class="p" data-group-id="0079123088-6">]</span><span class="p" data-group-id="0079123088-5">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="n">Accu</span><span class="p">.</span></code></pre><p>The function is called with two arguments. The first argument is the successive
elements in the list. The second argument is the accumulator. The function must
return a new accumulator, which is used the next time the function is called.</p><p>If you have a list of lists <code class="inline">L = [&quot;I&quot;,&quot;like&quot;,&quot;Erlang&quot;]</code>, then you can sum the
lengths of all the strings in <code class="inline">L</code> as follows:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">&gt; </span><span class="n">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="3510192586-1">[</span><span class="s">&quot;I&quot;</span><span class="p">,</span><span class="s">&quot;like&quot;</span><span class="p">,</span><span class="s">&quot;Erlang&quot;</span><span class="p" data-group-id="3510192586-1">]</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="3510192586-2">[</span><span class="s">&quot;I&quot;</span><span class="p">,</span><span class="s">&quot;like&quot;</span><span class="p">,</span><span class="s">&quot;Erlang&quot;</span><span class="p" data-group-id="3510192586-2">]</span><span class="gp unselectable">
10&gt; </span><span class="nc">lists</span><span class="p">:</span><span class="nf">foldl</span><span class="p" data-group-id="3510192586-3">(</span><span class="nf">fun</span><span class="p" data-group-id="3510192586-4">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">Sum</span><span class="p" data-group-id="3510192586-4">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nf">length</span><span class="p" data-group-id="3510192586-5">(</span><span class="n">X</span><span class="p" data-group-id="3510192586-5">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Sum</span><span class="w"> </span><span class="k">end</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p" data-group-id="3510192586-3">)</span><span class="p">.</span><span class="w">
</span><span class="mi">11</span></code></pre><p><a href="../../lib/stdlib-6.1.2/doc/html/lists.html#foldl/3"><code class="inline">lists:foldl/3</code></a> works like a <code class="inline">while</code> loop in an imperative language:</p><pre><code class="makeup erlang" translate="no"><span class="n">L</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="p" data-group-id="0251978037-1">[</span><span class="s">&quot;I&quot;</span><span class="p">,</span><span class="s">&quot;like&quot;</span><span class="p">,</span><span class="s">&quot;Erlang&quot;</span><span class="p" data-group-id="0251978037-1">]</span><span class="p">,</span><span class="w">
</span><span class="n">Sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="nf">while</span><span class="p" data-group-id="0251978037-2">(</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">!</span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="0251978037-3">[</span><span class="p" data-group-id="0251978037-3">]</span><span class="p" data-group-id="0251978037-2">)</span><span class="p" data-group-id="0251978037-4">{</span><span class="w">
    </span><span class="n">Sum</span><span class="w"> </span><span class="o">+</span><span class="o">=</span><span class="w"> </span><span class="nf">length</span><span class="p" data-group-id="0251978037-5">(</span><span class="nf">head</span><span class="p" data-group-id="0251978037-6">(</span><span class="n">L</span><span class="p" data-group-id="0251978037-6">)</span><span class="p" data-group-id="0251978037-5">)</span><span class="p">,</span><span class="w">
    </span><span class="n">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">tail</span><span class="p" data-group-id="0251978037-7">(</span><span class="n">L</span><span class="p" data-group-id="0251978037-7">)</span><span class="w">
</span><span class="k">end</span></code></pre><h3 id="mapfoldl" class="section-heading">
  <a href="#mapfoldl" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">mapfoldl</span>
</h3>
<p><a href="../../lib/stdlib-6.1.2/doc/html/lists.html#mapfoldl/3"><code class="inline">lists:mapfoldl/3</code></a> simultaneously maps and folds over a list:</p><pre><code class="makeup erlang" translate="no"><span class="nf">mapfoldl</span><span class="p" data-group-id="6401459312-1">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">Accu0</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6401459312-2">[</span><span class="n">Hd</span><span class="p">|</span><span class="n">Tail</span><span class="p" data-group-id="6401459312-2">]</span><span class="p" data-group-id="6401459312-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="p" data-group-id="6401459312-3">{</span><span class="n">R</span><span class="p">,</span><span class="n">Accu1</span><span class="p" data-group-id="6401459312-3">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">F</span><span class="p" data-group-id="6401459312-4">(</span><span class="n">Hd</span><span class="p">,</span><span class="w"> </span><span class="n">Accu0</span><span class="p" data-group-id="6401459312-4">)</span><span class="p">,</span><span class="w">
    </span><span class="p" data-group-id="6401459312-5">{</span><span class="n">Rs</span><span class="p">,</span><span class="n">Accu2</span><span class="p" data-group-id="6401459312-5">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">mapfoldl</span><span class="p" data-group-id="6401459312-6">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">Accu1</span><span class="p">,</span><span class="w"> </span><span class="n">Tail</span><span class="p" data-group-id="6401459312-6">)</span><span class="p">,</span><span class="w">
    </span><span class="p" data-group-id="6401459312-7">{</span><span class="p" data-group-id="6401459312-8">[</span><span class="n">R</span><span class="p">|</span><span class="n">Rs</span><span class="p" data-group-id="6401459312-8">]</span><span class="p">,</span><span class="w"> </span><span class="n">Accu2</span><span class="p" data-group-id="6401459312-7">}</span><span class="p">;</span><span class="w">
</span><span class="nf">mapfoldl</span><span class="p" data-group-id="6401459312-9">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">Accu</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6401459312-10">[</span><span class="p" data-group-id="6401459312-10">]</span><span class="p" data-group-id="6401459312-9">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="6401459312-11">{</span><span class="p" data-group-id="6401459312-12">[</span><span class="p" data-group-id="6401459312-12">]</span><span class="p">,</span><span class="w"> </span><span class="n">Accu</span><span class="p" data-group-id="6401459312-11">}</span><span class="p">.</span></code></pre><p>The following example shows how to change all letters in <code class="inline">L</code> to upper case and
then count them.</p><p>First the change to upper case:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">&gt; </span><span class="n">Upcase</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="nf">fun</span><span class="p" data-group-id="6023975173-1">(</span><span class="n">X</span><span class="p" data-group-id="6023975173-1">)</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="sc">$a</span><span class="w"> </span><span class="o">=&lt;</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w">  </span><span class="n">X</span><span class="w"> </span><span class="o">=&lt;</span><span class="w"> </span><span class="sc">$z</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="sc">$A</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="sc">$a</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="6023975173-2">(</span><span class="n">X</span><span class="p" data-group-id="6023975173-2">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="n">X</span><span class="w">
</span><span class="k">end</span><span class="p">.</span><span class="w">
</span><span class="p">#</span><span class="n">Fun</span><span class="o">&lt;</span><span class="ss">erl_eval</span><span class="p">.</span><span class="mf">6.72228031</span><span class="o">&gt;</span><span class="gp unselectable">
&gt; </span><span class="n">Upcase_word</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="nf">fun</span><span class="p" data-group-id="6023975173-3">(</span><span class="n">X</span><span class="p" data-group-id="6023975173-3">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
</span><span class="nc">lists</span><span class="p">:</span><span class="nf">map</span><span class="p" data-group-id="6023975173-4">(</span><span class="n">Upcase</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p" data-group-id="6023975173-4">)</span><span class="w">
</span><span class="k">end</span><span class="p">.</span><span class="w">
</span><span class="p">#</span><span class="n">Fun</span><span class="o">&lt;</span><span class="ss">erl_eval</span><span class="p">.</span><span class="mf">6.72228031</span><span class="o">&gt;</span><span class="gp unselectable">
&gt; </span><span class="n">Upcase_word</span><span class="p" data-group-id="6023975173-5">(</span><span class="s">&quot;Erlang&quot;</span><span class="p" data-group-id="6023975173-5">)</span><span class="p">.</span><span class="w">
</span><span class="s">&quot;ERLANG&quot;</span><span class="gp unselectable">
&gt; </span><span class="nc">lists</span><span class="p">:</span><span class="nf">map</span><span class="p" data-group-id="6023975173-6">(</span><span class="n">Upcase_word</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p" data-group-id="6023975173-6">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="6023975173-7">[</span><span class="s">&quot;I&quot;</span><span class="p">,</span><span class="s">&quot;LIKE&quot;</span><span class="p">,</span><span class="s">&quot;ERLANG&quot;</span><span class="p" data-group-id="6023975173-7">]</span></code></pre><p>Now, the fold and the map can be done at the same time:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">&gt; </span><span class="nc">lists</span><span class="p">:</span><span class="nf">mapfoldl</span><span class="p" data-group-id="9508967441-1">(</span><span class="nf">fun</span><span class="p" data-group-id="9508967441-2">(</span><span class="n">Word</span><span class="p">,</span><span class="w"> </span><span class="n">Sum</span><span class="p" data-group-id="9508967441-2">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
</span><span class="p" data-group-id="9508967441-3">{</span><span class="n">Upcase_word</span><span class="p" data-group-id="9508967441-4">(</span><span class="n">Word</span><span class="p" data-group-id="9508967441-4">)</span><span class="p">,</span><span class="w"> </span><span class="n">Sum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nf">length</span><span class="p" data-group-id="9508967441-5">(</span><span class="n">Word</span><span class="p" data-group-id="9508967441-5">)</span><span class="p" data-group-id="9508967441-3">}</span><span class="w">
</span><span class="k">end</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p" data-group-id="9508967441-1">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="9508967441-6">{</span><span class="p" data-group-id="9508967441-7">[</span><span class="s">&quot;I&quot;</span><span class="p">,</span><span class="s">&quot;LIKE&quot;</span><span class="p">,</span><span class="s">&quot;ERLANG&quot;</span><span class="p" data-group-id="9508967441-7">]</span><span class="p">,</span><span class="mi">11</span><span class="p" data-group-id="9508967441-6">}</span></code></pre><h3 id="filter" class="section-heading">
  <a href="#filter" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">filter</span>
</h3>
<p><a href="../../lib/stdlib-6.1.2/doc/html/lists.html#filter/2"><code class="inline">lists:filter/2</code></a> takes a predicate of one argument and a list and returns all elements
in the list that satisfy the predicate:</p><pre><code class="makeup erlang" translate="no"><span class="nf">filter</span><span class="p" data-group-id="3685655773-1">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3685655773-2">[</span><span class="n">H</span><span class="p">|</span><span class="n">T</span><span class="p" data-group-id="3685655773-2">]</span><span class="p" data-group-id="3685655773-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="n">F</span><span class="p" data-group-id="3685655773-3">(</span><span class="n">H</span><span class="p" data-group-id="3685655773-3">)</span><span class="w"> </span><span class="k">of</span><span class="w">
        </span><span class="ss">true</span><span class="w">  </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="3685655773-4">[</span><span class="n">H</span><span class="p">|</span><span class="nf">filter</span><span class="p" data-group-id="3685655773-5">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p" data-group-id="3685655773-5">)</span><span class="p" data-group-id="3685655773-4">]</span><span class="p">;</span><span class="w">
        </span><span class="ss">false</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nf">filter</span><span class="p" data-group-id="3685655773-6">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p" data-group-id="3685655773-6">)</span><span class="w">
    </span><span class="k">end</span><span class="p">;</span><span class="w">
</span><span class="nf">filter</span><span class="p" data-group-id="3685655773-7">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3685655773-8">[</span><span class="p" data-group-id="3685655773-8">]</span><span class="p" data-group-id="3685655773-7">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="3685655773-9">[</span><span class="p" data-group-id="3685655773-9">]</span><span class="p">.</span></code></pre><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">&gt; </span><span class="nc">lists</span><span class="p">:</span><span class="nf">filter</span><span class="p" data-group-id="4506263497-1">(</span><span class="n">Big</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4506263497-2">[</span><span class="mi">500</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p" data-group-id="4506263497-2">]</span><span class="p" data-group-id="4506263497-1">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="4506263497-3">[</span><span class="mi">500</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">45</span><span class="p" data-group-id="4506263497-3">]</span></code></pre><p>Combining maps and filters enables writing of very succinct code. For example,
to define a set difference function <code class="inline">diff(L1, L2)</code> to be the difference between
the lists <code class="inline">L1</code> and <code class="inline">L2</code>, the code can be written as follows:</p><pre><code class="makeup erlang" translate="no"><span class="nf">diff</span><span class="p" data-group-id="5542926597-1">(</span><span class="n">L1</span><span class="p">,</span><span class="w"> </span><span class="n">L2</span><span class="p" data-group-id="5542926597-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="nf">filter</span><span class="p" data-group-id="5542926597-2">(</span><span class="nf">fun</span><span class="p" data-group-id="5542926597-3">(</span><span class="n">X</span><span class="p" data-group-id="5542926597-3">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="nf">member</span><span class="p" data-group-id="5542926597-4">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">L2</span><span class="p" data-group-id="5542926597-4">)</span><span class="w"> </span><span class="k">end</span><span class="p">,</span><span class="w"> </span><span class="n">L1</span><span class="p" data-group-id="5542926597-2">)</span><span class="p">.</span></code></pre><p>This gives the list of all elements in L1 that are not contained in L2.</p><p>The AND intersection of the list <code class="inline">L1</code> and <code class="inline">L2</code> is also easily defined:</p><pre><code class="makeup erlang" translate="no"><span class="nf">intersection</span><span class="p" data-group-id="4162076075-1">(</span><span class="n">L1</span><span class="p">,</span><span class="n">L2</span><span class="p" data-group-id="4162076075-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nf">filter</span><span class="p" data-group-id="4162076075-2">(</span><span class="nf">fun</span><span class="p" data-group-id="4162076075-3">(</span><span class="n">X</span><span class="p" data-group-id="4162076075-3">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nf">member</span><span class="p" data-group-id="4162076075-4">(</span><span class="n">X</span><span class="p">,</span><span class="n">L1</span><span class="p" data-group-id="4162076075-4">)</span><span class="w"> </span><span class="k">end</span><span class="p">,</span><span class="w"> </span><span class="n">L2</span><span class="p" data-group-id="4162076075-2">)</span><span class="p">.</span></code></pre><h3 id="takewhile" class="section-heading">
  <a href="#takewhile" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">takewhile</span>
</h3>
<p><a href="../../lib/stdlib-6.1.2/doc/html/lists.html#takewhile/2"><code class="inline">lists:takewhile/2</code></a> takes elements <code class="inline">X</code> from a list <code class="inline">L</code> as long as the predicate
<code class="inline">P(X)</code> is true:</p><pre><code class="makeup erlang" translate="no"><span class="nf">takewhile</span><span class="p" data-group-id="1277850181-1">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1277850181-2">[</span><span class="n">H</span><span class="p">|</span><span class="n">T</span><span class="p" data-group-id="1277850181-2">]</span><span class="p" data-group-id="1277850181-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="n">Pred</span><span class="p" data-group-id="1277850181-3">(</span><span class="n">H</span><span class="p" data-group-id="1277850181-3">)</span><span class="w"> </span><span class="k">of</span><span class="w">
        </span><span class="ss">true</span><span class="w">  </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="1277850181-4">[</span><span class="n">H</span><span class="p">|</span><span class="nf">takewhile</span><span class="p" data-group-id="1277850181-5">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p" data-group-id="1277850181-5">)</span><span class="p" data-group-id="1277850181-4">]</span><span class="p">;</span><span class="w">
        </span><span class="ss">false</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="1277850181-6">[</span><span class="p" data-group-id="1277850181-6">]</span><span class="w">
    </span><span class="k">end</span><span class="p">;</span><span class="w">
</span><span class="nf">takewhile</span><span class="p" data-group-id="1277850181-7">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1277850181-8">[</span><span class="p" data-group-id="1277850181-8">]</span><span class="p" data-group-id="1277850181-7">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="p" data-group-id="1277850181-9">[</span><span class="p" data-group-id="1277850181-9">]</span><span class="p">.</span></code></pre><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">&gt; </span><span class="nc">lists</span><span class="p">:</span><span class="nf">takewhile</span><span class="p" data-group-id="4562680510-1">(</span><span class="n">Big</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4562680510-2">[</span><span class="mi">200</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">6</span><span class="p" data-group-id="4562680510-2">]</span><span class="p" data-group-id="4562680510-1">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="4562680510-3">[</span><span class="mi">200</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span><span class="mi">45</span><span class="p" data-group-id="4562680510-3">]</span></code></pre><h3 id="dropwhile" class="section-heading">
  <a href="#dropwhile" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">dropwhile</span>
</h3>
<p><a href="../../lib/stdlib-6.1.2/doc/html/lists.html#dropwhile/2"><code class="inline">lists:dropwhile/2</code></a> is the complement of <code class="inline">takewhile</code>:</p><pre><code class="makeup erlang" translate="no"><span class="nf">dropwhile</span><span class="p" data-group-id="4610506305-1">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4610506305-2">[</span><span class="n">H</span><span class="p">|</span><span class="n">T</span><span class="p" data-group-id="4610506305-2">]</span><span class="p" data-group-id="4610506305-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="n">Pred</span><span class="p" data-group-id="4610506305-3">(</span><span class="n">H</span><span class="p" data-group-id="4610506305-3">)</span><span class="w"> </span><span class="k">of</span><span class="w">
        </span><span class="ss">true</span><span class="w">  </span><span class="p">-&gt;</span><span class="w"> </span><span class="nf">dropwhile</span><span class="p" data-group-id="4610506305-4">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p" data-group-id="4610506305-4">)</span><span class="p">;</span><span class="w">
        </span><span class="ss">false</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="4610506305-5">[</span><span class="n">H</span><span class="p">|</span><span class="n">T</span><span class="p" data-group-id="4610506305-5">]</span><span class="w">
    </span><span class="k">end</span><span class="p">;</span><span class="w">
</span><span class="nf">dropwhile</span><span class="p" data-group-id="4610506305-6">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4610506305-7">[</span><span class="p" data-group-id="4610506305-7">]</span><span class="p" data-group-id="4610506305-6">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="p" data-group-id="4610506305-8">[</span><span class="p" data-group-id="4610506305-8">]</span><span class="p">.</span></code></pre><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">&gt; </span><span class="nc">lists</span><span class="p">:</span><span class="nf">dropwhile</span><span class="p" data-group-id="3569742157-1">(</span><span class="n">Big</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3569742157-2">[</span><span class="mi">200</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">6</span><span class="p" data-group-id="3569742157-2">]</span><span class="p" data-group-id="3569742157-1">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="3569742157-3">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">6</span><span class="p" data-group-id="3569742157-3">]</span></code></pre><h3 id="splitwith" class="section-heading">
  <a href="#splitwith" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">splitwith</span>
</h3>
<p><a href="../../lib/stdlib-6.1.2/doc/html/lists.html#splitwith/2"><code class="inline">lists:splitwith/2</code></a> splits the list <code class="inline">L</code> into the two sublists <code class="inline">{L1, L2}</code>, where
<code class="inline">L = takewhile(P, L)</code> and <code class="inline">L2 = dropwhile(P, L)</code>:</p><pre><code class="makeup erlang" translate="no"><span class="nf">splitwith</span><span class="p" data-group-id="6192394022-1">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p" data-group-id="6192394022-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="nf">splitwith</span><span class="p" data-group-id="6192394022-2">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6192394022-3">[</span><span class="p" data-group-id="6192394022-3">]</span><span class="p" data-group-id="6192394022-2">)</span><span class="p">.</span><span class="w">

</span><span class="nf">splitwith</span><span class="p" data-group-id="6192394022-4">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6192394022-5">[</span><span class="n">H</span><span class="p">|</span><span class="n">T</span><span class="p" data-group-id="6192394022-5">]</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p" data-group-id="6192394022-4">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="n">Pred</span><span class="p" data-group-id="6192394022-6">(</span><span class="n">H</span><span class="p" data-group-id="6192394022-6">)</span><span class="w"> </span><span class="k">of</span><span class="w">
        </span><span class="ss">true</span><span class="w">  </span><span class="p">-&gt;</span><span class="w"> </span><span class="nf">splitwith</span><span class="p" data-group-id="6192394022-7">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6192394022-8">[</span><span class="n">H</span><span class="p">|</span><span class="n">L</span><span class="p" data-group-id="6192394022-8">]</span><span class="p" data-group-id="6192394022-7">)</span><span class="p">;</span><span class="w">
        </span><span class="ss">false</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="6192394022-9">{</span><span class="nf">reverse</span><span class="p" data-group-id="6192394022-10">(</span><span class="n">L</span><span class="p" data-group-id="6192394022-10">)</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6192394022-11">[</span><span class="n">H</span><span class="p">|</span><span class="n">T</span><span class="p" data-group-id="6192394022-11">]</span><span class="p" data-group-id="6192394022-9">}</span><span class="w">
    </span><span class="k">end</span><span class="p">;</span><span class="w">
</span><span class="nf">splitwith</span><span class="p" data-group-id="6192394022-12">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6192394022-13">[</span><span class="p" data-group-id="6192394022-13">]</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p" data-group-id="6192394022-12">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="p" data-group-id="6192394022-14">{</span><span class="nf">reverse</span><span class="p" data-group-id="6192394022-15">(</span><span class="n">L</span><span class="p" data-group-id="6192394022-15">)</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6192394022-16">[</span><span class="p" data-group-id="6192394022-16">]</span><span class="p" data-group-id="6192394022-14">}</span><span class="p">.</span></code></pre><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">&gt; </span><span class="nc">lists</span><span class="p">:</span><span class="nf">splitwith</span><span class="p" data-group-id="3995618593-1">(</span><span class="n">Big</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3995618593-2">[</span><span class="mi">200</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">6</span><span class="p" data-group-id="3995618593-2">]</span><span class="p" data-group-id="3995618593-1">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="3995618593-3">{</span><span class="p" data-group-id="3995618593-4">[</span><span class="mi">200</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span><span class="mi">45</span><span class="p" data-group-id="3995618593-4">]</span><span class="p">,</span><span class="p" data-group-id="3995618593-5">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">6</span><span class="p" data-group-id="3995618593-5">]</span><span class="p" data-group-id="3995618593-3">}</span></code></pre><h2 id="funs-returning-funs" class="section-heading">
  <a href="#funs-returning-funs" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Funs Returning Funs</span>
</h2>
<p>So far, only functions that take funs as arguments have been described. More
powerful functions, that themselves return funs, can also be written. The
following examples illustrate these type of functions.</p><h3 id="simple-higher-order-functions" class="section-heading">
  <a href="#simple-higher-order-functions" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Simple Higher Order Functions</span>
</h3>
<p><code class="inline">Adder(X)</code> is a function that given <code class="inline">X</code>, returns a new function <code class="inline">G</code> such that
<code class="inline">G(K)</code> returns <code class="inline">K + X</code>:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">&gt; </span><span class="n">Adder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">fun</span><span class="p" data-group-id="8507199260-1">(</span><span class="n">X</span><span class="p" data-group-id="8507199260-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nf">fun</span><span class="p" data-group-id="8507199260-2">(</span><span class="n">Y</span><span class="p" data-group-id="8507199260-2">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="k">end</span><span class="w"> </span><span class="k">end</span><span class="p">.</span><span class="w">
</span><span class="p">#</span><span class="n">Fun</span><span class="o">&lt;</span><span class="ss">erl_eval</span><span class="p">.</span><span class="mf">6.72228031</span><span class="o">&gt;</span><span class="gp unselectable">
&gt; </span><span class="n">Add6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Adder</span><span class="p" data-group-id="8507199260-3">(</span><span class="mi">6</span><span class="p" data-group-id="8507199260-3">)</span><span class="p">.</span><span class="w">
</span><span class="p">#</span><span class="n">Fun</span><span class="o">&lt;</span><span class="ss">erl_eval</span><span class="p">.</span><span class="mf">6.72228031</span><span class="o">&gt;</span><span class="gp unselectable">
&gt; </span><span class="n">Add6</span><span class="p" data-group-id="8507199260-4">(</span><span class="mi">10</span><span class="p" data-group-id="8507199260-4">)</span><span class="p">.</span><span class="w">
</span><span class="mi">16</span></code></pre><h3 id="infinite-lists" class="section-heading">
  <a href="#infinite-lists" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Infinite Lists</span>
</h3>
<p>The idea is to write something like:</p><pre><code class="makeup erlang" translate="no"><span class="p">-</span><span class="na">module</span><span class="p" data-group-id="1339711832-1">(</span><span class="ss">lazy</span><span class="p" data-group-id="1339711832-1">)</span><span class="p">.</span><span class="w">
</span><span class="p">-</span><span class="na">export</span><span class="p" data-group-id="1339711832-2">(</span><span class="p" data-group-id="1339711832-3">[</span><span class="ss">ints_from</span><span class="p">/</span><span class="mi">1</span><span class="p" data-group-id="1339711832-3">]</span><span class="p" data-group-id="1339711832-2">)</span><span class="p">.</span><span class="w">
</span><span class="nf">ints_from</span><span class="p" data-group-id="1339711832-4">(</span><span class="n">N</span><span class="p" data-group-id="1339711832-4">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="nf">fun</span><span class="p" data-group-id="1339711832-5">(</span><span class="p" data-group-id="1339711832-5">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
            </span><span class="p" data-group-id="1339711832-6">[</span><span class="n">N</span><span class="p">|</span><span class="nf">ints_from</span><span class="p" data-group-id="1339711832-7">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p" data-group-id="1339711832-7">)</span><span class="p" data-group-id="1339711832-6">]</span><span class="w">
    </span><span class="k">end</span><span class="p">.</span></code></pre><p>Then proceed as follows:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">&gt; </span><span class="n">XX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">lazy</span><span class="p">:</span><span class="nf">ints_from</span><span class="p" data-group-id="5498231372-1">(</span><span class="mi">1</span><span class="p" data-group-id="5498231372-1">)</span><span class="p">.</span><span class="w">
</span><span class="p">#</span><span class="n">Fun</span><span class="o">&lt;</span><span class="ss">lazy</span><span class="p">.</span><span class="mf">0.29874839</span><span class="o">&gt;</span><span class="gp unselectable">
&gt; </span><span class="n">XX</span><span class="p" data-group-id="5498231372-2">(</span><span class="p" data-group-id="5498231372-2">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="5498231372-3">[</span><span class="mi">1</span><span class="p">|</span><span class="p">#</span><span class="n">Fun</span><span class="o">&lt;</span><span class="ss">lazy</span><span class="p">.</span><span class="mf">0.29874839</span><span class="o">&gt;</span><span class="p" data-group-id="5498231372-3">]</span><span class="gp unselectable">
&gt; </span><span class="nf">hd</span><span class="p" data-group-id="5498231372-4">(</span><span class="n">XX</span><span class="p" data-group-id="5498231372-5">(</span><span class="p" data-group-id="5498231372-5">)</span><span class="p" data-group-id="5498231372-4">)</span><span class="p">.</span><span class="w">
</span><span class="mi">1</span><span class="gp unselectable">
&gt; </span><span class="n">Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">tl</span><span class="p" data-group-id="5498231372-6">(</span><span class="n">XX</span><span class="p" data-group-id="5498231372-7">(</span><span class="p" data-group-id="5498231372-7">)</span><span class="p" data-group-id="5498231372-6">)</span><span class="p">.</span><span class="w">
</span><span class="p">#</span><span class="n">Fun</span><span class="o">&lt;</span><span class="ss">lazy</span><span class="p">.</span><span class="mf">0.29874839</span><span class="o">&gt;</span><span class="gp unselectable">
&gt; </span><span class="nf">hd</span><span class="p" data-group-id="5498231372-8">(</span><span class="n">Y</span><span class="p" data-group-id="5498231372-9">(</span><span class="p" data-group-id="5498231372-9">)</span><span class="p" data-group-id="5498231372-8">)</span><span class="p">.</span><span class="w">
</span><span class="mi">2</span></code></pre><p>And so on. This is an example of &quot;lazy embedding&quot;.</p><h3 id="parsing" class="section-heading">
  <a href="#parsing" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Parsing</span>
</h3>
<p>The following examples show parsers of the following type:</p><pre><code class="makeup erlang" translate="no"><span class="n">Parser</span><span class="p" data-group-id="3347348352-1">(</span><span class="n">Toks</span><span class="p" data-group-id="3347348352-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="3347348352-2">{</span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="n">Tree</span><span class="p">,</span><span class="w"> </span><span class="n">Toks1</span><span class="p" data-group-id="3347348352-2">}</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="ss">fail</span></code></pre><p><code class="inline">Toks</code> is the list of tokens to be parsed. A successful parse returns
<code class="inline">{ok, Tree, Toks1}</code>.</p><ul><li><code class="inline">Tree</code> is a parse tree.</li><li><code class="inline">Toks1</code> is a tail of <code class="inline">Tree</code> that contains symbols encountered after the
structure that was correctly parsed.</li></ul><p>An unsuccessful parse returns <code class="inline">fail</code>.</p><p>The following example illustrates a simple, functional parser that parses the
grammar:</p><pre><code class="text">(a | b) &amp; (c | d)</code></pre><p>The following code defines a function <code class="inline">pconst(X)</code> in the module <code class="inline">funparse</code>,
which returns a fun that parses a list of tokens:</p><pre><code class="makeup erlang" translate="no"><span class="nf">pconst</span><span class="p" data-group-id="0736196973-1">(</span><span class="n">X</span><span class="p" data-group-id="0736196973-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="nf">fun</span><span class="w"> </span><span class="p" data-group-id="0736196973-2">(</span><span class="n">T</span><span class="p" data-group-id="0736196973-2">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
       </span><span class="k">case</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="k">of</span><span class="w">
           </span><span class="p" data-group-id="0736196973-3">[</span><span class="n">X</span><span class="p">|</span><span class="n">T1</span><span class="p" data-group-id="0736196973-3">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="0736196973-4">{</span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0736196973-5">{</span><span class="ss">const</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p" data-group-id="0736196973-5">}</span><span class="p">,</span><span class="w"> </span><span class="n">T1</span><span class="p" data-group-id="0736196973-4">}</span><span class="p">;</span><span class="w">
           </span><span class="p">_</span><span class="w">      </span><span class="p">-&gt;</span><span class="w"> </span><span class="ss">fail</span><span class="w">
       </span><span class="k">end</span><span class="w">
    </span><span class="k">end</span><span class="p">.</span></code></pre><p>This function can be used as follows:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">&gt; </span><span class="n">P1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">funparse</span><span class="p">:</span><span class="nf">pconst</span><span class="p" data-group-id="4232207898-1">(</span><span class="ss">a</span><span class="p" data-group-id="4232207898-1">)</span><span class="p">.</span><span class="w">
</span><span class="p">#</span><span class="n">Fun</span><span class="o">&lt;</span><span class="ss">funparse</span><span class="p">.</span><span class="mf">0.22674075</span><span class="o">&gt;</span><span class="gp unselectable">
&gt; </span><span class="n">P1</span><span class="p" data-group-id="4232207898-2">(</span><span class="p" data-group-id="4232207898-3">[</span><span class="ss">a</span><span class="p">,</span><span class="ss">b</span><span class="p">,</span><span class="ss">c</span><span class="p" data-group-id="4232207898-3">]</span><span class="p" data-group-id="4232207898-2">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="4232207898-4">{</span><span class="ss">ok</span><span class="p">,</span><span class="p" data-group-id="4232207898-5">{</span><span class="ss">const</span><span class="p">,</span><span class="ss">a</span><span class="p" data-group-id="4232207898-5">}</span><span class="p">,</span><span class="p" data-group-id="4232207898-6">[</span><span class="ss">b</span><span class="p">,</span><span class="ss">c</span><span class="p" data-group-id="4232207898-6">]</span><span class="p" data-group-id="4232207898-4">}</span><span class="gp unselectable">
&gt; </span><span class="n">P1</span><span class="p" data-group-id="4232207898-7">(</span><span class="p" data-group-id="4232207898-8">[</span><span class="ss">x</span><span class="p">,</span><span class="ss">y</span><span class="p">,</span><span class="ss">z</span><span class="p" data-group-id="4232207898-8">]</span><span class="p" data-group-id="4232207898-7">)</span><span class="p">.</span><span class="w">
</span><span class="ss">fail</span></code></pre><p>Next, the two higher order functions <code class="inline">pand</code> and <code class="inline">por</code> are defined. They combine
primitive parsers to produce more complex parsers.</p><p>First <code class="inline">pand</code>:</p><pre><code class="makeup erlang" translate="no"><span class="nf">pand</span><span class="p" data-group-id="4488882280-1">(</span><span class="n">P1</span><span class="p">,</span><span class="w"> </span><span class="n">P2</span><span class="p" data-group-id="4488882280-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="nf">fun</span><span class="w"> </span><span class="p" data-group-id="4488882280-2">(</span><span class="n">T</span><span class="p" data-group-id="4488882280-2">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="k">case</span><span class="w"> </span><span class="n">P1</span><span class="p" data-group-id="4488882280-3">(</span><span class="n">T</span><span class="p" data-group-id="4488882280-3">)</span><span class="w"> </span><span class="k">of</span><span class="w">
            </span><span class="p" data-group-id="4488882280-4">{</span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="n">T1</span><span class="p" data-group-id="4488882280-4">}</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
                </span><span class="k">case</span><span class="w"> </span><span class="n">P2</span><span class="p" data-group-id="4488882280-5">(</span><span class="n">T1</span><span class="p" data-group-id="4488882280-5">)</span><span class="w"> </span><span class="k">of</span><span class="w">
                    </span><span class="p" data-group-id="4488882280-6">{</span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="n">R2</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="p" data-group-id="4488882280-6">}</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
                        </span><span class="p" data-group-id="4488882280-7">{</span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4488882280-8">{</span><span class="ss">&#39;and&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="n">R2</span><span class="p" data-group-id="4488882280-8">}</span><span class="p" data-group-id="4488882280-7">}</span><span class="p">;</span><span class="w">
                    </span><span class="ss">fail</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
                        </span><span class="ss">fail</span><span class="w">
                </span><span class="k">end</span><span class="p">;</span><span class="w">
            </span><span class="ss">fail</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
                </span><span class="ss">fail</span><span class="w">
        </span><span class="k">end</span><span class="w">
    </span><span class="k">end</span><span class="p">.</span></code></pre><p>Given a parser <code class="inline">P1</code> for grammar <code class="inline">G1</code>, and a parser <code class="inline">P2</code> for grammar <code class="inline">G2</code>,
<code class="inline">pand(P1, P2)</code> returns a parser for the grammar, which consists of sequences of
tokens that satisfy <code class="inline">G1</code>, followed by sequences of tokens that satisfy <code class="inline">G2</code>.</p><p><code class="inline">por(P1, P2)</code> returns a parser for the language described by the grammar <code class="inline">G1</code> or
<code class="inline">G2</code>:</p><pre><code class="makeup erlang" translate="no"><span class="nf">por</span><span class="p" data-group-id="5454352309-1">(</span><span class="n">P1</span><span class="p">,</span><span class="w"> </span><span class="n">P2</span><span class="p" data-group-id="5454352309-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="nf">fun</span><span class="w"> </span><span class="p" data-group-id="5454352309-2">(</span><span class="n">T</span><span class="p" data-group-id="5454352309-2">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="k">case</span><span class="w"> </span><span class="n">P1</span><span class="p" data-group-id="5454352309-3">(</span><span class="n">T</span><span class="p" data-group-id="5454352309-3">)</span><span class="w"> </span><span class="k">of</span><span class="w">
            </span><span class="p" data-group-id="5454352309-4">{</span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">T1</span><span class="p" data-group-id="5454352309-4">}</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
                </span><span class="p" data-group-id="5454352309-5">{</span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5454352309-6">{</span><span class="ss">&#39;or&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">R</span><span class="p" data-group-id="5454352309-6">}</span><span class="p">,</span><span class="w"> </span><span class="n">T1</span><span class="p" data-group-id="5454352309-5">}</span><span class="p">;</span><span class="w">
            </span><span class="ss">fail</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
                </span><span class="k">case</span><span class="w"> </span><span class="n">P2</span><span class="p" data-group-id="5454352309-7">(</span><span class="n">T</span><span class="p" data-group-id="5454352309-7">)</span><span class="w"> </span><span class="k">of</span><span class="w">
                    </span><span class="p" data-group-id="5454352309-8">{</span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="n">T1</span><span class="p" data-group-id="5454352309-8">}</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
                        </span><span class="p" data-group-id="5454352309-9">{</span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5454352309-10">{</span><span class="ss">&#39;or&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">R1</span><span class="p" data-group-id="5454352309-10">}</span><span class="p">,</span><span class="w"> </span><span class="n">T1</span><span class="p" data-group-id="5454352309-9">}</span><span class="p">;</span><span class="w">
                    </span><span class="ss">fail</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
                        </span><span class="ss">fail</span><span class="w">
                </span><span class="k">end</span><span class="w">
        </span><span class="k">end</span><span class="w">
    </span><span class="k">end</span><span class="p">.</span></code></pre><p>The original problem was to parse the grammar <code class="inline">(a | b) &amp; (c | d)</code>. The following
code addresses this problem:</p><pre><code class="makeup erlang" translate="no"><span class="nf">grammar</span><span class="p" data-group-id="9395675714-1">(</span><span class="p" data-group-id="9395675714-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="nf">pand</span><span class="p" data-group-id="9395675714-2">(</span><span class="w">
         </span><span class="nf">por</span><span class="p" data-group-id="9395675714-3">(</span><span class="nf">pconst</span><span class="p" data-group-id="9395675714-4">(</span><span class="ss">a</span><span class="p" data-group-id="9395675714-4">)</span><span class="p">,</span><span class="w"> </span><span class="nf">pconst</span><span class="p" data-group-id="9395675714-5">(</span><span class="ss">b</span><span class="p" data-group-id="9395675714-5">)</span><span class="p" data-group-id="9395675714-3">)</span><span class="p">,</span><span class="w">
         </span><span class="nf">por</span><span class="p" data-group-id="9395675714-6">(</span><span class="nf">pconst</span><span class="p" data-group-id="9395675714-7">(</span><span class="ss">c</span><span class="p" data-group-id="9395675714-7">)</span><span class="p">,</span><span class="w"> </span><span class="nf">pconst</span><span class="p" data-group-id="9395675714-8">(</span><span class="ss">d</span><span class="p" data-group-id="9395675714-8">)</span><span class="p" data-group-id="9395675714-6">)</span><span class="p" data-group-id="9395675714-2">)</span><span class="p">.</span></code></pre><p>The following code adds a parser interface to the grammar:</p><pre><code class="makeup erlang" translate="no"><span class="nf">parse</span><span class="p" data-group-id="9899337742-1">(</span><span class="n">List</span><span class="p" data-group-id="9899337742-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="p" data-group-id="9899337742-2">(</span><span class="nf">grammar</span><span class="p" data-group-id="9899337742-3">(</span><span class="p" data-group-id="9899337742-3">)</span><span class="p" data-group-id="9899337742-2">)</span><span class="p" data-group-id="9899337742-4">(</span><span class="n">List</span><span class="p" data-group-id="9899337742-4">)</span><span class="p">.</span></code></pre><p>The parser can be tested as follows:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">&gt; </span><span class="nc">funparse</span><span class="p">:</span><span class="nf">parse</span><span class="p" data-group-id="2531041881-1">(</span><span class="p" data-group-id="2531041881-2">[</span><span class="ss">a</span><span class="p">,</span><span class="ss">c</span><span class="p" data-group-id="2531041881-2">]</span><span class="p" data-group-id="2531041881-1">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="2531041881-3">{</span><span class="ss">ok</span><span class="p">,</span><span class="p" data-group-id="2531041881-4">{</span><span class="ss">&#39;and&#39;</span><span class="p">,</span><span class="p" data-group-id="2531041881-5">{</span><span class="ss">&#39;or&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="p" data-group-id="2531041881-6">{</span><span class="ss">const</span><span class="p">,</span><span class="ss">a</span><span class="p" data-group-id="2531041881-6">}</span><span class="p" data-group-id="2531041881-5">}</span><span class="p">,</span><span class="p" data-group-id="2531041881-7">{</span><span class="ss">&#39;or&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="p" data-group-id="2531041881-8">{</span><span class="ss">const</span><span class="p">,</span><span class="ss">c</span><span class="p" data-group-id="2531041881-8">}</span><span class="p" data-group-id="2531041881-7">}</span><span class="p" data-group-id="2531041881-4">}</span><span class="p" data-group-id="2531041881-3">}</span><span class="gp unselectable">
&gt; </span><span class="nc">funparse</span><span class="p">:</span><span class="nf">parse</span><span class="p" data-group-id="2531041881-9">(</span><span class="p" data-group-id="2531041881-10">[</span><span class="ss">a</span><span class="p">,</span><span class="ss">d</span><span class="p" data-group-id="2531041881-10">]</span><span class="p" data-group-id="2531041881-9">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="2531041881-11">{</span><span class="ss">ok</span><span class="p">,</span><span class="p" data-group-id="2531041881-12">{</span><span class="ss">&#39;and&#39;</span><span class="p">,</span><span class="p" data-group-id="2531041881-13">{</span><span class="ss">&#39;or&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="p" data-group-id="2531041881-14">{</span><span class="ss">const</span><span class="p">,</span><span class="ss">a</span><span class="p" data-group-id="2531041881-14">}</span><span class="p" data-group-id="2531041881-13">}</span><span class="p">,</span><span class="p" data-group-id="2531041881-15">{</span><span class="ss">&#39;or&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="p" data-group-id="2531041881-16">{</span><span class="ss">const</span><span class="p">,</span><span class="ss">d</span><span class="p" data-group-id="2531041881-16">}</span><span class="p" data-group-id="2531041881-15">}</span><span class="p" data-group-id="2531041881-12">}</span><span class="p" data-group-id="2531041881-11">}</span><span class="gp unselectable">
&gt; </span><span class="nc">funparse</span><span class="p">:</span><span class="nf">parse</span><span class="p" data-group-id="2531041881-17">(</span><span class="p" data-group-id="2531041881-18">[</span><span class="ss">b</span><span class="p">,</span><span class="ss">c</span><span class="p" data-group-id="2531041881-18">]</span><span class="p" data-group-id="2531041881-17">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="2531041881-19">{</span><span class="ss">ok</span><span class="p">,</span><span class="p" data-group-id="2531041881-20">{</span><span class="ss">&#39;and&#39;</span><span class="p">,</span><span class="p" data-group-id="2531041881-21">{</span><span class="ss">&#39;or&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="p" data-group-id="2531041881-22">{</span><span class="ss">const</span><span class="p">,</span><span class="ss">b</span><span class="p" data-group-id="2531041881-22">}</span><span class="p" data-group-id="2531041881-21">}</span><span class="p">,</span><span class="p" data-group-id="2531041881-23">{</span><span class="ss">&#39;or&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="p" data-group-id="2531041881-24">{</span><span class="ss">const</span><span class="p">,</span><span class="ss">c</span><span class="p" data-group-id="2531041881-24">}</span><span class="p" data-group-id="2531041881-23">}</span><span class="p" data-group-id="2531041881-20">}</span><span class="p" data-group-id="2531041881-19">}</span><span class="gp unselectable">
&gt; </span><span class="nc">funparse</span><span class="p">:</span><span class="nf">parse</span><span class="p" data-group-id="2531041881-25">(</span><span class="p" data-group-id="2531041881-26">[</span><span class="ss">b</span><span class="p">,</span><span class="ss">d</span><span class="p" data-group-id="2531041881-26">]</span><span class="p" data-group-id="2531041881-25">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="2531041881-27">{</span><span class="ss">ok</span><span class="p">,</span><span class="p" data-group-id="2531041881-28">{</span><span class="ss">&#39;and&#39;</span><span class="p">,</span><span class="p" data-group-id="2531041881-29">{</span><span class="ss">&#39;or&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="p" data-group-id="2531041881-30">{</span><span class="ss">const</span><span class="p">,</span><span class="ss">b</span><span class="p" data-group-id="2531041881-30">}</span><span class="p" data-group-id="2531041881-29">}</span><span class="p">,</span><span class="p" data-group-id="2531041881-31">{</span><span class="ss">&#39;or&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="p" data-group-id="2531041881-32">{</span><span class="ss">const</span><span class="p">,</span><span class="ss">d</span><span class="p" data-group-id="2531041881-32">}</span><span class="p" data-group-id="2531041881-31">}</span><span class="p" data-group-id="2531041881-28">}</span><span class="p" data-group-id="2531041881-27">}</span><span class="gp unselectable">
&gt; </span><span class="nc">funparse</span><span class="p">:</span><span class="nf">parse</span><span class="p" data-group-id="2531041881-33">(</span><span class="p" data-group-id="2531041881-34">[</span><span class="ss">a</span><span class="p">,</span><span class="ss">b</span><span class="p" data-group-id="2531041881-34">]</span><span class="p" data-group-id="2531041881-33">)</span><span class="p">.</span><span class="w">
</span><span class="ss">fail</span></code></pre>
</div>

<div class="bottom-actions" id="bottom-actions">
  <div class="bottom-actions-item">

      <a href="prog_ex_records.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
Records
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="list_comprehensions.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
List Comprehensions
        </span>
      </a>

  </div>
</div>
    <footer class="footer">
      <p>

        <span class="line">
          <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
            Search HexDocs
          </button>

            <a href="Erlang System Documentation.epub" title="ePub version">
              Download ePub version
            </a>

        </span>
      </p>

      <p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.34.1) for the

          <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

      </p>
<p>Copyright © 1996-2024 <a href="https://www.ericsson.com">Ericsson AB</a></p>
    </footer>
  </div>
</main>
</div>
<script>
  function mermaidLoaded() {
    mermaid.initialize({
      startOnLoad: false,
      theme: document.body.className.includes("dark") ? "dark" : "default"
    });
    let id = 0;
    for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
      const preEl = codeEl.parentElement;
      const graphDefinition = codeEl.textContent;
      const graphEl = document.createElement("div");
      const graphId = "mermaid-graph-" + id++;
      mermaid.render(graphId, graphDefinition).then(({svg, bindFunctions}) => {
        graphEl.innerHTML = svg;
        bindFunctions?.(graphEl);
        preEl.insertAdjacentElement("afterend", graphEl);
        preEl.remove();
      });
    }
  }
</script>
<script async src="https://cdn.jsdelivr.net/npm/mermaid@10.2.3/dist/mermaid.min.js" onload="mermaidLoaded();"></script>

  </body>
</html>
