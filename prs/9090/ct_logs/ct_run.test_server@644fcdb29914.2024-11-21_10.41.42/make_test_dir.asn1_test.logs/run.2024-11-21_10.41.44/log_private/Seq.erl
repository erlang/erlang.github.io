%% Generated by the Erlang ASN.1 BER compiler. Version: 5.3.1
%% Purpose: Encoding and decoding of the types in Seq.

-module('Seq').
-moduledoc false.
-compile(nowarn_unused_vars).
-dialyzer(no_improper_lists).
-dialyzer(no_match).
-include("Seq.hrl").
-asn1_info([{vsn,'5.3.1'},
            {module,'Seq'},
            {options,[{i,"/buildroot/otp/lib/asn1/make_test_dir/ct_logs/ct_run.test_server@644fcdb29914.2024-11-21_10.41.42/make_test_dir.asn1_test.logs/run.2024-11-21_10.41.44/log_private/"},
 {record_name_prefix,"a_"},
 {outdir,"/buildroot/otp/lib/asn1/make_test_dir/ct_logs/ct_run.test_server@644fcdb29914.2024-11-21_10.41.42/make_test_dir.asn1_test.logs/run.2024-11-21_10.41.44/log_private/"},
 {i,"."},
 {i,"/buildroot/otp/lib/asn1/make_test_dir/asn1_test/asn1_SUITE_data"}]}]).

-export([encoding_rule/0,maps/0,bit_string_format/0,
         legacy_erlang_types/0]).
-export(['dialyzer-suppressions'/1]).
-export([
enc_Seq/2,
enc_Seq1/2,
enc_Seq2/2,
enc_Seq3/2,
enc_Seq4/2,
enc_SeqDef1/2,
enc_SeqDef2/2,
enc_SeqDef3/2,
enc_SeqOpt1/2,
enc_SeqOpt2/2,
enc_SeqOpt3/2,
enc_SeqIn/2,
enc_SeqS1/2,
enc_SeqS2/2,
enc_SeqS3/2,
enc_SeqImp1/2,
enc_SeqImp2/2,
enc_SeqImp3/2,
enc_SeqCompOf/2
]).

-export([
dec_Seq/2,
dec_Seq1/2,
dec_Seq2/2,
dec_Seq3/2,
dec_Seq4/2,
dec_SeqDef1/2,
dec_SeqDef2/2,
dec_SeqDef3/2,
dec_SeqOpt1/2,
dec_SeqOpt2/2,
dec_SeqOpt3/2,
dec_SeqIn/2,
dec_SeqS1/2,
dec_SeqS2/2,
dec_SeqS3/2,
dec_SeqImp1/2,
dec_SeqImp2/2,
dec_SeqImp3/2,
dec_SeqCompOf/2
]).

-export([info/0]).

-export([encode/2,decode/2]).

encoding_rule() -> ber.

maps() -> false.

bit_string_format() -> bitstring.

legacy_erlang_types() -> false.

encode(Type, Data) ->
try iolist_to_binary(element(1, encode_disp(Type, Data))) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.


decode(Type, Data) ->
try
   Result = decode_disp(Type, element(1, ber_decode_nif(Data))),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

encode_disp('Seq', Data) -> enc_Seq(Data);
encode_disp('Seq1', Data) -> enc_Seq1(Data);
encode_disp('Seq2', Data) -> enc_Seq2(Data);
encode_disp('Seq3', Data) -> enc_Seq3(Data);
encode_disp('Seq4', Data) -> enc_Seq4(Data);
encode_disp('SeqDef1', Data) -> enc_SeqDef1(Data);
encode_disp('SeqDef2', Data) -> enc_SeqDef2(Data);
encode_disp('SeqDef3', Data) -> enc_SeqDef3(Data);
encode_disp('SeqOpt1', Data) -> enc_SeqOpt1(Data);
encode_disp('SeqOpt2', Data) -> enc_SeqOpt2(Data);
encode_disp('SeqOpt3', Data) -> enc_SeqOpt3(Data);
encode_disp('SeqIn', Data) -> enc_SeqIn(Data);
encode_disp('SeqS1', Data) -> enc_SeqS1(Data);
encode_disp('SeqS2', Data) -> enc_SeqS2(Data);
encode_disp('SeqS3', Data) -> enc_SeqS3(Data);
encode_disp('SeqImp1', Data) -> enc_SeqImp1(Data);
encode_disp('SeqImp2', Data) -> enc_SeqImp2(Data);
encode_disp('SeqImp3', Data) -> enc_SeqImp3(Data);
encode_disp('SeqCompOf', Data) -> enc_SeqCompOf(Data);
encode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

decode_disp('Seq', Data) -> dec_Seq(Data);
decode_disp('Seq1', Data) -> dec_Seq1(Data);
decode_disp('Seq2', Data) -> dec_Seq2(Data);
decode_disp('Seq3', Data) -> dec_Seq3(Data);
decode_disp('Seq4', Data) -> dec_Seq4(Data);
decode_disp('SeqDef1', Data) -> dec_SeqDef1(Data);
decode_disp('SeqDef2', Data) -> dec_SeqDef2(Data);
decode_disp('SeqDef3', Data) -> dec_SeqDef3(Data);
decode_disp('SeqOpt1', Data) -> dec_SeqOpt1(Data);
decode_disp('SeqOpt2', Data) -> dec_SeqOpt2(Data);
decode_disp('SeqOpt3', Data) -> dec_SeqOpt3(Data);
decode_disp('SeqIn', Data) -> dec_SeqIn(Data);
decode_disp('SeqS1', Data) -> dec_SeqS1(Data);
decode_disp('SeqS2', Data) -> dec_SeqS2(Data);
decode_disp('SeqS3', Data) -> dec_SeqS3(Data);
decode_disp('SeqImp1', Data) -> dec_SeqImp1(Data);
decode_disp('SeqImp2', Data) -> dec_SeqImp2(Data);
decode_disp('SeqImp3', Data) -> dec_SeqImp3(Data);
decode_disp('SeqCompOf', Data) -> dec_SeqCompOf(Data);
decode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

info() ->
   case ?MODULE:module_info(attributes) of
     Attributes when is_list(Attributes) ->
       case lists:keyfind(asn1_info, 1, Attributes) of
         {_,Info} when is_list(Info) ->
           Info;
         _ ->
           []
       end;
     _ ->
       []
   end.


%%================================
%%  Seq
%%================================
enc_Seq(Val) ->
    enc_Seq(Val, [<<48>>]).

enc_Seq(Val, TagIn) ->
{_,Cindex1,Cindex2,Cindex3,Cindex4,Cindex5,Cindex6,Cindex7} = Val,

%%-------------------------------------------------
%% attribute bool(1) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes1,EncLen1} = encode_boolean(Cindex1, [<<1>>]),

%%-------------------------------------------------
%% attribute boolCon(2) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_boolean(Cindex2, [<<148>>]),

%%-------------------------------------------------
%% attribute boolPri(3) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes3,EncLen3} = encode_boolean(Cindex3, [<<213>>]),

%%-------------------------------------------------
%% attribute boolApp(4) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes4,EncLen4} = encode_boolean(Cindex4, [<<86>>]),

%%-------------------------------------------------
%% attribute boolExpCon(5) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes5,EncLen5} = encode_boolean(Cindex5, [<<1>>,<<190>>]),

%%-------------------------------------------------
%% attribute boolExpPri(6) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes6,EncLen6} = encode_boolean(Cindex6, [<<1>>,<<255,31>>]),

%%-------------------------------------------------
%% attribute boolExpApp(7) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes7,EncLen7} = encode_boolean(Cindex7, [<<1>>,<<127,32>>]),

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3, EncBytes4, EncBytes5, EncBytes6, EncBytes7],
LenSoFar = EncLen1 + EncLen2 + EncLen3 + EncLen4 + EncLen5 + EncLen6 + EncLen7,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_Seq(Tlv) ->
   dec_Seq(Tlv, [16]).

dec_Seq(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute bool(1) with type BOOLEAN
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = decode_boolean(V1, [1]),

%%-------------------------------------------------
%% attribute boolCon(2) with type BOOLEAN
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = decode_boolean(V2, [131092]),

%%-------------------------------------------------
%% attribute boolPri(3) with type BOOLEAN
%%-------------------------------------------------
[V3|Tlv4] = Tlv3, 
Term3 = decode_boolean(V3, [196629]),

%%-------------------------------------------------
%% attribute boolApp(4) with type BOOLEAN
%%-------------------------------------------------
[V4|Tlv5] = Tlv4, 
Term4 = decode_boolean(V4, [65558]),

%%-------------------------------------------------
%% attribute boolExpCon(5) with type BOOLEAN
%%-------------------------------------------------
[V5|Tlv6] = Tlv5, 
Term5 = decode_boolean(V5, [131102,1]),

%%-------------------------------------------------
%% attribute boolExpPri(6) with type BOOLEAN
%%-------------------------------------------------
[V6|Tlv7] = Tlv6, 
Term6 = decode_boolean(V6, [196639,1]),

%%-------------------------------------------------
%% attribute boolExpApp(7) with type BOOLEAN
%%-------------------------------------------------
[V7|Tlv8] = Tlv7, 
Term7 = decode_boolean(V7, [65568,1]),

case Tlv8 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv8}}}) % extra fields not allowed
end,
Res1 = {a_Seq,Term1,Term2,Term3,Term4,Term5,Term6,Term7},
Res1.


%%================================
%%  Seq1
%%================================
enc_Seq1(Val) ->
    enc_Seq1(Val, [<<48>>]).

enc_Seq1(Val, TagIn) ->
{_,Cindex1,Cindex2,Cindex3} = Val,

%%-------------------------------------------------
%% attribute bool1(1) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes1,EncLen1} = encode_boolean(Cindex1, [<<1>>]),

%%-------------------------------------------------
%% attribute int1(2) with type INTEGER
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_integer(Cindex2, [<<2>>]),

%%-------------------------------------------------
%% attribute seq1(3)   External Seq:SeqIn
%%-------------------------------------------------
   {EncBytes3,EncLen3} = 'enc_SeqIn'(Cindex3, [<<48>>]),

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_Seq1(Tlv) ->
   dec_Seq1(Tlv, [16]).

dec_Seq1(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute bool1(1) with type BOOLEAN
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = decode_boolean(V1, [1]),

%%-------------------------------------------------
%% attribute int1(2) with type INTEGER
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = decode_integer(V2, [2]),

%%-------------------------------------------------
%% attribute seq1(3)   External Seq:SeqIn
%%-------------------------------------------------
[V3|Tlv4] = Tlv3, 
Term3 = 'dec_SeqIn'(V3, [16]),

case Tlv4 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv4}}}) % extra fields not allowed
end,
Res1 = {a_Seq1,Term1,Term2,Term3},
Res1.


%%================================
%%  Seq2
%%================================
enc_Seq2(Val) ->
    enc_Seq2(Val, [<<48>>]).

enc_Seq2(Val, TagIn) ->
{_,Cindex1,Cindex2,Cindex3} = Val,

%%-------------------------------------------------
%% attribute seq2(1)   External Seq:SeqIn
%%-------------------------------------------------
   {EncBytes1,EncLen1} = 'enc_SeqIn'(Cindex1, [<<48>>]),

%%-------------------------------------------------
%% attribute bool2(2) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_boolean(Cindex2, [<<1>>]),

%%-------------------------------------------------
%% attribute int2(3) with type INTEGER
%%-------------------------------------------------
   {EncBytes3,EncLen3} = encode_integer(Cindex3, [<<2>>]),

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_Seq2(Tlv) ->
   dec_Seq2(Tlv, [16]).

dec_Seq2(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute seq2(1)   External Seq:SeqIn
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = 'dec_SeqIn'(V1, [16]),

%%-------------------------------------------------
%% attribute bool2(2) with type BOOLEAN
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = decode_boolean(V2, [1]),

%%-------------------------------------------------
%% attribute int2(3) with type INTEGER
%%-------------------------------------------------
[V3|Tlv4] = Tlv3, 
Term3 = decode_integer(V3, [2]),

case Tlv4 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv4}}}) % extra fields not allowed
end,
Res1 = {a_Seq2,Term1,Term2,Term3},
Res1.


%%================================
%%  Seq3
%%================================
enc_Seq3(Val) ->
    enc_Seq3(Val, [<<48>>]).

enc_Seq3(Val, TagIn) ->
{_,Cindex1,Cindex2,Cindex3} = Val,

%%-------------------------------------------------
%% attribute bool3(1) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes1,EncLen1} = encode_boolean(Cindex1, [<<1>>]),

%%-------------------------------------------------
%% attribute seq3(2)   External Seq:SeqIn
%%-------------------------------------------------
   {EncBytes2,EncLen2} = 'enc_SeqIn'(Cindex2, [<<48>>]),

%%-------------------------------------------------
%% attribute int3(3) with type INTEGER
%%-------------------------------------------------
   {EncBytes3,EncLen3} = encode_integer(Cindex3, [<<2>>]),

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_Seq3(Tlv) ->
   dec_Seq3(Tlv, [16]).

dec_Seq3(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute bool3(1) with type BOOLEAN
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = decode_boolean(V1, [1]),

%%-------------------------------------------------
%% attribute seq3(2)   External Seq:SeqIn
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = 'dec_SeqIn'(V2, [16]),

%%-------------------------------------------------
%% attribute int3(3) with type INTEGER
%%-------------------------------------------------
[V3|Tlv4] = Tlv3, 
Term3 = decode_integer(V3, [2]),

case Tlv4 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv4}}}) % extra fields not allowed
end,
Res1 = {a_Seq3,Term1,Term2,Term3},
Res1.


%%================================
%%  Seq4
%%================================
enc_Seq4(Val) ->
    enc_Seq4(Val, [<<48>>]).

enc_Seq4(Val, TagIn) ->
{_,Cindex1,Cindex2,Cindex3} = Val,

%%-------------------------------------------------
%% attribute seq41(1)   External Seq:SeqIn
%%-------------------------------------------------
   {EncBytes1,EncLen1} = 'enc_SeqIn'(Cindex1, [<<48>>]),

%%-------------------------------------------------
%% attribute seq42(2)   External Seq:SeqIn
%%-------------------------------------------------
   {EncBytes2,EncLen2} = 'enc_SeqIn'(Cindex2, [<<48>>]),

%%-------------------------------------------------
%% attribute seq43(3)   External Seq:SeqIn
%%-------------------------------------------------
   {EncBytes3,EncLen3} = 'enc_SeqIn'(Cindex3, [<<48>>]),

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_Seq4(Tlv) ->
   dec_Seq4(Tlv, [16]).

dec_Seq4(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute seq41(1)   External Seq:SeqIn
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = 'dec_SeqIn'(V1, [16]),

%%-------------------------------------------------
%% attribute seq42(2)   External Seq:SeqIn
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = 'dec_SeqIn'(V2, [16]),

%%-------------------------------------------------
%% attribute seq43(3)   External Seq:SeqIn
%%-------------------------------------------------
[V3|Tlv4] = Tlv3, 
Term3 = 'dec_SeqIn'(V3, [16]),

case Tlv4 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv4}}}) % extra fields not allowed
end,
Res1 = {a_Seq4,Term1,Term2,Term3},
Res1.


%%================================
%%  SeqDef1
%%================================
enc_SeqDef1(Val) ->
    enc_SeqDef1(Val, [<<49>>]).

enc_SeqDef1(Val, TagIn) ->
{_,Cindex1,Cindex2,Cindex3} = Val,

%%-------------------------------------------------
%% attribute bool1(1) with type BOOLEAN DEFAULT = true
%%-------------------------------------------------
   {EncBytes1,EncLen1} =  case Cindex1 of
         asn1_DEFAULT ->
            {<<>>,0};
         _ when Cindex1 =:= true ->
            {<<>>,0};
         _ ->
            encode_boolean(Cindex1, [<<1>>])
       end,

%%-------------------------------------------------
%% attribute int1(2) with type INTEGER
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_integer(Cindex2, [<<2>>]),

%%-------------------------------------------------
%% attribute seq1(3)   External Seq:SeqIn DEFAULT = {a_SeqIn,asn1_NOVALUE,12}
%%-------------------------------------------------
   {EncBytes3,EncLen3} =  case Cindex3 of
         asn1_DEFAULT ->
            {<<>>,0};
         _ when Cindex3 =:= {a_SeqIn,asn1_NOVALUE,12} ->
            {<<>>,0};
         _ ->
            'enc_SeqIn'(Cindex3, [<<48>>])
       end,

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_SeqDef1(Tlv) ->
   dec_SeqDef1(Tlv, [17]).

dec_SeqDef1(Tlv, TagIn) ->
Tlv1 = match_tags(Tlv, TagIn),
SetFun = fun(FunTlv) ->
case FunTlv of 
      %bool1
TTlv = {1,_} ->
    {1, TTlv};
      %int1
TTlv = {2,_} ->
    {2, TTlv};
      %seq1
TTlv = {16,_} ->
    {3, TTlv};
      Else -> 
         {4, Else}
   end
   end,
PositionList = [SetFun(TempTlv)|| TempTlv <- Tlv1],
Tlv2 = [Stlv || {_,Stlv} <- lists:sort(PositionList)],

%%-------------------------------------------------
%% attribute bool1(1) with type BOOLEAN DEFAULT = true
%%-------------------------------------------------
{Term1,Tlv3} = case Tlv2 of
[{1,V1}|TempTlv3] ->
    {decode_boolean(V1, []), TempTlv3};
    _ ->
        {true,Tlv2}
end,

%%-------------------------------------------------
%% attribute int1(2) with type INTEGER
%%-------------------------------------------------
[V2|Tlv4] = Tlv3, 
Term2 = decode_integer(V2, [2]),

%%-------------------------------------------------
%% attribute seq1(3)   External Seq:SeqIn DEFAULT = {a_SeqIn,asn1_NOVALUE,12}
%%-------------------------------------------------
{Term3,Tlv5} = case Tlv4 of
[{16,V3}|TempTlv5] ->
    {'dec_SeqIn'(V3, []), TempTlv5};
    _ ->
        {{a_SeqIn,asn1_NOVALUE,12},Tlv4}
end,

case Tlv5 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv5}}}) % extra fields not allowed
end,
Res1 = {a_SeqDef1,Term1,Term2,Term3},
Res1.


%%================================
%%  SeqDef2
%%================================
enc_SeqDef2(Val) ->
    enc_SeqDef2(Val, [<<49>>]).

enc_SeqDef2(Val, TagIn) ->
{_,Cindex1,Cindex2,Cindex3} = Val,

%%-------------------------------------------------
%% attribute seq2(1)   External Seq:SeqIn DEFAULT = {a_SeqIn,asn1_NOVALUE,12}
%%-------------------------------------------------
   {EncBytes1,EncLen1} =  case Cindex1 of
         asn1_DEFAULT ->
            {<<>>,0};
         _ when Cindex1 =:= {a_SeqIn,asn1_NOVALUE,12} ->
            {<<>>,0};
         _ ->
            'enc_SeqIn'(Cindex1, [<<48>>])
       end,

%%-------------------------------------------------
%% attribute bool2(2) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_boolean(Cindex2, [<<1>>]),

%%-------------------------------------------------
%% attribute int2(3) with type INTEGER
%%-------------------------------------------------
   {EncBytes3,EncLen3} = encode_integer(Cindex3, [<<2>>]),

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_SeqDef2(Tlv) ->
   dec_SeqDef2(Tlv, [17]).

dec_SeqDef2(Tlv, TagIn) ->
Tlv1 = match_tags(Tlv, TagIn),
SetFun = fun(FunTlv) ->
case FunTlv of 
      %seq2
TTlv = {16,_} ->
    {1, TTlv};
      %bool2
TTlv = {1,_} ->
    {2, TTlv};
      %int2
TTlv = {2,_} ->
    {3, TTlv};
      Else -> 
         {4, Else}
   end
   end,
PositionList = [SetFun(TempTlv)|| TempTlv <- Tlv1],
Tlv2 = [Stlv || {_,Stlv} <- lists:sort(PositionList)],

%%-------------------------------------------------
%% attribute seq2(1)   External Seq:SeqIn DEFAULT = {a_SeqIn,asn1_NOVALUE,12}
%%-------------------------------------------------
{Term1,Tlv3} = case Tlv2 of
[{16,V1}|TempTlv3] ->
    {'dec_SeqIn'(V1, []), TempTlv3};
    _ ->
        {{a_SeqIn,asn1_NOVALUE,12},Tlv2}
end,

%%-------------------------------------------------
%% attribute bool2(2) with type BOOLEAN
%%-------------------------------------------------
[V2|Tlv4] = Tlv3, 
Term2 = decode_boolean(V2, [1]),

%%-------------------------------------------------
%% attribute int2(3) with type INTEGER
%%-------------------------------------------------
[V3|Tlv5] = Tlv4, 
Term3 = decode_integer(V3, [2]),

case Tlv5 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv5}}}) % extra fields not allowed
end,
Res1 = {a_SeqDef2,Term1,Term2,Term3},
Res1.


%%================================
%%  SeqDef3
%%================================
enc_SeqDef3(Val) ->
    enc_SeqDef3(Val, [<<49>>]).

enc_SeqDef3(Val, TagIn) ->
{_,Cindex1,Cindex2,Cindex3} = Val,

%%-------------------------------------------------
%% attribute bool3(1) with type BOOLEAN DEFAULT = true
%%-------------------------------------------------
   {EncBytes1,EncLen1} =  case Cindex1 of
         asn1_DEFAULT ->
            {<<>>,0};
         _ when Cindex1 =:= true ->
            {<<>>,0};
         _ ->
            encode_boolean(Cindex1, [<<1>>])
       end,

%%-------------------------------------------------
%% attribute seq3(2)   External Seq:SeqIn DEFAULT = {a_SeqIn,asn1_NOVALUE,12}
%%-------------------------------------------------
   {EncBytes2,EncLen2} =  case Cindex2 of
         asn1_DEFAULT ->
            {<<>>,0};
         _ when Cindex2 =:= {a_SeqIn,asn1_NOVALUE,12} ->
            {<<>>,0};
         _ ->
            'enc_SeqIn'(Cindex2, [<<48>>])
       end,

%%-------------------------------------------------
%% attribute int3(3) with type INTEGER DEFAULT = 17
%%-------------------------------------------------
   {EncBytes3,EncLen3} =  case Cindex3 of
         asn1_DEFAULT ->
            {<<>>,0};
         _ when Cindex3 =:= 17 ->
            {<<>>,0};
         _ ->
            encode_integer(Cindex3, [<<2>>])
       end,

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_SeqDef3(Tlv) ->
   dec_SeqDef3(Tlv, [17]).

dec_SeqDef3(Tlv, TagIn) ->
Tlv1 = match_tags(Tlv, TagIn),
SetFun = fun(FunTlv) ->
case FunTlv of 
      %bool3
TTlv = {1,_} ->
    {1, TTlv};
      %seq3
TTlv = {16,_} ->
    {2, TTlv};
      %int3
TTlv = {2,_} ->
    {3, TTlv};
      Else -> 
         {4, Else}
   end
   end,
PositionList = [SetFun(TempTlv)|| TempTlv <- Tlv1],
Tlv2 = [Stlv || {_,Stlv} <- lists:sort(PositionList)],

%%-------------------------------------------------
%% attribute bool3(1) with type BOOLEAN DEFAULT = true
%%-------------------------------------------------
{Term1,Tlv3} = case Tlv2 of
[{1,V1}|TempTlv3] ->
    {decode_boolean(V1, []), TempTlv3};
    _ ->
        {true,Tlv2}
end,

%%-------------------------------------------------
%% attribute seq3(2)   External Seq:SeqIn DEFAULT = {a_SeqIn,asn1_NOVALUE,12}
%%-------------------------------------------------
{Term2,Tlv4} = case Tlv3 of
[{16,V2}|TempTlv4] ->
    {'dec_SeqIn'(V2, []), TempTlv4};
    _ ->
        {{a_SeqIn,asn1_NOVALUE,12},Tlv3}
end,

%%-------------------------------------------------
%% attribute int3(3) with type INTEGER DEFAULT = 17
%%-------------------------------------------------
{Term3,Tlv5} = case Tlv4 of
[{2,V3}|TempTlv5] ->
    {decode_integer(V3, []), TempTlv5};
    _ ->
        {17,Tlv4}
end,

case Tlv5 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv5}}}) % extra fields not allowed
end,
Res1 = {a_SeqDef3,Term1,Term2,Term3},
Res1.


%%================================
%%  SeqOpt1
%%================================
enc_SeqOpt1(Val) ->
    enc_SeqOpt1(Val, [<<49>>]).

enc_SeqOpt1(Val, TagIn) ->
{_,Cindex1,Cindex2,Cindex3} = Val,

%%-------------------------------------------------
%% attribute bool1(1) with type BOOLEAN OPTIONAL
%%-------------------------------------------------
   {EncBytes1,EncLen1} =  case Cindex1 of
         asn1_NOVALUE -> {<<>>,0};
         _ ->
            encode_boolean(Cindex1, [<<1>>])
       end,

%%-------------------------------------------------
%% attribute int1(2) with type INTEGER
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_integer(Cindex2, [<<2>>]),

%%-------------------------------------------------
%% attribute seq1(3)   External Seq:SeqIn OPTIONAL
%%-------------------------------------------------
   {EncBytes3,EncLen3} =  case Cindex3 of
         asn1_NOVALUE -> {<<>>,0};
         _ ->
            'enc_SeqIn'(Cindex3, [<<48>>])
       end,

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_SeqOpt1(Tlv) ->
   dec_SeqOpt1(Tlv, [17]).

dec_SeqOpt1(Tlv, TagIn) ->
Tlv1 = match_tags(Tlv, TagIn),
SetFun = fun(FunTlv) ->
case FunTlv of 
      %bool1
TTlv = {1,_} ->
    {1, TTlv};
      %int1
TTlv = {2,_} ->
    {2, TTlv};
      %seq1
TTlv = {16,_} ->
    {3, TTlv};
      Else -> 
         {4, Else}
   end
   end,
PositionList = [SetFun(TempTlv)|| TempTlv <- Tlv1],
Tlv2 = [Stlv || {_,Stlv} <- lists:sort(PositionList)],

%%-------------------------------------------------
%% attribute bool1(1) with type BOOLEAN OPTIONAL
%%-------------------------------------------------
{Term1,Tlv3} = case Tlv2 of
[{1,V1}|TempTlv3] ->
    {decode_boolean(V1, []), TempTlv3};
    _ ->
        { asn1_NOVALUE, Tlv2}
end,

%%-------------------------------------------------
%% attribute int1(2) with type INTEGER
%%-------------------------------------------------
[V2|Tlv4] = Tlv3, 
Term2 = decode_integer(V2, [2]),

%%-------------------------------------------------
%% attribute seq1(3)   External Seq:SeqIn OPTIONAL
%%-------------------------------------------------
{Term3,Tlv5} = case Tlv4 of
[{16,V3}|TempTlv5] ->
    {'dec_SeqIn'(V3, []), TempTlv5};
    _ ->
        { asn1_NOVALUE, Tlv4}
end,

case Tlv5 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv5}}}) % extra fields not allowed
end,
Res1 = {a_SeqOpt1,Term1,Term2,Term3},
Res1.


%%================================
%%  SeqOpt2
%%================================
enc_SeqOpt2(Val) ->
    enc_SeqOpt2(Val, [<<49>>]).

enc_SeqOpt2(Val, TagIn) ->
{_,Cindex1,Cindex2,Cindex3} = Val,

%%-------------------------------------------------
%% attribute seq2(1)   External Seq:SeqIn OPTIONAL
%%-------------------------------------------------
   {EncBytes1,EncLen1} =  case Cindex1 of
         asn1_NOVALUE -> {<<>>,0};
         _ ->
            'enc_SeqIn'(Cindex1, [<<48>>])
       end,

%%-------------------------------------------------
%% attribute bool2(2) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_boolean(Cindex2, [<<1>>]),

%%-------------------------------------------------
%% attribute int2(3) with type INTEGER
%%-------------------------------------------------
   {EncBytes3,EncLen3} = encode_integer(Cindex3, [<<2>>]),

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_SeqOpt2(Tlv) ->
   dec_SeqOpt2(Tlv, [17]).

dec_SeqOpt2(Tlv, TagIn) ->
Tlv1 = match_tags(Tlv, TagIn),
SetFun = fun(FunTlv) ->
case FunTlv of 
      %seq2
TTlv = {16,_} ->
    {1, TTlv};
      %bool2
TTlv = {1,_} ->
    {2, TTlv};
      %int2
TTlv = {2,_} ->
    {3, TTlv};
      Else -> 
         {4, Else}
   end
   end,
PositionList = [SetFun(TempTlv)|| TempTlv <- Tlv1],
Tlv2 = [Stlv || {_,Stlv} <- lists:sort(PositionList)],

%%-------------------------------------------------
%% attribute seq2(1)   External Seq:SeqIn OPTIONAL
%%-------------------------------------------------
{Term1,Tlv3} = case Tlv2 of
[{16,V1}|TempTlv3] ->
    {'dec_SeqIn'(V1, []), TempTlv3};
    _ ->
        { asn1_NOVALUE, Tlv2}
end,

%%-------------------------------------------------
%% attribute bool2(2) with type BOOLEAN
%%-------------------------------------------------
[V2|Tlv4] = Tlv3, 
Term2 = decode_boolean(V2, [1]),

%%-------------------------------------------------
%% attribute int2(3) with type INTEGER
%%-------------------------------------------------
[V3|Tlv5] = Tlv4, 
Term3 = decode_integer(V3, [2]),

case Tlv5 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv5}}}) % extra fields not allowed
end,
Res1 = {a_SeqOpt2,Term1,Term2,Term3},
Res1.


%%================================
%%  SeqOpt3
%%================================
enc_SeqOpt3(Val) ->
    enc_SeqOpt3(Val, [<<49>>]).

enc_SeqOpt3(Val, TagIn) ->
{_,Cindex1,Cindex2,Cindex3} = Val,

%%-------------------------------------------------
%% attribute bool3(1) with type BOOLEAN OPTIONAL
%%-------------------------------------------------
   {EncBytes1,EncLen1} =  case Cindex1 of
         asn1_NOVALUE -> {<<>>,0};
         _ ->
            encode_boolean(Cindex1, [<<1>>])
       end,

%%-------------------------------------------------
%% attribute seq3(2)   External Seq:SeqIn OPTIONAL
%%-------------------------------------------------
   {EncBytes2,EncLen2} =  case Cindex2 of
         asn1_NOVALUE -> {<<>>,0};
         _ ->
            'enc_SeqIn'(Cindex2, [<<48>>])
       end,

%%-------------------------------------------------
%% attribute int3(3) with type INTEGER OPTIONAL
%%-------------------------------------------------
   {EncBytes3,EncLen3} =  case Cindex3 of
         asn1_NOVALUE -> {<<>>,0};
         _ ->
            encode_integer(Cindex3, [<<2>>])
       end,

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_SeqOpt3(Tlv) ->
   dec_SeqOpt3(Tlv, [17]).

dec_SeqOpt3(Tlv, TagIn) ->
Tlv1 = match_tags(Tlv, TagIn),
SetFun = fun(FunTlv) ->
case FunTlv of 
      %bool3
TTlv = {1,_} ->
    {1, TTlv};
      %seq3
TTlv = {16,_} ->
    {2, TTlv};
      %int3
TTlv = {2,_} ->
    {3, TTlv};
      Else -> 
         {4, Else}
   end
   end,
PositionList = [SetFun(TempTlv)|| TempTlv <- Tlv1],
Tlv2 = [Stlv || {_,Stlv} <- lists:sort(PositionList)],

%%-------------------------------------------------
%% attribute bool3(1) with type BOOLEAN OPTIONAL
%%-------------------------------------------------
{Term1,Tlv3} = case Tlv2 of
[{1,V1}|TempTlv3] ->
    {decode_boolean(V1, []), TempTlv3};
    _ ->
        { asn1_NOVALUE, Tlv2}
end,

%%-------------------------------------------------
%% attribute seq3(2)   External Seq:SeqIn OPTIONAL
%%-------------------------------------------------
{Term2,Tlv4} = case Tlv3 of
[{16,V2}|TempTlv4] ->
    {'dec_SeqIn'(V2, []), TempTlv4};
    _ ->
        { asn1_NOVALUE, Tlv3}
end,

%%-------------------------------------------------
%% attribute int3(3) with type INTEGER OPTIONAL
%%-------------------------------------------------
{Term3,Tlv5} = case Tlv4 of
[{2,V3}|TempTlv5] ->
    {decode_integer(V3, []), TempTlv5};
    _ ->
        { asn1_NOVALUE, Tlv4}
end,

case Tlv5 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv5}}}) % extra fields not allowed
end,
Res1 = {a_SeqOpt3,Term1,Term2,Term3},
Res1.


%%================================
%%  SeqIn
%%================================
enc_SeqIn(Val) ->
    enc_SeqIn(Val, [<<48>>]).

enc_SeqIn(Val, TagIn) ->
{_,Cindex1,Cindex2} = Val,

%%-------------------------------------------------
%% attribute boolIn(1) with type BOOLEAN OPTIONAL
%%-------------------------------------------------
   {EncBytes1,EncLen1} =  case Cindex1 of
         asn1_NOVALUE -> {<<>>,0};
         _ ->
            encode_boolean(Cindex1, [<<1>>])
       end,

%%-------------------------------------------------
%% attribute intIn(2) with type INTEGER DEFAULT = 12
%%-------------------------------------------------
   {EncBytes2,EncLen2} =  case Cindex2 of
         asn1_DEFAULT ->
            {<<>>,0};
         _ when Cindex2 =:= 12 ->
            {<<>>,0};
         _ ->
            encode_integer(Cindex2, [<<2>>])
       end,

   BytesSoFar = [EncBytes1, EncBytes2],
LenSoFar = EncLen1 + EncLen2,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_SeqIn(Tlv) ->
   dec_SeqIn(Tlv, [16]).

dec_SeqIn(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute boolIn(1) with type BOOLEAN OPTIONAL
%%-------------------------------------------------
{Term1,Tlv2} = case Tlv1 of
[{1,V1}|TempTlv2] ->
    {decode_boolean(V1, []), TempTlv2};
    _ ->
        { asn1_NOVALUE, Tlv1}
end,

%%-------------------------------------------------
%% attribute intIn(2) with type INTEGER DEFAULT = 12
%%-------------------------------------------------
{Term2,Tlv3} = case Tlv2 of
[{2,V2}|TempTlv3] ->
    {decode_integer(V2, []), TempTlv3};
    _ ->
        {12,Tlv2}
end,

case Tlv3 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv3}}}) % extra fields not allowed
end,
Res1 = {a_SeqIn,Term1,Term2},
Res1.


%%================================
%%  SeqS1
%%================================
enc_SeqS1(Val) ->
    enc_SeqS1(Val, [<<48>>]).

enc_SeqS1(Val, TagIn) ->
{_,Cindex1,Cindex2,Cindex3} = Val,

%%-------------------------------------------------
%% attribute boolS1(1) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes1,EncLen1} = encode_boolean(Cindex1, [<<1>>]),

%%-------------------------------------------------
%% attribute intS1(2) with type INTEGER
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_integer(Cindex2, [<<2>>]),

%%-------------------------------------------------
%% attribute seqS1(3) with type SEQUENCE
%%-------------------------------------------------
   {EncBytes3,EncLen3} = 'enc_SeqS1_seqS1'(Cindex3, [<<48>>]),

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
encode_tags(TagIn, BytesSoFar, LenSoFar).



%%================================
%%  SeqS1_seqS1
%%================================
enc_SeqS1_seqS1(Val, TagIn) ->
   {_,Cindex1,Cindex2} = Val,

%%-------------------------------------------------
%% attribute boolIn(1) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes1,EncLen1} = encode_boolean(Cindex1, [<<1>>]),

%%-------------------------------------------------
%% attribute intIn(2) with type INTEGER
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_integer(Cindex2, [<<2>>]),

   BytesSoFar = [EncBytes1, EncBytes2],
LenSoFar = EncLen1 + EncLen2,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_SeqS1(Tlv) ->
   dec_SeqS1(Tlv, [16]).

dec_SeqS1(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute boolS1(1) with type BOOLEAN
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = decode_boolean(V1, [1]),

%%-------------------------------------------------
%% attribute intS1(2) with type INTEGER
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = decode_integer(V2, [2]),

%%-------------------------------------------------
%% attribute seqS1(3) with type SEQUENCE
%%-------------------------------------------------
[V3|Tlv4] = Tlv3, 
Term3 = 'dec_SeqS1_seqS1'(V3, [16]),

case Tlv4 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv4}}}) % extra fields not allowed
end,
Res1 = {a_SeqS1,Term1,Term2,Term3},
Res1.
'dec_SeqS1_seqS1'(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute boolIn(1) with type BOOLEAN
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = decode_boolean(V1, [1]),

%%-------------------------------------------------
%% attribute intIn(2) with type INTEGER
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = decode_integer(V2, [2]),

case Tlv3 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv3}}}) % extra fields not allowed
end,
Res1 = {a_SeqS1_seqS1,Term1,Term2},
Res1.


%%================================
%%  SeqS2
%%================================
enc_SeqS2(Val) ->
    enc_SeqS2(Val, [<<48>>]).

enc_SeqS2(Val, TagIn) ->
{_,Cindex1,Cindex2,Cindex3} = Val,

%%-------------------------------------------------
%% attribute seqS2(1) with type SEQUENCE
%%-------------------------------------------------
   {EncBytes1,EncLen1} = 'enc_SeqS2_seqS2'(Cindex1, [<<48>>]),

%%-------------------------------------------------
%% attribute boolS2(2) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_boolean(Cindex2, [<<1>>]),

%%-------------------------------------------------
%% attribute intS2(3) with type INTEGER
%%-------------------------------------------------
   {EncBytes3,EncLen3} = encode_integer(Cindex3, [<<2>>]),

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
encode_tags(TagIn, BytesSoFar, LenSoFar).



%%================================
%%  SeqS2_seqS2
%%================================
enc_SeqS2_seqS2(Val, TagIn) ->
   {_,Cindex1,Cindex2} = Val,

%%-------------------------------------------------
%% attribute boolIn(1) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes1,EncLen1} = encode_boolean(Cindex1, [<<1>>]),

%%-------------------------------------------------
%% attribute intIn(2) with type INTEGER
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_integer(Cindex2, [<<2>>]),

   BytesSoFar = [EncBytes1, EncBytes2],
LenSoFar = EncLen1 + EncLen2,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_SeqS2(Tlv) ->
   dec_SeqS2(Tlv, [16]).

dec_SeqS2(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute seqS2(1) with type SEQUENCE
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = 'dec_SeqS2_seqS2'(V1, [16]),

%%-------------------------------------------------
%% attribute boolS2(2) with type BOOLEAN
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = decode_boolean(V2, [1]),

%%-------------------------------------------------
%% attribute intS2(3) with type INTEGER
%%-------------------------------------------------
[V3|Tlv4] = Tlv3, 
Term3 = decode_integer(V3, [2]),

case Tlv4 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv4}}}) % extra fields not allowed
end,
Res1 = {a_SeqS2,Term1,Term2,Term3},
Res1.
'dec_SeqS2_seqS2'(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute boolIn(1) with type BOOLEAN
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = decode_boolean(V1, [1]),

%%-------------------------------------------------
%% attribute intIn(2) with type INTEGER
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = decode_integer(V2, [2]),

case Tlv3 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv3}}}) % extra fields not allowed
end,
Res1 = {a_SeqS2_seqS2,Term1,Term2},
Res1.


%%================================
%%  SeqS3
%%================================
enc_SeqS3(Val) ->
    enc_SeqS3(Val, [<<48>>]).

enc_SeqS3(Val, TagIn) ->
{_,Cindex1,Cindex2,Cindex3} = Val,

%%-------------------------------------------------
%% attribute boolS3(1) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes1,EncLen1} = encode_boolean(Cindex1, [<<1>>]),

%%-------------------------------------------------
%% attribute seqS3(2) with type SEQUENCE
%%-------------------------------------------------
   {EncBytes2,EncLen2} = 'enc_SeqS3_seqS3'(Cindex2, [<<48>>]),

%%-------------------------------------------------
%% attribute intS3(3) with type INTEGER
%%-------------------------------------------------
   {EncBytes3,EncLen3} = encode_integer(Cindex3, [<<2>>]),

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
encode_tags(TagIn, BytesSoFar, LenSoFar).



%%================================
%%  SeqS3_seqS3
%%================================
enc_SeqS3_seqS3(Val, TagIn) ->
   {_,Cindex1,Cindex2} = Val,

%%-------------------------------------------------
%% attribute boolIn(1) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes1,EncLen1} = encode_boolean(Cindex1, [<<1>>]),

%%-------------------------------------------------
%% attribute intIn(2) with type INTEGER
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_integer(Cindex2, [<<2>>]),

   BytesSoFar = [EncBytes1, EncBytes2],
LenSoFar = EncLen1 + EncLen2,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_SeqS3(Tlv) ->
   dec_SeqS3(Tlv, [16]).

dec_SeqS3(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute boolS3(1) with type BOOLEAN
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = decode_boolean(V1, [1]),

%%-------------------------------------------------
%% attribute seqS3(2) with type SEQUENCE
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = 'dec_SeqS3_seqS3'(V2, [16]),

%%-------------------------------------------------
%% attribute intS3(3) with type INTEGER
%%-------------------------------------------------
[V3|Tlv4] = Tlv3, 
Term3 = decode_integer(V3, [2]),

case Tlv4 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv4}}}) % extra fields not allowed
end,
Res1 = {a_SeqS3,Term1,Term2,Term3},
Res1.
'dec_SeqS3_seqS3'(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute boolIn(1) with type BOOLEAN
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = decode_boolean(V1, [1]),

%%-------------------------------------------------
%% attribute intIn(2) with type INTEGER
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = decode_integer(V2, [2]),

case Tlv3 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv3}}}) % extra fields not allowed
end,
Res1 = {a_SeqS3_seqS3,Term1,Term2},
Res1.


%%================================
%%  SeqImp1
%%================================
enc_SeqImp1(Val) ->
    enc_SeqImp1(Val, [<<49>>]).

enc_SeqImp1(Val, TagIn) ->
{_,Cindex1,Cindex2,Cindex3} = Val,

%%-------------------------------------------------
%% attribute set(1)   External SeqSetLib:Set1
%%-------------------------------------------------
   {EncBytes1,EncLen1} = 'SeqSetLib':'enc_Set1'(Cindex1, [<<49>>]),

%%-------------------------------------------------
%% attribute bool(2) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_boolean(Cindex2, [<<1>>]),

%%-------------------------------------------------
%% attribute int(3) with type INTEGER
%%-------------------------------------------------
   {EncBytes3,EncLen3} = encode_integer(Cindex3, [<<2>>]),

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_SeqImp1(Tlv) ->
   dec_SeqImp1(Tlv, [17]).

dec_SeqImp1(Tlv, TagIn) ->
Tlv1 = match_tags(Tlv, TagIn),
SetFun = fun(FunTlv) ->
case FunTlv of 
      %set
TTlv = {17,_} ->
    {1, TTlv};
      %bool
TTlv = {1,_} ->
    {2, TTlv};
      %int
TTlv = {2,_} ->
    {3, TTlv};
      Else -> 
         {4, Else}
   end
   end,
PositionList = [SetFun(TempTlv)|| TempTlv <- Tlv1],
Tlv2 = [Stlv || {_,Stlv} <- lists:sort(PositionList)],

%%-------------------------------------------------
%% attribute set(1)   External SeqSetLib:Set1
%%-------------------------------------------------
[V1|Tlv3] = Tlv2, 
Term1 = 'SeqSetLib':'dec_Set1'(V1, [17]),

%%-------------------------------------------------
%% attribute bool(2) with type BOOLEAN
%%-------------------------------------------------
[V2|Tlv4] = Tlv3, 
Term2 = decode_boolean(V2, [1]),

%%-------------------------------------------------
%% attribute int(3) with type INTEGER
%%-------------------------------------------------
[V3|Tlv5] = Tlv4, 
Term3 = decode_integer(V3, [2]),

case Tlv5 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv5}}}) % extra fields not allowed
end,
Res1 = {a_SeqImp1,Term1,Term2,Term3},
Res1.


%%================================
%%  SeqImp2
%%================================
enc_SeqImp2(Val) ->
    enc_SeqImp2(Val, [<<49>>]).

enc_SeqImp2(Val, TagIn) ->
{_,Cindex1,Cindex2,Cindex3} = Val,

%%-------------------------------------------------
%% attribute bool(1) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes1,EncLen1} = encode_boolean(Cindex1, [<<1>>]),

%%-------------------------------------------------
%% attribute set(2)   External SeqSetLib:Set1
%%-------------------------------------------------
   {EncBytes2,EncLen2} = 'SeqSetLib':'enc_Set1'(Cindex2, [<<49>>]),

%%-------------------------------------------------
%% attribute int(3) with type INTEGER
%%-------------------------------------------------
   {EncBytes3,EncLen3} = encode_integer(Cindex3, [<<2>>]),

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_SeqImp2(Tlv) ->
   dec_SeqImp2(Tlv, [17]).

dec_SeqImp2(Tlv, TagIn) ->
Tlv1 = match_tags(Tlv, TagIn),
SetFun = fun(FunTlv) ->
case FunTlv of 
      %bool
TTlv = {1,_} ->
    {1, TTlv};
      %set
TTlv = {17,_} ->
    {2, TTlv};
      %int
TTlv = {2,_} ->
    {3, TTlv};
      Else -> 
         {4, Else}
   end
   end,
PositionList = [SetFun(TempTlv)|| TempTlv <- Tlv1],
Tlv2 = [Stlv || {_,Stlv} <- lists:sort(PositionList)],

%%-------------------------------------------------
%% attribute bool(1) with type BOOLEAN
%%-------------------------------------------------
[V1|Tlv3] = Tlv2, 
Term1 = decode_boolean(V1, [1]),

%%-------------------------------------------------
%% attribute set(2)   External SeqSetLib:Set1
%%-------------------------------------------------
[V2|Tlv4] = Tlv3, 
Term2 = 'SeqSetLib':'dec_Set1'(V2, [17]),

%%-------------------------------------------------
%% attribute int(3) with type INTEGER
%%-------------------------------------------------
[V3|Tlv5] = Tlv4, 
Term3 = decode_integer(V3, [2]),

case Tlv5 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv5}}}) % extra fields not allowed
end,
Res1 = {a_SeqImp2,Term1,Term2,Term3},
Res1.


%%================================
%%  SeqImp3
%%================================
enc_SeqImp3(Val) ->
    enc_SeqImp3(Val, [<<49>>]).

enc_SeqImp3(Val, TagIn) ->
{_,Cindex1,Cindex2,Cindex3} = Val,

%%-------------------------------------------------
%% attribute bool(1) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes1,EncLen1} = encode_boolean(Cindex1, [<<1>>]),

%%-------------------------------------------------
%% attribute int(2) with type INTEGER
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_integer(Cindex2, [<<2>>]),

%%-------------------------------------------------
%% attribute set(3)   External SeqSetLib:Set1
%%-------------------------------------------------
   {EncBytes3,EncLen3} = 'SeqSetLib':'enc_Set1'(Cindex3, [<<49>>]),

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_SeqImp3(Tlv) ->
   dec_SeqImp3(Tlv, [17]).

dec_SeqImp3(Tlv, TagIn) ->
Tlv1 = match_tags(Tlv, TagIn),
SetFun = fun(FunTlv) ->
case FunTlv of 
      %bool
TTlv = {1,_} ->
    {1, TTlv};
      %int
TTlv = {2,_} ->
    {2, TTlv};
      %set
TTlv = {17,_} ->
    {3, TTlv};
      Else -> 
         {4, Else}
   end
   end,
PositionList = [SetFun(TempTlv)|| TempTlv <- Tlv1],
Tlv2 = [Stlv || {_,Stlv} <- lists:sort(PositionList)],

%%-------------------------------------------------
%% attribute bool(1) with type BOOLEAN
%%-------------------------------------------------
[V1|Tlv3] = Tlv2, 
Term1 = decode_boolean(V1, [1]),

%%-------------------------------------------------
%% attribute int(2) with type INTEGER
%%-------------------------------------------------
[V2|Tlv4] = Tlv3, 
Term2 = decode_integer(V2, [2]),

%%-------------------------------------------------
%% attribute set(3)   External SeqSetLib:Set1
%%-------------------------------------------------
[V3|Tlv5] = Tlv4, 
Term3 = 'SeqSetLib':'dec_Set1'(V3, [17]),

case Tlv5 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv5}}}) % extra fields not allowed
end,
Res1 = {a_SeqImp3,Term1,Term2,Term3},
Res1.


%%================================
%%  SeqCompOf
%%================================
enc_SeqCompOf(Val) ->
    enc_SeqCompOf(Val, [<<48>>]).

enc_SeqCompOf(Val, TagIn) ->
{_,Cindex1,Cindex2,Cindex3} = Val,

%%-------------------------------------------------
%% attribute boolS3(1) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes1,EncLen1} = encode_boolean(Cindex1, [<<1>>]),

%%-------------------------------------------------
%% attribute seqS3(2) with type SEQUENCE
%%-------------------------------------------------
   {EncBytes2,EncLen2} = 'enc_SeqCompOf_seqS3'(Cindex2, [<<48>>]),

%%-------------------------------------------------
%% attribute intS3(3) with type INTEGER
%%-------------------------------------------------
   {EncBytes3,EncLen3} = encode_integer(Cindex3, [<<2>>]),

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
encode_tags(TagIn, BytesSoFar, LenSoFar).



%%================================
%%  SeqCompOf_seqS3
%%================================
enc_SeqCompOf_seqS3(Val, TagIn) ->
   {_,Cindex1,Cindex2} = Val,

%%-------------------------------------------------
%% attribute boolIn(1) with type BOOLEAN
%%-------------------------------------------------
   {EncBytes1,EncLen1} = encode_boolean(Cindex1, [<<1>>]),

%%-------------------------------------------------
%% attribute intIn(2) with type INTEGER
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_integer(Cindex2, [<<2>>]),

   BytesSoFar = [EncBytes1, EncBytes2],
LenSoFar = EncLen1 + EncLen2,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_SeqCompOf(Tlv) ->
   dec_SeqCompOf(Tlv, [16]).

dec_SeqCompOf(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute boolS3(1) with type BOOLEAN OPTIONAL
%%-------------------------------------------------
{Term1,Tlv2} = case Tlv1 of
[{1,V1}|TempTlv2] ->
    {decode_boolean(V1, []), TempTlv2};
    _ ->
        { asn1_NOVALUE, Tlv1}
end,

%%-------------------------------------------------
%% attribute seqS3(2) with type SEQUENCE OPTIONAL
%%-------------------------------------------------
{Term2,Tlv3} = case Tlv2 of
[{16,V2}|TempTlv3] ->
    {'dec_SeqCompOf_seqS3'(V2, []), TempTlv3};
    _ ->
        { asn1_NOVALUE, Tlv2}
end,

%%-------------------------------------------------
%% attribute intS3(3) with type INTEGER OPTIONAL
%%-------------------------------------------------
{Term3,Tlv4} = case Tlv3 of
[{2,V3}|TempTlv4] ->
    {decode_integer(V3, []), TempTlv4};
    _ ->
        { asn1_NOVALUE, Tlv3}
end,

case Tlv4 of [] -> true; _ -> true end, % ... extra fields skipped
Res1 = {a_SeqCompOf,Term1,Term2,Term3},
Res1.
'dec_SeqCompOf_seqS3'(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute boolIn(1) with type BOOLEAN
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = decode_boolean(V1, [1]),

%%-------------------------------------------------
%% attribute intIn(2) with type INTEGER
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = decode_integer(V2, [2]),

case Tlv3 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv3}}}) % extra fields not allowed
end,
Res1 = {a_SeqCompOf_seqS3,Term1,Term2},
Res1.

%%%
%%% Run-time functions.
%%%

'dialyzer-suppressions'(Arg) ->
    ok.

ber_decode_nif(B) ->
    asn1rt_nif:decode_ber_tlv(B).

decode_boolean(Tlv, TagIn) ->
    Val = match_tags(Tlv, TagIn),
    case Val of
        <<0:8>> ->
            false;
        <<_:8>> ->
            true;
        _ ->
            exit({error, {asn1, {decode_boolean, Val}}})
    end.

decode_integer(Tlv, TagIn) ->
    Bin = match_tags(Tlv, TagIn),
    Len = byte_size(Bin),
    <<Int:Len/signed-unit:8>> = Bin,
    Int.

encode_boolean(true, TagIn) ->
    encode_tags(TagIn, [255], 1);
encode_boolean(false, TagIn) ->
    encode_tags(TagIn, [0], 1);
encode_boolean(X, _) ->
    exit({error, {asn1, {encode_boolean, X}}}).

encode_integer(Val) ->
    Bytes =
        if
            Val >= 0 ->
                encode_integer_pos(Val, []);
            true ->
                encode_integer_neg(Val, [])
        end,
    {Bytes, length(Bytes)}.

encode_integer(Val, Tag) when is_integer(Val) ->
    encode_tags(Tag, encode_integer(Val));
encode_integer(Val, _Tag) ->
    exit({error, {asn1, {encode_integer, Val}}}).

encode_integer_neg(-1, [B1 | _T] = L) when B1 > 127 ->
    L;
encode_integer_neg(N, Acc) ->
    encode_integer_neg(N bsr 8, [N band 255 | Acc]).

encode_integer_pos(0, [B | _Acc] = L) when B < 128 ->
    L;
encode_integer_pos(N, Acc) ->
    encode_integer_pos(N bsr 8, [N band 255 | Acc]).

encode_length(L) when L =< 127 ->
    {[L], 1};
encode_length(L) ->
    Oct = minimum_octets(L),
    Len = length(Oct),
    if
        Len =< 126 ->
            {[128 bor Len | Oct], Len + 1};
        true ->
            exit({error, {asn1, too_long_length_oct, Len}})
    end.

encode_tags(TagIn, {BytesSoFar, LenSoFar}) ->
    encode_tags(TagIn, BytesSoFar, LenSoFar).

encode_tags([Tag | Trest], BytesSoFar, LenSoFar) ->
    {Bytes2, L2} = encode_length(LenSoFar),
    encode_tags(Trest,
                [Tag, Bytes2 | BytesSoFar],
                LenSoFar + byte_size(Tag) + L2);
encode_tags([], BytesSoFar, LenSoFar) ->
    {BytesSoFar, LenSoFar}.

match_tags({T, V}, [T]) ->
    V;
match_tags({T, V}, [T | Tt]) ->
    match_tags(V, Tt);
match_tags([{T, V}], [T | Tt]) ->
    match_tags(V, Tt);
match_tags([{T, _V} | _] = Vlist, [T]) ->
    Vlist;
match_tags(Tlv, []) ->
    Tlv;
match_tags({Tag, _V} = Tlv, [T | _Tt]) ->
    exit({error, {asn1, {wrong_tag, {{expected, T}, {got, Tag, Tlv}}}}}).

minimum_octets(0, Acc) ->
    Acc;
minimum_octets(Val, Acc) ->
    minimum_octets(Val bsr 8, [Val band 255 | Acc]).

minimum_octets(Val) ->
    minimum_octets(Val, []).
