<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/erts/emulator/make_test_dir/emulator_test/efile_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%</i>
<a name="2"/>    2: <i>%% %CopyrightBegin%</i>
<a name="3"/>    3: <i>%% </i>
<a name="4"/>    4: <i>%% Copyright Ericsson AB 1997-2022. All Rights Reserved.</i>
<a name="5"/>    5: <i>%% </i>
<a name="6"/>    6: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="7"/>    7: <i>%% you may not use this file except in compliance with the License.</i>
<a name="8"/>    8: <i>%% You may obtain a copy of the License at</i>
<a name="9"/>    9: <i>%%</i>
<a name="10"/>   10: <i>%%     http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="11"/>   11: <i>%%</i>
<a name="12"/>   12: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="13"/>   13: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="14"/>   14: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="15"/>   15: <i>%% See the License for the specific language governing permissions and</i>
<a name="16"/>   16: <i>%% limitations under the License.</i>
<a name="17"/>   17: <i>%% </i>
<a name="18"/>   18: <i>%% %CopyrightEnd%</i>
<a name="19"/>   19: 
<a name="20"/>   20: <b>-module</b>(efile_SUITE).
<a name="21"/>   21: <b>-export</b>([all/0, suite/0]).
<a name="22"/>   22: <b>-export</b>([init_per_testcase/2, end_per_testcase/2]).
<a name="23"/>   23: <b>-export</b>([iter_max_files/1, proc_zero_sized_files/1]).
<a name="24"/>   24: 
<a name="25"/>   25: <b>-export</b>([do_iter_max_files/2]).
<a name="26"/>   26: 
<a name="27"/>   27: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="28"/>   28: <b>-include_lib</b>(&quot;stdlib/include/assert.hrl&quot;).
<a name="29"/>   29: 
<a name="suite-0"/><a name="suite-last_expr"/><a name="30"/>   30: <b>suite</b>() -&gt; [{ct_hooks,[ts_install_cth]}].
<a name="31"/>   31: 
<a name="all-0"/><a name="32"/>   32: <b>all</b>() -&gt; 
<a name="all-last_expr"/><a name="33"/>   33:     [iter_max_files, proc_zero_sized_files].
<a name="34"/>   34: 
<a name="35"/>   35: 
<a name="init_per_testcase-2"/><a name="36"/>   36: <b>init_per_testcase</b>(_TestCase, Config) -&gt;
<a name="init_per_testcase-last_expr"/><a name="37"/>   37:     Config.
<a name="end_per_testcase-2"/><a name="38"/>   38: <b>end_per_testcase</b>(_TestCase, Config) -&gt;
<a name="end_per_testcase-last_expr"/><a name="39"/>   39: <b>    erts_test_utils:ept_check_leaked_nodes</b>(Config).
<a name="40"/>   40: 
<a name="41"/>   41: <i>%%</i>
<a name="42"/>   42: <i>%% Open as many files as possible. Do this several times and check </i>
<a name="43"/>   43: <i>%% that we get the same number of files every time.</i>
<a name="44"/>   44: <i>%%</i>
<a name="45"/>   45: 
<a name="iter_max_files-1"/><a name="46"/>   46: <b>iter_max_files</b>(Config) when is_list(Config) -&gt;
<a name="iter_max_files-last_expr"/><a name="47"/>   47: <b>    case os:type</b>() of
<a name="48"/>   48:         {win32, _} -&gt; {skip, &quot;Windows lacks a hard limit on file handles&quot;};
<a name="49"/>   49:         _ -&gt; iter_max_files_1(Config)
<a name="50"/>   50:     end.
<a name="51"/>   51: 
<a name="iter_max_files_1-1"/><a name="52"/>   52: <b>iter_max_files_1</b>(Config) -&gt;
<a name="53"/>   53:     DataDir = proplists:get_value(data_dir,Config),
<a name="54"/>   54:     TestFile = filename:join(DataDir, &quot;existing_file&quot;),
<a name="55"/>   55:     case erlang:system_info(debug_compiled) of
<a name="56"/>   56:         true -&gt;
<a name="57"/>   57:             N = 5;
<a name="58"/>   58:         false -&gt;
<a name="59"/>   59:             N = 10
<a name="60"/>   60:     end,
<a name="61"/>   61:     %% Run on a different node in order to make the test more stable.
<a name="62"/>   62:     {ok, Peer, Node} = ?CT_PEER(),
<a name="63"/>   63:     L = rpc:call(Node,?MODULE,do_iter_max_files,[N, TestFile]),
<a name="64"/>   64:     peer:stop(Peer),
<a name="65"/>   65:     io:format(&quot;Number of files opened in each test:~n~w\n&quot;, [L]),
<a name="66"/>   66:     verify_max_files(L),
<a name="67"/>   67:     Head = hd(L),
<a name="68"/>   68:     if  Head &gt;= 2 -&gt; ok;
<a name="69"/>   69:         true -&gt; ct:fail(too_few_files)
<a name="70"/>   70:     end,
<a name="iter_max_files_1-last_expr"/><a name="71"/>   71: <b>    {comment, &quot;Max files: &quot; ++ integer_to_list</b>(hd(L))}.
<a name="72"/>   72: 
<a name="do_iter_max_files-2"/><a name="73"/>   73: <b>do_iter_max_files</b>(N, Name) when N &gt; 0 -&gt; 
<a name="74"/>   74:     [max_files(Name)| do_iter_max_files(N-1, Name)];
<a name="75"/>   75: <b>do_iter_max_files</b>(_, _) -&gt;
<a name="do_iter_max_files-last_expr"/><a name="76"/>   76:     [].
<a name="77"/>   77: 
<a name="78"/>   78: <i>%% The attempts shouldn't vary too much; we used to require that they were all</i>
<a name="79"/>   79: <i>%% exactly equal, but after we reimplemented the file driver as a NIF we</i>
<a name="80"/>   80: <i>%% noticed that the only reason it was stable on Darwin was because the port</i>
<a name="81"/>   81: <i>%% limit was hit before ulimit.</i>
<a name="verify_max_files-1"/><a name="82"/>   82: <b>verify_max_files</b>(Attempts) -&gt;
<a name="83"/>   83:     N = length(Attempts),
<a name="84"/>   84:     Mean = lists:sum(Attempts) / N,
<a name="85"/>   85:     Variance = lists:sum([(X - Mean) * (X - Mean) || X &lt;- Attempts]) / N,
<a name="verify_max_files-last_expr"/><a name="86"/>   86: <b>    true = math:sqrt</b>(Variance) =&lt; 1 + (Mean / 1000).
<a name="87"/>   87: 
<a name="max_files-1"/><a name="88"/>   88: <b>max_files</b>(Name) -&gt;
<a name="89"/>   89:     Fds = open_files(Name),
<a name="90"/>   90:     N = length(Fds),
<a name="91"/>   91:     close_files(Fds),
<a name="max_files-last_expr"/><a name="92"/>   92:     N.
<a name="93"/>   93: 
<a name="close_files-1"/><a name="94"/>   94: <b>close_files</b>([Fd| Fds]) -&gt;
<a name="95"/>   95:     file:close(Fd),
<a name="96"/>   96:     close_files(Fds);
<a name="97"/>   97: <b>close_files</b>([]) -&gt;
<a name="close_files-last_expr"/><a name="98"/>   98:     ok.
<a name="99"/>   99: 
<a name="open_files-1"/><a name="100"/>  100: <b>open_files</b>(Name) -&gt;
<a name="open_files-last_expr"/><a name="101"/>  101: <b>    case file:open</b>(Name, [read,raw]) of
<a name="102"/>  102:         {ok, Fd} -&gt;
<a name="103"/>  103:             [Fd| open_files(Name)];
<a name="104"/>  104:         {error, _Reason} -&gt;
<a name="105"/>  105:             %		  io:format(&quot;Error reason: ~p&quot;, [_Reason]),
<a name="106"/>  106:             []
<a name="107"/>  107:     end.
<a name="108"/>  108: 
<a name="109"/>  109: <i>%% @doc If /proc filesystem exists (no way to know if it is real proc or just</i>
<a name="110"/>  110: <i>%% a /proc directory), let's read some zero sized files 500 times each, while</i>
<a name="111"/>  111: <i>%% ensuring that response isn't empty &lt;&lt; &gt;&gt;</i>
<a name="proc_zero_sized_files-1"/><a name="112"/>  112: <b>proc_zero_sized_files</b>(Config) when is_list(Config) -&gt;
<a name="113"/>  113:     TestFiles0 = [%% Some files which exist on Linux but might be missing on
<a name="114"/>  114:                   %% other systems
<a name="115"/>  115:                   &quot;/proc/cpuinfo&quot;,
<a name="116"/>  116:                   &quot;/proc/meminfo&quot;,
<a name="117"/>  117:                   &quot;/proc/partitions&quot;,
<a name="118"/>  118:                   &quot;/proc/swaps&quot;,
<a name="119"/>  119:                   &quot;/proc/version&quot;,
<a name="120"/>  120:                   &quot;/proc/uptime&quot;,
<a name="121"/>  121:                   %% curproc is present on FreeBSD
<a name="122"/>  122:                   &quot;/proc/curproc/cmdline&quot;],
<a name="123"/>  123: 
<a name="124"/>  124:     TestFiles = [F || F &lt;- TestFiles0, filelib:is_file(F)],
<a name="125"/>  125: 
<a name="proc_zero_sized_files-last_expr"/><a name="126"/>  126:     case TestFiles of
<a name="127"/>  127:         [_|_] -&gt;
<a name="128"/>  128:             %% For 6 inputs and 500 attempts each this do run anywhere
<a name="129"/>  129:             %% between 500 and 3000 function calls.
<a name="130"/>  130:             [do_proc_zero_sized(F, 500) || F &lt;- TestFiles],
<a name="131"/>  131:             ok;
<a name="132"/>  132:         [] -&gt;
<a name="133"/>  133:             {skip, &quot;Failed to find any known zero-sized files&quot;}
<a name="134"/>  134:     end.
<a name="135"/>  135: 
<a name="136"/>  136: <i>%% @doc Test one file N times to also trigger possible leaking fds and memory</i>
<a name="do_proc_zero_sized-2"/><a name="137"/>  137: <b>do_proc_zero_sized</b>(_Filename, 0) -&gt; ok;
<a name="138"/>  138: <b>do_proc_zero_sized</b>(Filename, N) -&gt;
<a name="139"/>  139:     Data = file:read_file(Filename),
<a name="140"/>  140:     ?assertNotEqual(&lt;&lt;&gt;&gt;, Data),
<a name="do_proc_zero_sized-last_expr"/><a name="141"/>  141: <b>    do_proc_zero_sized</b>(Filename, N-1).
</pre>
</body>
</html>
