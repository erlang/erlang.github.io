<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/lib/ssl/make_test_dir/ssl_test/ssl_pem_cache_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%</i>
<a name="2"/>    2: <i>%% %CopyrightBegin%</i>
<a name="3"/>    3: <i>%%</i>
<a name="4"/>    4: <i>%% Copyright Ericsson AB 2015-2023. All Rights Reserved.</i>
<a name="5"/>    5: <i>%%</i>
<a name="6"/>    6: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="7"/>    7: <i>%% you may not use this file except in compliance with the License.</i>
<a name="8"/>    8: <i>%% You may obtain a copy of the License at</i>
<a name="9"/>    9: <i>%%</i>
<a name="10"/>   10: <i>%%     http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="11"/>   11: <i>%%</i>
<a name="12"/>   12: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="13"/>   13: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="14"/>   14: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="15"/>   15: <i>%% See the License for the specific language governing permissions and</i>
<a name="16"/>   16: <i>%% limitations under the License.</i>
<a name="17"/>   17: <i>%%</i>
<a name="18"/>   18: <i>%% %CopyrightEnd%</i>
<a name="19"/>   19: <i>%%</i>
<a name="20"/>   20: <i>%% (Note: See the document internal_doc/pem_and_cert_cache.md for additional</i>
<a name="21"/>   21: <i>%% information)</i>
<a name="22"/>   22: <i>%%</i>
<a name="23"/>   23: 
<a name="24"/>   24: <b>-module</b>(ssl_pem_cache_SUITE).
<a name="25"/>   25: 
<a name="26"/>   26: <b>-behaviour</b>(ct_suite).
<a name="27"/>   27: 
<a name="28"/>   28: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="29"/>   29: <b>-include_lib</b>(&quot;kernel/include/file.hrl&quot;).
<a name="30"/>   30: <b>-include_lib</b>(&quot;public_key/include/public_key.hrl&quot;).
<a name="31"/>   31: <b>-include</b>(&quot;ssl_test_lib.hrl&quot;).
<a name="32"/>   32: 
<a name="33"/>   33: <i>%% Callback functions</i>
<a name="34"/>   34: <b>-export</b>([all/0,
<a name="35"/>   35:          groups/0,
<a name="36"/>   36:          init_per_suite/1,
<a name="37"/>   37:          end_per_suite/1,
<a name="38"/>   38:          init_per_group/2,
<a name="39"/>   39:          end_per_group/2,
<a name="40"/>   40:          init_per_testcase/2,
<a name="41"/>   41:          end_per_testcase/2]).
<a name="42"/>   42: 
<a name="43"/>   43: <i>%% Testcases</i>
<a name="44"/>   44: <b>-export</b>([pem_certfile_keyfile_periodical_cleanup/0,
<a name="45"/>   45:          pem_certfile_keyfile_periodical_cleanup/1,
<a name="46"/>   46:          pem_cacertfile_periodical_cleanup/0,
<a name="47"/>   47:          pem_cacertfile_periodical_cleanup/1,
<a name="48"/>   48:          pem_manual_cleanup/0,
<a name="49"/>   49:          pem_manual_cleanup/1,
<a name="50"/>   50:          invalid_insert/0,
<a name="51"/>   51:          invalid_insert/1,
<a name="52"/>   52:          new_root_pem_manual_cleanup/0,
<a name="53"/>   53:          new_root_pem_manual_cleanup/1,
<a name="54"/>   54:          new_root_pem_periodical_cleanup/0,
<a name="55"/>   55:          new_root_pem_periodical_cleanup/1,
<a name="56"/>   56:          new_root_pem_no_cleanup/0,
<a name="57"/>   57:          new_root_pem_no_cleanup/1,
<a name="58"/>   58:          new_root_pem_no_cleanup_symlink/0,
<a name="59"/>   59:          new_root_pem_no_cleanup_symlink/1,
<a name="60"/>   60:          new_root_pem_no_cleanup_hardlink/0,
<a name="61"/>   61:          new_root_pem_no_cleanup_hardlink/1,
<a name="62"/>   62:          alternative_path_hardlink/0,
<a name="63"/>   63:          alternative_path_hardlink/1,
<a name="64"/>   64:          alternative_path_symlink/0,
<a name="65"/>   65:          alternative_path_symlink/1,
<a name="66"/>   66:          alternative_path_noabspath/0,
<a name="67"/>   67:          alternative_path_noabspath/1,
<a name="68"/>   68:          alternative_path_symlink_relative/0,
<a name="69"/>   69:          alternative_path_symlink_relative/1,
<a name="70"/>   70:          check_cert/3
<a name="71"/>   71:         ]).
<a name="72"/>   72: 
<a name="73"/>   73: <b>-define</b>(CLEANUP_INTERVAL, 5000).
<a name="74"/>   74: <b>-define</b>(BIG_CLEANUP_INTERVAL, 600000).
<a name="75"/>   75: <b>-define</b>(SLEEP_AMOUNT, 1000).
<a name="76"/>   76: <b>-define</b>(KEY(NUMBER), ssl_test_lib:hardcode_rsa_key(NUMBER)).
<a name="77"/>   77: 
<a name="78"/>   78: <i>%%--------------------------------------------------------------------</i>
<a name="79"/>   79: <i>%% Common Test interface functions -----------------------------------</i>
<a name="80"/>   80: <i>%%--------------------------------------------------------------------</i>
<a name="all-0"/><a name="81"/>   81: <b>all</b>() -&gt;
<a name="all-last_expr"/><a name="82"/>   82:     [pem_certfile_keyfile_periodical_cleanup,
<a name="83"/>   83:      pem_cacertfile_periodical_cleanup,
<a name="84"/>   84:      pem_manual_cleanup,
<a name="85"/>   85:      invalid_insert,
<a name="86"/>   86:      new_root_pem_manual_cleanup,
<a name="87"/>   87:      new_root_pem_periodical_cleanup,
<a name="88"/>   88:      new_root_pem_no_cleanup,
<a name="89"/>   89:      new_root_pem_no_cleanup_symlink,
<a name="90"/>   90:      new_root_pem_no_cleanup_hardlink,
<a name="91"/>   91:      alternative_path_noabspath,
<a name="92"/>   92:      alternative_path_hardlink,
<a name="93"/>   93:      alternative_path_symlink,
<a name="94"/>   94:      alternative_path_symlink_relative].
<a name="95"/>   95: 
<a name="groups-0"/><a name="groups-last_expr"/><a name="96"/>   96: <b>groups</b>() -&gt; [].
<a name="97"/>   97: 
<a name="init_per_suite-1"/><a name="98"/>   98: <b>init_per_suite</b>(Config0) -&gt;
<a name="99"/>   99:     catch application:stop(crypto),
<a name="init_per_suite-last_expr"/><a name="100"/>  100: <b>    try application:start</b>(crypto) of
<a name="101"/>  101: 	ok -&gt;
<a name="102"/>  102: 	    ssl_test_lib:clean_start(),
<a name="103"/>  103: 	    %% make rsa certs
<a name="104"/>  104:             ssl_test_lib:make_rsa_cert(Config0)
<a name="105"/>  105:     catch _:_ -&gt;
<a name="106"/>  106: 	    {skip, &quot;Crypto did not start&quot;}
<a name="107"/>  107:     end.
<a name="108"/>  108: 
<a name="end_per_suite-1"/><a name="109"/>  109: <b>end_per_suite</b>(_Config) -&gt;
<a name="end_per_suite-last_expr"/><a name="110"/>  110: <b>    application:stop</b>(crypto).
<a name="111"/>  111: 
<a name="init_per_group-2"/><a name="112"/>  112: <b>init_per_group</b>(_GroupName, Config) -&gt;
<a name="init_per_group-last_expr"/><a name="113"/>  113:     Config.
<a name="114"/>  114: 
<a name="end_per_group-2"/><a name="115"/>  115: <b>end_per_group</b>(_GroupName, Config) -&gt;
<a name="end_per_group-last_expr"/><a name="116"/>  116:     Config.
<a name="117"/>  117: 
<a name="init_per_testcase-2"/><a name="118"/>  118: <b>init_per_testcase</b>(pem_certfile_keyfile_periodical_cleanup = Case, Config) -&gt;
<a name="119"/>  119:     adjust_pem_periodical_cleanup_interval(Case, Config, ?CLEANUP_INTERVAL),
<a name="120"/>  120:     ssl:clear_pem_cache(),
<a name="121"/>  121:     Config;
<a name="122"/>  122: <b>init_per_testcase</b>(pem_cacertfile_periodical_cleanup = Case, Config) -&gt;
<a name="123"/>  123:     adjust_pem_periodical_cleanup_interval(Case, Config, ?CLEANUP_INTERVAL),
<a name="124"/>  124:     ssl:clear_pem_cache(),
<a name="125"/>  125:     Config;
<a name="126"/>  126: <b>init_per_testcase</b>(new_root_pem_periodical_cleanup = Case, Config) -&gt;
<a name="127"/>  127:     adjust_pem_periodical_cleanup_interval(Case, Config, ?CLEANUP_INTERVAL),
<a name="128"/>  128:     ssl:clear_pem_cache(),
<a name="129"/>  129:     Config;
<a name="130"/>  130: <b>init_per_testcase</b>(new_root_pem_manual_cleanup = Case, Config) -&gt;
<a name="131"/>  131:     adjust_pem_periodical_cleanup_interval(Case, Config, ?BIG_CLEANUP_INTERVAL),
<a name="132"/>  132:     ssl:clear_pem_cache(),
<a name="133"/>  133:     Config;
<a name="134"/>  134: <b>init_per_testcase</b>(_Case, Config) -&gt;
<a name="135"/>  135:     ssl_test_lib:clean_start(),
<a name="136"/>  136:     ssl:clear_pem_cache(),
<a name="137"/>  137:     ct:timetrap({seconds, 20}),
<a name="init_per_testcase-last_expr"/><a name="138"/>  138:     Config.
<a name="139"/>  139: 
<a name="adjust_pem_periodical_cleanup_interval-3"/><a name="140"/>  140: <b>adjust_pem_periodical_cleanup_interval</b>(Case, Config, Interval) -&gt;
<a name="141"/>  141:     application:load(ssl),
<a name="142"/>  142:     end_per_testcase(Case, Config) ,
<a name="143"/>  143:     application:set_env(ssl, ssl_pem_cache_clean, Interval),
<a name="144"/>  144:     ssl:start(),
<a name="adjust_pem_periodical_cleanup_interval-last_expr"/><a name="145"/>  145: <b>    ct:timetrap</b>({minutes, 1}).
<a name="146"/>  146: 
<a name="end_per_testcase-2"/><a name="147"/>  147: <b>end_per_testcase</b>(_TestCase, Config) -&gt;
<a name="148"/>  148:     ssl_test_lib:clean_env(),
<a name="149"/>  149:     ssl:stop(),
<a name="end_per_testcase-last_expr"/><a name="150"/>  150:     Config.
<a name="151"/>  151: 
<a name="152"/>  152: <i>%%--------------------------------------------------------------------</i>
<a name="153"/>  153: <i>%% Test Cases --------------------------------------------------------</i>
<a name="154"/>  154: <i>%%--------------------------------------------------------------------</i>
<a name="pem_certfile_keyfile_periodical_cleanup-0"/><a name="155"/>  155: <b>pem_certfile_keyfile_periodical_cleanup</b>() -&gt;
<a name="pem_certfile_keyfile_periodical_cleanup-last_expr"/><a name="156"/>  156:     [{doc, &quot;Test PEM cache invalidate mechanism using mtime attribute &quot;
<a name="157"/>  157:       &quot;adjustment - certfile and keyfile.&quot;}].
<a name="158"/>  158: <i>%% 1. establish TLS connection</i>
<a name="159"/>  159: <i>%% 2. mtime adjusted for certfile, keyfile for server</i>
<a name="160"/>  160: <i>%% 3. during cleanup:</i>
<a name="161"/>  161: <i>%%    1. 2 files removed from PEM Cache</i>
<a name="162"/>  162: <i>%%    2. Ca trust store and its references mapping tables are not affected    </i>
<a name="163"/>  163: <i>%% 4. After TLS disconnect only the PEM cache is populated</i>
<a name="pem_certfile_keyfile_periodical_cleanup-1"/><a name="164"/>  164: <b>pem_certfile_keyfile_periodical_cleanup</b>(Config) when is_list(Config) -&gt;
<a name="165"/>  165:     Expected = #{init =&gt; [0, 0, 0, 0], connected =&gt; [6, 6, 2, 2],
<a name="166"/>  166:                 cleaned =&gt; [4, 6, 2, 2], disconnected =&gt; [4, 0, 0, 0]},
<a name="pem_certfile_keyfile_periodical_cleanup-last_expr"/><a name="167"/>  167: <b>    pem_periodical_cleanup</b>(Config, [certfile, keyfile], Expected, false).
<a name="168"/>  168: 
<a name="pem_cacertfile_periodical_cleanup-0"/><a name="169"/>  169: <b>pem_cacertfile_periodical_cleanup</b>() -&gt;
<a name="pem_cacertfile_periodical_cleanup-last_expr"/><a name="170"/>  170:     [{doc, &quot;Test pem cache invalidate mechanism using mtime attribute &quot;
<a name="171"/>  171:       &quot;adjustment - cacertfile.&quot;}].
<a name="172"/>  172: <i>%% 1. establish TLS connection</i>
<a name="173"/>  173: <i>%% 2. mtime adjusted for cacertfile for server</i>
<a name="174"/>  174: <i>%% 3. during cleanup:</i>
<a name="175"/>  175: <i>%%    1. 1 file removed from PEM Cache</i>
<a name="176"/>  176: <i>%%    2. The file will however be reentered as it is a CA file that is</i>
<a name="177"/>  177: <i>%%       referenced </i>
<a name="178"/>  178: <i>%% 4. After TLS disconnect only the PEM cache is populated</i>
<a name="pem_cacertfile_periodical_cleanup-1"/><a name="179"/>  179: <b>pem_cacertfile_periodical_cleanup</b>(Config) when is_list(Config) -&gt;
<a name="180"/>  180:     Expected = #{init =&gt; [0, 0, 0, 0], connected =&gt; [6, 6, 2, 2],
<a name="181"/>  181:                  cleaned =&gt; [6, 6, 2, 2], disconnected =&gt; [6, 0, 0, 0]},
<a name="pem_cacertfile_periodical_cleanup-last_expr"/><a name="182"/>  182: <b>    pem_periodical_cleanup</b>(Config, [cacertfile], Expected, true).
<a name="183"/>  183: 
<a name="pem_manual_cleanup-0"/><a name="184"/>  184: <b>pem_manual_cleanup</b>() -&gt;
<a name="pem_manual_cleanup-last_expr"/><a name="185"/>  185:     [{doc,&quot;Test that internal reference table is cleaned properly even when &quot;
<a name="186"/>  186:       &quot; the PEM cache is cleared&quot; }].
<a name="187"/>  187: <i>%% 1. establish 1st TLS connection</i>
<a name="188"/>  188: <i>%% 2. The server and client process will now have a reference to its CA file </i>
<a name="189"/>  189: <i>%% 3. ssl:clear_pem_cache() will empty the PEM cache but as we have</i>
<a name="190"/>  190: <i>%%    references to the CAfiles they will be read back, and possible updated</i>
<a name="191"/>  191: <i>%%    in the CA store. (Will not happen in this test).</i>
<a name="192"/>  192: <i>%% 4. establish 2nd TLS connection</i>
<a name="193"/>  193: <i>%% 5. Now there will be two server and two client processes in total 4 references</i>
<a name="194"/>  194: <i>%% 6. The same files are used for both connections so the total amount of file is</i>
<a name="195"/>  195: <i>%%    still 6.</i>
<a name="196"/>  196: <i>%% 7. Upon disconnecting summed ref counters are reduced to 2 and 0 </i>
<a name="197"/>  197: <i>%%    When there is no reference to a CA file (the entries for its CA certs)</i>
<a name="198"/>  198: <i>%%    will be removed from the CA store. All files will still be cached.</i>
<a name="199"/>  199: <i>%% 10. Clear the PEM cache and check that it is empty.</i>
<a name="pem_manual_cleanup-1"/><a name="200"/>  200: <b>pem_manual_cleanup</b>(Config) when is_list(Config) -&gt;
<a name="201"/>  201:     %% Initialy all tables are empty. First size will be nubmer of
<a name="202"/>  202:     %% files (PEM cache), second size will be number of CA certs (CA store), 
<a name="203"/>  203:     %% third and forth number of CA files (used for reference counting and mapping
<a name="204"/>  204:     %% from filename to ref key)
<a name="205"/>  205:     [0, 0, 0, 0] = get_table_sizes(),
<a name="206"/>  206: 
<a name="207"/>  207:     {Server, Client} = basic_verify_test_no_close(Config),
<a name="208"/>  208:     2 = get_total_number_of_references(),
<a name="209"/>  209:     %% 6 files (cacerts,cert,key x 2), 6 CA certs in 2 different CA files
<a name="210"/>  210:     [6, 6, 2, 2] = get_table_sizes(),
<a name="211"/>  211: 
<a name="212"/>  212:     ssl:clear_pem_cache(),                              
<a name="213"/>  213:     [2, 6, 2, 2] = get_table_sizes(), %% Pemcache cleared and used CAs read back
<a name="214"/>  214: 
<a name="215"/>  215:     {Server1, Client1} = basic_verify_test_no_close(Config),
<a name="216"/>  216:     %% Total 4 processes reference a CA file
<a name="217"/>  217:     4 = get_total_number_of_references(),
<a name="218"/>  218:     %% New connection causes keys end entity certs and keys to be cached again
<a name="219"/>  219:     [6, 6, 2, 2] = get_table_sizes(),
<a name="220"/>  220: 
<a name="221"/>  221:     [ssl_test_lib:close(A) || A &lt;- [Server, Client]],
<a name="222"/>  222:     [6, 6, 2, 2] = get_table_sizes(), %% All CA files are still referenced
<a name="223"/>  223:     %% Total 2 processes reference a CA file
<a name="224"/>  224:     2 = get_total_number_of_references(),
<a name="225"/>  225: 
<a name="226"/>  226:     [ssl_test_lib:close(A) || A &lt;- [Server1, Client1]],
<a name="227"/>  227:      %% No processes reference a CA file
<a name="228"/>  228:     0 = get_total_number_of_references(),
<a name="229"/>  229:     %% All files are still cached
<a name="230"/>  230:     [6, 0, 0, 0] = get_table_sizes(),
<a name="231"/>  231: 
<a name="232"/>  232:     ssl:clear_pem_cache(),
<a name="pem_manual_cleanup-last_expr"/><a name="233"/>  233: <b>    [0, 0, 0, 0] = get_table_sizes</b>().
<a name="234"/>  234: 
<a name="invalid_insert-0"/><a name="235"/>  235: <b>invalid_insert</b>() -&gt;
<a name="invalid_insert-last_expr"/><a name="236"/>  236:     [{doc, &quot;Test that insert of invalid pem does not cause empty cache entry&quot;}].
<a name="237"/>  237: <i>%% 1. attempt to establish TLS connection with client passing invalid path in</i>
<a name="238"/>  238: <i>%%    cacertfile option</i>
<a name="239"/>  239: <i>%% 2. verify PEM Cache table is populated with options passed by server</i>
<a name="240"/>  240: <i>%% 3. connection is not established as error happens during handshake, </i>
<a name="241"/>  241: <i>%%    when client tries to open file passed in cacertfile option</i>
<a name="242"/>  242: <i>%% 4. verify Cert, CaFileRef tables are empty and the reference count is zero</i>
<a name="invalid_insert-1"/><a name="243"/>  243: <b>invalid_insert</b>(Config) when is_list(Config) -&gt;
<a name="244"/>  244:     process_flag(trap_exit, true),
<a name="245"/>  245:     [0, 0, 0, 0] = get_table_sizes(),  %% Initialy all tables are empty
<a name="246"/>  246:     ClientOpts = ssl_test_lib:ssl_options(client_rsa_verify_opts, Config),
<a name="247"/>  247:     ServerOpts = ssl_test_lib:ssl_options(server_rsa_verify_opts, Config),
<a name="248"/>  248:     {ClientNode, ServerNode, Hostname} = ssl_test_lib:run_where(Config),
<a name="249"/>  249:     BadClientOpts = [{cacertfile, &quot;tmp/does_not_exist.pem&quot;} |
<a name="250"/>  250:                      proplists:delete(cacertfile, ClientOpts)],
<a name="251"/>  251:     Server =
<a name="252"/>  252: 	ssl_test_lib:start_server([{node, ServerNode}, {port, 0},
<a name="253"/>  253: 				   {from, self()},
<a name="254"/>  254: 				   {mfa, {ssl_test_lib, no_result, []}},
<a name="255"/>  255: 				   {options, ServerOpts}]),
<a name="256"/>  256:     Port = ssl_test_lib:inet_port(Server),
<a name="257"/>  257:     ssl_test_lib:start_client_error([{node, ClientNode},
<a name="258"/>  258:                                {port, Port}, {host, Hostname},
<a name="259"/>  259:                                {from, self()}, {options, BadClientOpts}]),
<a name="260"/>  260:     [3, 0, 0, 0] = get_table_sizes(), %% Server options are cached and bad client options ignored
<a name="261"/>  261:     0 = get_total_number_of_references(),
<a name="invalid_insert-last_expr"/><a name="262"/>  262: <b>    [3, 0, 0, 0] = get_table_sizes</b>(). %% Cache is still valid
<a name="263"/>  263: 
<a name="new_root_pem_manual_cleanup-0"/><a name="264"/>  264: <b>new_root_pem_manual_cleanup</b>() -&gt;
<a name="new_root_pem_manual_cleanup-last_expr"/><a name="265"/>  265: <b>    [{doc, &quot;Test that changed PEM-files on disk followed by ssl:clear_pem_cache</b>()&quot;
<a name="266"/>  266:       &quot; invalidates trusted CA cache as well as ordinary PEM cache. &quot;
<a name="267"/>  267:       &quot;This test case recreates a PEM file, resulting with its actual content change.&quot;}].
<a name="268"/>  268: <i>%% 1. ITERATE below over 2 cert chains</i>
<a name="269"/>  269: <i>%%    1. in one scenario overwritten cert chain has the same private keys - so both</i>
<a name="270"/>  270: <i>%%       cert chains are 'compatible'</i>
<a name="271"/>  271: <i>%%    2. in second scenario overwrittern cert chain has a differet private key for</i>
<a name="272"/>  272: <i>%%       intermediate cert - cert chains are not 'compatible'</i>
<a name="273"/>  273: <i>%% 2. create initial config in PEM files - 1st cert chain is created</i>
<a name="274"/>  274: <i>%% 3. make 1st TLS connection</i>
<a name="275"/>  275: <i>%% 4. verify cert on client side by:</i>
<a name="276"/>  276: <i>%%    1. get server Cert with ssl:peercert(Socket)</i>
<a name="277"/>  277: <i>%%    2. extract trusted certs from file - load data from disk</i>
<a name="278"/>  278: <i>%%    3. with CA certs extracted from file, attempt to build a chain for server Cert</i>
<a name="279"/>  279: <i>%%    4. verify that RootCert found is the same as one passed as argument</i>
<a name="280"/>  280: <i>%% 5. check tables are populated as expected</i>
<a name="281"/>  281: <i>%% 6. (copy server cacertfile to separate file - for checking chain with not</i>
<a name="282"/>  282: <i>%%    cleanup flow)</i>
<a name="283"/>  283: <i>%% 7. overwrite config in PEM files - server cert chain is updated</i>
<a name="284"/>  284: <i>%% 8. check in-memory tables were not changed even though files on disk are updated</i>
<a name="285"/>  285: <i>%% 9. -&gt; ssl:clear_pem_cache() / ct:sleep() -</i>
<a name="286"/>  286: <i>%% 10. check PemCache is empty CaRefCnt and CaFileRef tables are unchanged</i>
<a name="287"/>  287: <i>%% 11. check Cert table was update (certificate conntent was updated)</i>
<a name="288"/>  288: <i>%% 12. make 2nd TLS connection</i>
<a name="289"/>  289: <i>%% 13. verify server cert on client side (use NEW server root as argument)</i>
<a name="290"/>  290: <i>%% 14. check the sum of  counters is 4 - 2 connections using same cert data</i>
<a name="291"/>  291: <i>%% 15. check CaFileRef table contains same data as for 1st connection</i>
<a name="292"/>  292: <i>%% 16. check Cert table was reloaded with different certs</i>
<a name="293"/>  293: <i>%% 17. check PemCache table was loaded with different file content</i>
<a name="294"/>  294: <i>%% 18. close connections in a sequence, check sum of counters value and final</i>
<a name="295"/>  295: <i>%%     content of tables (connection related should be empty when last connection</i>
<a name="296"/>  296: <i>%%     is terminated)</i>
<a name="new_root_pem_manual_cleanup-1"/><a name="297"/>  297: <b>new_root_pem_manual_cleanup</b>(Config) when is_list(Config) -&gt;
<a name="298"/>  298:     Expected = #{init =&gt; [0, 0, 0, 0], connected1 =&gt; [6, 6, 2, 2],
<a name="299"/>  299:                  cleaned =&gt; [2, 6, 2, 2], connected2 =&gt; [6, 6, 2, 2],
<a name="300"/>  300:                  disconnected1 =&gt; [6, 6, 2, 2], disconnected2 =&gt; [6,0,0,0]},
<a name="301"/>  301:     new_root_pem_helper(Config, manual, Expected, fun identity/1),
<a name="302"/>  302:     %% verify also same key sequence for initial and overwritten certs PEM files
<a name="new_root_pem_manual_cleanup-last_expr"/><a name="303"/>  303: <b>    new_root_pem_helper</b>(Config, manual, Expected, fun identity/1, 5).
<a name="304"/>  304: 
<a name="new_root_pem_periodical_cleanup-0"/><a name="305"/>  305: <b>new_root_pem_periodical_cleanup</b>() -&gt;
<a name="new_root_pem_periodical_cleanup-last_expr"/><a name="306"/>  306:     [{doc, &quot;Test that changed PEM-files on disk followed by periodical cleanup&quot;
<a name="307"/>  307:       &quot; invalidates trusted CA store as well as ordinary PEM cache. &quot;
<a name="308"/>  308:       &quot;This test case recreates a PEM file, resulting with its actual content change.&quot;}].
<a name="309"/>  309: <i>%% see new_root_pem_manual_cleanup for specification</i>
<a name="new_root_pem_periodical_cleanup-1"/><a name="310"/>  310: <b>new_root_pem_periodical_cleanup</b>(Config) when is_list(Config) -&gt;
<a name="311"/>  311:     ExpectedStats = #{init =&gt; [0, 0, 0, 0], connected1 =&gt; [6, 6, 2, 2],
<a name="312"/>  312:                       cleaned =&gt; [2, 6, 2, 2], connected2 =&gt; [6, 6, 2, 2],
<a name="313"/>  313:                       disconnected1 =&gt; [6, 6, 2, 2], disconnected2 =&gt; [6,0,0,0]},
<a name="314"/>  314:     new_root_pem_helper(Config, periodical, ExpectedStats, fun identity/1),
<a name="315"/>  315:     %% verify also same key sequence for initial and overwritten certs PEM files
<a name="new_root_pem_periodical_cleanup-last_expr"/><a name="316"/>  316: <b>    new_root_pem_helper</b>(Config, periodical, ExpectedStats, fun identity/1, 5).
<a name="317"/>  317: 
<a name="new_root_pem_no_cleanup-0"/><a name="318"/>  318: <b>new_root_pem_no_cleanup</b>() -&gt;
<a name="new_root_pem_no_cleanup-last_expr"/><a name="319"/>  319:     [{doc, &quot;Test that changed PEM-files on disk not followed by any cleanup&quot;
<a name="320"/>  320:       &quot; will not be used for making connection.&quot;
<a name="321"/>  321:       &quot;This test case recreates a PEM file, resulting with its actual content change.&quot;}].
<a name="322"/>  322: <i>%% 1. for link variant, replace path in ClientConf with a link - both</i>
<a name="323"/>  323: <i>%%    connection will use links on client side</i>
<a name="324"/>  324: <i>%% 2. create initial config in PEM files - 1st cert chain is created</i>
<a name="325"/>  325: <i>%% 3. make 1st TLS connection</i>
<a name="326"/>  326: <i>%% 4. verify server cert on client side by:</i>
<a name="327"/>  327: <i>%%    1. get server Cert with ssl:peercert(Socket)</i>
<a name="328"/>  328: <i>%%    2. extract trusted certs from file - load data from disk</i>
<a name="329"/>  329: <i>%%    3. with CA certs extracted from file, attempt to build a chain for server Cert</i>
<a name="330"/>  330: <i>%%    4. verify that RootCert found is the same as one passed as argument</i>
<a name="331"/>  331: <i>%% 5. check tables are populated as expected</i>
<a name="332"/>  332: <i>%% 6. (copy server cacertfile to separate file - for checking chain with not</i>
<a name="333"/>  333: <i>%%    cleanup flow)</i>
<a name="334"/>  334: <i>%% 7. overwrite config in PEM files - server cert chain is updated</i>
<a name="335"/>  335: <i>%% 8. check in-memory tables were not changed even though files on disk are updated</i>
<a name="336"/>  336: <i>%% 9. make 2nd TLS connection</i>
<a name="337"/>  337: <i>%% 10. verify server cert on client side (use the same server root as argument)</i>
<a name="338"/>  338: <i>%% 11. check the sum of  counters is 4 - 2 connections using same cert data</i>
<a name="339"/>  339: <i>%% 12. check PemCache and Cert tables hold the same data as for 1st connection</i>
<a name="340"/>  340: <i>%% 13. close connections in a sequence, check sum of counters value and final</i>
<a name="341"/>  341: <i>%%     content of tables (connection related should be empty when last connection</i>
<a name="342"/>  342: <i>%%     is terminated)</i>
<a name="new_root_pem_no_cleanup-1"/><a name="343"/>  343: <b>new_root_pem_no_cleanup</b>(Config) when is_list(Config) -&gt;
<a name="344"/>  344:     ExpectedStats = #{init =&gt; [0, 0, 0, 0], connected1 =&gt; [6, 6, 2, 2],
<a name="345"/>  345:                       cleaned =&gt; [6, 6, 2, 2], connected2 =&gt; [6, 6, 2, 2],
<a name="346"/>  346:                       disconnected1 =&gt; [6, 6, 2, 2], disconnected2 =&gt; [6,0,0,0]},
<a name="new_root_pem_no_cleanup-last_expr"/><a name="347"/>  347: <b>    new_root_pem_helper</b>(Config, no_cleanup, ExpectedStats, fun identity/1).
<a name="348"/>  348: 
<a name="new_root_pem_no_cleanup_symlink-0"/><a name="349"/>  349: <b>new_root_pem_no_cleanup_symlink</b>() -&gt;
<a name="new_root_pem_no_cleanup_symlink-last_expr"/><a name="350"/>  350:     [{doc, &quot;Test that changed PEM-files on disk not followed by any cleanup&quot;
<a name="351"/>  351:       &quot; will not be used for making connection - even with symlink. &quot;
<a name="352"/>  352:       &quot;This test case recreates a PEM file, resulting with its actual content change.&quot;}].
<a name="353"/>  353: <i>%% see new_root_pem_no_cleanup for specification</i>
<a name="new_root_pem_no_cleanup_symlink-1"/><a name="354"/>  354: <b>new_root_pem_no_cleanup_symlink</b>(Config) when is_list(Config) -&gt;
<a name="355"/>  355:     ExpectedStats = #{init =&gt; [0, 0, 0, 0], connected1 =&gt; [6, 6, 2, 2],
<a name="356"/>  356:                       cleaned =&gt; [6, 6, 2, 2], connected2 =&gt; [6, 6, 2, 2],
<a name="357"/>  357:                       disconnected1 =&gt; [6, 6, 2, 2], disconnected2 =&gt; [6,0,0,0]},
<a name="new_root_pem_no_cleanup_symlink-last_expr"/><a name="358"/>  358: <b>    new_root_pem_helper</b>(Config, no_cleanup, ExpectedStats, fun make_symlink/1).
<a name="359"/>  359: 
<a name="new_root_pem_no_cleanup_hardlink-0"/><a name="360"/>  360: <b>new_root_pem_no_cleanup_hardlink</b>() -&gt;
<a name="new_root_pem_no_cleanup_hardlink-last_expr"/><a name="361"/>  361:     [{doc, &quot;Test that changed PEM-files on disk not followed by any cleanup&quot;
<a name="362"/>  362:       &quot; will not be used for making connection - even with hardlink. &quot;
<a name="363"/>  363:       &quot;This test case recreates a PEM file, resulting with its actual content change.&quot;}].
<a name="364"/>  364: <i>%% see new_root_pem_no_cleanup for specification</i>
<a name="new_root_pem_no_cleanup_hardlink-1"/><a name="365"/>  365: <b>new_root_pem_no_cleanup_hardlink</b>(Config) when is_list(Config) -&gt;
<a name="366"/>  366:     ExpectedStats = #{init =&gt; [0, 0, 0, 0], connected1 =&gt; [6, 6, 2, 2],
<a name="367"/>  367:                       cleaned =&gt; [6, 6, 2, 2], connected2 =&gt; [6, 6, 2, 2],
<a name="368"/>  368:                       disconnected1 =&gt; [6, 6, 2, 2], disconnected2 =&gt; [6,0,0,0]},
<a name="new_root_pem_no_cleanup_hardlink-last_expr"/><a name="369"/>  369: <b>    new_root_pem_helper</b>(Config, no_cleanup, ExpectedStats, fun make_hardlink/1).
<a name="370"/>  370: 
<a name="alternative_path_hardlink-0"/><a name="371"/>  371: <b>alternative_path_hardlink</b>() -&gt;
<a name="alternative_path_hardlink-last_expr"/><a name="372"/>  372:     [{doc,&quot;Test that internal reference table contains expected data for&quot;
<a name="373"/>  373:       &quot; absolute and hard link. &quot;
<a name="374"/>  374:       &quot;This test verifies handling of same file with an alternative reference.&quot;}].
<a name="375"/>  375: <i>%% 1. copy client cacertfile to CWD</i>
<a name="376"/>  376: <i>%% 2. establish connection using client CA cert file specified with full path</i>
<a name="377"/>  377: <i>%% 3. check sum of counters is 2</i>
<a name="378"/>  378: <i>%% 4. check table sizes</i>
<a name="379"/>  379: <i>%% 5. establish connection using client CA cert file specified with alternative</i>
<a name="380"/>  380: <i>%%    - hardlink, symlink or just filename instead of path</i>
<a name="381"/>  381: <i>%% 6. check sum of counters is 4</i>
<a name="382"/>  382: <i>%% 7. check table sizes</i>
<a name="383"/>  383: <i>%% 8. copy client CA cert file into sub-directory</i>
<a name="384"/>  384: <i>%% 9. change CWD to subdirectory</i>
<a name="385"/>  385: <i>%% 10. establish connection using client CA cert file specified with alternative</i>
<a name="386"/>  386: <i>%%    - hardlink, symlink or just filename instead of path</i>
<a name="alternative_path_hardlink-1"/><a name="387"/>  387: <b>alternative_path_hardlink</b>(Config) when is_list(Config) -&gt;
<a name="388"/>  388:     Expected = #{init =&gt; [0, 0, 0, 0], connected1 =&gt; [6, 6, 2, 2],
<a name="389"/>  389:                  connected2 =&gt; [7, 9, 3, 3], connected3 =&gt; [8, 12, 4, 4],
<a name="390"/>  390:                  disconnected =&gt; [8, 0, 0, 0]},
<a name="alternative_path_hardlink-last_expr"/><a name="391"/>  391: <b>    alternative_path_helper</b>(Config, fun make_hardlink/1, Expected).
<a name="392"/>  392: 
<a name="alternative_path_symlink-0"/><a name="393"/>  393: <b>alternative_path_symlink</b>() -&gt;
<a name="alternative_path_symlink-last_expr"/><a name="394"/>  394:     [{doc,&quot;Test that internal reference table contains only one instance of data &quot;
<a name="395"/>  395:       &quot;for absolute path and symbolic link pointing to same file.&quot;
<a name="396"/>  396:       &quot;This test verifies handling of same file with an alternative reference.&quot;
<a name="397"/>  397:       &quot;Symlink is expected to be converted to absolute file path - &quot;
<a name="398"/>  398:       &quot;as a result establishing 2nd connection should not add new data to tables.&quot;}].
<a name="399"/>  399: <i>%% see alternative_path_hardlink for detailed specification</i>
<a name="alternative_path_symlink-1"/><a name="400"/>  400: <b>alternative_path_symlink</b>(Config) when is_list(Config) -&gt;
<a name="401"/>  401:     Expected = #{init =&gt; [0, 0, 0, 0], connected1 =&gt; [6, 6, 2, 2],
<a name="402"/>  402:                  connected2 =&gt; [6, 6, 2, 2], connected3 =&gt; [7, 9, 3, 3],
<a name="403"/>  403:                  disconnected =&gt; [7, 0, 0, 0]},
<a name="alternative_path_symlink-last_expr"/><a name="404"/>  404: <b>    alternative_path_helper</b>(Config, fun make_symlink/1, Expected).
<a name="405"/>  405: 
<a name="alternative_path_noabspath-0"/><a name="406"/>  406: <b>alternative_path_noabspath</b>() -&gt;
<a name="alternative_path_noabspath-last_expr"/><a name="407"/>  407:     [{doc,&quot;Test that internal reference table contains only one instance of data &quot;
<a name="408"/>  408:       &quot;for absolute and relative paths pointing to same file. &quot;
<a name="409"/>  409:       &quot;This test verifies handling of same file with an alternative reference.&quot;
<a name="410"/>  410:       &quot;Relative file path is expected to be converted to absolute file path  - &quot;
<a name="411"/>  411:       &quot;as a result establishing 2nd connection should not add new data to tables.&quot;}].
<a name="412"/>  412: <i>%% see alternative_path_hardlink for detailed specification</i>
<a name="alternative_path_noabspath-1"/><a name="413"/>  413: <b>alternative_path_noabspath</b>(Config) when is_list(Config) -&gt;
<a name="414"/>  414:     Expected = #{init =&gt; [0, 0, 0, 0], connected1 =&gt; [6, 6, 2, 2],
<a name="415"/>  415:                  connected2 =&gt; [6, 6, 2, 2], connected3 =&gt; [7, 9, 3, 3],
<a name="416"/>  416:                  disconnected =&gt; [7, 0, 0, 0]},
<a name="alternative_path_noabspath-last_expr"/><a name="417"/>  417: <b>    alternative_path_helper</b>(Config, fun strip_path/1, Expected).
<a name="418"/>  418: 
<a name="alternative_path_symlink_relative-0"/><a name="419"/>  419: <b>alternative_path_symlink_relative</b>() -&gt;
<a name="alternative_path_symlink_relative-last_expr"/><a name="420"/>  420:     [{doc,&quot;Test that internal reference table contains separate instance of data &quot;
<a name="421"/>  421:       &quot;for absolute path and relative symbolic ink pointing to a file in subdirectory.&quot;
<a name="422"/>  422:       &quot;This test verifies handling of different files.&quot;
<a name="423"/>  423:       &quot;Relative path to a symlink is expected to be converted to absolute file path - &quot;
<a name="424"/>  424:       &quot;as a result establishing 2nd connection should add new data to tables.&quot;}].
<a name="425"/>  425: <i>%% see alternative_path_hardlink for detailed specification</i>
<a name="alternative_path_symlink_relative-1"/><a name="426"/>  426: <b>alternative_path_symlink_relative</b>(Config) when is_list(Config) -&gt;
<a name="427"/>  427:     Expected = #{init =&gt; [0, 0, 0, 0], connected1 =&gt; [6, 6, 2, 2],
<a name="428"/>  428:                  connected2 =&gt; [7, 9, 3, 3], connected3 =&gt; [8, 12, 4, 4],
<a name="429"/>  429:                  disconnected =&gt; [8, 0, 0, 0]},
<a name="alternative_path_symlink_relative-last_expr"/><a name="430"/>  430: <b>    alternative_path_helper</b>(Config, fun make_symlink_noabspath/1, Expected).
<a name="431"/>  431: 
<a name="432"/>  432: <i>%%--------------------------------------------------------------------</i>
<a name="433"/>  433: <i>%% Internal functions</i>
<a name="434"/>  434: <i>%%--------------------------------------------------------------------</i>
<a name="get_table_sizes-0"/><a name="435"/>  435: <b>get_table_sizes</b>() -&gt;
<a name="436"/>  436:     ct:sleep(?SLEEP_AMOUNT),
<a name="437"/>  437:     DbSizes = [{Label, Db, ssl_pkix_db:db_size(Db)} ||
<a name="438"/>  438:                 {Label, Db} &lt;- get_table_refs()],
<a name="get_table_sizes-last_expr"/><a name="439"/>  439:     [Size || {_, _, Size} &lt;- DbSizes].
<a name="440"/>  440: 
<a name="get_total_number_of_references-0"/><a name="441"/>  441: <b>get_total_number_of_references</b>() -&gt;
<a name="442"/>  442:     CaFileRef = proplists:get_value(ca_ref_cnt, get_table_refs()),
<a name="443"/>  443:     CountReferencedFiles = fun({Ref, _}, Acc) -&gt;
<a name="444"/>  444:                                    ets:update_counter(CaFileRef,Ref,0) + Acc
<a name="445"/>  445:                            end,
<a name="get_total_number_of_references-last_expr"/><a name="446"/>  446: <b>    ets:foldl</b>(CountReferencedFiles, 0, CaFileRef).
<a name="447"/>  447: 
<a name="get_table_refs-0"/><a name="448"/>  448: <b>get_table_refs</b>() -&gt;
<a name="449"/>  449:     _ = sys:get_status(whereis(ssl_manager)),
<a name="450"/>  450:     _ = sys:get_status(whereis(ssl_pem_cache)),
<a name="451"/>  451:     {status, _, _, StatusInfo} = sys:get_status(whereis(ssl_manager)),
<a name="452"/>  452:     [_, _,_, _, Prop] = StatusInfo,
<a name="453"/>  453:     State = ssl_test_lib:state(Prop),
<a name="get_table_refs-last_expr"/><a name="454"/>  454: <b>    case element</b>(5, State) of
<a name="455"/>  455:         [Cert, {CaRefCnt, CaFileRef}, PemCache| _] -&gt;
<a name="456"/>  456:             [{pem_cache, PemCache},
<a name="457"/>  457:              {cert, Cert},
<a name="458"/>  458:              {ca_ref_cnt, CaRefCnt},
<a name="459"/>  459:              {ca_file_ref, CaFileRef}];
<a name="460"/>  460:         _ -&gt;
<a name="461"/>  461:             undefined
<a name="462"/>  462:     end.
<a name="463"/>  463: 
<a name="get_tables-0"/><a name="464"/>  464: <b>get_tables</b>() -&gt;
<a name="get_tables-last_expr"/><a name="465"/>  465: <b>    [{Id, get_table</b>(T)} || {Id, T} &lt;- get_table_refs()].
<a name="466"/>  466: 
<a name="check_tables-1"/><a name="467"/>  467: <b>check_tables</b>(ExpectedTables) -&gt;
<a name="468"/>  468:     ActualTables = [{Id, get_table(T)} || {Id, T} &lt;- get_table_refs(),
<a name="469"/>  469:                                           proplists:is_defined(Id, ExpectedTables)],
<a name="470"/>  470:     Zipped = lists:zip(ExpectedTables, ActualTables),
<a name="471"/>  471: 
<a name="472"/>  472:     CompareTables = fun({ExpectedLabel, ExpectedTable},
<a name="473"/>  473:                         {ActualLabel, ActualTable}) -&gt;
<a name="474"/>  474:                             ExpectedLabel = ActualLabel,
<a name="475"/>  475:                             ExpectedTableSorted = lists:sort(ExpectedTable),
<a name="476"/>  476:                             ActualTableSorted = lists:sort(ActualTable),
<a name="477"/>  477:                             case ExpectedTableSorted == ActualTableSorted of
<a name="478"/>  478:                                 true -&gt;
<a name="479"/>  479:                                     ok;
<a name="480"/>  480:                                 _ -&gt;
<a name="481"/>  481:                                     ?CT_PAL(&quot;Mismatch for table ~w&quot;, [ActualLabel]),
<a name="482"/>  482:                                     ?CT_PAL(&quot;Expected = ~w&quot;, [ExpectedTableSorted]),
<a name="483"/>  483:                                     ?CT_PAL(&quot;Actual = ~w&quot;, [ActualTableSorted]),
<a name="484"/>  484:                                     ct:fail({data_mismatch, ActualLabel})
<a name="485"/>  485:                             end
<a name="486"/>  486:                     end,
<a name="check_tables-last_expr"/><a name="487"/>  487: <b>    [CompareTables</b>(Expected, Actual) || {Expected, Actual} &lt;- Zipped].
<a name="488"/>  488: 
<a name="get_table-1"/><a name="489"/>  489: <b>get_table</b>(TableRef) -&gt;
<a name="get_table-last_expr"/><a name="490"/>  490: <b>    get_table</b>(TableRef, ets:first(TableRef), []).
<a name="491"/>  491: 
<a name="get_table-3"/><a name="492"/>  492: <b>get_table</b>(TableRef, Key, Acc) -&gt;
<a name="get_table-last_expr"/><a name="493"/>  493:     case Key of
<a name="494"/>  494:         '$end_of_table' -&gt;
<a name="495"/>  495:             Acc;
<a name="496"/>  496:         _ -&gt;
<a name="497"/>  497:             get_table(TableRef, ets:next(TableRef, Key),
<a name="498"/>  498:                       [ets:lookup(TableRef, Key) | Acc])
<a name="499"/>  499:     end.
<a name="500"/>  500: 
<a name="new_root_pem_helper-4"/><a name="501"/>  501: <b>new_root_pem_helper</b>(Config, CleanMode, ExpectedStats, TransformFun) -&gt;
<a name="502"/>  502:     %% by default use different key sequence for initial and overwritten certs PEM files
<a name="new_root_pem_helper-last_expr"/><a name="503"/>  503: <b>    new_root_pem_helper</b>(Config, CleanMode, ExpectedStats, TransformFun, 6).
<a name="new_root_pem_helper-5"/><a name="504"/>  504: <b>new_root_pem_helper</b>(Config, CleanMode,
<a name="505"/>  505:                    #{init := Init, connected1 := Connected1, cleaned := Cleaned,
<a name="506"/>  506:                     connected2 := Connected2, disconnected1 := Disconnected1,
<a name="507"/>  507:                     disconnected2 := Disconnected2} = _ExpectedStats, TransformFun,
<a name="508"/>  508:                     IntermediateServerKeyId) -&gt;
<a name="509"/>  509:     %% ExpectedStats map passed to function contains expected sizes of tables
<a name="510"/>  510:     %% holding various cert, cacert, keyfile data.
<a name="511"/>  511:     %% Init - represents initial state
<a name="512"/>  512:     %% ConnectedN - state after establishing Nth connection
<a name="513"/>  513:     %% Cleaned - state after periodical cleanup
<a name="514"/>  514:     %% DisconnectedN - state after closing Nth connection
<a name="515"/>  515:     ?CT_LOG(&quot;&gt;&gt;&gt; IntermediateServerKeyId = ~w&quot;, [IntermediateServerKeyId]),
<a name="516"/>  516:     {ServerCAFile, ClientConf0, ServerConf, ServerRootCert0, ClientBase, ServerBase} =
<a name="517"/>  517:         create_initial_config(Config),
<a name="518"/>  518: 
<a name="519"/>  519:     CACertfilePath = proplists:get_value(cacertfile, ClientConf0),
<a name="new_root_pem_helper-last_expr"/><a name="520"/>  520: <b>    case TransformFun</b>(CACertfilePath) of
<a name="521"/>  521:         {ok, TransformedPath} -&gt;
<a name="522"/>  522:             ClientConf = [{cacertfile, TransformedPath} | proplists:delete(cacertfile, ClientConf0)],
<a name="523"/>  523:             {ClientNode, ServerNode, Hostname} = ssl_test_lib:run_where(Config),
<a name="524"/>  524:             Init = get_table_sizes(),
<a name="525"/>  525:             {Client0, Server0} =
<a name="526"/>  526:                 make_connection_check_cert(ServerRootCert0, ClientNode, ClientConf,
<a name="527"/>  527:                                            ServerNode, ServerConf, Hostname, ServerCAFile),
<a name="528"/>  528:             Connected1 = get_table_sizes(),
<a name="529"/>  529:             [{pem_cache, PemCacheData0}, {cert, CertData0},
<a name="530"/>  530:              {ca_ref_cnt, CaRefCntData0}, {ca_file_ref, CaFileRefData0}] = get_tables(),
<a name="531"/>  531:             ServerCAFile0 = ServerCAFile ++ &quot;_original&quot;,
<a name="532"/>  532:             {ok, _} = file:copy(ServerCAFile, ServerCAFile0),
<a name="533"/>  533:             ServerRootCert =
<a name="534"/>  534:                 overwrite_files_with_new_configuration(ServerRootCert0,
<a name="535"/>  535:                                                        ClientBase, ServerBase,
<a name="536"/>  536:                                                        IntermediateServerKeyId),
<a name="537"/>  537:             check_tables([{pem_cache, PemCacheData0}, {cert, CertData0},
<a name="538"/>  538:                           {ca_ref_cnt, CaRefCntData0}, {ca_file_ref, CaFileRefData0}]),
<a name="539"/>  539:             case CleanMode of
<a name="540"/>  540:                 manual -&gt; ssl:clear_pem_cache();
<a name="541"/>  541:                 periodical -&gt; ct:sleep(round(1.5 * ?CLEANUP_INTERVAL));
<a name="542"/>  542:                 no_cleanup -&gt; ok
<a name="543"/>  543:             end,
<a name="544"/>  544:             Cleaned = get_table_sizes(),
<a name="545"/>  545: 
<a name="546"/>  546:             [{pem_cache, PemCacheData1}, {cert, CertData1},
<a name="547"/>  547:              {ca_ref_cnt, CaRefCntData1}, {ca_file_ref, _}] = get_tables(),
<a name="548"/>  548:             {Client1, Server1} = case CleanMode of
<a name="549"/>  549:                                      no_cleanup -&gt;
<a name="550"/>  550:                                          check_tables([{pem_cache, PemCacheData0},
<a name="551"/>  551:                                                        {cert, CertData0},
<a name="552"/>  552:                                                        {ca_ref_cnt, CaRefCntData0},
<a name="553"/>  553:                                                        {ca_file_ref, CaFileRefData0}]),
<a name="554"/>  554:                                          make_connection_check_cert(ServerRootCert0, ClientNode, ClientConf,
<a name="555"/>  555:                                                                     ServerNode, ServerConf, Hostname, ServerCAFile0);
<a name="556"/>  556:                                      _ -&gt;
<a name="557"/>  557:                                          false = (CertData1 == CertData0),
<a name="558"/>  558:                                          make_connection_check_cert(ServerRootCert, ClientNode, ClientConf,
<a name="559"/>  559:                                                                     ServerNode, ServerConf, Hostname, ServerCAFile)
<a name="560"/>  560:                                  end,
<a name="561"/>  561:             
<a name="562"/>  562:             4 = get_total_number_of_references(),
<a name="563"/>  563:             Connected2 = get_table_sizes(),
<a name="564"/>  564:             [{pem_cache, PemCacheData2}, {cert, CertData2},
<a name="565"/>  565:              {ca_ref_cnt, CaRefCntData2}, {ca_file_ref, _}] = get_tables(),
<a name="566"/>  566:             case CleanMode of
<a name="567"/>  567:                 no_cleanup -&gt;
<a name="568"/>  568:                     check_tables([{pem_cache, PemCacheData0},
<a name="569"/>  569:                                   {cert, CertData0}]);
<a name="570"/>  570:                 _ -&gt;
<a name="571"/>  571:                     check_tables([{ca_file_ref, CaFileRefData0}]),
<a name="572"/>  572:                     false = (CertData0 == CertData2),
<a name="573"/>  573:                     false = (PemCacheData0 == PemCacheData2)
<a name="574"/>  574:             end,
<a name="575"/>  575:             true = (CaRefCntData2 /= CaRefCntData1),
<a name="576"/>  576: 
<a name="577"/>  577:             [ssl_test_lib:close(A) || A &lt;- [Client1, Server1]],
<a name="578"/>  578:             2 = get_total_number_of_references(),
<a name="579"/>  579:             Disconnected1 = get_table_sizes(),
<a name="580"/>  580: 
<a name="581"/>  581:             case CleanMode of
<a name="582"/>  582:                 no_cleanup -&gt;
<a name="583"/>  583:                     check_tables([{pem_cache, PemCacheData1}]);
<a name="584"/>  584:                 _ -&gt;
<a name="585"/>  585:                     check_tables([{pem_cache, PemCacheData2}])
<a name="586"/>  586:             end,
<a name="587"/>  587:             check_tables([{cert, CertData1}, {ca_ref_cnt, CaRefCntData0},
<a name="588"/>  588:                           {ca_file_ref, CaFileRefData0}]),
<a name="589"/>  589:             [ssl_test_lib:close(A) || A &lt;- [Client0, Server0]],
<a name="590"/>  590:             0 = get_total_number_of_references(),
<a name="591"/>  591:             Disconnected2 = get_table_sizes(),
<a name="592"/>  592:             case CleanMode of
<a name="593"/>  593:                 no_cleanup -&gt;
<a name="594"/>  594:                     check_tables([{pem_cache, PemCacheData1}, {cert, []},
<a name="595"/>  595:                                   {ca_ref_cnt, []}, {ca_file_ref, []}]);
<a name="596"/>  596:                 _ -&gt;
<a name="597"/>  597:                     check_tables([{pem_cache, PemCacheData2}, {cert, []},
<a name="598"/>  598:                                   {ca_ref_cnt, []}, {ca_file_ref, []}])
<a name="599"/>  599:             end,
<a name="600"/>  600: 
<a name="601"/>  601:             ssl:clear_pem_cache(),
<a name="602"/>  602:             [0, 0, 0, 0] = get_table_sizes(),
<a name="603"/>  603:             ok;
<a name="604"/>  604:         {skip, Reason} -&gt;
<a name="605"/>  605:             {skip, Reason}
<a name="606"/>  606:     end.
<a name="607"/>  607: 
<a name="alternative_path_helper-3"/><a name="608"/>  608: <b>alternative_path_helper</b>(Config, GetAlternative,
<a name="609"/>  609:                   #{init := Init, connected1 := Connected1,
<a name="610"/>  610:                     connected2 := Connected2, connected3 := Connected3,
<a name="611"/>  611:                     disconnected := Disconnected}) -&gt;
<a name="612"/>  612:     %% ExpectedStats map passed to function contains expected sizes of tables
<a name="613"/>  613:     %% holding various cert, cacert, keyfile data.
<a name="614"/>  614:     %% Init - represents initial state
<a name="615"/>  615:     %% ConnectedN - state after establishing Nth connection
<a name="616"/>  616:     %% Disconnected - state after closing connections
<a name="617"/>  617:     ClientOpts = ssl_test_lib:ssl_options(client_rsa_verify_opts, Config),
<a name="618"/>  618:     CACertFilePath0 = ssl_test_lib:ssl_options(cacertfile, ClientOpts),
<a name="619"/>  619:     {ok, CACertFilename} = strip_path(CACertFilePath0),
<a name="620"/>  620:     {ok, Cwd} = file:get_cwd(),
<a name="621"/>  621: 
<a name="622"/>  622:     CACertFilePath1 = filename:join([Cwd, CACertFilename]),
<a name="623"/>  623:     {ok, _} = file:copy(CACertFilePath0, CACertFilePath1),
<a name="624"/>  624:     0 = get_total_number_of_references(),
<a name="625"/>  625:     Init = get_table_sizes(),
<a name="626"/>  626: 
<a name="627"/>  627:     %% connect with full path
<a name="628"/>  628:     {Server0, Client0} = basic_verify_test_no_close(
<a name="629"/>  629:                          replace_cacertfile(Config, CACertFilePath1)),
<a name="630"/>  630:     2 = get_total_number_of_references(),
<a name="631"/>  631:     Connected1 = get_table_sizes(),
<a name="632"/>  632: 
<a name="633"/>  633:     TestAlternative = fun(ExpectedTotalCounter, ExpectedSizes, CertPath) -&gt;
<a name="634"/>  634:                               case GetAlternative(CertPath) of
<a name="635"/>  635:                                   {skip, _} = R -&gt;
<a name="636"/>  636:                                       [{skip, R}];
<a name="637"/>  637:                                   {ok, Alternative} -&gt;
<a name="638"/>  638:                                       %% connect with filename only
<a name="639"/>  639:                                       {Server, Client} = basic_verify_test_no_close(
<a name="640"/>  640:                                                            replace_cacertfile(Config, Alternative)),
<a name="641"/>  641:                                       ExpectedTotalCounter = get_total_number_of_references(),
<a name="642"/>  642:                                       ExpectedSizes = get_table_sizes(),
<a name="643"/>  643:                                       [Server, Client]
<a name="644"/>  644:                               end
<a name="645"/>  645:                       end,
<a name="646"/>  646: 
<a name="647"/>  647:     R1 = TestAlternative(4, Connected2, CACertFilePath1),
<a name="648"/>  648: 
<a name="649"/>  649:     %% check that same filenames in different folders don't collide
<a name="650"/>  650:     SubDirPath = make_subdirectory(Cwd, &quot;subdir&quot;),
<a name="651"/>  651:     CACertFilePath2 = filename:join([SubDirPath, CACertFilename]),
<a name="652"/>  652: 
<a name="653"/>  653:     {ok, _} = file:copy(CACertFilePath0, CACertFilePath2),
<a name="654"/>  654:     ok = c:cd(SubDirPath),
<a name="655"/>  655:     R2 = TestAlternative(6, Connected3, CACertFilePath2),
<a name="656"/>  656: 
<a name="657"/>  657:     ProcessesCreated = R1 ++ R2,
<a name="alternative_path_helper-last_expr"/><a name="658"/>  658: <b>    case proplists:lookup</b>(skip, ProcessesCreated) of
<a name="659"/>  659:         none -&gt;
<a name="660"/>  660:             [ssl_test_lib:close(Actor) || Actor &lt;- [Server0, Client0] ++
<a name="661"/>  661:                                               ProcessesCreated],
<a name="662"/>  662:             ct:sleep(?SLEEP_AMOUNT),
<a name="663"/>  663:             _ = sys:get_status(whereis(ssl_manager)),
<a name="664"/>  664:             0 = get_total_number_of_references(),
<a name="665"/>  665:             Disconnected = get_table_sizes(),
<a name="666"/>  666:             ok;
<a name="667"/>  667:         {skip, Reason} -&gt;
<a name="668"/>  668:             {skip, Reason}
<a name="669"/>  669:     end.
<a name="670"/>  670: 
<a name="make_connection_check_cert-7"/><a name="671"/>  671: <b>make_connection_check_cert</b>(ServerRootCert, ClientNode, ClientConf, ServerNode,
<a name="672"/>  672:                            ServerConf, Hostname, ServerCAFile) -&gt;
<a name="673"/>  673:     Server =
<a name="674"/>  674: 	ssl_test_lib:start_server([{node, ServerNode}, {port, 0},
<a name="675"/>  675: 				   {from, self()},
<a name="676"/>  676: 				   {mfa, {ssl_test_lib, no_result, []}},
<a name="677"/>  677: 				   {options, ServerConf}]),
<a name="678"/>  678:     Port = ssl_test_lib:inet_port(Server),
<a name="679"/>  679:     Client =
<a name="680"/>  680: 	ssl_test_lib:start_client([{node, ClientNode},
<a name="681"/>  681:                                    {port, Port}, {host, Hostname},
<a name="682"/>  682: 				   {from, self()},
<a name="683"/>  683: 				   {mfa, {?MODULE, check_cert,
<a name="684"/>  684:                                           [ServerRootCert, ServerCAFile]}},
<a name="685"/>  685:                                    {options, [{verify, verify_peer} | ClientConf]}]),
<a name="686"/>  686: 
<a name="687"/>  687:     ssl_test_lib:check_result(Client, ok),
<a name="make_connection_check_cert-last_expr"/><a name="688"/>  688:     {Client, Server}.
<a name="689"/>  689: 
<a name="create_initial_config-1"/><a name="690"/>  690: <b>create_initial_config</b>(Config) -&gt;
<a name="691"/>  691:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="692"/>  692:     #{cert := ServerRootCert0} = SRoot =
<a name="693"/>  693:         public_key:pkix_test_root_cert(&quot;OTP test server ROOT&quot;,
<a name="694"/>  694:                                        [{key, ?KEY(6)}, {digest, sha256}]),
<a name="695"/>  695:     DerConfig =
<a name="696"/>  696:         public_key:pkix_test_data(
<a name="697"/>  697:           #{server_chain =&gt;
<a name="698"/>  698:                 #{root =&gt; SRoot,
<a name="699"/>  699:                   intermediates =&gt; [[{key, ?KEY(5)},  {digest, sha256}]],
<a name="700"/>  700:                   peer =&gt; [{key, ?KEY(4)},  {digest, sha256}]},
<a name="701"/>  701:             client_chain =&gt;
<a name="702"/>  702:                 #{root =&gt; [{key, ?KEY(1)},  {digest, sha256}],
<a name="703"/>  703:                   intermediates =&gt; [[{key, ?KEY(2)}, {digest, sha256} ]],
<a name="704"/>  704:                   peer =&gt; [{key, ?KEY(3)}]}}),
<a name="705"/>  705:     ClientBase = filename:join(PrivDir, &quot;client_test&quot;),
<a name="706"/>  706:     ServerBase = filename:join(PrivDir, &quot;server_test&quot;),
<a name="707"/>  707:     PemConfig = x509_test:gen_pem_config_files(DerConfig, ClientBase, ServerBase),
<a name="708"/>  708:     ClientConf = ssl_test_lib:ssl_options(client_config, PemConfig),
<a name="709"/>  709:     ServerConf = ssl_test_lib:ssl_options(server_config, PemConfig),
<a name="create_initial_config-last_expr"/><a name="710"/>  710: <b>    {proplists:get_value</b>(cacertfile, ServerConf), ClientConf, ServerConf, ServerRootCert0,
<a name="711"/>  711:     ClientBase, ServerBase}.
<a name="712"/>  712: 
<a name="overwrite_files_with_new_configuration-4"/><a name="713"/>  713: <b>overwrite_files_with_new_configuration</b>(ServerRootCert0, ClientBase,
<a name="714"/>  714:                                        ServerBase, IntermediateServerKey) -&gt;
<a name="715"/>  715:     Key = ?KEY(1),
<a name="716"/>  716:     OTPCert = public_key:pkix_decode_cert(ServerRootCert0, otp),
<a name="717"/>  717:     TBS = OTPCert#'OTPCertificate'.tbsCertificate,
<a name="718"/>  718:     #'RSAPrivateKey'{modulus=N, publicExponent=E} = Key,
<a name="719"/>  719:     Public = #'RSAPublicKey'{modulus=N, publicExponent=E},
<a name="720"/>  720:     Algo = #'PublicKeyAlgorithm'{algorithm= ?rsaEncryption, parameters='NULL'},
<a name="721"/>  721:     SPKI = #'OTPSubjectPublicKeyInfo'{algorithm = Algo,
<a name="722"/>  722:                                       subjectPublicKey = Public},
<a name="723"/>  723:     ServerRootCert1 = public_key:pkix_sign(TBS#'OTPTBSCertificate'{subjectPublicKeyInfo = SPKI}, Key),
<a name="724"/>  724:     DerConfig1 =
<a name="725"/>  725:         public_key:pkix_test_data(
<a name="726"/>  726:           #{server_chain =&gt;
<a name="727"/>  727:                 #{root =&gt; #{cert =&gt; ServerRootCert1, key =&gt; Key},
<a name="728"/>  728:                   intermediates =&gt; [[{key, ?KEY(IntermediateServerKey)}, {digest, sha256}]],
<a name="729"/>  729:                   peer =&gt; [{key, ?KEY(4)}, {digest, sha256} ]},
<a name="730"/>  730:             client_chain =&gt;
<a name="731"/>  731:                 #{root =&gt; [{key, ?KEY(1)}, {digest, sha256} ],
<a name="732"/>  732:                   intermediates =&gt; [[{key, ?KEY(2)},  {digest, sha256}]],
<a name="733"/>  733:                   peer =&gt; [{key, ?KEY(3)}, {digest, sha256}]}}),
<a name="734"/>  734:     %% Overwrite old config files
<a name="735"/>  735:     _ = x509_test:gen_pem_config_files(DerConfig1, ClientBase, ServerBase),
<a name="overwrite_files_with_new_configuration-last_expr"/><a name="736"/>  736:     ServerRootCert1.
<a name="737"/>  737: 
<a name="pem_periodical_cleanup-4"/><a name="738"/>  738: <b>pem_periodical_cleanup</b>(Config, FileIds,
<a name="739"/>  739:             #{init := Init, connected := Connected,
<a name="740"/>  740:               cleaned := Cleaned, disconnected := Disconnected} = _ExpectedStats, IsSame)-&gt;
<a name="741"/>  741:     %% ExpectedStats map passed to function contains expected sizes of tables
<a name="742"/>  742:     %% holding various cert, cacert, keyfile data.
<a name="743"/>  743:     %% Init - represents initial state
<a name="744"/>  744:     %% Connected - state after connection is established
<a name="745"/>  745:     %% Cleaned - state after periodical cleanup
<a name="746"/>  746:     %% Disconnected - state after disconnecting
<a name="747"/>  747:     process_flag(trap_exit, true),
<a name="748"/>  748:     %% wait so that certificate mtime is smaller the ssl_pem_cache start time
<a name="749"/>  749:     %% we want to avoid invalidation of all cert files - happens when server
<a name="750"/>  750:     %% start time and file mtime is the same number in seconds
<a name="751"/>  751:     %% and all files get invalidated
<a name="752"/>  752:     ct:sleep(4 * ?SLEEP_AMOUNT),
<a name="753"/>  753:     Init = get_table_sizes(),
<a name="754"/>  754: 
<a name="755"/>  755:     ServerOpts = ssl_test_lib:ssl_options(server_rsa_verify_opts, Config),
<a name="756"/>  756:     
<a name="757"/>  757:     {Server, Client} = basic_verify_test_no_close(Config),
<a name="758"/>  758: 
<a name="759"/>  759:     Connected = get_table_sizes(),
<a name="760"/>  760:     [{pem_cache, PemCacheData0}, {cert, CertData0}, {ca_ref_cnt, CaRefCntData0},
<a name="761"/>  761:      {ca_file_ref, CaFileRefData0}] = get_tables(),
<a name="762"/>  762: 
<a name="763"/>  763:     MakeLookingYounger =
<a name="764"/>  764:         fun (Type) -&gt;
<a name="765"/>  765:                 %% make file looking like modified recently
<a name="766"/>  766:                 Certfile = proplists:get_value(Type, ServerOpts),
<a name="767"/>  767:                 {ok, #file_info{mtime = OriginalTime} = FileInfo} =
<a name="768"/>  768:                     file:read_file_info(Certfile),
<a name="769"/>  769:                 Time = later(),
<a name="770"/>  770:                 ok = file:write_file_info(Certfile, FileInfo#file_info{mtime = Time}),
<a name="771"/>  771:                 {Certfile, FileInfo, OriginalTime}
<a name="772"/>  772:         end,
<a name="773"/>  773: 
<a name="774"/>  774:     Memory = [MakeLookingYounger(F) || F &lt;- FileIds],
<a name="775"/>  775:     ct:sleep(round(1.5 * ?CLEANUP_INTERVAL)),
<a name="776"/>  776:     _ = sys:get_status(whereis(ssl_manager)),
<a name="777"/>  777:     Result =
<a name="778"/>  778:         try
<a name="779"/>  779:             Cleaned = get_table_sizes(),
<a name="780"/>  780:             [{pem_cache, PemCacheData1}, _, _, _] = get_tables(),
<a name="781"/>  781:             check_tables([{pem_cache, PemCacheData1}, {cert, CertData0}, {ca_ref_cnt, CaRefCntData0},
<a name="782"/>  782:                           {ca_file_ref, CaFileRefData0}]),
<a name="783"/>  783: 
<a name="784"/>  784:             [] = [{missing, Row} || Row &lt;- PemCacheData1,
<a name="785"/>  785:                                     not lists:member(Row, PemCacheData0)],
<a name="786"/>  786:             case IsSame of
<a name="787"/>  787:                 true -&gt;
<a name="788"/>  788:                     [] = PemCacheData0 -- PemCacheData1;
<a name="789"/>  789:                 _ -&gt;
<a name="790"/>  790:                     ok
<a name="791"/>  791:             end,
<a name="792"/>  792: 
<a name="793"/>  793:             %% restore original mtime attributes
<a name="794"/>  794:             [ok = file:write_file_info(C, F#file_info{mtime = OT}) ||
<a name="795"/>  795:                 {C, F, OT} &lt;- Memory],
<a name="796"/>  796: 
<a name="797"/>  797:             [ssl_test_lib:close(A) || A &lt;- [Server, Client]],
<a name="798"/>  798:             Disconnected = get_table_sizes(),
<a name="799"/>  799:             ok
<a name="800"/>  800:         catch _:Reason:ST -&gt;
<a name="801"/>  801:                 {Reason,ST}
<a name="802"/>  802:         end,
<a name="pem_periodical_cleanup-last_expr"/><a name="803"/>  803:     case Result of
<a name="804"/>  804:         ok -&gt;
<a name="805"/>  805:             ok;
<a name="806"/>  806:         _ -&gt;
<a name="807"/>  807:             ct:fail(Result)
<a name="808"/>  808:     end.
<a name="809"/>  809: 
<a name="later-0"/><a name="810"/>  810: <b>later</b>()-&gt;
<a name="811"/>  811:     DateTime = calendar:now_to_local_time(os:timestamp()),
<a name="812"/>  812:     Gregorian = calendar:datetime_to_gregorian_seconds(DateTime),
<a name="later-last_expr"/><a name="813"/>  813: <b>    calendar:gregorian_seconds_to_datetime</b>(Gregorian + (2 * ?CLEANUP_INTERVAL)).
<a name="814"/>  814: 
<a name="basic_verify_test_no_close-1"/><a name="815"/>  815: <b>basic_verify_test_no_close</b>(Config) -&gt;
<a name="816"/>  816:     ClientOpts = ssl_test_lib:ssl_options(client_rsa_opts, Config),
<a name="817"/>  817:     ServerOpts = ssl_test_lib:ssl_options(server_rsa_opts, Config),
<a name="818"/>  818: 
<a name="819"/>  819:     {ClientNode, ServerNode, Hostname} = ssl_test_lib:run_where(Config),
<a name="820"/>  820: 
<a name="821"/>  821:     Server = ssl_test_lib:start_server([{node, ServerNode}, {port, 0},
<a name="822"/>  822: 					{from, self()},
<a name="823"/>  823: 					{mfa, {ssl_test_lib, send_recv_result_active, []}},
<a name="824"/>  824: 					{options, ServerOpts}]),
<a name="825"/>  825:     Port = ssl_test_lib:inet_port(Server),
<a name="826"/>  826:     Client = ssl_test_lib:start_client([{node, ClientNode}, {port, Port},
<a name="827"/>  827: 					{host, Hostname},
<a name="828"/>  828: 					{from, self()},
<a name="829"/>  829: 					{mfa, {ssl_test_lib, send_recv_result_active, []}},
<a name="830"/>  830: 					{options, ClientOpts}]),
<a name="831"/>  831:     ssl_test_lib:check_result(Server, ok, Client, ok),
<a name="basic_verify_test_no_close-last_expr"/><a name="832"/>  832:     {Server, Client}.
<a name="833"/>  833: 
<a name="replace_cacertfile-2"/><a name="834"/>  834: <b>replace_cacertfile</b>(Config, CACertFile) -&gt;
<a name="835"/>  835:     ClientOpts0 = ssl_test_lib:ssl_options(client_rsa_opts, Config),
<a name="836"/>  836:     ClientOpts = [{cacertfile, CACertFile} | proplists:delete(cacertfile, ClientOpts0)],
<a name="replace_cacertfile-last_expr"/><a name="837"/>  837: <b>    [{client_rsa_opts, ClientOpts} | proplists:delete</b>(client_rsa_opts, Config)].
<a name="838"/>  838: 
<a name="check_cert-3"/><a name="839"/>  839: <b>check_cert</b>(Socket, RootCert, File) -&gt;
<a name="840"/>  840:     {ok, Cert} = ssl:peercert(Socket),
<a name="841"/>  841:     {ok, Extracted} = ssl_pkix_db:extract_trusted_certs(File),
<a name="842"/>  842:     {ok, RootCert, _} = ssl_certificate:certificate_chain(Cert, ets:new(foo, []),
<a name="843"/>  843:                                                           Extracted, [], encoded),
<a name="check_cert-last_expr"/><a name="844"/>  844:     ok.
<a name="845"/>  845: 
<a name="strip_path-1"/><a name="846"/>  846: <b>strip_path</b>(AbsPath) -&gt;
<a name="strip_path-last_expr"/><a name="847"/>  847: <b>    {ok, lists:last</b>(filename:split(AbsPath))}.
<a name="848"/>  848: 
<a name="make_hardlink-1"/><a name="849"/>  849: <b>make_hardlink</b>(AbsPath) -&gt;
<a name="850"/>  850:     LinkPath = AbsPath ++ &quot;_hardlink&quot;,
<a name="make_hardlink-last_expr"/><a name="851"/>  851: <b>    case file:make_link</b>(AbsPath, LinkPath) of
<a name="852"/>  852:         ok -&gt;
<a name="853"/>  853:             {ok, LinkPath};
<a name="854"/>  854:         Reason -&gt;
<a name="855"/>  855:             {skip, Reason}
<a name="856"/>  856:     end.
<a name="857"/>  857: 
<a name="make_symlink-1"/><a name="858"/>  858: <b>make_symlink</b>(AbsPath) -&gt;
<a name="859"/>  859:     LinkPath = AbsPath ++ &quot;_symlink&quot;,
<a name="make_symlink-last_expr"/><a name="860"/>  860: <b>    case file:make_symlink</b>(AbsPath, LinkPath) of
<a name="861"/>  861:         ok -&gt;
<a name="862"/>  862:             {ok, LinkPath};
<a name="863"/>  863:         Reason -&gt;
<a name="864"/>  864:             {skip, Reason}
<a name="865"/>  865:     end.
<a name="866"/>  866: 
<a name="make_symlink_noabspath-1"/><a name="867"/>  867: <b>make_symlink_noabspath</b>(CACertFilePath1) -&gt;
<a name="868"/>  868:     {ok, Cwd} = file:get_cwd(),
<a name="869"/>  869:     {ok, CACertFilename1} = strip_path(CACertFilePath1),
<a name="870"/>  870: 
<a name="871"/>  871:     SubDir = &quot;foo&quot;,
<a name="872"/>  872:     SubDirPath = make_subdirectory(Cwd, SubDir),
<a name="873"/>  873:     CACertFilename2 = CACertFilename1 ++ &quot;_copy&quot;,
<a name="874"/>  874:     LinkName = CACertFilename2 ++ &quot;_symlink&quot;,
<a name="875"/>  875:     CACertFilePath2 = filename:join([SubDirPath, CACertFilename2]),
<a name="876"/>  876:     {ok, _} = file:copy(CACertFilePath1, CACertFilePath2),
<a name="make_symlink_noabspath-last_expr"/><a name="877"/>  877: <b>    case file:make_symlink</b>(CACertFilename2,
<a name="878"/>  878:                            filename:join([SubDirPath, LinkName])) of
<a name="879"/>  879:         ok -&gt;
<a name="880"/>  880:             {ok, filename:join([SubDir, LinkName])};
<a name="881"/>  881:         Reason -&gt;
<a name="882"/>  882:             {skip, Reason}
<a name="883"/>  883:     end.
<a name="884"/>  884: 
<a name="make_subdirectory-2"/><a name="885"/>  885: <b>make_subdirectory</b>(Cwd, SubDir) -&gt;
<a name="886"/>  886:     SubDirPath = filename:join([Cwd, SubDir]),
<a name="887"/>  887:     case file:read_file_info(SubDirPath) of
<a name="888"/>  888:         {error, enoent} -&gt;
<a name="889"/>  889:             ok = file:make_dir(SubDirPath);
<a name="890"/>  890:         _ -&gt;
<a name="891"/>  891:             ok
<a name="892"/>  892:     end,
<a name="make_subdirectory-last_expr"/><a name="893"/>  893:     SubDirPath.
<a name="894"/>  894: 
<a name="identity-1"/><a name="identity-last_expr"/><a name="895"/>  895: <b>identity</b>(Path) -&gt; {ok, Path}.
</pre>
<script>
var hash = window.location.hash.substring(1);
var anchor = document.getElementsByName(hash);
anchor[0].style.backgroundColor="orange";
</script>
</body>
</html>
