<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/lib/dialyzer/make_test_dir/dialyzer_test/iplt_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <b>-module</b>(iplt_SUITE).
<a name="2"/>    2: 
<a name="3"/>    3: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="4"/>    4: <b>-include_lib</b>(&quot;stdlib/include/assert.hrl&quot;).
<a name="5"/>    5: <b>-include_lib</b>(&quot;dialyzer/src/dialyzer.hrl&quot;).
<a name="6"/>    6: <b>-include</b>(&quot;dialyzer_test_constants.hrl&quot;).
<a name="7"/>    7: 
<a name="8"/>    8: <b>-export</b>([suite/0, all/0,
<a name="9"/>    9:          init_per_testcase/2,
<a name="10"/>   10:          end_per_testcase/2,
<a name="11"/>   11:          beam_tests/1,
<a name="12"/>   12:          local_fun_same_as_callback/1,
<a name="13"/>   13:          letrec_rvals/1,
<a name="14"/>   14:          missing_plt_file/1,
<a name="15"/>   15:          build_xdg_plt/1,
<a name="16"/>   16:          mod_dep_from_behaviour/1,
<a name="17"/>   17:          mod_dep_from_record_definition_field_value_default_used/1,
<a name="18"/>   18:          mod_dep_from_record_definition_field_value_default_unused/1,
<a name="19"/>   19:          mod_dep_from_record_definition_field_type/1,
<a name="20"/>   20:          mod_dep_from_overloaded_callback/1,
<a name="21"/>   21:          mod_dep_from_exported_overloaded_fun_spec/1,
<a name="22"/>   22:          mod_dep_from_unexported_overloaded_fun_spec/1,
<a name="23"/>   23:          mod_dep_from_callback_constraint/1,
<a name="24"/>   24:          mod_dep_from_unexported_fun_spec_constraint/1,
<a name="25"/>   25:          mod_dep_from_exported_fun_spec_constraint/1,
<a name="26"/>   26:          mod_dep_from_exported_type/1,
<a name="27"/>   27:          mod_dep_from_callback_return/1,
<a name="28"/>   28:          mod_dep_from_callback_args/1,
<a name="29"/>   29:          mod_dep_from_unexported_opaque_type_args/1,
<a name="30"/>   30:          mod_dep_from_exported_opaque_type_args/1,
<a name="31"/>   31:          mod_dep_from_unexported_opaque_type/1,
<a name="32"/>   32:          mod_dep_from_exported_opaque_type/1,
<a name="33"/>   33:          mod_dep_from_unexported_type_args/1,
<a name="34"/>   34:          mod_dep_from_exported_type_args/1,
<a name="35"/>   35:          mod_dep_from_unexported_fun_spec_args/1,
<a name="36"/>   36:          mod_dep_from_exported_fun_spec_args/1,
<a name="37"/>   37:          mod_dep_from_unexported_fun_spec_return/1,
<a name="38"/>   38:          mod_dep_from_exported_fun_spec_return/1,
<a name="39"/>   39:          mod_dep_from_unexported_type/1,
<a name="40"/>   40:          adding_warning_apps_after_a_run_without_them_causes_any_new_warnings_to_be_reported/1,
<a name="41"/>   41:          removing_warning_apps_after_a_run_with_them_causes_any_warnings_for_the_removed_apps_not_to_be_reported/1,
<a name="42"/>   42:          removing_legal_warnings_with_existing_stored_warnings_in_plt_does_not_result_in_old_warnings_being_printed/1,
<a name="43"/>   43:          adding_legal_warnings_with_existing_stored_warnings_in_plt_results_in_new_warnings_being_printed/1,
<a name="44"/>   44:          reading_from_one_plt_and_writing_to_another_does_not_mutate_the_input_plt/1,
<a name="45"/>   45:          reading_from_and_writing_to_one_plt_mutates_it/1,
<a name="46"/>   46:          beams_with_no_debug_info_are_rejected/1
<a name="47"/>   47:         ]).
<a name="48"/>   48: 
<a name="suite-0"/><a name="49"/>   49: <b>suite</b>() -&gt;
<a name="suite-last_expr"/><a name="50"/>   50:   [{timetrap, ?plt_timeout}].
<a name="51"/>   51: 
<a name="all-0"/><a name="all-last_expr"/><a name="52"/>   52: <b>all</b>() -&gt; [build_xdg_plt, beam_tests, 
<a name="53"/>   53:           local_fun_same_as_callback,
<a name="54"/>   54:           letrec_rvals,
<a name="55"/>   55:           missing_plt_file,
<a name="56"/>   56:           mod_dep_from_behaviour,
<a name="57"/>   57:           mod_dep_from_record_definition_field_value_default_used,
<a name="58"/>   58:           mod_dep_from_record_definition_field_value_default_unused,
<a name="59"/>   59:           mod_dep_from_record_definition_field_type,
<a name="60"/>   60:           mod_dep_from_overloaded_callback,
<a name="61"/>   61:           mod_dep_from_exported_overloaded_fun_spec,
<a name="62"/>   62:           mod_dep_from_unexported_overloaded_fun_spec,
<a name="63"/>   63:           mod_dep_from_callback_constraint,
<a name="64"/>   64:           mod_dep_from_unexported_fun_spec_constraint,
<a name="65"/>   65:           mod_dep_from_exported_fun_spec_constraint,
<a name="66"/>   66:           mod_dep_from_exported_type,
<a name="67"/>   67:           mod_dep_from_callback_return,
<a name="68"/>   68:           mod_dep_from_callback_args,
<a name="69"/>   69:           mod_dep_from_unexported_opaque_type_args,
<a name="70"/>   70:           mod_dep_from_exported_opaque_type_args,
<a name="71"/>   71:           mod_dep_from_unexported_opaque_type,
<a name="72"/>   72:           mod_dep_from_exported_opaque_type,
<a name="73"/>   73:           mod_dep_from_unexported_type_args,
<a name="74"/>   74:           mod_dep_from_exported_type_args,
<a name="75"/>   75:           mod_dep_from_unexported_fun_spec_args,
<a name="76"/>   76:           mod_dep_from_exported_fun_spec_args,
<a name="77"/>   77:           mod_dep_from_unexported_fun_spec_return,
<a name="78"/>   78:           mod_dep_from_exported_fun_spec_return,
<a name="79"/>   79:           mod_dep_from_unexported_type,
<a name="80"/>   80:           adding_warning_apps_after_a_run_without_them_causes_any_new_warnings_to_be_reported,
<a name="81"/>   81:           removing_warning_apps_after_a_run_with_them_causes_any_warnings_for_the_removed_apps_not_to_be_reported,
<a name="82"/>   82:           removing_legal_warnings_with_existing_stored_warnings_in_plt_does_not_result_in_old_warnings_being_printed,
<a name="83"/>   83:           adding_legal_warnings_with_existing_stored_warnings_in_plt_results_in_new_warnings_being_printed,
<a name="84"/>   84:           reading_from_one_plt_and_writing_to_another_does_not_mutate_the_input_plt,
<a name="85"/>   85:           reading_from_and_writing_to_one_plt_mutates_it,
<a name="86"/>   86:           beams_with_no_debug_info_are_rejected
<a name="87"/>   87:           ].
<a name="88"/>   88: 
<a name="init_per_testcase-2"/><a name="89"/>   89: <b>init_per_testcase</b>(_TestCase, Config) -&gt;
<a name="90"/>   90:   % Always run from a clean default PLT, so tests aren't dependent on what
<a name="91"/>   91:   % happens to be in the default user cache when they start
<a name="92"/>   92:   _ = file:delete(dialyzer_iplt:get_default_iplt_filename()),
<a name="init_per_testcase-last_expr"/><a name="93"/>   93:   Config.
<a name="94"/>   94: 
<a name="end_per_testcase-2"/><a name="95"/>   95: <b>end_per_testcase</b>(_TestCase, _Config) -&gt;
<a name="end_per_testcase-last_expr"/><a name="96"/>   96:   ok.
<a name="97"/>   97: 
<a name="build_xdg_plt-1"/><a name="98"/>   98: <b>build_xdg_plt</b>(Config) -&gt;
<a name="99"/>   99:     TestHome = filename:join(?config(priv_dir, Config), ?FUNCTION_NAME),
<a name="100"/>  100: 
<a name="101"/>  101:     %% We change the $HOME of the emulator to run this test
<a name="102"/>  102:     HomeEnv = case os:type() of
<a name="103"/>  103:                   {win32, _} -&gt;
<a name="104"/>  104:                       [Drive | Path] = filename:split(TestHome),
<a name="105"/>  105:                       [{&quot;APPDATA&quot;, filename:join(TestHome,&quot;AppData&quot;)},
<a name="106"/>  106:                        {&quot;HOMEDRIVE&quot;, Drive}, {&quot;HOMEPATH&quot;, Path}];
<a name="107"/>  107:                   _ -&gt;
<a name="108"/>  108:                       [{&quot;HOME&quot;, TestHome}]
<a name="109"/>  109:               end,
<a name="110"/>  110: 
<a name="111"/>  111:     {ok, Peer, Node} = ?CT_PEER(#{ env =&gt; HomeEnv }),
<a name="112"/>  112: 
<a name="113"/>  113:     erpc:call(
<a name="114"/>  114:       Node,
<a name="115"/>  115:       fun() -&gt;
<a name="116"/>  116:         ?assertMatch([], dialyzer:run(
<a name="117"/>  117:                            [{analysis_type, incremental},
<a name="118"/>  118:                             {apps, [erts]},
<a name="119"/>  119:                             {warnings, [no_unknown]}])),
<a name="120"/>  120:         ?assertMatch(
<a name="121"/>  121:            {ok,_}, file:read_file(
<a name="122"/>  122:                      filename:join(
<a name="123"/>  123:                        filename:basedir(user_cache, &quot;erlang&quot;),
<a name="124"/>  124:                        &quot;.dialyzer_iplt&quot;)))
<a name="125"/>  125:       end),
<a name="126"/>  126: 
<a name="build_xdg_plt-last_expr"/><a name="127"/>  127: <b>    peer:stop</b>(Peer).
<a name="128"/>  128: 
<a name="beam_tests-1"/><a name="129"/>  129: <b>beam_tests</b>(Config) when is_list(Config) -&gt;
<a name="130"/>  130:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="131"/>  131:     Plt = filename:join(PrivDir, &quot;beam_tests.iplt&quot;),
<a name="132"/>  132:     Src = &lt;&lt;&quot;
<a name="133"/>  133:         -module(no_auto_import).
<a name="134"/>  134: 
<a name="135"/>  135:         %% Copied from erl_lint_SUITE.erl, clash6
<a name="136"/>  136: 
<a name="137"/>  137:         -export([size/1]).
<a name="138"/>  138: 
<a name="139"/>  139:         size([]) -&gt;
<a name="140"/>  140:             0;
<a name="141"/>  141:         size({N,_}) -&gt;
<a name="142"/>  142:             N;
<a name="143"/>  143:         size([_|T]) -&gt;
<a name="144"/>  144:             1+size(T).
<a name="145"/>  145:     &quot;&gt;&gt;,
<a name="146"/>  146:     Opts = [no_auto_import],
<a name="147"/>  147:     {ok, BeamFile} = compile(Config, Src, no_auto_import, Opts),
<a name="148"/>  148:     [] = run_dialyzer(incremental, [BeamFile], [{output_plt, Plt}]),
<a name="beam_tests-last_expr"/><a name="149"/>  149:     ok.
<a name="150"/>  150: 
<a name="151"/>  151: 
<a name="152"/>  152: 
<a name="153"/>  153: <i>%%% If a behaviour module contains an non-exported function with the same name</i>
<a name="154"/>  154: <i>%%% as one of the behaviour's callbacks, the callback info was inadvertently</i>
<a name="155"/>  155: <i>%%% deleted from the PLT as the dialyzer_plt:delete_list/2 function was cleaning</i>
<a name="156"/>  156: <i>%%% up the callback table. This bug was reported by Brujo Benavides.</i>
<a name="157"/>  157: 
<a name="local_fun_same_as_callback-1"/><a name="158"/>  158: <b>local_fun_same_as_callback</b>(Config) when is_list(Config) -&gt;
<a name="159"/>  159:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="160"/>  160:     Prog1 =
<a name="161"/>  161:       &lt;&lt;&quot;-module(bad_behaviour).
<a name="162"/>  162:          -callback bad() -&gt; bad.
<a name="163"/>  163:          -export([publicly_bad/0]).
<a name="164"/>  164: 
<a name="165"/>  165:          %% @doc This function is here just to avoid the 'unused' warning for bad/0
<a name="166"/>  166:          publicly_bad() -&gt; bad().
<a name="167"/>  167: 
<a name="168"/>  168:          %% @doc This function overlaps with the callback with the same name, and
<a name="169"/>  169:          %%      that was an issue for dialyzer since it's a private function.
<a name="170"/>  170:          bad() -&gt; bad.&quot;&gt;&gt;,
<a name="171"/>  171:     {ok, Beam} = compile(Config, Prog1, bad_behaviour, []),
<a name="172"/>  172: 
<a name="173"/>  173:     ErlangBeam = case code:where_is_file(&quot;erlang.beam&quot;) of
<a name="174"/>  174:                      non_existing -&gt;
<a name="175"/>  175:                          filename:join([code:root_dir(),
<a name="176"/>  176:                                         &quot;erts&quot;, &quot;preloaded&quot;, &quot;ebin&quot;,
<a name="177"/>  177:                                         &quot;erlang.beam&quot;]);
<a name="178"/>  178:                      EBeam -&gt;
<a name="179"/>  179:                          EBeam
<a name="180"/>  180:                  end,
<a name="181"/>  181:     Plt = filename:join(PrivDir, &quot;plt_bad_behaviour.iplt&quot;),
<a name="182"/>  182:     Opts = [{from, byte_code}, {warnings, [no_unknown]}],
<a name="183"/>  183:     [] = dialyzer:run([{analysis_type, incremental},
<a name="184"/>  184:                        {files, [Beam, ErlangBeam]},
<a name="185"/>  185:                        {output_plt, Plt}] ++ Opts),
<a name="186"/>  186: 
<a name="187"/>  187:     Prog2 =
<a name="188"/>  188:         &lt;&lt;&quot;-module(bad_child).
<a name="189"/>  189:            -behaviour(bad_behaviour).
<a name="190"/>  190: 
<a name="191"/>  191:            -export([bad/0]).
<a name="192"/>  192: 
<a name="193"/>  193:            %% @doc This function incorrectly implements bad_behaviour.
<a name="194"/>  194:            bad() -&gt; not_bad.&quot;&gt;&gt;,
<a name="195"/>  195:     {ok, TestBeam} = compile(Config, Prog2, bad_child, []),
<a name="196"/>  196: 
<a name="197"/>  197:     [{warn_behaviour, _,
<a name="198"/>  198:       {callback_type_mismatch,
<a name="199"/>  199:        [bad_behaviour,bad,0,&quot;'not_bad'&quot;,&quot;'bad'&quot;]}}] =
<a name="200"/>  200:         dialyzer:run([{analysis_type, incremental},
<a name="201"/>  201:                       {files, [TestBeam, Beam, ErlangBeam]},
<a name="202"/>  202:                       {init_plt, Plt}] ++ Opts),
<a name="local_fun_same_as_callback-last_expr"/><a name="203"/>  203:     ok.
<a name="204"/>  204: 
<a name="205"/>  205: 
<a name="206"/>  206: 
<a name="letrec_rvals-1"/><a name="207"/>  207: <b>letrec_rvals</b>(Config) -&gt;
<a name="208"/>  208:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="209"/>  209:     Plt = filename:join(PrivDir, &quot;letrec_rvals.iplt&quot;),
<a name="210"/>  210:     Prog = &lt;&lt;&quot;
<a name="211"/>  211: <b>-module</b>(letrec_rvals).
<a name="212"/>  212: 
<a name="213"/>  213: <b>-export</b>([demo_fun/1]).
<a name="214"/>  214: 
<a name="215"/>  215: demo_fun(_Arg) -&gt;
<a name="216"/>  216:     case ok of
<a name="217"/>  217:         _ -&gt;
<a name="218"/>  218:             _Res = _Arg,
<a name="219"/>  219:             [ ok || _ &lt;- [] ]
<a name="220"/>  220:     end,
<a name="221"/>  221:     _Res.
<a name="222"/>  222: 
<a name="223"/>  223: handle_info() -&gt;
<a name="224"/>  224:     case chids_to_audit() of
<a name="225"/>  225:         {ChIds, St2} -&gt;
<a name="226"/>  226:             [ ChId || ChId &lt;- ChIds ],
<a name="227"/>  227:             ok
<a name="228"/>  228:     end,
<a name="229"/>  229:     check_done(St2).
<a name="230"/>  230: 
<a name="231"/>  231: chids_to_audit() -&gt;
<a name="232"/>  232:     some_module:get_audit_list().
<a name="233"/>  233: 
<a name="234"/>  234: check_done(_) -&gt;
<a name="235"/>  235:     ok.
<a name="236"/>  236:     &quot;&gt;&gt;,
<a name="237"/>  237:     {ok, BeamFile} = compile(Config, Prog, letrec_rvals, []),
<a name="238"/>  238:     _ = run_dialyzer(incremental, [BeamFile], [{output_plt, Plt}]),
<a name="letrec_rvals-last_expr"/><a name="239"/>  239:     ok.
<a name="240"/>  240: 
<a name="missing_plt_file-1"/><a name="241"/>  241: <b>missing_plt_file</b>(Config) -&gt;
<a name="242"/>  242:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="243"/>  243:     PltFile = filename:join(PrivDir, &quot;missing_plt_file.iplt&quot;),
<a name="244"/>  244:     Prog2 = &lt;&lt;&quot;-module(missing_plt_file2).
<a name="245"/>  245:               t() -&gt; foo.&quot;&gt;&gt;,
<a name="246"/>  246:     {ok, BeamFile2} = compile(Config, Prog2, missing_plt_file2, []),
<a name="247"/>  247: 
<a name="248"/>  248:     true = missing_plt_file_1(Config, PltFile, BeamFile2),
<a name="249"/>  249:     true = missing_plt_file_2(Config, PltFile, BeamFile2),
<a name="missing_plt_file-last_expr"/><a name="250"/>  250:     ok.
<a name="251"/>  251: 
<a name="missing_plt_file_1-3"/><a name="252"/>  252: <b>missing_plt_file_1</b>(Config, PltFile, BeamFile2) -&gt;
<a name="253"/>  253:     BeamFile = create1(Config, PltFile),
<a name="254"/>  254:     ok = file:delete(BeamFile),
<a name="missing_plt_file_1-last_expr"/><a name="255"/>  255: <b>    try incr</b>(PltFile, BeamFile2), true
<a name="256"/>  256:     catch throw:{dialyzer_error, _} -&gt; false
<a name="257"/>  257:     end.
<a name="258"/>  258: 
<a name="create1-2"/><a name="259"/>  259: <b>create1</b>(Config, PltFile) -&gt;
<a name="260"/>  260:     Prog = &lt;&lt;&quot;-module(missing_plt_file).
<a name="261"/>  261:               t() -&gt; foo.&quot;&gt;&gt;,
<a name="262"/>  262:     {ok, BeamFile} = compile(Config, Prog, missing_plt_file, []),
<a name="263"/>  263:     Files = [BeamFile],
<a name="264"/>  264:     _ = file:delete(PltFile),
<a name="265"/>  265:     _ = dialyzer:run([{files,Files},
<a name="266"/>  266:                        {init_plt, PltFile},
<a name="267"/>  267:                        {output_plt, PltFile},
<a name="268"/>  268:                        {analysis_type, incremental}]),
<a name="create1-last_expr"/><a name="269"/>  269:     BeamFile.
<a name="270"/>  270: 
<a name="missing_plt_file_2-3"/><a name="271"/>  271: <b>missing_plt_file_2</b>(Config, PltFile, BeamFile2) -&gt;
<a name="272"/>  272:     BeamFile = create2(Config, PltFile),
<a name="273"/>  273:     ok = file:delete(BeamFile),
<a name="missing_plt_file_2-last_expr"/><a name="274"/>  274: <b>    try incr</b>(PltFile, BeamFile2), true
<a name="275"/>  275:     catch throw:{dialyzer_error, _} -&gt; false
<a name="276"/>  276:     end.
<a name="277"/>  277: 
<a name="create2-2"/><a name="278"/>  278: <b>create2</b>(Config, PltFile) -&gt;
<a name="279"/>  279:     Prog = &lt;&lt;&quot;-module(missing_plt_file).
<a name="280"/>  280:               t() -&gt; foo.&quot;&gt;&gt;,
<a name="281"/>  281:     {ok, BeamFile} = compile(Config, Prog, missing_plt_file, []),
<a name="282"/>  282:     Files = [BeamFile],
<a name="283"/>  283:     _ = file:delete(PltFile),
<a name="284"/>  284:     _ = dialyzer:run([{files,Files},
<a name="285"/>  285:                        {output_plt, PltFile},
<a name="286"/>  286:                        {analysis_type, incremental}]),
<a name="create2-last_expr"/><a name="287"/>  287:     BeamFile.
<a name="288"/>  288: 
<a name="incr-2"/><a name="289"/>  289: <b>incr</b>(PltFile, BeamFile2) -&gt;
<a name="290"/>  290:     Files = [BeamFile2],
<a name="incr-last_expr"/><a name="291"/>  291: <b>    dialyzer:run</b>([{files, Files},
<a name="292"/>  292:                   {plts,[PltFile]},
<a name="293"/>  293:                   {analysis_type, incremental}]).
<a name="294"/>  294: 
<a name="mod_dep_from_record_definition_field_value_default_unused-1"/><a name="295"/>  295: <b>mod_dep_from_record_definition_field_value_default_unused</b>(Config) -&gt;
<a name="296"/>  296:     DependerSrc = &lt;&lt;&quot;
<a name="297"/>  297:       -module(depender).
<a name="298"/>  298: 
<a name="299"/>  299:       -record(my_record,
<a name="300"/>  300:         { num_field = type_deps:get_num() :: number(),
<a name="301"/>  301:           str_field,
<a name="302"/>  302:           bool_field
<a name="303"/>  303:         }).
<a name="304"/>  304:       &quot;&gt;&gt;,
<a name="305"/>  305:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, []}],
<a name="mod_dep_from_record_definition_field_value_default_unused-last_expr"/><a name="306"/>  306: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc, ExpectedTypeDepsInPlt).
<a name="307"/>  307: 
<a name="mod_dep_from_record_definition_field_value_default_used-1"/><a name="308"/>  308: <b>mod_dep_from_record_definition_field_value_default_used</b>(Config) -&gt;
<a name="309"/>  309:     DependerSrc = &lt;&lt;&quot;
<a name="310"/>  310:       -module(depender).
<a name="311"/>  311:       -export([f/0]).
<a name="312"/>  312: 
<a name="313"/>  313:       -record(my_record,
<a name="314"/>  314:         { num_field = type_deps:get_num() :: number(),
<a name="315"/>  315:           str_field,
<a name="316"/>  316:           bool_field
<a name="317"/>  317:         }).
<a name="318"/>  318: 
<a name="319"/>  319:       f() -&gt; #my_record{str_field = \&quot;foo\&quot;, bool_field = true}. % type_deps:get_num() used implicitly here
<a name="320"/>  320:       &quot;&gt;&gt;,
<a name="321"/>  321:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="mod_dep_from_record_definition_field_value_default_used-last_expr"/><a name="322"/>  322: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc, ExpectedTypeDepsInPlt).
<a name="323"/>  323: 
<a name="mod_dep_from_behaviour-1"/><a name="324"/>  324: <b>mod_dep_from_behaviour</b>(Config) -&gt;
<a name="325"/>  325:     DependerSrc = &lt;&lt;&quot;
<a name="326"/>  326:       -module(depender).
<a name="327"/>  327:       -behaviour(type_deps).
<a name="328"/>  328:       -export([quux/1]).
<a name="329"/>  329: 
<a name="330"/>  330:       quux(N) -&gt; N + 1. % Depends on behaviour module to check the callback implementation
<a name="331"/>  331:       &quot;&gt;&gt;,
<a name="332"/>  332:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="mod_dep_from_behaviour-last_expr"/><a name="333"/>  333: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc, ExpectedTypeDepsInPlt).
<a name="334"/>  334: 
<a name="mod_dep_from_record_definition_field_type-1"/><a name="335"/>  335: <b>mod_dep_from_record_definition_field_type</b>(Config) -&gt;
<a name="336"/>  336:     DependerSrc = &lt;&lt;&quot;
<a name="337"/>  337:       -module(depender).
<a name="338"/>  338: 
<a name="339"/>  339:       -record(my_record,
<a name="340"/>  340:         { num_field = 1 :: type_deps:number_like(),
<a name="341"/>  341:           str_field,
<a name="342"/>  342:           bool_field
<a name="343"/>  343:         }).
<a name="344"/>  344:       &quot;&gt;&gt;,
<a name="345"/>  345:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="mod_dep_from_record_definition_field_type-last_expr"/><a name="346"/>  346: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc, ExpectedTypeDepsInPlt).
<a name="347"/>  347: 
<a name="mod_dep_from_overloaded_callback-1"/><a name="348"/>  348: <b>mod_dep_from_overloaded_callback</b>(Config) -&gt;
<a name="349"/>  349:     DependerSrc1 = &lt;&lt;&quot;
<a name="350"/>  350:       -module(depender).
<a name="351"/>  351: 
<a name="352"/>  352:       -callback f(string()) -&gt; string()
<a name="353"/>  353:                 ; (type_deps:number_like()) -&gt; type_deps:number_like().
<a name="354"/>  354:       &quot;&gt;&gt;,
<a name="355"/>  355:     DependerSrc2 = &lt;&lt;&quot;
<a name="356"/>  356:       -module(depender).
<a name="357"/>  357: 
<a name="358"/>  358:       -callback f(type_deps:number_like()) -&gt; type_deps:number_like()
<a name="359"/>  359:                 ; (string()) -&gt; string().
<a name="360"/>  360:       &quot;&gt;&gt;,
<a name="361"/>  361:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="362"/>  362:     ok = check_plt_deps(Config, ?FUNCTION_NAME, DependerSrc1, ExpectedTypeDepsInPlt),
<a name="mod_dep_from_overloaded_callback-last_expr"/><a name="363"/>  363: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc2, ExpectedTypeDepsInPlt).
<a name="364"/>  364: 
<a name="mod_dep_from_exported_overloaded_fun_spec-1"/><a name="365"/>  365: <b>mod_dep_from_exported_overloaded_fun_spec</b>(Config) -&gt;
<a name="366"/>  366:     DependerSrc1 = &lt;&lt;&quot;
<a name="367"/>  367:       -module(depender).
<a name="368"/>  368:       -export([f/1]).
<a name="369"/>  369: 
<a name="370"/>  370:       -spec f({a, atom()}) -&gt; atom()
<a name="371"/>  371:             ; ({n, type_deps:number_like()}) -&gt; type_deps:number_like().
<a name="372"/>  372:       f({a, X}) when is_atom(X) -&gt; X;
<a name="373"/>  373:       f({n, X}) when is_number(X) -&gt; X.
<a name="374"/>  374:       &quot;&gt;&gt;,
<a name="375"/>  375:     DependerSrc2 = &lt;&lt;&quot;
<a name="376"/>  376:       -module(depender).
<a name="377"/>  377:       -export([f/1]).
<a name="378"/>  378: 
<a name="379"/>  379:       -spec f({n, type_deps:number_like()}) -&gt; type_deps:number_like()
<a name="380"/>  380:             ; ({a, atom()}) -&gt; atom().
<a name="381"/>  381:       f({n, X}) when is_number(X) -&gt; X;
<a name="382"/>  382:       f({a, X}) when is_atom(X) -&gt; X.
<a name="383"/>  383:       &quot;&gt;&gt;,
<a name="384"/>  384:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="385"/>  385:     ok = check_plt_deps(Config, ?FUNCTION_NAME, DependerSrc1, ExpectedTypeDepsInPlt),
<a name="mod_dep_from_exported_overloaded_fun_spec-last_expr"/><a name="386"/>  386: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc2, ExpectedTypeDepsInPlt).
<a name="387"/>  387: 
<a name="mod_dep_from_unexported_overloaded_fun_spec-1"/><a name="388"/>  388: <b>mod_dep_from_unexported_overloaded_fun_spec</b>(Config) -&gt;
<a name="389"/>  389:     DependerSrc1 = &lt;&lt;&quot;
<a name="390"/>  390:       -module(depender).
<a name="391"/>  391:       -compile({nowarn_unused_function, [f/1]}).
<a name="392"/>  392: 
<a name="393"/>  393:       -spec f({a, atom()}) -&gt; atom()
<a name="394"/>  394:             ; ({n, type_deps:number_like()}) -&gt; type_deps:number_like().
<a name="395"/>  395:       f({a, X}) when is_atom(X) -&gt; X;
<a name="396"/>  396:       f({n, X}) when is_number(X) -&gt; X.
<a name="397"/>  397:       &quot;&gt;&gt;,
<a name="398"/>  398:     DependerSrc2 = &lt;&lt;&quot;
<a name="399"/>  399:       -module(depender).
<a name="400"/>  400:       -compile({nowarn_unused_function, [f/1]}).
<a name="401"/>  401: 
<a name="402"/>  402:       -spec f({n, type_deps:number_like()}) -&gt; type_deps:number_like()
<a name="403"/>  403:             ; ({a, atom()}) -&gt; atom().
<a name="404"/>  404:       f({n, X}) when is_number(X) -&gt; X;
<a name="405"/>  405:       f({a, X}) when is_atom(X) -&gt; X.
<a name="406"/>  406:       &quot;&gt;&gt;,
<a name="407"/>  407:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="408"/>  408:     ok = check_plt_deps(Config, ?FUNCTION_NAME, DependerSrc1, ExpectedTypeDepsInPlt),
<a name="mod_dep_from_unexported_overloaded_fun_spec-last_expr"/><a name="409"/>  409: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc2, ExpectedTypeDepsInPlt).
<a name="410"/>  410: 
<a name="mod_dep_from_callback_constraint-1"/><a name="411"/>  411: <b>mod_dep_from_callback_constraint</b>(Config) -&gt;
<a name="412"/>  412:     DependerSrc1 = &lt;&lt;&quot;
<a name="413"/>  413:       -module(depender).
<a name="414"/>  414: 
<a name="415"/>  415:       -callback f(X) -&gt; string() when X :: type_deps:number_like().
<a name="416"/>  416:       &quot;&gt;&gt;,
<a name="417"/>  417:     DependerSrc2 = &lt;&lt;&quot;
<a name="418"/>  418:       -module(depender).
<a name="419"/>  419: 
<a name="420"/>  420:       -callback f(X :: type_deps:number_like()) -&gt; string().
<a name="421"/>  421:       &quot;&gt;&gt;,
<a name="422"/>  422:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="423"/>  423:     ok = check_plt_deps(Config, ?FUNCTION_NAME, DependerSrc1, ExpectedTypeDepsInPlt),
<a name="mod_dep_from_callback_constraint-last_expr"/><a name="424"/>  424: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc2, ExpectedTypeDepsInPlt).
<a name="425"/>  425: 
<a name="mod_dep_from_unexported_fun_spec_constraint-1"/><a name="426"/>  426: <b>mod_dep_from_unexported_fun_spec_constraint</b>(Config) -&gt;
<a name="427"/>  427:     DependerSrc = &lt;&lt;&quot;
<a name="428"/>  428:       -module(depender).
<a name="429"/>  429:       -compile({nowarn_unused_function, [f/1]}).
<a name="430"/>  430: 
<a name="431"/>  431:       -spec f(N) -&gt; number() when N :: type_deps:number_like().
<a name="432"/>  432:       f(N) -&gt; N.
<a name="433"/>  433:       &quot;&gt;&gt;,
<a name="434"/>  434:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="mod_dep_from_unexported_fun_spec_constraint-last_expr"/><a name="435"/>  435: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc, ExpectedTypeDepsInPlt).
<a name="436"/>  436: 
<a name="mod_dep_from_exported_fun_spec_constraint-1"/><a name="437"/>  437: <b>mod_dep_from_exported_fun_spec_constraint</b>(Config) -&gt;
<a name="438"/>  438:     DependerSrc = &lt;&lt;&quot;
<a name="439"/>  439:       -module(depender).
<a name="440"/>  440:       -export([f/1]).
<a name="441"/>  441: 
<a name="442"/>  442:       -spec f(N) -&gt; number() when N :: type_deps:number_like().
<a name="443"/>  443:       f(N) -&gt; N.
<a name="444"/>  444:       &quot;&gt;&gt;,
<a name="445"/>  445:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="mod_dep_from_exported_fun_spec_constraint-last_expr"/><a name="446"/>  446: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc, ExpectedTypeDepsInPlt).
<a name="447"/>  447: 
<a name="mod_dep_from_callback_return-1"/><a name="448"/>  448: <b>mod_dep_from_callback_return</b>(Config) -&gt;
<a name="449"/>  449:     DependerSrc = &lt;&lt;&quot;
<a name="450"/>  450:       -module(depender).
<a name="451"/>  451: 
<a name="452"/>  452:       -callback f(string()) -&gt; type_deps:number_like().
<a name="453"/>  453:       &quot;&gt;&gt;,
<a name="454"/>  454:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="mod_dep_from_callback_return-last_expr"/><a name="455"/>  455: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc, ExpectedTypeDepsInPlt).
<a name="456"/>  456: 
<a name="mod_dep_from_callback_args-1"/><a name="457"/>  457: <b>mod_dep_from_callback_args</b>(Config) -&gt;
<a name="458"/>  458:     DependerSrc = &lt;&lt;&quot;
<a name="459"/>  459:       -module(depender).
<a name="460"/>  460: 
<a name="461"/>  461:       -callback f(type_deps:number_like()) -&gt; string().
<a name="462"/>  462:       &quot;&gt;&gt;,
<a name="463"/>  463:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="mod_dep_from_callback_args-last_expr"/><a name="464"/>  464: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc, ExpectedTypeDepsInPlt).
<a name="465"/>  465: 
<a name="mod_dep_from_unexported_opaque_type-1"/><a name="466"/>  466: <b>mod_dep_from_unexported_opaque_type</b>(Config) -&gt;
<a name="467"/>  467:     DependerSrc = &lt;&lt;&quot;
<a name="468"/>  468:       -module(depender).
<a name="469"/>  469: 
<a name="470"/>  470:       -opaque my_type() :: {string(), type_deps:number_like()}.
<a name="471"/>  471:       &quot;&gt;&gt;,
<a name="472"/>  472:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="mod_dep_from_unexported_opaque_type-last_expr"/><a name="473"/>  473: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc, ExpectedTypeDepsInPlt).
<a name="474"/>  474: 
<a name="mod_dep_from_exported_opaque_type-1"/><a name="475"/>  475: <b>mod_dep_from_exported_opaque_type</b>(Config) -&gt;
<a name="476"/>  476:     DependerSrc = &lt;&lt;&quot;
<a name="477"/>  477:       -module(depender).
<a name="478"/>  478:       -export_type([my_type/0]).
<a name="479"/>  479: 
<a name="480"/>  480:       -opaque my_type() :: {string(), type_deps:number_like()}.
<a name="481"/>  481:       &quot;&gt;&gt;,
<a name="482"/>  482:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="mod_dep_from_exported_opaque_type-last_expr"/><a name="483"/>  483: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc, ExpectedTypeDepsInPlt).
<a name="484"/>  484: 
<a name="mod_dep_from_unexported_opaque_type_args-1"/><a name="485"/>  485: <b>mod_dep_from_unexported_opaque_type_args</b>(Config) -&gt;
<a name="486"/>  486:     DependerSrc = &lt;&lt;&quot;
<a name="487"/>  487:       -module(depender).
<a name="488"/>  488: 
<a name="489"/>  489:       -type my_type() :: type_deps:my_opaque(number()).
<a name="490"/>  490:       &quot;&gt;&gt;,
<a name="491"/>  491:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="mod_dep_from_unexported_opaque_type_args-last_expr"/><a name="492"/>  492: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc, ExpectedTypeDepsInPlt).
<a name="493"/>  493: 
<a name="mod_dep_from_exported_opaque_type_args-1"/><a name="494"/>  494: <b>mod_dep_from_exported_opaque_type_args</b>(Config) -&gt;
<a name="495"/>  495:     DependerSrc = &lt;&lt;&quot;
<a name="496"/>  496:       -module(depender).
<a name="497"/>  497:       -export_type([my_type/0]).
<a name="498"/>  498: 
<a name="499"/>  499:       -type my_type() :: type_deps:my_opaque(number()).
<a name="500"/>  500:       &quot;&gt;&gt;,
<a name="501"/>  501:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="mod_dep_from_exported_opaque_type_args-last_expr"/><a name="502"/>  502: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc, ExpectedTypeDepsInPlt).
<a name="503"/>  503: 
<a name="mod_dep_from_unexported_type_args-1"/><a name="504"/>  504: <b>mod_dep_from_unexported_type_args</b>(Config) -&gt;
<a name="505"/>  505:     DependerSrc = &lt;&lt;&quot;
<a name="506"/>  506:       -module(depender).
<a name="507"/>  507: 
<a name="508"/>  508:       -type my_type() :: {string(), type_deps:number_like()}.
<a name="509"/>  509:       &quot;&gt;&gt;,
<a name="510"/>  510:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="mod_dep_from_unexported_type_args-last_expr"/><a name="511"/>  511: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc, ExpectedTypeDepsInPlt).
<a name="512"/>  512: 
<a name="mod_dep_from_exported_type_args-1"/><a name="513"/>  513: <b>mod_dep_from_exported_type_args</b>(Config) -&gt;
<a name="514"/>  514:     DependerSrc = &lt;&lt;&quot;
<a name="515"/>  515:       -module(depender).
<a name="516"/>  516:       -export_type([my_type/0]).
<a name="517"/>  517: 
<a name="518"/>  518:       -type my_type() :: {string(), type_deps:number_like()}.
<a name="519"/>  519:       &quot;&gt;&gt;,
<a name="520"/>  520:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="mod_dep_from_exported_type_args-last_expr"/><a name="521"/>  521: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc, ExpectedTypeDepsInPlt).
<a name="522"/>  522: 
<a name="mod_dep_from_unexported_fun_spec_args-1"/><a name="523"/>  523: <b>mod_dep_from_unexported_fun_spec_args</b>(Config) -&gt;
<a name="524"/>  524:     DependerSrc = &lt;&lt;&quot;
<a name="525"/>  525:       -module(depender).
<a name="526"/>  526:       -compile({nowarn_unused_function, [f/1]}).
<a name="527"/>  527: 
<a name="528"/>  528:       -spec f(type_deps:number_like()) -&gt; number().
<a name="529"/>  529:       f(N) -&gt; N.
<a name="530"/>  530:       &quot;&gt;&gt;,
<a name="531"/>  531:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="mod_dep_from_unexported_fun_spec_args-last_expr"/><a name="532"/>  532: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc, ExpectedTypeDepsInPlt).
<a name="533"/>  533: 
<a name="mod_dep_from_exported_fun_spec_args-1"/><a name="534"/>  534: <b>mod_dep_from_exported_fun_spec_args</b>(Config) -&gt;
<a name="535"/>  535:     DependerSrc = &lt;&lt;&quot;
<a name="536"/>  536:       -module(depender).
<a name="537"/>  537:       -export([f/1]).
<a name="538"/>  538: 
<a name="539"/>  539:       -spec f(N :: type_deps:number_like()) -&gt; number().
<a name="540"/>  540:       f(N) -&gt; N.
<a name="541"/>  541:       &quot;&gt;&gt;,
<a name="542"/>  542:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="mod_dep_from_exported_fun_spec_args-last_expr"/><a name="543"/>  543: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc, ExpectedTypeDepsInPlt).
<a name="544"/>  544: 
<a name="mod_dep_from_unexported_fun_spec_return-1"/><a name="545"/>  545: <b>mod_dep_from_unexported_fun_spec_return</b>(Config) -&gt;
<a name="546"/>  546:     DependerSrc = &lt;&lt;&quot;
<a name="547"/>  547:       -module(depender).
<a name="548"/>  548:       -compile({nowarn_unused_function, [f/0]}).
<a name="549"/>  549: 
<a name="550"/>  550:       -spec f() -&gt; type_deps:number_like().
<a name="551"/>  551:       f() -&gt; 1.
<a name="552"/>  552:       &quot;&gt;&gt;,
<a name="553"/>  553:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="mod_dep_from_unexported_fun_spec_return-last_expr"/><a name="554"/>  554: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc, ExpectedTypeDepsInPlt).
<a name="555"/>  555: 
<a name="mod_dep_from_exported_fun_spec_return-1"/><a name="556"/>  556: <b>mod_dep_from_exported_fun_spec_return</b>(Config) -&gt;
<a name="557"/>  557:     DependerSrc = &lt;&lt;&quot;
<a name="558"/>  558:       -module(depender).
<a name="559"/>  559:       -export([f/0]).
<a name="560"/>  560: 
<a name="561"/>  561:       -spec f() -&gt; type_deps:number_like().
<a name="562"/>  562:       f() -&gt; 1.
<a name="563"/>  563:       &quot;&gt;&gt;,
<a name="564"/>  564:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="mod_dep_from_exported_fun_spec_return-last_expr"/><a name="565"/>  565: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc, ExpectedTypeDepsInPlt).
<a name="566"/>  566: 
<a name="mod_dep_from_unexported_type-1"/><a name="567"/>  567: <b>mod_dep_from_unexported_type</b>(Config) -&gt;
<a name="568"/>  568:     DependerSrc = &lt;&lt;&quot;
<a name="569"/>  569:       -module(depender).
<a name="570"/>  570: 
<a name="571"/>  571:       -type my_type() :: type_deps:list_like(number()).
<a name="572"/>  572:       &quot;&gt;&gt;,
<a name="573"/>  573:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="mod_dep_from_unexported_type-last_expr"/><a name="574"/>  574: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc, ExpectedTypeDepsInPlt).
<a name="575"/>  575: 
<a name="mod_dep_from_exported_type-1"/><a name="576"/>  576: <b>mod_dep_from_exported_type</b>(Config) -&gt;
<a name="577"/>  577:     DependerSrc = &lt;&lt;&quot;
<a name="578"/>  578:       -module(depender).
<a name="579"/>  579:       -export_type([my_type/0]).
<a name="580"/>  580: 
<a name="581"/>  581:       -type my_type() :: type_deps:list_like(number()).
<a name="582"/>  582:       &quot;&gt;&gt;,
<a name="583"/>  583:     ExpectedTypeDepsInPlt = [{depender, []}, {type_deps, [depender]}],
<a name="mod_dep_from_exported_type-last_expr"/><a name="584"/>  584: <b>    ok = check_plt_deps</b>(Config, ?FUNCTION_NAME, DependerSrc, ExpectedTypeDepsInPlt).
<a name="585"/>  585: 
<a name="check_plt_deps-4"/><a name="586"/>  586: <b>check_plt_deps</b>(Config, TestName, DependerSrc, ExpectedTypeDepsInPltUnsorted) -&gt;
<a name="587"/>  587:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="588"/>  588:     PltFile = filename:join(PrivDir, atom_to_list(TestName) ++ &quot;.iplt&quot;),
<a name="589"/>  589:     {ok, DepsBeamFile} = compile(Config, type_deps, []),
<a name="590"/>  590:     {ok, DependerBeamFile} = compile(Config, DependerSrc, depender, []),
<a name="591"/>  591:     [] = run_dialyzer(incremental,
<a name="592"/>  592:                       [DependerBeamFile, DepsBeamFile],
<a name="593"/>  593:                       [{init_plt, PltFile}, {output_plt, PltFile}, {warnings, [no_unknown]}]),
<a name="594"/>  594:     {_ResPlt, #iplt_info{mod_deps = DepsByModule}} = dialyzer_iplt:plt_and_info_from_file(PltFile),
<a name="595"/>  595: 
<a name="596"/>  596:     ActualTypeDepsInPlt =
<a name="597"/>  597:       lists:sort(dict:to_list(dict:erase(erlang, DepsByModule))),
<a name="598"/>  598:     ExpectedTypeDepsInPlt =
<a name="599"/>  599:       lists:usort(ExpectedTypeDepsInPltUnsorted),
<a name="600"/>  600: 
<a name="check_plt_deps-last_expr"/><a name="601"/>  601: <b>    ?assertEqual</b>(
<a name="602"/>  602:       ExpectedTypeDepsInPlt,
<a name="603"/>  603:       ActualTypeDepsInPlt,
<a name="604"/>  604:       {missing, ExpectedTypeDepsInPlt -- ActualTypeDepsInPlt,
<a name="605"/>  605:        extra, ActualTypeDepsInPlt -- ExpectedTypeDepsInPlt}).
<a name="606"/>  606: 
<a name="607"/>  607: <i>%% Builds the named module using the source in the iplt_SUITE_data dir</i>
<a name="compile-3"/><a name="608"/>  608: <b>compile</b>(Config, Module, CompileOpts) -&gt;
<a name="609"/>  609:     Source = lists:concat([Module, &quot;.erl&quot;]),
<a name="610"/>  610:     PrivDir = proplists:get_value(priv_dir,Config),
<a name="611"/>  611:     DataDir = proplists:get_value(data_dir,Config),
<a name="612"/>  612:     SrcFilename = filename:join([DataDir, Source]),
<a name="613"/>  613:     Opts = [{outdir, PrivDir}, debug_info | CompileOpts],
<a name="614"/>  614:     {ok, Module} = compile:file(SrcFilename, Opts),
<a name="compile-last_expr"/><a name="615"/>  615: <b>    {ok, filename:join</b>([PrivDir, lists:concat([Module, &quot;.beam&quot;])])}.
<a name="616"/>  616: 
<a name="617"/>  617: <i>%% Builds the named module using the literal source given</i>
<a name="compile-4"/><a name="618"/>  618: <b>compile</b>(Config, Prog, Module, CompileOpts) -&gt;
<a name="619"/>  619:     Source = lists:concat([Module, &quot;.erl&quot;]),
<a name="620"/>  620:     PrivDir = proplists:get_value(priv_dir,Config),
<a name="621"/>  621:     Filename = filename:join([PrivDir, Source]),
<a name="622"/>  622:     ok = file:write_file(Filename, Prog),
<a name="623"/>  623:     Opts = [{outdir, PrivDir}, debug_info | CompileOpts],
<a name="624"/>  624:     {ok, Module} = compile:file(Filename, Opts),
<a name="compile-last_expr"/><a name="625"/>  625: <b>    {ok, filename:join</b>([PrivDir, lists:concat([Module, &quot;.beam&quot;])])}.
<a name="626"/>  626: 
<a name="run_dialyzer-3"/><a name="627"/>  627: <b>run_dialyzer</b>(Analysis, Files, Opts) -&gt;
<a name="run_dialyzer-last_expr"/><a name="628"/>  628: <b>    dialyzer:run</b>([{analysis_type, Analysis},
<a name="629"/>  629:                   {files, Files},
<a name="630"/>  630:                   {from, byte_code},
<a name="631"/>  631:                   {warnings, [no_unknown]} |
<a name="632"/>  632:                   Opts]).
<a name="633"/>  633: 
<a name="634"/>  634: 
<a name="m_src_without_warning-0"/><a name="m_src_without_warning-last_expr"/><a name="635"/>  635: <b>m_src_without_warning</b>() -&gt; &lt;&lt;&quot;
<a name="636"/>  636:   -module(m).
<a name="637"/>  637:   -export([updt/3]).
<a name="638"/>  638: 
<a name="639"/>  639:   updt(X, K, V) -&gt; X#{ K =&gt; V }.
<a name="640"/>  640:   &quot;&gt;&gt;.
<a name="641"/>  641: 
<a name="m_src_with_warning-0"/><a name="m_src_with_warning-last_expr"/><a name="642"/>  642: <b>m_src_with_warning</b>() -&gt; &lt;&lt;&quot;
<a name="643"/>  643:   -module(m).
<a name="644"/>  644:   -export([updt/3]).
<a name="645"/>  645: 
<a name="646"/>  646:   -spec updt(list(), term(), term()) -&gt; list(). % Warning: Spec is wrong! Function takes a map, not a list
<a name="647"/>  647:   updt(X, K, V) -&gt; X#{ K =&gt; V }.
<a name="648"/>  648:   &quot;&gt;&gt;.
<a name="649"/>  649: 
<a name="adding_warning_apps_after_a_run_without_them_causes_any_new_warnings_to_be_reported-1"/><a name="650"/>  650: <b>adding_warning_apps_after_a_run_without_them_causes_any_new_warnings_to_be_reported</b>(Config) -&gt;
<a name="651"/>  651:     PrivDir = ?config(priv_dir, Config),
<a name="652"/>  652:     PltFile = filename:join(PrivDir, atom_to_list(?FUNCTION_NAME) ++ &quot;.iplt&quot;),
<a name="653"/>  653:     Opts = [{init_plt, [PltFile]}],
<a name="654"/>  654:     OptsNoContractWarn = [{init_plt, [PltFile]}, {warnings, [no_contracts]}],
<a name="655"/>  655:     {ok, Beam} = compile(Config, m_src_with_warning(), m, []),
<a name="656"/>  656:     ?assertEqual(
<a name="657"/>  657:        [],
<a name="658"/>  658:        run_dialyzer(incremental, [Beam], OptsNoContractWarn)),
<a name="adding_warning_apps_after_a_run_without_them_causes_any_new_warnings_to_be_reported-last_expr"/><a name="659"/>  659: <b>    ?assertMatch</b>(
<a name="660"/>  660:        [{warn_contract_types,
<a name="661"/>  661:          {_, {5,4}},
<a name="662"/>  662:          {invalid_contract,[m,updt,3,{[1],true},&quot;([any()],term(),term()) -&gt; [any()]&quot;,&quot;(map(),_,_) -&gt; map()&quot;]}}
<a name="663"/>  663:        ],
<a name="664"/>  664:        run_dialyzer(incremental, [Beam], Opts)).
<a name="665"/>  665: 
<a name="removing_warning_apps_after_a_run_with_them_causes_any_warnings_for_the_removed_apps_not_to_be_reported-1"/><a name="666"/>  666: <b>removing_warning_apps_after_a_run_with_them_causes_any_warnings_for_the_removed_apps_not_to_be_reported</b>(Config) -&gt;
<a name="667"/>  667:     PrivDir = ?config(priv_dir, Config),
<a name="668"/>  668:     PltFile = filename:join(PrivDir, atom_to_list(?FUNCTION_NAME) ++ &quot;.iplt&quot;),
<a name="669"/>  669:     Opts = [{init_plt, [PltFile]}],
<a name="670"/>  670:     OptsNoContractWarn = [{init_plt, [PltFile]}, {warnings, [no_contracts]}],
<a name="671"/>  671:     {ok, Beam} = compile(Config, m_src_with_warning(), m, []),
<a name="672"/>  672:     ?assertMatch(
<a name="673"/>  673:       [{warn_contract_types,
<a name="674"/>  674:           {_, {5,4}},
<a name="675"/>  675:           {invalid_contract,[m,updt,3,{[1],true},&quot;([any()],term(),term()) -&gt; [any()]&quot;,&quot;(map(),_,_) -&gt; map()&quot;]}}
<a name="676"/>  676:       ],
<a name="677"/>  677:       run_dialyzer(incremental, [Beam], Opts)),
<a name="removing_warning_apps_after_a_run_with_them_causes_any_warnings_for_the_removed_apps_not_to_be_reported-last_expr"/><a name="678"/>  678: <b>    ?assertEqual</b>(
<a name="679"/>  679:        [],
<a name="680"/>  680:        run_dialyzer(incremental, [Beam], OptsNoContractWarn)).
<a name="681"/>  681: 
<a name="removing_legal_warnings_with_existing_stored_warnings_in_plt_does_not_result_in_old_warnings_being_printed-1"/><a name="682"/>  682: <b>removing_legal_warnings_with_existing_stored_warnings_in_plt_does_not_result_in_old_warnings_being_printed</b>(Config) -&gt;
<a name="683"/>  683:     PrivDir = ?config(priv_dir, Config),
<a name="684"/>  684:     PltFile = filename:join(PrivDir, atom_to_list(?FUNCTION_NAME) ++ &quot;.iplt&quot;),
<a name="685"/>  685:     Opts = [{init_plt, [PltFile]}],
<a name="686"/>  686:     {ok, BeamFileBefore} = compile(Config, m_src_with_warning(), m, []),
<a name="687"/>  687:     ?assertMatch(
<a name="688"/>  688:       [{warn_contract_types,
<a name="689"/>  689:           {_, {5,4}},
<a name="690"/>  690:           {invalid_contract,[m,updt,3,{[1],true},&quot;([any()],term(),term()) -&gt; [any()]&quot;,&quot;(map(),_,_) -&gt; map()&quot;]}}
<a name="691"/>  691:       ],
<a name="692"/>  692:       run_dialyzer(incremental, [BeamFileBefore], Opts)),
<a name="693"/>  693:     {ok, BeamFileAfter} = compile(Config, m_src_without_warning(), m, []),
<a name="removing_legal_warnings_with_existing_stored_warnings_in_plt_does_not_result_in_old_warnings_being_printed-last_expr"/><a name="694"/>  694: <b>    ?assertEqual</b>(
<a name="695"/>  695:        [],
<a name="696"/>  696:        run_dialyzer(incremental, [BeamFileAfter], Opts)).
<a name="697"/>  697: 
<a name="adding_legal_warnings_with_existing_stored_warnings_in_plt_results_in_new_warnings_being_printed-1"/><a name="698"/>  698: <b>adding_legal_warnings_with_existing_stored_warnings_in_plt_results_in_new_warnings_being_printed</b>(Config) -&gt;
<a name="699"/>  699:     PrivDir = ?config(priv_dir, Config),
<a name="700"/>  700:     PltFile = filename:join(PrivDir, atom_to_list(?FUNCTION_NAME) ++ &quot;.iplt&quot;),
<a name="701"/>  701:     Opts = [{init_plt, [PltFile]}],
<a name="702"/>  702:     {ok, BeamFileAfter} = compile(Config, m_src_without_warning(), m, []),
<a name="703"/>  703:     ?assertEqual(
<a name="704"/>  704:        [],
<a name="705"/>  705:        run_dialyzer(incremental, [BeamFileAfter], Opts)),
<a name="706"/>  706:     {ok, BeamFileBefore} = compile(Config, m_src_with_warning(), m, []),
<a name="adding_legal_warnings_with_existing_stored_warnings_in_plt_results_in_new_warnings_being_printed-last_expr"/><a name="707"/>  707: <b>    ?assertMatch</b>(
<a name="708"/>  708:       [{warn_contract_types,
<a name="709"/>  709:           {_, {5,4}},
<a name="710"/>  710:           {invalid_contract,[m,updt,3,{[1],true},&quot;([any()],term(),term()) -&gt; [any()]&quot;,&quot;(map(),_,_) -&gt; map()&quot;]}}
<a name="711"/>  711:       ],
<a name="712"/>  712:       run_dialyzer(incremental, [BeamFileBefore], Opts)).
<a name="713"/>  713: 
<a name="reading_from_one_plt_and_writing_to_another_does_not_mutate_the_input_plt-1"/><a name="714"/>  714: <b>reading_from_one_plt_and_writing_to_another_does_not_mutate_the_input_plt</b>(Config) when is_list(Config) -&gt;
<a name="715"/>  715:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="716"/>  716:     Prog1 =
<a name="717"/>  717:       &lt;&lt;&quot;-module(foo).
<a name="718"/>  718:          -export([bar/0]).
<a name="719"/>  719: 
<a name="720"/>  720:          -spec bar() -&gt; ok.
<a name="721"/>  721:          bar() -&gt; ok.&quot;&gt;&gt;,
<a name="722"/>  722:     {ok, Beam1} = compile(Config, Prog1, foo, []),
<a name="723"/>  723: 
<a name="724"/>  724:     Plt1 = filename:join(PrivDir, &quot;prog1.iplt&quot;),
<a name="725"/>  725:     ?assertMatch([], dialyzer:run([{analysis_type, incremental},
<a name="726"/>  726:                        {files, [Beam1]},
<a name="727"/>  727:                        {init_plt, Plt1},
<a name="728"/>  728:                        {from, byte_code},
<a name="729"/>  729:                        {warnings, [no_unknown]}])),
<a name="730"/>  730: 
<a name="731"/>  731:     % Now PLT v1 should exist
<a name="732"/>  732:     Plt1ContentsBefore = dialyzer_plt:get_all_contracts(dialyzer_iplt:from_file(Plt1)),
<a name="733"/>  733:     ?assertMatch({ok, {contract,_,_,_}},
<a name="734"/>  734:                  maps:find({foo,bar,0}, Plt1ContentsBefore)),
<a name="735"/>  735:     ?assertMatch(error,
<a name="736"/>  736:                  maps:find({foo,baz,0}, Plt1ContentsBefore)),
<a name="737"/>  737: 
<a name="738"/>  738:     Prog2 =
<a name="739"/>  739:       &lt;&lt;&quot;-module(foo).
<a name="740"/>  740:          -export([bar/0, baz/0]).
<a name="741"/>  741: 
<a name="742"/>  742:          -spec bar() -&gt; ok.
<a name="743"/>  743:          bar() -&gt; ok.
<a name="744"/>  744: 
<a name="745"/>  745:          -spec baz() -&gt; ok.
<a name="746"/>  746:          baz() -&gt; ok.&quot;&gt;&gt;,
<a name="747"/>  747:     {ok, Beam2} = compile(Config, Prog2, foo, []),
<a name="748"/>  748: 
<a name="749"/>  749:     Plt2 = filename:join(PrivDir, &quot;prog2.iplt&quot;),
<a name="750"/>  750:     ?assertMatch([], dialyzer:run([{analysis_type, incremental},
<a name="751"/>  751:                        {files, [Beam2]},
<a name="752"/>  752:                        {init_plt, Plt1},
<a name="753"/>  753:                        {output_plt, Plt2},
<a name="754"/>  754:                        {from, byte_code},
<a name="755"/>  755:                        {warnings, [no_unknown]}])),
<a name="756"/>  756: 
<a name="757"/>  757:     % Now PLT v1 should be the same, but PLT v2 should have the changes in it
<a name="758"/>  758:     Plt1ContentsAfter = dialyzer_plt:get_all_contracts(dialyzer_iplt:from_file(Plt1)),
<a name="759"/>  759:     ?assertMatch({ok, {contract,_,_,_}},
<a name="760"/>  760:                  maps:find({foo,bar,0}, Plt1ContentsAfter)),
<a name="761"/>  761:     ?assertMatch(error,
<a name="762"/>  762:                  maps:find({foo,baz,0}, Plt1ContentsAfter)),
<a name="763"/>  763: 
<a name="764"/>  764:     Plt2Contents = dialyzer_plt:get_all_contracts(dialyzer_iplt:from_file(Plt2)),
<a name="765"/>  765:     ?assertMatch({ok, {contract,_,_,_}},
<a name="766"/>  766:                  maps:find({foo,bar,0}, Plt2Contents)),
<a name="reading_from_one_plt_and_writing_to_another_does_not_mutate_the_input_plt-last_expr"/><a name="767"/>  767: <b>    ?assertMatch</b>({ok, {contract,_,_,_}},
<a name="768"/>  768:                  maps:find({foo,baz,0}, Plt2Contents)).
<a name="769"/>  769: 
<a name="reading_from_and_writing_to_one_plt_mutates_it-1"/><a name="770"/>  770: <b>reading_from_and_writing_to_one_plt_mutates_it</b>(Config) when is_list(Config) -&gt;
<a name="771"/>  771:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="772"/>  772:     Prog1 =
<a name="773"/>  773:       &lt;&lt;&quot;-module(foo).
<a name="774"/>  774:          -export([bar/0]).
<a name="775"/>  775: 
<a name="776"/>  776:          -spec bar() -&gt; ok.
<a name="777"/>  777:          bar() -&gt; ok.&quot;&gt;&gt;,
<a name="778"/>  778:     {ok, Beam1} = compile(Config, Prog1, foo, []),
<a name="779"/>  779: 
<a name="780"/>  780:     Plt = filename:join(PrivDir, &quot;mutate.iplt&quot;),
<a name="781"/>  781:     ?assertMatch([], dialyzer:run([{analysis_type, incremental},
<a name="782"/>  782:                        {files, [Beam1]},
<a name="783"/>  783:                        {init_plt, Plt},
<a name="784"/>  784:                        {from, byte_code},
<a name="785"/>  785:                        {warnings, [no_unknown]}])),
<a name="786"/>  786: 
<a name="787"/>  787:     % Now PLT should exist after running incremental mode
<a name="788"/>  788:     PltContentsBefore = dialyzer_plt:get_all_contracts(dialyzer_iplt:from_file(Plt)),
<a name="789"/>  789:     ?assertMatch({ok, {contract,_,_,_}},
<a name="790"/>  790:                  maps:find({foo,bar,0}, PltContentsBefore)),
<a name="791"/>  791:     ?assertMatch(error,
<a name="792"/>  792:                  maps:find({foo,baz,0}, PltContentsBefore)),
<a name="793"/>  793: 
<a name="794"/>  794:     Prog2 =
<a name="795"/>  795:       &lt;&lt;&quot;-module(foo).
<a name="796"/>  796:          -export([bar/0, baz/0]).
<a name="797"/>  797: 
<a name="798"/>  798:          -spec bar() -&gt; ok.
<a name="799"/>  799:          bar() -&gt; ok.
<a name="800"/>  800: 
<a name="801"/>  801:          -spec baz() -&gt; ok.
<a name="802"/>  802:          baz() -&gt; ok.&quot;&gt;&gt;,
<a name="803"/>  803:     {ok, Beam2} = compile(Config, Prog2, foo, []),
<a name="804"/>  804: 
<a name="805"/>  805:     ?assertMatch([], dialyzer:run([{analysis_type, incremental},
<a name="806"/>  806:                        {files, [Beam2]},
<a name="807"/>  807:                        {init_plt, Plt},
<a name="808"/>  808:                        {output_plt, Plt},
<a name="809"/>  809:                        {from, byte_code},
<a name="810"/>  810:                        {warnings, [no_unknown]}])),
<a name="811"/>  811: 
<a name="812"/>  812:     % Now PLT should have been mutated to contain the new version of module 'foo'
<a name="813"/>  813:     PltContentsAfter = dialyzer_plt:get_all_contracts(dialyzer_iplt:from_file(Plt)),
<a name="814"/>  814:     ?assertMatch({ok, {contract,_,_,_}}, maps:find({foo,bar,0}, PltContentsAfter)),
<a name="reading_from_and_writing_to_one_plt_mutates_it-last_expr"/><a name="815"/>  815: <b>    ?assertMatch</b>({ok, {contract,_,_,_}}, maps:find({foo,baz,0}, PltContentsAfter)).
<a name="816"/>  816: 
<a name="beams_with_no_debug_info_are_rejected-1"/><a name="817"/>  817: <b>beams_with_no_debug_info_are_rejected</b>(Config) when is_list(Config) -&gt;
<a name="818"/>  818:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="819"/>  819:     Plt = filename:join(PrivDir, atom_to_list(?FUNCTION_NAME) ++ &quot;.iplt&quot;),
<a name="820"/>  820:     Src = &lt;&lt;&quot;
<a name="821"/>  821:         -module(my_list).
<a name="822"/>  822: 
<a name="823"/>  823:         -export([my_size/1]).
<a name="824"/>  824: 
<a name="825"/>  825:         -spec my_size(list()) -&gt; non_neg_integer().
<a name="826"/>  826:         my_size([]) -&gt;
<a name="827"/>  827:             0;
<a name="828"/>  828:         my_size({N,_}) -&gt;
<a name="829"/>  829:             N;
<a name="830"/>  830:         my_size([_|T]) -&gt;
<a name="831"/>  831:             1+my_size(T).
<a name="832"/>  832:     &quot;&gt;&gt;,
<a name="833"/>  833:     SrcFilename = filename:join([PrivDir, &quot;my_list.erl&quot;]),
<a name="834"/>  834:     ok = file:write_file(SrcFilename, Src),
<a name="835"/>  835:     Opts = [{outdir, PrivDir}], % No debug info enabled
<a name="836"/>  836:     {ok, Module} = compile:file(SrcFilename, Opts),
<a name="837"/>  837:     BeamFile = filename:join([PrivDir, lists:concat([Module, &quot;.beam&quot;])]),
<a name="838"/>  838: 
<a name="beams_with_no_debug_info_are_rejected-last_expr"/><a name="839"/>  839: <b>    ?assertThrow</b>(
<a name="840"/>  840:        {dialyzer_error, &quot;Could not compute MD5 for .beam (debug_info error) - did you forget to set the debug_info compilation option? &quot; ++ _},
<a name="841"/>  841:        run_dialyzer(incremental, [BeamFile], [{output_plt, Plt}])).
</pre>
<script>
var hash = window.location.hash.substring(1);
var anchor = document.getElementsByName(hash);
anchor[0].style.backgroundColor="orange";
</script>
</body>
</html>
