<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/lib/stdlib/make_test_dir/stdlib_test/peer_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%% @doc</i>
<a name="2"/>    2: <i>%%% Smoke tests for peer node controller</i>
<a name="3"/>    3: <i>%%% @end</i>
<a name="4"/>    4: <b>-module</b>(peer_SUITE).
<a name="5"/>    5: <b>-author</b>(&quot;maximfca@gmail.com&quot;).
<a name="6"/>    6: 
<a name="7"/>    7: <i>%% Common Test headers</i>
<a name="8"/>    8: <b>-include_lib</b>(&quot;stdlib/include/assert.hrl&quot;).
<a name="9"/>    9: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="10"/>   10: 
<a name="11"/>   11: <i>%% Test server callbacks</i>
<a name="12"/>   12: <b>-export</b>([
<a name="13"/>   13:     suite/0,
<a name="14"/>   14:     all/0,
<a name="15"/>   15:     groups/0,
<a name="16"/>   16:     init_per_group/2,
<a name="17"/>   17:     end_per_group/2
<a name="18"/>   18: ]).
<a name="19"/>   19: 
<a name="20"/>   20: <i>%% Test cases</i>
<a name="21"/>   21: <b>-export</b>([
<a name="22"/>   22:     dist/0, dist/1,
<a name="23"/>   23:     peer_down_crash/0, peer_down_crash/1,
<a name="24"/>   24:     peer_down_crash_tcp/1,
<a name="25"/>   25:     peer_down_continue/0, peer_down_continue/1,
<a name="26"/>   26:     peer_down_boot/0, peer_down_boot/1,
<a name="27"/>   27:     dist_io_redirect/0, dist_io_redirect/1,
<a name="28"/>   28:     dist_localhost/0, dist_localhost/1,
<a name="29"/>   29:     errors/0, errors/1,
<a name="30"/>   30:     basic/0, basic/1,
<a name="31"/>   31:     peer_states/0, peer_states/1,
<a name="32"/>   32:     cast/0, cast/1,
<a name="33"/>   33:     detached/0, detached/1,
<a name="34"/>   34:     dyn_peer/0, dyn_peer/1,
<a name="35"/>   35:     stop_peer/0, stop_peer/1,
<a name="36"/>   36:     shutdown_halt/0, shutdown_halt/1,
<a name="37"/>   37:     shutdown_halt_timeout/0, shutdown_halt_timeout/1,
<a name="38"/>   38:     shutdown_stop/0, shutdown_stop/1,
<a name="39"/>   39:     shutdown_stop_timeout/0, shutdown_stop_timeout/1,
<a name="40"/>   40:     shutdown_close/0, shutdown_close/1,
<a name="41"/>   41:     init_debug/0, init_debug/1,
<a name="42"/>   42:     io_redirect/0, io_redirect/1,
<a name="43"/>   43:     multi_node/0, multi_node/1,
<a name="44"/>   44:     dist_up_down/0, dist_up_down/1,
<a name="45"/>   45:     duplicate_name/0, duplicate_name/1,
<a name="46"/>   46:     old_release/0, old_release/1,
<a name="47"/>   47:     ssh/0, ssh/1,
<a name="48"/>   48:     docker/0, docker/1,
<a name="49"/>   49:     cntrl_channel_handler_crash/0, cntrl_channel_handler_crash/1,
<a name="50"/>   50:     cntrl_channel_handler_crash_old_release/0, cntrl_channel_handler_crash_old_release/1
<a name="51"/>   51: ]).
<a name="52"/>   52: 
<a name="suite-0"/><a name="53"/>   53: <b>suite</b>() -&gt;
<a name="suite-last_expr"/><a name="54"/>   54:     [{timetrap, {minutes, 1}}].
<a name="55"/>   55: 
<a name="shutdown_alternatives-0"/><a name="56"/>   56: <b>shutdown_alternatives</b>() -&gt;
<a name="shutdown_alternatives-last_expr"/><a name="57"/>   57:     [shutdown_halt, shutdown_halt_timeout, shutdown_stop, shutdown_stop_timeout, shutdown_close].
<a name="58"/>   58: 
<a name="alternative-0"/><a name="59"/>   59: <b>alternative</b>() -&gt;
<a name="alternative-last_expr"/><a name="60"/>   60:     [basic, peer_states, cast, detached, dyn_peer, stop_peer,
<a name="61"/>   61:      io_redirect, multi_node, duplicate_name, cntrl_channel_handler_crash,
<a name="62"/>   62:      cntrl_channel_handler_crash_old_release | shutdown_alternatives()].
<a name="63"/>   63: 
<a name="groups-0"/><a name="64"/>   64: <b>groups</b>() -&gt;
<a name="groups-last_expr"/><a name="65"/>   65:     [
<a name="66"/>   66:         {dist, [parallel], [errors, dist, peer_down_crash, peer_down_continue, peer_down_boot,
<a name="67"/>   67:                             dist_up_down, dist_localhost, cntrl_channel_handler_crash,
<a name="68"/>   68:                             cntrl_channel_handler_crash_old_release | shutdown_alternatives()]},
<a name="69"/>   69:         {dist_seq, [], [dist_io_redirect,      %% Cannot be run in parallel in dist group
<a name="70"/>   70:                         peer_down_crash_tcp]},
<a name="71"/>   71:         {tcp, [parallel], alternative()},
<a name="72"/>   72:         {standard_io, [parallel], [init_debug | alternative()]},
<a name="73"/>   73:         {compatibility, [parallel], [old_release]},
<a name="74"/>   74:         {remote, [parallel], [ssh]}
<a name="75"/>   75:     ].
<a name="76"/>   76: 
<a name="all-0"/><a name="77"/>   77: <b>all</b>() -&gt;
<a name="all-last_expr"/><a name="78"/>   78:     [{group, dist}, {group, dist_seq}, {group, tcp}, {group, standard_io},
<a name="79"/>   79:      {group, compatibility}, {group, remote}].
<a name="80"/>   80: 
<a name="init_per_group-2"/><a name="81"/>   81: <b>init_per_group</b>(remote, Config) -&gt;
<a name="82"/>   82:     %% check that SSH can connect to localhost, skip the test if not
<a name="83"/>   83:     try os:cmd(&quot;ssh localhost echo ok&quot;) of
<a name="84"/>   84:         &quot;ok\n&quot; -&gt; Config;
<a name="85"/>   85:         _ -&gt; {skip, &quot;'ssh localhost echo ok' did not return ok&quot;}
<a name="86"/>   86:     catch
<a name="87"/>   87:         Class:Reason -&gt;
<a name="88"/>   88:             SkipReason = io_lib:format(&quot;'ssh localhost echo ok' failed with ~s:~p&quot;, [Class, Reason]),
<a name="89"/>   89:             {skip, SkipReason}
<a name="90"/>   90:     end;
<a name="91"/>   91: <b>init_per_group</b>(dist, Config) -&gt;
<a name="92"/>   92:     case erlang:is_alive() of
<a name="93"/>   93:         true -&gt; Config;
<a name="94"/>   94:         false -&gt; {skip, &quot;origin is not distributed&quot;}
<a name="95"/>   95:     end;
<a name="96"/>   96: <b>init_per_group</b>(tcp, Config) -&gt;
<a name="97"/>   97:     [{connection, 0} | Config];
<a name="98"/>   98: <b>init_per_group</b>(standard_io, Config) -&gt;
<a name="99"/>   99:     [{connection, standard_io} | Config];
<a name="100"/>  100: <b>init_per_group</b>(_Group, Config) -&gt;
<a name="init_per_group-last_expr"/><a name="101"/>  101:     Config.
<a name="102"/>  102: 
<a name="end_per_group-2"/><a name="103"/>  103: <b>end_per_group</b>(_TestCase, Config) -&gt;
<a name="end_per_group-last_expr"/><a name="104"/>  104: <b>    proplists:delete</b>(connection, Config).
<a name="105"/>  105: 
<a name="106"/>  106: <i>%% -------------------------------------------------------------------</i>
<a name="107"/>  107: <i>%% Distribution-enabled cases</i>
<a name="108"/>  108: 
<a name="errors-0"/><a name="109"/>  109: <b>errors</b>() -&gt;
<a name="errors-last_expr"/><a name="110"/>  110:     [{doc, &quot;Verify that invalid command line is rejected immediately&quot;}].
<a name="111"/>  111: 
<a name="errors-1"/><a name="112"/>  112: <b>errors</b>(Config) when is_list(Config) -&gt;
<a name="113"/>  113:     ?assertException(error, {invalid_arg, atom}, peer:start(#{args =&gt; atom})),
<a name="114"/>  114:     ?assertException(error, {invalid_arg, $s}, peer:start(#{args =&gt; &quot;string&quot;})),
<a name="115"/>  115:     ?assertException(error, {invalid_arg, [&quot;2&quot;]}, peer:start(#{args =&gt; [&quot;1&quot;, [&quot;2&quot;]]})),
<a name="116"/>  116:     ?assertException(error, {exec, atom}, peer:start(#{exec =&gt; atom, name =&gt; name})),
<a name="117"/>  117:     ?assertException(error, {exec, atom}, peer:start(#{exec =&gt; {atom, []}, name =&gt; name})),
<a name="118"/>  118:     ?assertException(error, {exec, atom}, peer:start(#{exec =&gt; {&quot;erl&quot;, [atom]}, name =&gt; name})),
<a name="errors-last_expr"/><a name="119"/>  119: <b>    ?assertException</b>(error, not_alive, peer:start(#{})). %% peer node won't start - it's not alive
<a name="120"/>  120: 
<a name="dist-0"/><a name="121"/>  121: <b>dist</b>() -&gt;
<a name="dist-last_expr"/><a name="122"/>  122:     [{doc, &quot;Classic behaviour: detached peer with no alternative, connects via dist&quot;}].
<a name="123"/>  123: 
<a name="124"/>  124: <i>%% Classic 'slave': start new node locally, with random name, ask peer control process to exit normally</i>
<a name="dist-1"/><a name="125"/>  125: <b>dist</b>(Config) when is_list(Config) -&gt;
<a name="126"/>  126:     {ok, Peer, Node} = peer:start_link(),
<a name="127"/>  127:     %% distribution is expected to be connected
<a name="128"/>  128:     ?assertEqual(Node, erpc:call(Node, erlang, node, [])),
<a name="129"/>  129:     %% but not alternative...
<a name="130"/>  130:     ?assertException(error, noconnection, peer:call(Peer, erlang, node, [])),
<a name="131"/>  131:     ?assertEqual(true, net_kernel:disconnect(Node)),
<a name="132"/>  132:     %% ^^^ this makes the node go down, but we also need to ensure that net_kernel
<a name="133"/>  133:     %%  finished processing
<a name="134"/>  134:     ct:sleep(500),
<a name="135"/>  135:     _ = sys:get_state(net_kernel),
<a name="dist-last_expr"/><a name="136"/>  136: <b>    ?assertException</b>(exit, {noproc, _}, peer:get_state(Peer)).
<a name="137"/>  137: 
<a name="peer_down_crash-0"/><a name="138"/>  138: <b>peer_down_crash</b>() -&gt;
<a name="peer_down_crash-last_expr"/><a name="139"/>  139:     [{doc, &quot;Tests peer_down handling when crash mode is requested&quot;}].
<a name="140"/>  140: 
<a name="peer_down_crash-1"/><a name="141"/>  141: <b>peer_down_crash</b>(Config) when is_list(Config) -&gt;
<a name="142"/>  142:     %% two-way link: &quot;crash&quot; mode
<a name="143"/>  143:     {ok, Peer, Node} = peer:start_link(#{name =&gt; peer:random_name(?FUNCTION_NAME),
<a name="144"/>  144:         args =&gt; [&quot;-connect_all&quot;, &quot;false&quot;], peer_down =&gt; crash}),
<a name="145"/>  145:     %% verify node started locally
<a name="146"/>  146:     ?assertEqual(Node, erpc:call(Node, erlang, node, [])),
<a name="147"/>  147:     %% verify there is no alternative connection
<a name="148"/>  148:     ?assertException(error, noconnection, peer:call(Peer, erlang, node, [])),
<a name="149"/>  149:     %% unlink and monitor
<a name="150"/>  150:     unlink(Peer),
<a name="151"/>  151:     MRef = monitor(process, Peer),
<a name="152"/>  152:     ?assertEqual(true, net_kernel:disconnect(Node)),
<a name="153"/>  153:     %% ^^^ this makes the node go down
<a name="154"/>  154:     %% since two-way link is requested, it triggers peer to stop
<a name="peer_down_crash-last_expr"/><a name="155"/>  155:     receive
<a name="156"/>  156:         {'DOWN', MRef, process, Peer, {nodedown, Node}} -&gt;
<a name="157"/>  157:             ok
<a name="158"/>  158:     after 2000 -&gt;
<a name="159"/>  159:         link(Peer),
<a name="160"/>  160:         {fail, disconnect_timeout}
<a name="161"/>  161:     end.
<a name="162"/>  162: 
<a name="163"/>  163: <i>%% Verify option combo #{peer_down=&gt;crash, connection=&gt;0}</i>
<a name="164"/>  164: <i>%% exits control process abnormally.</i>
<a name="peer_down_crash_tcp-1"/><a name="165"/>  165: <b>peer_down_crash_tcp</b>(Config) when is_list(Config) -&gt;
<a name="166"/>  166:     %% two-way link: &quot;crash&quot; mode
<a name="167"/>  167:     {ok, Peer, Node} = peer:start_link(#{name =&gt; peer:random_name(?FUNCTION_NAME),
<a name="168"/>  168:                                          peer_down =&gt; crash,
<a name="169"/>  169:                                          connection =&gt; 0}),
<a name="170"/>  170:     %% verify node started locally
<a name="171"/>  171:     ?assertEqual(Node, peer:call(Peer, erlang, node, [])),
<a name="172"/>  172:     %% verify there is no distribution connection
<a name="173"/>  173:     ?assertEqual([], erlang:nodes(connected)),
<a name="174"/>  174:     %% unlink and monitor
<a name="175"/>  175:     unlink(Peer),
<a name="176"/>  176:     MRef = monitor(process, Peer),
<a name="177"/>  177:     %% Make the node go down
<a name="178"/>  178:     ok = erpc:cast(Node, erlang, halt, [0]),
<a name="179"/>  179: 
<a name="180"/>  180:     %% since two-way link is requested, it triggers peer to stop
<a name="peer_down_crash_tcp-last_expr"/><a name="181"/>  181:     receive
<a name="182"/>  182:         {'DOWN', MRef, process, Peer, tcp_closed} -&gt;
<a name="183"/>  183:             ok
<a name="184"/>  184:     after 5000 -&gt;
<a name="185"/>  185:         link(Peer),
<a name="186"/>  186:         {fail, disconnect_timeout}
<a name="187"/>  187:     end.
<a name="188"/>  188: 
<a name="peer_down_continue-0"/><a name="189"/>  189: <b>peer_down_continue</b>() -&gt;
<a name="peer_down_continue-last_expr"/><a name="190"/>  190:     [{doc, &quot;Tests peer_down handling for continue setting&quot;}].
<a name="191"/>  191: 
<a name="peer_down_continue-1"/><a name="192"/>  192: <b>peer_down_continue</b>(Config) when is_list(Config) -&gt;
<a name="193"/>  193:     {ok, Peer, Node} = peer:start_link(#{name =&gt; peer:random_name(?FUNCTION_NAME),
<a name="194"/>  194:         args =&gt; [&quot;-connect_all&quot;, &quot;false&quot;], peer_down =&gt; continue}),
<a name="195"/>  195:     ?assertEqual(ok, erpc:cast(Node, erlang, halt, [])),
<a name="196"/>  196:     ct:sleep(500),
<a name="197"/>  197:     sys:replace_state(net_kernel, fun(S) -&gt; sys:get_state(Peer), S end),
<a name="198"/>  198:     ?assertMatch({down, _}, peer:get_state(Peer)),
<a name="peer_down_continue-last_expr"/><a name="199"/>  199: <b>    peer:stop</b>(Peer).
<a name="200"/>  200: 
<a name="peer_down_boot-0"/><a name="201"/>  201: <b>peer_down_boot</b>() -&gt;
<a name="peer_down_boot-last_expr"/><a name="202"/>  202:     [{doc, &quot;Tests that peer node failing boot fails start_link correctly&quot;}].
<a name="203"/>  203: 
<a name="peer_down_boot-1"/><a name="204"/>  204: <b>peer_down_boot</b>(Config) when is_list(Config) -&gt;
<a name="peer_down_boot-last_expr"/><a name="205"/>  205: <b>    ?assertException</b>(exit, {boot_failed, {exit_status, 1}},
<a name="206"/>  206:         peer:start_link(#{connection =&gt; standard_io, name =&gt; peer:random_name(), args =&gt; [&quot;-no_epmd&quot;]})).
<a name="207"/>  207: 
<a name="dist_io_redirect-0"/><a name="208"/>  208: <b>dist_io_redirect</b>() -&gt;
<a name="dist_io_redirect-last_expr"/><a name="209"/>  209:     [{doc, &quot;Tests i/o redirection working for dist&quot;}].
<a name="210"/>  210: 
<a name="dist_io_redirect-1"/><a name="211"/>  211: <b>dist_io_redirect</b>(Config) when is_list(Config) -&gt;
<a name="212"/>  212:     %% Common Test changes group leader process to capture output.
<a name="213"/>  213:     %% 'peer' relays output via control process group leader.
<a name="214"/>  214:     ct:capture_start(),
<a name="215"/>  215:     {ok, Peer, Node} = peer:start_link(#{name =&gt; peer:random_name(?FUNCTION_NAME),
<a name="216"/>  216:         args =&gt; [&quot;-connect_all&quot;, &quot;false&quot;, &quot;-eval&quot;, &quot;io:format(\&quot;out\&quot;).&quot;]}),
<a name="217"/>  217:     %% RPC is smart enough to set the group leader, so force 'user' output
<a name="218"/>  218:     %% to check that peer node redirects 'user' to the current process group
<a name="219"/>  219:     %% leader.
<a name="220"/>  220:     ?assertEqual(ok, erpc:call(Node, io, format, [user, &quot;STRONGFLOUR.&quot;, []])),
<a name="221"/>  221:     %% verify that 'send' is ignored when no alternative connection is done
<a name="222"/>  222:     ?assertEqual(ok, peer:send(Peer, init, {stop, stop})),
<a name="223"/>  223:     %% check that RPC sets the group leader, even via 'apply'
<a name="224"/>  224:     ?assertEqual(ok, erpc:call(Node, erlang, apply, [io, format, [&quot;second.&quot;]])),
<a name="225"/>  225:     %% 'eval' at the end may be quite slow, so have to wait here
<a name="226"/>  226:     ct:sleep(500),
<a name="227"/>  227:     peer:stop(Peer),
<a name="228"/>  228:     ct:capture_stop(),
<a name="229"/>  229:     Texts = ct:capture_get(),
<a name="230"/>  230:     %% order is not guaranteed, so sort explicitly
<a name="dist_io_redirect-last_expr"/><a name="231"/>  231: <b>    ?assertEqual</b>(lists:sort([&quot;STRONGFLOUR.&quot;, &quot;second.&quot;, &quot;out&quot;]), lists:sort(Texts)).
<a name="232"/>  232: 
<a name="dist_up_down-0"/><a name="233"/>  233: <b>dist_up_down</b>() -&gt;
<a name="dist_up_down-last_expr"/><a name="234"/>  234: <b>    [{doc, &quot;Test that Erlang distribution can go up and down </b>(with TCP alternative)&quot;}].
<a name="235"/>  235: 
<a name="dist_up_down-1"/><a name="236"/>  236: <b>dist_up_down</b>(Config) when is_list(Config) -&gt;
<a name="237"/>  237:     %% skip establishing full mesh, for it makes 'global' hang
<a name="238"/>  238:     %% TODO: fix 'global.erl' locker process so it does not hang
<a name="239"/>  239:     {ok, Peer, Node} = peer:start_link(#{name =&gt; peer:random_name(?FUNCTION_NAME),
<a name="240"/>  240:         connection =&gt; {{127, 0, 0, 1}, 0}, args =&gt; [&quot;-connect_all&quot;, &quot;false&quot;]}),
<a name="241"/>  241:     ?assertEqual(true, net_kernel:connect_node(Node)),
<a name="242"/>  242:     ?assertEqual(true, net_kernel:disconnect(Node)),
<a name="243"/>  243:     ?assertEqual(true, net_kernel:connect_node(Node)),
<a name="dist_up_down-last_expr"/><a name="244"/>  244: <b>    peer:stop</b>(Peer).
<a name="245"/>  245: 
<a name="dist_localhost-0"/><a name="246"/>  246: <b>dist_localhost</b>() -&gt;
<a name="dist_localhost-last_expr"/><a name="247"/>  247:     [{doc, &quot;Test that localhost and gethostname operate together&quot;}].
<a name="248"/>  248: 
<a name="dist_localhost-1"/><a name="249"/>  249: <b>dist_localhost</b>(Config) when is_list(Config) -&gt;
<a name="250"/>  250:     {ok, Peer, Node} = peer:start_link(#{name =&gt; peer:random_name(?FUNCTION_NAME), host =&gt; &quot;localhost&quot;}),
<a name="251"/>  251:     ?assertMatch([_, &quot;localhost&quot;], string:lexemes(atom_to_list(Node), &quot;@&quot;)),
<a name="252"/>  252:     %% start second peer, ensure they see each other
<a name="253"/>  253:     {ok, Host} = inet:gethostname(),
<a name="254"/>  254:     {ok, Peer2, Node2} = peer:start_link(#{name =&gt; peer:random_name(?FUNCTION_NAME), host =&gt; Host}),
<a name="255"/>  255:     true = erpc:call(Node, net_kernel, connect_node, [Node2]),
<a name="256"/>  256:     peer:stop(Peer),
<a name="dist_localhost-last_expr"/><a name="257"/>  257: <b>    peer:stop</b>(Peer2).
<a name="258"/>  258: 
<a name="259"/>  259: <i>%% -------------------------------------------------------------------</i>
<a name="260"/>  260: <i>%% alternative connection cases</i>
<a name="261"/>  261: 
<a name="262"/>  262: <i>%% Runs in the peer node context, forward a message from peer node to origin</i>
<a name="263"/>  263: <i>%%  node via alternative connection.</i>
<a name="264"/>  264: <b>-spec forward</b>(Dest :: pid() | atom(), Message :: term()) -&gt; term().
<a name="forward-2"/><a name="265"/>  265: <b>forward</b>(Dest, Message) -&gt;
<a name="forward-last_expr"/><a name="266"/>  266: <b>    group_leader</b>() ! {message, Dest, Message}.
<a name="267"/>  267: 
<a name="basic-0"/><a name="268"/>  268: <b>basic</b>() -&gt;
<a name="basic-last_expr"/><a name="269"/>  269:     [{doc, &quot;Tests peer node start, and do some RPC via stdin/stdout&quot;}].
<a name="270"/>  270: 
<a name="basic-1"/><a name="271"/>  271: <b>basic</b>(Config) when is_list(Config) -&gt;
<a name="272"/>  272:     Conn = proplists:get_value(connection, Config),
<a name="273"/>  273:     {ok, Peer, _Node} = peer:start_link(#{connection =&gt; Conn}),
<a name="274"/>  274:     %% test the alternative connection
<a name="275"/>  275:     ?assertEqual('nonode@nohost', peer:call(Peer, erlang, node, [])),
<a name="276"/>  276:     ?assertException(throw, ball, peer:call(Peer, erlang, throw, [ball])),
<a name="277"/>  277:     %% setup code path to this module (needed to &quot;fancy RPC&quot;)
<a name="278"/>  278:     Path = filename:dirname(code:which(?MODULE)),
<a name="279"/>  279:     ?assertEqual(true, peer:call(Peer, code, add_path, [Path])),
<a name="280"/>  280:     %% fancy RPC via message exchange (uses forwarding from the peer)
<a name="281"/>  281:     Control = self(),
<a name="282"/>  282:     RFun = fun() -&gt; receive do -&gt; forward(Control, done) end end,
<a name="283"/>  283:     RemotePid = peer:call(Peer, erlang, spawn, [RFun]),
<a name="284"/>  284:     peer:send(Peer, RemotePid, do),
<a name="285"/>  285:     %% wait back from that process
<a name="286"/>  286:     receive done -&gt; ok end,
<a name="287"/>  287:     %% shutdown the node
<a name="288"/>  288:     ?assertEqual(ok, peer:stop(Peer)),
<a name="basic-last_expr"/><a name="289"/>  289: <b>    ?assertNot</b>(is_process_alive(Peer)).
<a name="290"/>  290: 
<a name="peer_states-0"/><a name="291"/>  291: <b>peer_states</b>() -&gt;
<a name="peer_states-last_expr"/><a name="292"/>  292:     [{doc, &quot;Tests peer node states&quot;}].
<a name="293"/>  293: 
<a name="peer_states-1"/><a name="294"/>  294: <b>peer_states</b>(Config) when is_list(Config) -&gt;
<a name="295"/>  295:     Conn = proplists:get_value(connection, Config),
<a name="296"/>  296:     {ok, Peer} = peer:start_link(#{connection =&gt; Conn, wait_boot =&gt; {self(), ?FUNCTION_NAME},
<a name="297"/>  297:         peer_down =&gt; continue}),
<a name="298"/>  298:     ?assertEqual(booting, peer:get_state(Peer)),
<a name="299"/>  299:     %% running
<a name="300"/>  300:     receive {?FUNCTION_NAME, {started, _Node, Peer}} -&gt; ok end,
<a name="301"/>  301:     ?assertEqual(running, peer:get_state(Peer)),
<a name="302"/>  302:     peer:cast(Peer, erlang, halt, []),
<a name="303"/>  303:     ct:sleep(1000), %% source of flakiness, should switch to some better notification mechanism
<a name="304"/>  304:     %% down
<a name="305"/>  305:     ?assertMatch({down, _}, peer:get_state(Peer)),
<a name="peer_states-last_expr"/><a name="306"/>  306: <b>    peer:stop</b>(Peer).
<a name="307"/>  307: 
<a name="cast-0"/><a name="308"/>  308: <b>cast</b>() -&gt;
<a name="cast-last_expr"/><a name="309"/>  309:     [{doc, &quot;Tests casts via alternative connections&quot;}].
<a name="310"/>  310: 
<a name="cast-1"/><a name="311"/>  311: <b>cast</b>(Config) when is_list(Config) -&gt;
<a name="312"/>  312:     Conn = proplists:get_value(connection, Config),
<a name="313"/>  313:     {ok, Peer, _Node} = peer:start_link(#{connection =&gt; Conn}),
<a name="314"/>  314:     %% cast RPC
<a name="315"/>  315:     ?assertEqual(undefined, peer:call(Peer, application, get_env, [kernel, foo])),
<a name="316"/>  316:     peer:cast(Peer, application, set_env, [kernel, foo, bar]),
<a name="317"/>  317:     %% this is only to ensure application_controller completed processing
<a name="318"/>  318:     peer:call(Peer, sys, get_state, [application_controller]),
<a name="319"/>  319:     ?assertEqual({ok, bar}, peer:call(Peer, application, get_env, [kernel, foo])),
<a name="cast-last_expr"/><a name="320"/>  320: <b>    peer:stop</b>(Peer).
<a name="321"/>  321: 
<a name="detached-0"/><a name="322"/>  322: <b>detached</b>() -&gt;
<a name="detached-last_expr"/><a name="323"/>  323: <b>    [{doc, &quot;Tests detached node </b>(RPC via alternative connection)&quot;}].
<a name="324"/>  324: 
<a name="detached-1"/><a name="325"/>  325: <b>detached</b>(Config) when is_list(Config) -&gt;
<a name="326"/>  326:     Conn = proplists:get_value(connection, Config),
<a name="327"/>  327:     {ok, Peer, _Node} = peer:start_link(#{connection =&gt; Conn}),
<a name="328"/>  328:     ?assertEqual('nonode@nohost', peer:call(Peer, erlang, node, [])),
<a name="329"/>  329:     %% check exceptions
<a name="330"/>  330:     ?assertException(throw, ball, peer:call(Peer, erlang, throw, [ball])),
<a name="331"/>  331:     %% check tcp forwarding
<a name="332"/>  332:     Path = filename:dirname(code:which(?MODULE)),
<a name="333"/>  333:     ?assertEqual(true, peer:call(Peer, code, add_path, [Path])),
<a name="334"/>  334:     %% fancy RPC via message exchange (uses forwarding from the peer)
<a name="335"/>  335:     Control = self(),
<a name="336"/>  336:     RFun = fun() -&gt; receive do -&gt; forward(Control, done) end end,
<a name="337"/>  337:     RemotePid = peer:call(Peer, erlang, spawn, [RFun]),
<a name="338"/>  338:     %% test that sending message over alternative TCP connection works
<a name="339"/>  339:     peer:send(Peer, RemotePid, do),
<a name="340"/>  340:     %% wait back from that process
<a name="341"/>  341:     receive done -&gt; ok end,
<a name="342"/>  342:     %% logging via TCP
<a name="343"/>  343:     ct:capture_start(),
<a name="344"/>  344:     peer:call(Peer, io, format, [&quot;one.&quot;]),
<a name="345"/>  345:     peer:call(Peer, erlang, apply, [io, format, [&quot;two.&quot;]]),
<a name="346"/>  346:     peer:stop(Peer),
<a name="347"/>  347:     ct:capture_stop(),
<a name="348"/>  348:     Texts = ct:capture_get(),
<a name="349"/>  349:     %% just stop
<a name="detached-last_expr"/><a name="350"/>  350: <b>    ?assertEqual</b>([&quot;one.&quot;, &quot;two.&quot;], Texts).
<a name="351"/>  351: 
<a name="dyn_peer-0"/><a name="352"/>  352: <b>dyn_peer</b>() -&gt;
<a name="dyn_peer-last_expr"/><a name="353"/>  353:     [{doc, &quot;Origin is not distributed, and peer becomes distributed dynamically&quot;}].
<a name="354"/>  354: 
<a name="dyn_peer-1"/><a name="355"/>  355: <b>dyn_peer</b>(Config) when is_list(Config) -&gt;
<a name="356"/>  356:     Conn = proplists:get_value(connection, Config),
<a name="357"/>  357:     {ok, Peer, 'nonode@nohost'} = peer:start_link(#{connection =&gt; Conn}), %% start not distributed
<a name="358"/>  358:     Node = list_to_atom(lists:concat([peer:random_name(?FUNCTION_NAME), &quot;@forced.host&quot;])),
<a name="359"/>  359:     {ok, _} = peer:call(Peer, net_kernel, start, [[Node, longnames]]),
<a name="360"/>  360:     ?assertEqual(Node, peer:call(Peer, erlang, node, [])),
<a name="dyn_peer-last_expr"/><a name="361"/>  361: <b>    peer:stop</b>(Peer).
<a name="362"/>  362: 
<a name="stop_peer-0"/><a name="363"/>  363: <b>stop_peer</b>() -&gt;
<a name="stop_peer-last_expr"/><a name="364"/>  364:     [{doc, &quot;Test that peer shuts down even when node sleeps, but control connection closed&quot;}].
<a name="365"/>  365: 
<a name="stop_peer-1"/><a name="366"/>  366: <b>stop_peer</b>(Config) when is_list(Config) -&gt;
<a name="367"/>  367:     Conn = proplists:get_value(connection, Config),
<a name="368"/>  368:     {ok, Peer, _Node} = peer:start_link(#{name =&gt; peer:random_name(?FUNCTION_NAME),
<a name="369"/>  369:         connection =&gt; Conn, args =&gt; [&quot;-eval&quot;, &quot;timer:sleep(60000).&quot;]}),
<a name="370"/>  370:     %% shutdown node
<a name="stop_peer-last_expr"/><a name="371"/>  371: <b>    peer:stop</b>(Peer).
<a name="372"/>  372: 
<a name="shutdown_halt-0"/><a name="373"/>  373: <b>shutdown_halt</b>() -&gt;
<a name="shutdown_halt-last_expr"/><a name="374"/>  374:     [{doc, &quot;Test that peer shutdown halt wait until node connection is down&quot;}].
<a name="shutdown_halt-1"/><a name="375"/>  375: <b>shutdown_halt</b>(Config) when is_list(Config) -&gt;
<a name="376"/>  376:     false = shutdown_test(Config, ?FUNCTION_NAME, halt, 500, false, 1000),
<a name="shutdown_halt-last_expr"/><a name="377"/>  377:     ok.
<a name="378"/>  378: 
<a name="shutdown_halt_timeout-0"/><a name="379"/>  379: <b>shutdown_halt_timeout</b>() -&gt;
<a name="shutdown_halt_timeout-last_expr"/><a name="380"/>  380:     [{doc, &quot;Test that peer shutdown halt forcefully takes down connection on timeout&quot;}].
<a name="shutdown_halt_timeout-1"/><a name="381"/>  381: <b>shutdown_halt_timeout</b>(Config) when is_list(Config) -&gt;
<a name="382"/>  382:     false = shutdown_test(Config, ?FUNCTION_NAME, {halt, 1000}, 5000, true, 1500),
<a name="shutdown_halt_timeout-last_expr"/><a name="383"/>  383:     ok.
<a name="384"/>  384: 
<a name="shutdown_stop-0"/><a name="385"/>  385: <b>shutdown_stop</b>() -&gt;
<a name="shutdown_stop-last_expr"/><a name="386"/>  386:     [{doc, &quot;Test that peer shutdown stop wait until node connection is down&quot;}].
<a name="shutdown_stop-1"/><a name="387"/>  387: <b>shutdown_stop</b>(Config) when is_list(Config) -&gt;
<a name="388"/>  388:     false = shutdown_test(Config, ?FUNCTION_NAME, infinity, 500, false, 2000),
<a name="shutdown_stop-last_expr"/><a name="389"/>  389:     ok.
<a name="390"/>  390: 
<a name="shutdown_stop_timeout-0"/><a name="391"/>  391: <b>shutdown_stop_timeout</b>() -&gt;
<a name="shutdown_stop_timeout-last_expr"/><a name="392"/>  392:     [{doc, &quot;Test that peer shutdown stop forcefully takes down connection on timeout&quot;}].
<a name="shutdown_stop_timeout-1"/><a name="393"/>  393: <b>shutdown_stop_timeout</b>(Config) when is_list(Config) -&gt;
<a name="394"/>  394:     false = shutdown_test(Config, ?FUNCTION_NAME, 1000, 5000, true, 2500),
<a name="shutdown_stop_timeout-last_expr"/><a name="395"/>  395:     ok.
<a name="396"/>  396: 
<a name="shutdown_close-0"/><a name="397"/>  397: <b>shutdown_close</b>() -&gt;
<a name="shutdown_close-last_expr"/><a name="398"/>  398:     [{doc, &quot;Test that peer shutdown close does not wait for dist connection&quot;}].
<a name="shutdown_close-1"/><a name="399"/>  399: <b>shutdown_close</b>(Config) when is_list(Config) -&gt;
<a name="400"/>  400:     _ = shutdown_test(Config, ?FUNCTION_NAME, close, 5000, true, 200),
<a name="shutdown_close-last_expr"/><a name="401"/>  401:     ok.
<a name="402"/>  402: 
<a name="shutdown_test-6"/><a name="403"/>  403: <b>shutdown_test</b>(Config, TC, Shutdown, BlockTime, StopWhileBlocked, MaxWaitTime) -&gt;
<a name="404"/>  404:     Options0 = #{name =&gt; ?CT_PEER_NAME(TC),
<a name="405"/>  405:                  shutdown =&gt; Shutdown,
<a name="406"/>  406:                  args =&gt; [&quot;-hidden&quot;, &quot;-pa&quot;, filename:dirname(code:which(?MODULE)),
<a name="407"/>  407:                           &quot;-setcookie&quot;, atom_to_list(erlang:get_cookie())]},
<a name="408"/>  408:     Options = case proplists:get_value(connection, Config) of
<a name="409"/>  409:                   undefined -&gt; Options0;
<a name="410"/>  410:                   Conn -&gt; maps:put(connection, Conn, Options0)
<a name="411"/>  411:               end,
<a name="412"/>  412:     {ok, Peer, Node} = peer:start_link(Options),
<a name="413"/>  413:     EnsureBlockedWait = 500,
<a name="414"/>  414:     BlockStart = erlang:monotonic_time(millisecond),
<a name="415"/>  415:     erpc:cast(Node,
<a name="416"/>  416:               fun () -&gt;
<a name="417"/>  417:                       erts_debug:set_internal_state(available_internal_state, true),
<a name="418"/>  418:                       erts_debug:set_internal_state(block, BlockTime+EnsureBlockedWait)
<a name="419"/>  419:               end),
<a name="420"/>  420:     receive after EnsureBlockedWait -&gt; ok end, %% Ensure blocked...
<a name="421"/>  421:     Start = erlang:monotonic_time(millisecond),
<a name="422"/>  422:     peer:stop(Peer),
<a name="423"/>  423:     End = erlang:monotonic_time(millisecond),
<a name="424"/>  424:     WaitTime = End - Start,
<a name="425"/>  425:     BlockTimeLeft = BlockTime + EnsureBlockedWait - (Start - BlockStart),
<a name="426"/>  426:     Connected = lists:member(Node, nodes(connected)),
<a name="427"/>  427:     ct:pal(&quot;Connected = ~p~nWaitTime = ~p~nBlockTimeLeft = ~p~n&quot;,
<a name="428"/>  428:            [Connected, WaitTime, BlockTimeLeft]),
<a name="429"/>  429:     true = WaitTime =&lt; MaxWaitTime,
<a name="430"/>  430:     case StopWhileBlocked of
<a name="431"/>  431:         true -&gt; ok;
<a name="432"/>  432:         false -&gt; true = WaitTime &gt;= BlockTimeLeft, ok
<a name="433"/>  433:     end,
<a name="shutdown_test-last_expr"/><a name="434"/>  434:     Connected.
<a name="435"/>  435: 
<a name="init_debug-0"/><a name="436"/>  436: <b>init_debug</b>() -&gt;
<a name="init_debug-last_expr"/><a name="437"/>  437:     [{doc, &quot;Test that debug messages in init work&quot;}].
<a name="438"/>  438: 
<a name="init_debug-1"/><a name="439"/>  439: <b>init_debug</b>(Config) when is_list(Config) -&gt;
<a name="440"/>  440:     ct:capture_start(),
<a name="441"/>  441:     {ok, Peer, _Node} = peer:start_link(#{name =&gt; peer:random_name(?FUNCTION_NAME), shutdown =&gt; 1000,
<a name="442"/>  442:         connection =&gt; standard_io, args =&gt; [&quot;-init_debug&quot;]}),
<a name="443"/>  443:     ct:sleep(200), %% without this sleep, peer is not fast enough to print
<a name="444"/>  444:     peer:stop(Peer),
<a name="445"/>  445:     ct:capture_stop(),
<a name="446"/>  446:     Texts = lists:append([string:trim(Str, trailing, &quot;\r\n&quot;) || Str &lt;- ct:capture_get()]),
<a name="447"/>  447:     %% every boot script starts with this
<a name="448"/>  448:     Expected = &quot;{progress,preloaded}&quot;,
<a name="449"/>  449:     Actual = lists:sublist(Texts, 1, length(Expected)),
<a name="init_debug-last_expr"/><a name="450"/>  450: <b>    ?assertEqual</b>(Expected, Actual).
<a name="451"/>  451: 
<a name="io_redirect-0"/><a name="452"/>  452: <b>io_redirect</b>() -&gt;
<a name="io_redirect-last_expr"/><a name="453"/>  453:     [{doc, &quot;Tests i/o redirection working for std&quot;}].
<a name="454"/>  454: 
<a name="io_redirect-1"/><a name="455"/>  455: <b>io_redirect</b>(Config) when is_list(Config) -&gt;
<a name="456"/>  456:     Conn = proplists:get_value(connection, Config),
<a name="457"/>  457:     {ok, Peer, _Node} = peer:start_link(#{connection =&gt; Conn}),
<a name="458"/>  458:     ct:capture_start(),
<a name="459"/>  459:     peer:call(Peer, io, format, [user, &quot;test.&quot;, []]),
<a name="460"/>  460:     peer:call(Peer, erlang, apply, [io, format, [&quot;second.&quot;]]),
<a name="461"/>  461:     %% ensure no dist connection is set up
<a name="462"/>  462:     ?assertNot(lists:member(Peer, nodes()), {dist_connected, Peer, nodes()}),
<a name="463"/>  463:     ct:capture_stop(),
<a name="464"/>  464:     Texts = ct:capture_get(),
<a name="465"/>  465:     peer:stop(Peer),
<a name="io_redirect-last_expr"/><a name="466"/>  466: <b>    ?assertEqual</b>([&quot;test.&quot;, &quot;second.&quot;], Texts).
<a name="467"/>  467: 
<a name="multi_node-0"/><a name="468"/>  468: <b>multi_node</b>() -&gt;
<a name="multi_node-last_expr"/><a name="469"/>  469:     [{doc, &quot;Tests several nodes starting concurrently&quot;}].
<a name="470"/>  470: 
<a name="multi_node-1"/><a name="471"/>  471: <b>multi_node</b>(Config) when is_list(Config) -&gt;
<a name="472"/>  472:     Conn = proplists:get_value(connection, Config),
<a name="473"/>  473:     Peers = [
<a name="474"/>  474:         peer:start_link(#{name =&gt; peer:random_name(?FUNCTION_NAME),
<a name="475"/>  475:             wait_boot =&gt; {self(), tag}, connection =&gt; Conn})
<a name="476"/>  476:         || _ &lt;- lists:seq(1, 4)],
<a name="477"/>  477:     Nodes = [receive {tag, {started, Node, Peer}} -&gt; Node end || {ok, Peer} &lt;- Peers],
<a name="478"/>  478:     ?assertEqual(4, length(Nodes)),
<a name="multi_node-last_expr"/><a name="479"/>  479: <b>    [?assertEqual</b>(ok, peer:stop(Peer)) || {ok, Peer} &lt;- Peers].
<a name="480"/>  480: 
<a name="duplicate_name-0"/><a name="481"/>  481: <b>duplicate_name</b>() -&gt;
<a name="duplicate_name-last_expr"/><a name="482"/>  482:     [{doc, &quot;Tests that a node with the same name fails to start&quot;}].
<a name="483"/>  483: 
<a name="duplicate_name-1"/><a name="484"/>  484: <b>duplicate_name</b>(Config) when is_list(Config) -&gt;
<a name="485"/>  485:     Conn = proplists:get_value(connection, Config),
<a name="486"/>  486:     {ok, Peer, _Node} = peer:start_link(#{connection =&gt; Conn, name =&gt; ?FUNCTION_NAME, register =&gt; false}),
<a name="487"/>  487:     ?assertException(exit, _, peer:start_link(#{connection =&gt; standard_io, name =&gt; ?FUNCTION_NAME})),
<a name="duplicate_name-last_expr"/><a name="488"/>  488: <b>    peer:stop</b>(Peer).
<a name="489"/>  489: 
<a name="490"/>  490: <i>%% -------------------------------------------------------------------</i>
<a name="491"/>  491: <i>%% Compatibility: old releases</i>
<a name="old_release-0"/><a name="492"/>  492: <b>old_release</b>() -&gt;
<a name="old_release-last_expr"/><a name="493"/>  493:     [{doc, &quot;Verity running with previous OTP release&quot;}].
<a name="494"/>  494: 
<a name="old_release-1"/><a name="495"/>  495: <b>old_release</b>(Config) when is_list(Config) -&gt;
<a name="496"/>  496:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="497"/>  497:     %% don't expect OTP 10 to be available
<a name="498"/>  498:     ?assertEqual(not_available, ?CT_PEER_REL([], &quot;10&quot;, PrivDir)),
<a name="499"/>  499:     PrevRel = integer_to_list(list_to_integer(erlang:system_info(otp_release)) - 2),
<a name="old_release-last_expr"/><a name="500"/>  500: <b>    case ?CT_PEER_REL</b>([], PrevRel, PrivDir) of
<a name="501"/>  501:         not_available -&gt;
<a name="502"/>  502:             {skip, &quot;OTP &quot; ++ PrevRel ++ &quot; not found&quot;};
<a name="503"/>  503:         {ok, Peer, Node} -&gt;
<a name="504"/>  504:             ?assertEqual(PrevRel, rpc:call(Node, erlang, system_info, [otp_release])),
<a name="505"/>  505:             peer:stop(Peer)
<a name="506"/>  506:     end.
<a name="507"/>  507: 
<a name="508"/>  508: <i>%% -------------------------------------------------------------------</i>
<a name="509"/>  509: <i>%% SSH/Docker cases</i>
<a name="510"/>  510: 
<a name="ssh-0"/><a name="511"/>  511: <b>ssh</b>() -&gt;
<a name="ssh-last_expr"/><a name="512"/>  512: <b>    [{doc, &quot;Tests ssh </b>(localhost) node support&quot;}].
<a name="513"/>  513: 
<a name="ssh-1"/><a name="514"/>  514: <b>ssh</b>(Config) when is_list(Config) -&gt;
<a name="515"/>  515:     %% figure out path to 'erl' locally ('erl' may not be in path via SSH)
<a name="ssh-last_expr"/><a name="516"/>  516: <b>    case {os:find_executable</b>(&quot;erl&quot;), os:find_executable(&quot;ssh&quot;)} of
<a name="517"/>  517:         {false, _} -&gt;
<a name="518"/>  518:             {skip, &quot;erl not found&quot;};
<a name="519"/>  519:         {ErlPath, SshPath} -&gt;
<a name="520"/>  520:             Name = peer:random_name(?FUNCTION_NAME),
<a name="521"/>  521:             {OsName, _} = os:type(),
<a name="522"/>  522:             Options = #{exec =&gt; {SshPath, [&quot;localhost&quot;, ErlPath]},
<a name="523"/>  523:                         connection =&gt; standard_io, name =&gt; Name, host =&gt; &quot;localhost&quot;},
<a name="524"/>  524:             {ok, Peer, _Node} =
<a name="525"/>  525:                 try peer:start_link(Options) of
<a name="526"/>  526:                     Result -&gt; Result
<a name="527"/>  527:                 catch error:{boot_failed, normal} when OsName =:= win32 -&gt;
<a name="528"/>  528:                         %% If the boot fails on windows, ssh may have ended up
<a name="529"/>  529:                         %% in wsl, so we try to boot using a wsl path
<a name="530"/>  530:                         WslPath = string:trim(os:cmd(&quot;wsl wslpath -u &quot; ++ ErlPath)),
<a name="531"/>  531:                         peer:start_link(
<a name="532"/>  532:                           Options#{ exec =&gt; {SshPath, [&quot;localhost&quot;, WslPath]}})
<a name="533"/>  533:                 end,
<a name="534"/>  534: 
<a name="535"/>  535:             %% TODO: how to check it really goes over SSH?
<a name="536"/>  536:             %% ssh-ed node is not distributed
<a name="537"/>  537:             ?assertEqual(list_to_atom(Name ++ &quot;@localhost&quot;), peer:call(Peer, erlang, node, [])),
<a name="538"/>  538:             peer:stop(Peer)
<a name="539"/>  539:     end.
<a name="540"/>  540: 
<a name="docker-0"/><a name="541"/>  541: <b>docker</b>() -&gt;
<a name="docker-last_expr"/><a name="542"/>  542:     [{doc, &quot;Tests starting peer node in Docker container&quot;}, {timetrap, {seconds, 60}}].
<a name="543"/>  543: 
<a name="build_release-1"/><a name="544"/>  544: <b>build_release</b>(Dir) -&gt;
<a name="545"/>  545:     application:load(sasl), %% otherwise application:get_key will fail
<a name="546"/>  546:     %% build release (tarball)
<a name="547"/>  547:     RelFile = filename:join(Dir, &quot;lambda.rel&quot;),
<a name="548"/>  548:     Release = {release, {&quot;lambda&quot;, &quot;1.0.0&quot;}, {erts, erlang:system_info(version)},
<a name="549"/>  549:         [{App, begin {ok, Vsn} = application:get_key(App, vsn), Vsn end} || App &lt;- [kernel, stdlib, sasl]]},
<a name="550"/>  550:     ok = file:write_file(RelFile, list_to_binary(lists:flatten(io_lib:format(&quot;~tp.&quot;, [Release])))),
<a name="551"/>  551:     RelFileNoExt = filename:join(Dir, &quot;lambda&quot;),
<a name="552"/>  552:     {ok, systools_make, []} = systools:make_script(RelFileNoExt, [silent, {outdir, Dir}]),
<a name="build_release-last_expr"/><a name="553"/>  553: <b>    ok = systools:make_tar</b>(RelFileNoExt, [{erts, code:root_dir()}]).
<a name="554"/>  554: 
<a name="build_image-1"/><a name="555"/>  555: <b>build_image</b>(Dir) -&gt;
<a name="556"/>  556:     %% build docker image
<a name="557"/>  557:     BuildScript = filename:join(Dir, &quot;Dockerfile&quot;),
<a name="558"/>  558:     Dockerfile =
<a name="559"/>  559:         &quot;FROM ubuntu:20.04 as runner\n&quot;
<a name="560"/>  560:         &quot;WORKDIR /opt/lambda\n&quot;
<a name="561"/>  561:         &quot;COPY lambda.tar.gz /tmp\n&quot;
<a name="562"/>  562:         &quot;RUN tar -zxvf /tmp/lambda.tar.gz -C /opt/lambda\n&quot;
<a name="563"/>  563:         &quot;ENTRYPOINT [\&quot;/opt/lambda/erts-&quot; ++ erlang:system_info(version) ++ &quot;/bin/dyn_erl\&quot;, \&quot;-boot\&quot;, \&quot;/opt/lambda/releases/1.0.0/start\&quot;]\n&quot;,
<a name="564"/>  564:     ok = file:write_file(BuildScript, Dockerfile),
<a name="565"/>  565:     Output = os:cmd(&quot;docker build -t lambda &quot; ++ Dir),
<a name="build_image-last_expr"/><a name="566"/>  566: <b>    ct:pal</b>(&quot;Build result: ~s~n&quot;, [Output]).
<a name="567"/>  567: 
<a name="docker-1"/><a name="568"/>  568: <b>docker</b>(Config) when is_list(Config) -&gt;
<a name="docker-last_expr"/><a name="569"/>  569: <b>    case os:find_executable</b>(&quot;docker&quot;) of
<a name="570"/>  570:         false -&gt;
<a name="571"/>  571:             {skip, &quot;Docker not found&quot;};
<a name="572"/>  572:         Docker -&gt;
<a name="573"/>  573:             PrivDir = proplists:get_value(priv_dir, Config),
<a name="574"/>  574:             build_release(PrivDir),
<a name="575"/>  575:             build_image(PrivDir),
<a name="576"/>  576: 
<a name="577"/>  577:             {ok, Peer, Node} = peer:start_link(#{name =&gt; ?CT_PEER_NAME(),
<a name="578"/>  578:                 exec =&gt; {Docker, [&quot;run&quot;, &quot;-i&quot;, &quot;lambda&quot;]}, connection =&gt; standard_io}),
<a name="579"/>  579:             ?assertEqual(Node, peer:call(Peer, erlang, node, [])),
<a name="580"/>  580:             peer:stop(Peer)
<a name="581"/>  581:     end.
<a name="582"/>  582: 
<a name="cntrl_channel_handler_crash-0"/><a name="583"/>  583: <b>cntrl_channel_handler_crash</b>() -&gt;
<a name="cntrl_channel_handler_crash-last_expr"/><a name="584"/>  584:     [{doc, &quot;Test that peer node is halted if peer control channel handler process crashes&quot;}].
<a name="585"/>  585: 
<a name="cntrl_channel_handler_crash-1"/><a name="586"/>  586: <b>cntrl_channel_handler_crash</b>(Config) -&gt;
<a name="587"/>  587:     NameOpts = #{name =&gt; ?CT_PEER_NAME()},
<a name="588"/>  588:     Opts = case proplists:get_value(connection, Config) of
<a name="589"/>  589:                undefined -&gt; NameOpts;
<a name="590"/>  590:                Conn -&gt; NameOpts#{connection =&gt; Conn}
<a name="591"/>  591:            end,
<a name="592"/>  592:     {ok, _Peer, Node} = peer:start_link(Opts),
<a name="cntrl_channel_handler_crash-last_expr"/><a name="593"/>  593: <b>    cntrl_channel_handler_crash_test</b>(Node).
<a name="594"/>  594: 
<a name="cntrl_channel_handler_crash_old_release-0"/><a name="595"/>  595: <b>cntrl_channel_handler_crash_old_release</b>() -&gt;
<a name="cntrl_channel_handler_crash_old_release-last_expr"/><a name="596"/>  596:     [{doc, &quot;Test that peer node running an old release is halted if peer control channel handler process crashes&quot;}].
<a name="597"/>  597: 
<a name="cntrl_channel_handler_crash_old_release-1"/><a name="598"/>  598: <b>cntrl_channel_handler_crash_old_release</b>(Config) -&gt;
<a name="599"/>  599:     NameOpts = #{name =&gt; ?CT_PEER_NAME()},
<a name="600"/>  600:     Opts = case proplists:get_value(connection, Config) of
<a name="601"/>  601:                undefined -&gt; NameOpts;
<a name="602"/>  602:                Conn -&gt; NameOpts#{connection =&gt; Conn}
<a name="603"/>  603:            end,
<a name="604"/>  604:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="605"/>  605:     OldRel = integer_to_list(list_to_integer(erlang:system_info(otp_release)) - 2),
<a name="cntrl_channel_handler_crash_old_release-last_expr"/><a name="606"/>  606: <b>    case ?CT_PEER_REL</b>(Opts, OldRel, PrivDir) of
<a name="607"/>  607:         not_available -&gt;
<a name="608"/>  608:             {skip, &quot;No OTP &quot; ++ OldRel ++ &quot; installation found&quot;};
<a name="609"/>  609:         {ok, _Peer, Node} -&gt;
<a name="610"/>  610:             cntrl_channel_handler_crash_test(Node)
<a name="611"/>  611:     end.
<a name="612"/>  612: 
<a name="cntrl_channel_handler_crash_test-1"/><a name="613"/>  613: <b>cntrl_channel_handler_crash_test</b>(Node) -&gt;
<a name="614"/>  614:     true = monitor_node(Node, true),
<a name="615"/>  615:     ChkStck = fun ChkStck (_Pid, []) -&gt;
<a name="616"/>  616:                       ok;
<a name="617"/>  617:                   ChkStck (Pid, [{peer, io_server_loop, _, _} | _]) -&gt;
<a name="618"/>  618:                       throw(Pid);
<a name="619"/>  619:                   ChkStck (Pid, [{peer, origin_link, _, _} | _]) -&gt;
<a name="620"/>  620:                       throw(Pid);
<a name="621"/>  621:                   ChkStck (Pid, [_SF|SFs]) -&gt;
<a name="622"/>  622:                       ChkStck(Pid, SFs)
<a name="623"/>  623:               end,
<a name="624"/>  624:     ChkConnHandler = fun (undefined) -&gt;
<a name="625"/>  625:                              ok;
<a name="626"/>  626:                          (Pid) when is_pid(Pid) -&gt;
<a name="627"/>  627:                              case erpc:call(Node, erlang, process_info,
<a name="628"/>  628:                                             [Pid, current_stacktrace]) of
<a name="629"/>  629:                                  {current_stacktrace, STrace} -&gt;
<a name="630"/>  630:                                      ChkStck(Pid, STrace);
<a name="631"/>  631:                                  _ -&gt;
<a name="632"/>  632:                                      ok
<a name="633"/>  633:                              end
<a name="634"/>  634:                      end,
<a name="635"/>  635:     ConnHandler = try
<a name="636"/>  636:                       ChkConnHandler(erpc:call(Node, erlang, whereis, [user])),
<a name="637"/>  637:                       lists:foreach(fun (Pid) -&gt;
<a name="638"/>  638:                                             ChkConnHandler(Pid)
<a name="639"/>  639:                                     end, erpc:call(Node, erlang, processes, [])),
<a name="640"/>  640:                       error(no_cntrl_channel_handler_found)
<a name="641"/>  641:                   catch
<a name="642"/>  642:                       throw:Pid when is_pid(Pid) -&gt; Pid
<a name="643"/>  643:                   end,
<a name="644"/>  644:     PeerSup = erpc:call(Node, erlang, whereis, [peer_supervision]),
<a name="645"/>  645:     ct:log(&quot;peer_supervision state: ~p~n&quot;, [erpc:call(Node, sys, get_state, [PeerSup])]),
<a name="646"/>  646:     {links, Links} = erpc:call(Node, erlang, process_info, [PeerSup, links]),
<a name="647"/>  647:     true = lists:member(ConnHandler, Links),
<a name="648"/>  648:     ok = erpc:cast(Node, erlang, exit, [ConnHandler, kill]),
<a name="cntrl_channel_handler_crash_test-last_expr"/><a name="649"/>  649:     receive
<a name="650"/>  650:         {nodedown, Node} -&gt;
<a name="651"/>  651:             ok
<a name="652"/>  652:     after
<a name="653"/>  653:         5000 -&gt;
<a name="654"/>  654:             ct:fail(peer_did_not_halt)
<a name="655"/>  655:     end.
</pre>
</body>
</html>
