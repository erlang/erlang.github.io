<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/lib/kernel/make_test_dir/kernel_test/erl_distribution_wb_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%</i>
<a name="2"/>    2: <i>%% %CopyrightBegin%</i>
<a name="3"/>    3: <i>%% </i>
<a name="4"/>    4: <i>%% Copyright Ericsson AB 1999-2023. All Rights Reserved.</i>
<a name="5"/>    5: <i>%% </i>
<a name="6"/>    6: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="7"/>    7: <i>%% you may not use this file except in compliance with the License.</i>
<a name="8"/>    8: <i>%% You may obtain a copy of the License at</i>
<a name="9"/>    9: <i>%%</i>
<a name="10"/>   10: <i>%%     http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="11"/>   11: <i>%%</i>
<a name="12"/>   12: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="13"/>   13: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="14"/>   14: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="15"/>   15: <i>%% See the License for the specific language governing permissions and</i>
<a name="16"/>   16: <i>%% limitations under the License.</i>
<a name="17"/>   17: <i>%% </i>
<a name="18"/>   18: <i>%% %CopyrightEnd%</i>
<a name="19"/>   19: <i>%%</i>
<a name="20"/>   20: <b>-module</b>(erl_distribution_wb_SUITE).
<a name="21"/>   21: 
<a name="22"/>   22: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="23"/>   23: <b>-include_lib</b>(&quot;kernel/include/inet.hrl&quot;).
<a name="24"/>   24: 
<a name="25"/>   25: <b>-export</b>([all/0, suite/0,groups/0,init_per_suite/1, end_per_suite/1, 
<a name="26"/>   26: 	 init_per_group/2,end_per_group/2]).
<a name="27"/>   27: 
<a name="28"/>   28: <b>-export</b>([init_per_testcase/2, end_per_testcase/2, whitebox/1, 
<a name="29"/>   29: 	 switch_options/1, missing_compulsory_dflags/1,
<a name="30"/>   30:          dflag_mandatory_25/1]).
<a name="31"/>   31: 
<a name="32"/>   32: 
<a name="33"/>   33: <b>-define</b>(to_port(Socket, Data),
<a name="34"/>   34: 	case inet_tcp:send(Socket, Data) of
<a name="35"/>   35: 	    {error, closed} -&gt;
<a name="36"/>   36: 		self() ! {tcp_closed, Socket},
<a name="37"/>   37: 	        {error, closed};
<a name="38"/>   38: 	    R -&gt;
<a name="39"/>   39: 	        R
<a name="40"/>   40:         end).
<a name="41"/>   41: 
<a name="42"/>   42: <b>-define</b>(DIST_VER_HIGH, 6).
<a name="43"/>   43: <b>-define</b>(DIST_VER_LOW, 5).
<a name="44"/>   44: 
<a name="45"/>   45: <b>-define</b>(DFLAG_PUBLISHED,                16#01).
<a name="46"/>   46: <b>-define</b>(DFLAG_ATOM_CACHE,               16#02).
<a name="47"/>   47: <b>-define</b>(DFLAG_EXTENDED_REFERENCES,      16#04).
<a name="48"/>   48: <b>-define</b>(DFLAG_DIST_MONITOR,             16#08).
<a name="49"/>   49: <b>-define</b>(DFLAG_FUN_TAGS,                 16#10).
<a name="50"/>   50: <b>-define</b>(DFLAG_NEW_FUN_TAGS,             16#80).
<a name="51"/>   51: <b>-define</b>(DFLAG_EXTENDED_PIDS_PORTS,     16#100).
<a name="52"/>   52: <b>-define</b>(DFLAG_EXPORT_PTR_TAG,          16#200).
<a name="53"/>   53: <b>-define</b>(DFLAG_BIT_BINARIES,            16#400).
<a name="54"/>   54: <b>-define</b>(DFLAG_NEW_FLOATS,              16#800).
<a name="55"/>   55: <b>-define</b>(DFLAG_UTF8_ATOMS,            16#10000).
<a name="56"/>   56: <b>-define</b>(DFLAG_MAP_TAG,               16#20000).
<a name="57"/>   57: <b>-define</b>(DFLAG_BIG_CREATION,          16#40000).
<a name="58"/>   58: <b>-define</b>(DFLAG_HANDSHAKE_23,        16#1000000).
<a name="59"/>   59: <b>-define</b>(DFLAG_UNLINK_ID,           16#2000000).
<a name="60"/>   60: <b>-define</b>(DFLAG_MANDATORY_25_DIGEST, 16#4000000).
<a name="61"/>   61: <b>-define</b>(DFLAG_V4_NC,             16#400000000).
<a name="62"/>   62: 
<a name="63"/>   63: <i>%% From OTP R9 extended references are compulsory.</i>
<a name="64"/>   64: <i>%% From OTP R10 extended pids and ports are compulsory.</i>
<a name="65"/>   65: <i>%% From OTP 20 UTF8 atoms are compulsory.</i>
<a name="66"/>   66: <i>%% From OTP 21 NEW_FUN_TAGS is compulsory (no more tuple fallback {fun, ...}).</i>
<a name="67"/>   67: <i>%% From OTP 23 BIG_CREATION is compulsory.</i>
<a name="68"/>   68: <i>%% From OTP 25 HANDSHAKE_23, NEW_FLOATS, MAP_TAG, EXPORT_PTR_TAG, and BIT_BINARIES are compulsory.</i>
<a name="69"/>   69: 
<a name="70"/>   70: <b>-define</b>(DFLAGS_MANDATORY_25,
<a name="71"/>   71:         (?DFLAG_EXTENDED_REFERENCES bor
<a name="72"/>   72:              ?DFLAG_FUN_TAGS bor
<a name="73"/>   73:              ?DFLAG_EXTENDED_PIDS_PORTS bor
<a name="74"/>   74:              ?DFLAG_UTF8_ATOMS bor
<a name="75"/>   75:              ?DFLAG_NEW_FUN_TAGS bor
<a name="76"/>   76:              ?DFLAG_BIG_CREATION bor
<a name="77"/>   77:              ?DFLAG_HANDSHAKE_23 bor
<a name="78"/>   78:              ?DFLAG_NEW_FLOATS bor
<a name="79"/>   79:              ?DFLAG_MAP_TAG bor
<a name="80"/>   80:              ?DFLAG_EXPORT_PTR_TAG bor
<a name="81"/>   81:              ?DFLAG_BIT_BINARIES bor
<a name="82"/>   82:              ?DFLAG_HANDSHAKE_23)).
<a name="83"/>   83: 
<a name="84"/>   84: <i>%% From OTP 26 V4_NC and UNLINK_ID are compulsory.</i>
<a name="85"/>   85: 
<a name="86"/>   86: <b>-define</b>(DFLAGS_MANDATORY_26,
<a name="87"/>   87:         (?DFLAG_V4_NC bor
<a name="88"/>   88:              ?DFLAG_UNLINK_ID)).
<a name="89"/>   89: 
<a name="90"/>   90: <b>-define</b>(COMPULSORY_DFLAGS,
<a name="91"/>   91:         (?DFLAGS_MANDATORY_25 bor
<a name="92"/>   92:              ?DFLAGS_MANDATORY_26)).
<a name="93"/>   93: 
<a name="94"/>   94: <b>-define</b>(PASS_THROUGH, $p).
<a name="95"/>   95: 
<a name="96"/>   96: <b>-define</b>(shutdown(X), exit(X)).
<a name="97"/>   97: <b>-define</b>(int16(X), [((X) bsr 8) band 16#ff, (X) band 16#ff]).
<a name="98"/>   98: 
<a name="99"/>   99: <b>-define</b>(int32(X), 
<a name="100"/>  100: 	[((X) bsr 24) band 16#ff, ((X) bsr 16) band 16#ff,
<a name="101"/>  101: 	 ((X) bsr 8) band 16#ff, (X) band 16#ff]).
<a name="102"/>  102: 
<a name="103"/>  103: <b>-define</b>(i16(X1,X0),
<a name="104"/>  104:         (?u16(X1,X0) - 
<a name="105"/>  105: 	     (if (X1) &gt; 127 -&gt; 16#10000; true -&gt; 0 end))).
<a name="106"/>  106: 
<a name="107"/>  107: <b>-define</b>(u16(X1,X0),
<a name="108"/>  108:         (((X1) bsl 8) bor (X0))).
<a name="109"/>  109: 
<a name="110"/>  110: <b>-define</b>(u32(X3,X2,X1,X0),
<a name="111"/>  111:         (((X3) bsl 24) bor ((X2) bsl 16) bor ((X1) bsl 8) bor (X0))).
<a name="112"/>  112: 
<a name="suite-0"/><a name="113"/>  113: <b>suite</b>() -&gt;
<a name="suite-last_expr"/><a name="114"/>  114:     [{ct_hooks,[ts_install_cth]},
<a name="115"/>  115:      {timetrap,{minutes,1}}].
<a name="116"/>  116: 
<a name="all-0"/><a name="117"/>  117: <b>all</b>() -&gt; 
<a name="all-last_expr"/><a name="118"/>  118:     [whitebox, switch_options, missing_compulsory_dflags, dflag_mandatory_25].
<a name="119"/>  119: 
<a name="groups-0"/><a name="120"/>  120: <b>groups</b>() -&gt; 
<a name="groups-last_expr"/><a name="121"/>  121:     [].
<a name="122"/>  122: 
<a name="init_per_suite-1"/><a name="123"/>  123: <b>init_per_suite</b>(Config) -&gt;
<a name="init_per_suite-last_expr"/><a name="124"/>  124:     Config.
<a name="125"/>  125: 
<a name="end_per_suite-1"/><a name="126"/>  126: <b>end_per_suite</b>(_Config) -&gt;
<a name="end_per_suite-last_expr"/><a name="127"/>  127:     ok.
<a name="128"/>  128: 
<a name="init_per_group-2"/><a name="129"/>  129: <b>init_per_group</b>(_GroupName, Config) -&gt;
<a name="init_per_group-last_expr"/><a name="130"/>  130:     Config.
<a name="131"/>  131: 
<a name="end_per_group-2"/><a name="132"/>  132: <b>end_per_group</b>(_GroupName, Config) -&gt;
<a name="end_per_group-last_expr"/><a name="133"/>  133:     Config.
<a name="134"/>  134: 
<a name="135"/>  135: 
<a name="init_per_testcase-2"/><a name="136"/>  136: <b>init_per_testcase</b>(Func, Config) when is_atom(Func), is_list(Config) -&gt;
<a name="init_per_testcase-last_expr"/><a name="137"/>  137:     Config.
<a name="138"/>  138: 
<a name="end_per_testcase-2"/><a name="139"/>  139: <b>end_per_testcase</b>(_Func, _Config) -&gt;
<a name="end_per_testcase-last_expr"/><a name="140"/>  140:     ok.
<a name="141"/>  141: 
<a name="142"/>  142: <i>%% Tests switching of options for the tcp port, as this is done</i>
<a name="143"/>  143: <i>%% when the distribution port is to be shortcut into the emulator.</i>
<a name="144"/>  144: <i>%% Maybe this should be in the inet test suite, but only the distribution</i>
<a name="145"/>  145: <i>%% does such horrible things...</i>
<a name="switch_options-1"/><a name="146"/>  146: <b>switch_options</b>(Config) when is_list(Config) -&gt;
<a name="147"/>  147:     ok = test_switch_active(),
<a name="148"/>  148:     ok = test_switch_active_partial() ,
<a name="149"/>  149:     ok = test_switch_active_and_packet(),    
<a name="switch_options-last_expr"/><a name="150"/>  150:     ok.
<a name="151"/>  151: 
<a name="152"/>  152: 
<a name="153"/>  153: <i>%% Whitebox testing of distribution handshakes.</i>
<a name="whitebox-1"/><a name="154"/>  154: <b>whitebox</b>(Config) when is_list(Config) -&gt;
<a name="155"/>  155:     {ok, Peer, Node} = ?CT_PEER(),
<a name="156"/>  156:     Cookie = erlang:get_cookie(),
<a name="157"/>  157:     {_,Host} = split(node()),
<a name="158"/>  158:     [begin
<a name="159"/>  159:          io:format(&quot;Test TrustEpmd=~p\n&quot;, [TrustEpmd]),
<a name="160"/>  160:          ok = pending_up_md5(Node, join(ccc,Host), TrustEpmd, Cookie),
<a name="161"/>  161:          ok = simultaneous_md5(Node, join('A',Host), TrustEpmd, Cookie),
<a name="162"/>  162:          ok = simultaneous_md5(Node, join(zzzzzzzzzz,Host), TrustEpmd, Cookie)
<a name="163"/>  163:      end
<a name="164"/>  164:      || TrustEpmd &lt;- [true, false]],
<a name="165"/>  165:     peer:stop(Peer),
<a name="whitebox-last_expr"/><a name="166"/>  166:     ok.
<a name="167"/>  167: 
<a name="168"/>  168: <i>%%</i>
<a name="169"/>  169: <i>%% The actual tests</i>
<a name="170"/>  170: <i>%%</i>
<a name="171"/>  171: 
<a name="172"/>  172: <i>%%</i>
<a name="173"/>  173: <i>%% Switch tcp options test</i>
<a name="174"/>  174: <i>%%</i>
<a name="175"/>  175: 
<a name="test_switch_active-0"/><a name="176"/>  176: <b>test_switch_active</b>() -&gt;
<a name="177"/>  177:     {Client, Server} = socket_pair(0, 4),
<a name="178"/>  178:     ok = write_packets_32(Client, 1, 5),
<a name="179"/>  179:     receive after 2000 -&gt; ok end,
<a name="180"/>  180:     ok = read_packets(Server, 1, 1),
<a name="181"/>  181:     receive after 2000 -&gt; ok end,
<a name="182"/>  182:     ok = read_packets(Server, 2, 2),
<a name="183"/>  183:     inet:setopts(Server, [{active, true}]),
<a name="184"/>  184:     ok = receive_packets(Server, 3, 5),
<a name="185"/>  185:     close_pair({Client, Server}),
<a name="test_switch_active-last_expr"/><a name="186"/>  186:     ok.
<a name="187"/>  187: 
<a name="test_switch_active_partial-0"/><a name="188"/>  188: <b>test_switch_active_partial</b>() -&gt;
<a name="189"/>  189:     {Client, Server} = socket_pair(0, 4),
<a name="190"/>  190:     ok = write_packets_32(Client, 1, 2),
<a name="191"/>  191:     ok = gen_tcp:send(Client,[?int32(4), [0,0,0]]),
<a name="192"/>  192:     receive after 2000 -&gt; ok end,
<a name="193"/>  193:     ok = read_packets(Server, 1, 1),
<a name="194"/>  194:     receive after 2000 -&gt; ok end,
<a name="195"/>  195:     ok = read_packets(Server, 2, 2),
<a name="196"/>  196:     inet:setopts(Server, [{active, true}]),
<a name="197"/>  197:     ok = gen_tcp:send(Client,[3]),
<a name="198"/>  198:     ok = write_packets_32(Client, 4, 5),
<a name="199"/>  199:     ok = receive_packets(Server, 3, 5),
<a name="200"/>  200:     close_pair({Client, Server}),
<a name="test_switch_active_partial-last_expr"/><a name="201"/>  201:     ok.
<a name="202"/>  202: 
<a name="do_test_switch_active_and_packet-2"/><a name="203"/>  203: <b>do_test_switch_active_and_packet</b>(SendBefore, SendAfter) -&gt;
<a name="204"/>  204:     {Client, Server} = socket_pair(0, 2),
<a name="205"/>  205:     ok = write_packets_16(Client, 1, 2),
<a name="206"/>  206:     ok = gen_tcp:send(Client,SendBefore),
<a name="207"/>  207:     receive after 2000 -&gt; ok end,
<a name="208"/>  208:     ok = read_packets(Server, 1, 1),
<a name="209"/>  209:     receive after 2000 -&gt; ok end,
<a name="210"/>  210:     ok = read_packets(Server, 2, 2),
<a name="211"/>  211:     inet:setopts(Server, [{packet,4}, {active, true}]),
<a name="212"/>  212:     ok = gen_tcp:send(Client,SendAfter),
<a name="213"/>  213:     ok = write_packets_32(Client, 4, 5),
<a name="214"/>  214:     ok = receive_packets(Server, 3, 5),
<a name="215"/>  215:     close_pair({Client, Server}),
<a name="do_test_switch_active_and_packet-last_expr"/><a name="216"/>  216:     ok.
<a name="217"/>  217: 
<a name="test_switch_active_and_packet-0"/><a name="218"/>  218: <b>test_switch_active_and_packet</b>() -&gt;
<a name="219"/>  219:     ok = do_test_switch_active_and_packet([0],[0,0,4,0,0,0,3]),
<a name="220"/>  220:     ok = do_test_switch_active_and_packet([0,0],[0,4,0,0,0,3]),
<a name="221"/>  221:     ok = do_test_switch_active_and_packet([0,0,0],[4,0,0,0,3]),
<a name="222"/>  222:     ok = do_test_switch_active_and_packet([0,0,0,4],[0,0,0,3]),
<a name="223"/>  223:     ok = do_test_switch_active_and_packet([0,0,0,4,0],[0,0,3]),
<a name="224"/>  224:     ok = do_test_switch_active_and_packet([0,0,0,4,0,0],[0,3]),
<a name="225"/>  225:     ok = do_test_switch_active_and_packet([0,0,0,4,0,0,0],[3]),
<a name="226"/>  226:     ok = do_test_switch_active_and_packet([0,0,0,4,0,0,0,3],[]),
<a name="test_switch_active_and_packet-last_expr"/><a name="227"/>  227:     ok.
<a name="228"/>  228: 
<a name="229"/>  229: 
<a name="230"/>  230: <i>%%</i>
<a name="231"/>  231: <i>%% Handshake tests</i>
<a name="232"/>  232: <i>%%</i>
<a name="pending_up_md5-4"/><a name="233"/>  233: <b>pending_up_md5</b>(Node,OurName,TrustEpmd,Cookie) -&gt;
<a name="234"/>  234:     {NA,NB} = split(Node),
<a name="235"/>  235:     {port,PortNo,EpmdSaysVersion} = erl_epmd:port_please(NA,NB),
<a name="236"/>  236:     {ok, SocketA} = gen_tcp:connect(atom_to_list(NB),PortNo,
<a name="237"/>  237: 				    [{active,false},
<a name="238"/>  238: 				     {packet,2}]),
<a name="239"/>  239:     AssumedVersion = case TrustEpmd of
<a name="240"/>  240:                          true -&gt; EpmdSaysVersion;
<a name="241"/>  241:                          false -&gt; ?DIST_VER_LOW
<a name="242"/>  242:                      end,
<a name="243"/>  243:     SentNameMsg = send_name(SocketA,OurName,AssumedVersion),
<a name="244"/>  244:     ok = recv_status(SocketA),
<a name="245"/>  245:     {Node,HisChallengeA} = recv_challenge(SocketA),
<a name="246"/>  246:     OurChallengeA = gen_challenge(),
<a name="247"/>  247:     OurDigestA = gen_digest(HisChallengeA, Cookie),
<a name="248"/>  248:     send_complement(SocketA, SentNameMsg),
<a name="249"/>  249:     send_challenge_reply(SocketA, OurChallengeA, OurDigestA),
<a name="250"/>  250:     ok = recv_challenge_ack(SocketA, OurChallengeA, Cookie),
<a name="251"/>  251: <i>%%%</i>
<a name="252"/>  252: <i>%%% OK, one connection is up, now lets be nasty and try another up:</i>
<a name="253"/>  253: <i>%%%</i>
<a name="254"/>  254: <i>%%% But wait for a while, the other node might not have done setnode</i>
<a name="255"/>  255: <i>%%% just yet...</i>
<a name="256"/>  256:     receive after 1000 -&gt; ok end,
<a name="257"/>  257:     {ok, SocketB} = gen_tcp:connect(atom_to_list(NB),PortNo,
<a name="258"/>  258: 				    [{active,false},
<a name="259"/>  259: 				     {packet,2}]),
<a name="260"/>  260:     SentNameMsg = send_name(SocketB,OurName,AssumedVersion),
<a name="261"/>  261:     alive = recv_status(SocketB),
<a name="262"/>  262:     send_status(SocketB, true),
<a name="263"/>  263:     gen_tcp:close(SocketA),
<a name="264"/>  264:     {Node,HisChallengeB} = recv_challenge(SocketB),
<a name="265"/>  265:     OurChallengeB = gen_challenge(),
<a name="266"/>  266:     OurDigestB = gen_digest(HisChallengeB, Cookie),
<a name="267"/>  267:     send_complement(SocketB, SentNameMsg),
<a name="268"/>  268:     send_challenge_reply(SocketB, OurChallengeB, OurDigestB),
<a name="269"/>  269:     ok = recv_challenge_ack(SocketB, OurChallengeB, Cookie),
<a name="270"/>  270: <i>%%%</i>
<a name="271"/>  271: <i>%%% Well, are we happy?</i>
<a name="272"/>  272: <i>%%%</i>
<a name="273"/>  273: 
<a name="274"/>  274:     inet:setopts(SocketB, [{active, false},
<a name="275"/>  275: 			   {packet, 4}]),
<a name="276"/>  276:     gen_tcp:send(SocketB,build_rex_message('',OurName)),
<a name="277"/>  277:     {Header, Message} = recv_message(SocketB),
<a name="278"/>  278:     io:format(&quot;Received header ~p, data ~p.~n&quot;,
<a name="279"/>  279: 	      [Header, Message]),
<a name="280"/>  280:     gen_tcp:close(SocketB),
<a name="pending_up_md5-last_expr"/><a name="281"/>  281:     ok.
<a name="282"/>  282: 
<a name="simultaneous_md5-4"/><a name="283"/>  283: <b>simultaneous_md5</b>(Node, OurName, TrustEpmd, Cookie) when OurName &lt; Node -&gt;
<a name="284"/>  284:     pong = net_adm:ping(Node),
<a name="285"/>  285:     LSocket = case gen_tcp:listen(0, [{active, false}, {packet,2}]) of
<a name="286"/>  286: 		  {ok, Socket} -&gt;
<a name="287"/>  287: 		      Socket;
<a name="288"/>  288: 		  Else -&gt;
<a name="289"/>  289: 		      exit(Else)
<a name="290"/>  290: 	      end,
<a name="291"/>  291:     EpmdSocket = register_node(OurName, LSocket),
<a name="292"/>  292:     {NA, NB} = split(Node),
<a name="293"/>  293:     rpc:cast(Node, net_adm, ping, [OurName]),
<a name="294"/>  294:     receive after 1000 -&gt; ok end,
<a name="295"/>  295:     {port, PortNo, EpmdSaysVersion} = erl_epmd:port_please(NA,NB),
<a name="296"/>  296:     {ok, SocketA} = gen_tcp:connect(atom_to_list(NB),PortNo,
<a name="297"/>  297: 				    [{active,false},
<a name="298"/>  298: 				     {packet,2}]),
<a name="299"/>  299:     AssumedVersion = case TrustEpmd of
<a name="300"/>  300:                          true -&gt; EpmdSaysVersion;
<a name="301"/>  301:                          false -&gt; ?DIST_VER_LOW
<a name="302"/>  302:                      end,
<a name="303"/>  303:     send_name(SocketA, OurName, AssumedVersion),
<a name="304"/>  304:     %% We are still not marked up on the other side, as our first message 
<a name="305"/>  305:     %% is not sent.
<a name="306"/>  306:     SocketB = case gen_tcp:accept(LSocket) of
<a name="307"/>  307: 		  {ok, Socket1} -&gt;
<a name="308"/>  308: 		      Socket1;
<a name="309"/>  309: 		  Else2 -&gt;
<a name="310"/>  310: 		      exit(Else2)
<a name="311"/>  311: 	      end,
<a name="312"/>  312:     nok = recv_status(SocketA),
<a name="313"/>  313:     %% Now we are expected to close A
<a name="314"/>  314:     gen_tcp:close(SocketA),
<a name="315"/>  315:     %% But still Socket B will continue
<a name="316"/>  316:     {Node,GotFlags} = recv_name(SocketB),
<a name="317"/>  317:     true = (GotFlags band ?DFLAG_HANDSHAKE_23) =/= 0,
<a name="318"/>  318:     send_status(SocketB, ok_simultaneous),
<a name="319"/>  319:     MyChallengeB = gen_challenge(),
<a name="320"/>  320:     send_challenge(SocketB, OurName, MyChallengeB, GotFlags),
<a name="321"/>  321:     {ok,HisChallengeB} = recv_challenge_reply(SocketB, MyChallengeB, Cookie),
<a name="322"/>  322:     DigestB = gen_digest(HisChallengeB,Cookie),
<a name="323"/>  323:     send_challenge_ack(SocketB, DigestB),
<a name="324"/>  324:     inet:setopts(SocketB, [{active, false},
<a name="325"/>  325: 			   {packet, 4}]),
<a name="326"/>  326:     %% This should be the ping message.
<a name="327"/>  327:     {Header, Message} = recv_message(SocketB),
<a name="328"/>  328:     io:format(&quot;Received header ~p, data ~p.~n&quot;,
<a name="329"/>  329: 	      [Header, Message]),
<a name="330"/>  330:     gen_tcp:close(SocketB),
<a name="331"/>  331:     gen_tcp:close(LSocket),
<a name="332"/>  332:     gen_tcp:close(EpmdSocket),
<a name="333"/>  333:     ok;
<a name="334"/>  334: 
<a name="335"/>  335: <b>simultaneous_md5</b>(Node, OurName, TrustEpmd, Cookie) when OurName &gt; Node -&gt;
<a name="336"/>  336:     pong = net_adm:ping(Node),
<a name="337"/>  337:     LSocket = case gen_tcp:listen(0, [{active, false}, {packet,2}]) of
<a name="338"/>  338: 		  {ok, Socket} -&gt;
<a name="339"/>  339: 		      Socket;
<a name="340"/>  340: 		  Else -&gt;
<a name="341"/>  341: 		      exit(Else)
<a name="342"/>  342: 	      end,
<a name="343"/>  343:     EpmdSocket = register_node(OurName, LSocket),
<a name="344"/>  344:     {NA, NB} = split(Node),
<a name="345"/>  345:     rpc:cast(Node, net_adm, ping, [OurName]),
<a name="346"/>  346:     receive after 1000 -&gt; ok end,
<a name="347"/>  347:     {port, PortNo, EpmdSaysVersion} = erl_epmd:port_please(NA,NB),
<a name="348"/>  348:     {ok, SocketA} = gen_tcp:connect(atom_to_list(NB),PortNo,
<a name="349"/>  349: 				    [{active,false},
<a name="350"/>  350: 				     {packet,2}]),
<a name="351"/>  351:     SocketB = case gen_tcp:accept(LSocket) of
<a name="352"/>  352: 		  {ok, Socket1} -&gt;
<a name="353"/>  353: 		      Socket1;
<a name="354"/>  354: 		  Else2 -&gt;
<a name="355"/>  355: 		      exit(Else2)
<a name="356"/>  356: 	      end,
<a name="357"/>  357:     AssumedVersion = case TrustEpmd of
<a name="358"/>  358:                          true -&gt; EpmdSaysVersion;
<a name="359"/>  359:                          false -&gt; ?DIST_VER_LOW
<a name="360"/>  360:                      end,
<a name="361"/>  361:     SentNameMsg = send_name(SocketA,OurName, AssumedVersion),
<a name="362"/>  362:     ok_simultaneous = recv_status(SocketA),
<a name="363"/>  363:     %% Socket B should die during this
<a name="364"/>  364:     case catch begin
<a name="365"/>  365: 		   {Node, GotFlagsB} = recv_name(SocketB),
<a name="366"/>  366:                    true = (GotFlagsB band ?DFLAG_HANDSHAKE_23) =/= 0,
<a name="367"/>  367: 		   send_status(SocketB, ok_simultaneous),
<a name="368"/>  368: 		   MyChallengeB = gen_challenge(),
<a name="369"/>  369: 		   send_challenge(SocketB, OurName, MyChallengeB, GotFlagsB),
<a name="370"/>  370: 		   {ok,HisChallengeB} = recv_challenge_reply(
<a name="371"/>  371: 				     SocketB,
<a name="372"/>  372: 				     MyChallengeB,
<a name="373"/>  373: 				     Cookie),
<a name="374"/>  374: 		   DigestB = gen_digest(HisChallengeB,Cookie),
<a name="375"/>  375: 		   send_challenge_ack(SocketB, DigestB),
<a name="376"/>  376: 		   inet:setopts(SocketB, [{active, false},
<a name="377"/>  377: 					  {packet, 4}]),
<a name="378"/>  378: 		   {HeaderB, MessageB} = recv_message(SocketB),
<a name="379"/>  379: 		   io:format(&quot;Received header ~p, data ~p.~n&quot;,
<a name="380"/>  380: 			     [HeaderB, MessageB])
<a name="381"/>  381: 	       end of
<a name="382"/>  382: 	{'EXIT', Exitcode} -&gt;
<a name="383"/>  383: 	    io:format(&quot;Expected exitsignal caught: ~p.~n&quot;,
<a name="384"/>  384: 		      [Exitcode]);
<a name="385"/>  385: 	Success -&gt;
<a name="386"/>  386: 	    io:format(&quot;Unexpected success: ~p~n&quot;,
<a name="387"/>  387: 		      [Success]),
<a name="388"/>  388: 	    exit(unexpected_success)
<a name="389"/>  389:     end,
<a name="390"/>  390:     gen_tcp:close(SocketB),
<a name="391"/>  391:     %% But still Socket A will continue
<a name="392"/>  392:     {Node,HisChallengeA} = recv_challenge(SocketA),
<a name="393"/>  393:     OurChallengeA = gen_challenge(),
<a name="394"/>  394:     OurDigestA = gen_digest(HisChallengeA, Cookie),
<a name="395"/>  395:     send_complement(SocketA, SentNameMsg),
<a name="396"/>  396:     send_challenge_reply(SocketA, OurChallengeA, OurDigestA),
<a name="397"/>  397:     ok = recv_challenge_ack(SocketA, OurChallengeA, Cookie),
<a name="398"/>  398: 
<a name="399"/>  399:     inet:setopts(SocketA, [{active, false},
<a name="400"/>  400: 			   {packet, 4}]),
<a name="401"/>  401:     gen_tcp:send(SocketA,build_rex_message('',OurName)),
<a name="402"/>  402:     {Header, Message} = recv_message(SocketA),
<a name="403"/>  403:     io:format(&quot;Received header ~p, data ~p.~n&quot;,
<a name="404"/>  404: 	      [Header, Message]),
<a name="405"/>  405:     gen_tcp:close(SocketA),
<a name="406"/>  406:     gen_tcp:close(LSocket),
<a name="407"/>  407:     gen_tcp:close(EpmdSocket),
<a name="simultaneous_md5-last_expr"/><a name="408"/>  408:     ok.
<a name="409"/>  409: 
<a name="missing_compulsory_dflags-1"/><a name="410"/>  410: <b>missing_compulsory_dflags</b>(Config) when is_list(Config) -&gt;
<a name="411"/>  411:     Cookie = erlang:get_cookie(),
<a name="412"/>  412:     {ok, Peer, Node} = ?CT_PEER(),
<a name="413"/>  413:     {NA,NB} = split(Node),
<a name="414"/>  414:     {port,PortNo,_} = erl_epmd:port_please(NA,NB),
<a name="415"/>  415:     [begin
<a name="416"/>  416:          io:format(&quot;Assumed version ~p, Missing flags ~.16B\n&quot;,
<a name="417"/>  417:                    [Version, MissingFlags]),
<a name="418"/>  418:          {ok, SocketA} = gen_tcp:connect(atom_to_list(NB),PortNo,
<a name="419"/>  419:                                          [{active,false},
<a name="420"/>  420:                                           {packet,2}]),
<a name="421"/>  421:          BadNode = list_to_atom(?CT_PEER_NAME()++&quot;@&quot;++atom_to_list(NB)),
<a name="422"/>  422:          Flags = ?COMPULSORY_DFLAGS band (bnot MissingFlags),
<a name="423"/>  423:          SentNameMsg = send_name(SocketA, BadNode, Version, Flags),
<a name="424"/>  424:          case {Version, MissingFlags bsr 32} of
<a name="425"/>  425:              {?DIST_VER_LOW, HighFlags} when HighFlags =/= 0 -&gt;
<a name="426"/>  426:                  %% Missing flag in high word, peer will not detect that
<a name="427"/>  427:                  %% until we send complement.
<a name="428"/>  428:                  ok = recv_status(SocketA),
<a name="429"/>  429:                  {Node,HisChallengeA} = recv_challenge(SocketA),
<a name="430"/>  430:                  OurChallengeA = gen_challenge(),
<a name="431"/>  431:                  OurDigestA = gen_digest(HisChallengeA, Cookie),
<a name="432"/>  432:                  send_complement(SocketA, SentNameMsg, Flags),
<a name="433"/>  433:                  send_challenge_reply(SocketA, OurChallengeA, OurDigestA),
<a name="434"/>  434: 
<a name="435"/>  435:                  %% Would normally expect recv_challenge_ack but dist_util
<a name="436"/>  436:                  %% reacts to missing flags with a status message instead.
<a name="437"/>  437:                  not_allowed = recv_status(SocketA);
<a name="438"/>  438: 
<a name="439"/>  439:              _ -&gt;
<a name="440"/>  440:                  not_allowed = recv_status(SocketA)
<a name="441"/>  441:          end,
<a name="442"/>  442:          gen_tcp:close(SocketA)
<a name="443"/>  443:      end
<a name="444"/>  444:      || Version &lt;- lists:seq(?DIST_VER_LOW, ?DIST_VER_HIGH),
<a name="445"/>  445:         MissingFlags &lt;- [?DFLAG_BIT_BINARIES,
<a name="446"/>  446:                          ?DFLAG_HANDSHAKE_23,
<a name="447"/>  447:                          ?DFLAG_V4_NC]],
<a name="448"/>  448: 
<a name="449"/>  449:     peer:stop(Peer),
<a name="missing_compulsory_dflags-last_expr"/><a name="450"/>  450:     ok.
<a name="451"/>  451: 
<a name="452"/>  452: <i>%% Test that instead of passing all compulsory flags, we can instead</i>
<a name="453"/>  453: <i>%% pass only ?DFLAG_MANDATORY_25_DIGEST to ensure that we will be able to communicate</i>
<a name="454"/>  454: <i>%% with a future release where ?DFLAG_MANDATORY_25_DIGEST is mandatory.</i>
<a name="dflag_mandatory_25-1"/><a name="455"/>  455: <b>dflag_mandatory_25</b>(_Config) -&gt;
<a name="456"/>  456:     {ok, Peer, Node} = ?CT_PEER(),
<a name="457"/>  457:     {NA,NB} = split(Node),
<a name="458"/>  458:     {port,PortNo,_} = erl_epmd:port_please(NA, NB),
<a name="459"/>  459:     {ok, SocketA} = gen_tcp:connect(atom_to_list(NB),
<a name="460"/>  460:                                     PortNo,
<a name="461"/>  461:                                     [{active,false},{packet,2}]),
<a name="462"/>  462:     OtherNode = list_to_atom(?CT_PEER_NAME()++&quot;@&quot;++atom_to_list(NB)),
<a name="463"/>  463:     send_name(SocketA, OtherNode, ?DIST_VER_HIGH,
<a name="464"/>  464:               ?DFLAG_MANDATORY_25_DIGEST bor ?DFLAGS_MANDATORY_26),
<a name="465"/>  465:     ok = recv_status(SocketA),
<a name="466"/>  466:     gen_tcp:close(SocketA),
<a name="467"/>  467:     peer:stop(Peer),
<a name="dflag_mandatory_25-last_expr"/><a name="468"/>  468:     ok.
<a name="469"/>  469: 
<a name="470"/>  470: <i>%%</i>
<a name="471"/>  471: <i>%% Here comes the utilities</i>
<a name="472"/>  472: <i>%%</i>
<a name="473"/>  473: 
<a name="474"/>  474: <i>%%</i>
<a name="475"/>  475: <i>%% Switch option utilities</i>
<a name="476"/>  476: <i>%%</i>
<a name="write_packets_32-3"/><a name="477"/>  477: <b>write_packets_32</b>(_, M, N) when M &gt; N -&gt;
<a name="478"/>  478:     ok;
<a name="479"/>  479: <b>write_packets_32</b>(Sock, M, N) -&gt;
<a name="480"/>  480:     ok = gen_tcp:send(Sock,[?int32(4), ?int32(M)]),
<a name="write_packets_32-last_expr"/><a name="481"/>  481: <b>    write_packets_32</b>(Sock, M+1, N).
<a name="482"/>  482: 
<a name="write_packets_16-3"/><a name="483"/>  483: <b>write_packets_16</b>(_, M, N) when M &gt; N -&gt;
<a name="484"/>  484:     ok;
<a name="485"/>  485: <b>write_packets_16</b>(Sock, M, N) -&gt;
<a name="486"/>  486:     ok = gen_tcp:send(Sock,[?int16(4), ?int32(M)]),
<a name="write_packets_16-last_expr"/><a name="487"/>  487: <b>    write_packets_16</b>(Sock, M+1, N).
<a name="488"/>  488: 
<a name="read_packets-3"/><a name="489"/>  489: <b>read_packets</b>(_, M, N) when M &gt; N -&gt;
<a name="490"/>  490:     ok;
<a name="491"/>  491: <b>read_packets</b>(Sock, M, N) -&gt;
<a name="492"/>  492:     Expected = ?int32(M),
<a name="read_packets-last_expr"/><a name="493"/>  493: <b>    case gen_tcp:recv</b>(Sock, 0) of
<a name="494"/>  494: 	{ok, Expected} -&gt;
<a name="495"/>  495: 	    read_packets(Sock, M+1, N);
<a name="496"/>  496: 	{ok, Unexpected} -&gt;
<a name="497"/>  497: 	    exit({unexpected_data_read, Unexpected});
<a name="498"/>  498: 	Error -&gt;
<a name="499"/>  499: 	    exit({error_read, Error})
<a name="500"/>  500:     end.
<a name="501"/>  501: 
<a name="receive_packets-3"/><a name="502"/>  502: <b>receive_packets</b>(Sock, M, N) when M &gt; N -&gt;
<a name="503"/>  503:     receive
<a name="504"/>  504: 	{tcp, Sock, Data} -&gt;
<a name="505"/>  505: 	    exit({extra_data, Data})
<a name="506"/>  506:     after 0 -&gt;
<a name="507"/>  507: 	    ok
<a name="508"/>  508:     end;
<a name="509"/>  509: 
<a name="510"/>  510: <b>receive_packets</b>(Sock, M, N) -&gt;
<a name="511"/>  511:     Expect = ?int32(M),
<a name="receive_packets-last_expr"/><a name="512"/>  512:     receive
<a name="513"/>  513: 	{tcp, Sock, Expect} -&gt;
<a name="514"/>  514: 	    receive_packets(Sock, M+1, N); 
<a name="515"/>  515: 	{tcp, Sock, Unexpected} -&gt;
<a name="516"/>  516: 	    exit({unexpected_data_received, Unexpected})
<a name="517"/>  517:     after 500 -&gt;
<a name="518"/>  518: 	    exit({no_data_received_for,M})
<a name="519"/>  519:     end.
<a name="520"/>  520: 
<a name="socket_pair-2"/><a name="521"/>  521: <b>socket_pair</b>(ClientPack, ServerPack) -&gt;
<a name="522"/>  522:     {ok, Listen} = gen_tcp:listen(0, [{active, false}, 
<a name="523"/>  523: 				      {packet, ServerPack}]),
<a name="524"/>  524:     {ok, Host} = inet:gethostname(),
<a name="525"/>  525:     {ok, Port} = inet:port(Listen),
<a name="526"/>  526:     {ok, Client} = gen_tcp:connect(Host, Port, [{active, false}, 
<a name="527"/>  527: 						{packet, ClientPack}]),
<a name="528"/>  528:     {ok, Server} = gen_tcp:accept(Listen),
<a name="529"/>  529:     gen_tcp:close(Listen),
<a name="socket_pair-last_expr"/><a name="530"/>  530:     {Client, Server}.
<a name="531"/>  531: 
<a name="close_pair-1"/><a name="532"/>  532: <b>close_pair</b>({Client, Server}) -&gt;
<a name="533"/>  533:     gen_tcp:close(Client),
<a name="534"/>  534:     gen_tcp:close(Server),
<a name="close_pair-last_expr"/><a name="535"/>  535:     ok.
<a name="536"/>  536: 
<a name="537"/>  537: 
<a name="538"/>  538: <i>%%</i>
<a name="539"/>  539: <i>%% Handshake utilities</i>
<a name="540"/>  540: <i>%%</i>
<a name="541"/>  541: 
<a name="542"/>  542: <i>%%</i>
<a name="543"/>  543: <i>%% MD5 hashing</i>
<a name="544"/>  544: <i>%%</i>
<a name="545"/>  545: 
<a name="gen_challenge-0"/><a name="546"/>  546: <b>gen_challenge</b>() -&gt;
<a name="gen_challenge-last_expr"/><a name="547"/>  547: <b>    rand:uniform</b>(1000000).
<a name="548"/>  548: 
<a name="549"/>  549: <i>%% Generate a message digest from Challenge number and Cookie	</i>
<a name="gen_digest-2"/><a name="550"/>  550: <b>gen_digest</b>(Challenge, Cookie) when is_integer(Challenge), is_atom(Cookie) -&gt;
<a name="551"/>  551:     C0 = erlang:md5_init(),
<a name="552"/>  552:     C1 = erlang:md5_update(C0, atom_to_list(Cookie)),
<a name="553"/>  553:     C2 = erlang:md5_update(C1, integer_to_list(Challenge)),
<a name="gen_digest-last_expr"/><a name="554"/>  554: <b>    binary_to_list</b>(erlang:md5_final(C2)).
<a name="555"/>  555: 
<a name="556"/>  556: 
<a name="557"/>  557: <i>%%</i>
<a name="558"/>  558: <i>%% The different stages of the MD5 handshake</i>
<a name="559"/>  559: <i>%%</i>
<a name="560"/>  560: 
<a name="send_status-2"/><a name="561"/>  561: <b>send_status</b>(Socket, Stat) -&gt;
<a name="send_status-last_expr"/><a name="562"/>  562: <b>    case gen_tcp:send</b>(Socket, [$s | atom_to_list(Stat)]) of
<a name="563"/>  563: 	{error, _} -&gt;
<a name="564"/>  564: 	    ?shutdown(could_not_send_status);
<a name="565"/>  565: 	_ -&gt; 
<a name="566"/>  566: 	    true
<a name="567"/>  567:     end.
<a name="568"/>  568: 
<a name="569"/>  569: 
<a name="recv_status-1"/><a name="570"/>  570: <b>recv_status</b>(Socket) -&gt;
<a name="recv_status-last_expr"/><a name="571"/>  571: <b>    case gen_tcp:recv</b>(Socket, 0) of
<a name="572"/>  572: 	{ok, [$s|StrStat]} -&gt;
<a name="573"/>  573: 	    list_to_atom(StrStat);
<a name="574"/>  574: 	Bad -&gt;
<a name="575"/>  575: 	    exit(Bad)
<a name="576"/>  576:     end.
<a name="577"/>  577: 
<a name="send_challenge-4"/><a name="578"/>  578: <b>send_challenge</b>(Socket, Node, Challenge, GotFlags) -&gt;
<a name="579"/>  579:     Flags = ?COMPULSORY_DFLAGS bor ?DFLAG_MANDATORY_25_DIGEST,
<a name="send_challenge-last_expr"/><a name="580"/>  580: <b>    send_challenge</b>(Socket, Node, Challenge, GotFlags, Flags).
<a name="581"/>  581: 
<a name="send_challenge-5"/><a name="582"/>  582: <b>send_challenge</b>(Socket, Node, Challenge, GotFlags, Flags) -&gt;
<a name="583"/>  583:     true = (GotFlags band ?DFLAG_HANDSHAKE_23) =/= 0,
<a name="584"/>  584:     {ok, {{_Ip1,_Ip2,_Ip3,_Ip4}, _}} = inet:sockname(Socket),
<a name="585"/>  585:     NodeName = atom_to_list(Node),
<a name="586"/>  586:     Nlen = length(NodeName),
<a name="587"/>  587:     Creation = erts_internal:get_creation(),
<a name="send_challenge-last_expr"/><a name="588"/>  588: <b>    ?to_port</b>(Socket, [$N, &lt;&lt;(Flags bor ?DFLAG_HANDSHAKE_23):64&gt;&gt;,
<a name="589"/>  589:                       &lt;&lt;Challenge:32&gt;&gt;, &lt;&lt;Creation:32&gt;&gt;,
<a name="590"/>  590:                       &lt;&lt;Nlen:16&gt;&gt;, NodeName
<a name="591"/>  591:                       ]).
<a name="592"/>  592: 
<a name="recv_challenge-1"/><a name="593"/>  593: <b>recv_challenge</b>(Socket) -&gt;
<a name="594"/>  594:     {ok, Msg} = gen_tcp:recv(Socket, 0),
<a name="595"/>  595:     %%io:format(&quot;recv_challenge Msg=~p\n&quot;, [Msg]),
<a name="recv_challenge-last_expr"/><a name="596"/>  596:     case Msg of
<a name="597"/>  597:         [$N, F7,F6,F5,F4,F3,F2,F1,F0, CA3,CA2,CA1,CA0,
<a name="598"/>  598:          Cr3,Cr2,Cr1,Cr0, NL1,NL0 | Ns] -&gt;
<a name="599"/>  599: 	    &lt;&lt;Flags:64&gt;&gt; = &lt;&lt;F7,F6,F5,F4,F3,F2,F1,F0&gt;&gt;,
<a name="600"/>  600:             verify_flags(Flags),
<a name="601"/>  601:             &lt;&lt;Creation:32&gt;&gt; = &lt;&lt;Cr3,Cr2,Cr1,Cr0&gt;&gt;,
<a name="602"/>  602:             true = (Creation =/= 0),
<a name="603"/>  603:             &lt;&lt;NameLen:16&gt;&gt; = &lt;&lt;NL1,NL0&gt;&gt;,
<a name="604"/>  604:             NameLen = length(Ns),
<a name="605"/>  605: 	    Node = list_to_atom(Ns),
<a name="606"/>  606: 	    Challenge = ?u32(CA3,CA2,CA1,CA0),
<a name="607"/>  607: 	    {Node, Challenge};
<a name="608"/>  608: 
<a name="609"/>  609: 	_ -&gt;
<a name="610"/>  610: 	    ?shutdown(no_node)	    
<a name="611"/>  611:     end.
<a name="612"/>  612: 
<a name="verify_flags-1"/><a name="613"/>  613: <b>verify_flags</b>(Flags) -&gt;
<a name="614"/>  614:     RequiredFlags = ?COMPULSORY_DFLAGS bor ?DFLAG_MANDATORY_25_DIGEST,
<a name="verify_flags-last_expr"/><a name="615"/>  615:     if
<a name="616"/>  616:         Flags band RequiredFlags =:= RequiredFlags -&gt;
<a name="617"/>  617:             ok;
<a name="618"/>  618:         true -&gt;
<a name="619"/>  619:             io:format(&quot;Given flags:    ~.16.0B\n&quot;, [Flags]),
<a name="620"/>  620:             io:format(&quot;Required flags: ~.16.0B\n&quot;, [RequiredFlags]),
<a name="621"/>  621:             ct:fail(missing_dflags)
<a name="622"/>  622:     end.
<a name="623"/>  623: 
<a name="send_complement-2"/><a name="624"/>  624: <b>send_complement</b>(Socket, SentNameMsg) -&gt;
<a name="send_complement-last_expr"/><a name="625"/>  625: <b>    send_complement</b>(Socket, SentNameMsg, ?COMPULSORY_DFLAGS).
<a name="626"/>  626: 
<a name="send_complement-3"/><a name="627"/>  627: <b>send_complement</b>(Socket, SentNameMsg, Flags) -&gt;
<a name="send_complement-last_expr"/><a name="628"/>  628:     case SentNameMsg of
<a name="629"/>  629:         $n -&gt;
<a name="630"/>  630:             FlagsHigh = Flags bsr 32,
<a name="631"/>  631:             ?to_port(Socket, [$c,
<a name="632"/>  632:                               &lt;&lt;FlagsHigh:32&gt;&gt;,
<a name="633"/>  633:                               ?int32(erts_internal:get_creation())]);
<a name="634"/>  634:         $N -&gt;
<a name="635"/>  635:             ok
<a name="636"/>  636:     end.
<a name="637"/>  637: 
<a name="send_challenge_reply-3"/><a name="638"/>  638: <b>send_challenge_reply</b>(Socket, Challenge, Digest) -&gt;
<a name="send_challenge_reply-last_expr"/><a name="639"/>  639: <b>    ?to_port</b>(Socket, [$r,?int32(Challenge),Digest]).
<a name="640"/>  640: 
<a name="recv_challenge_reply-3"/><a name="641"/>  641: <b>recv_challenge_reply</b>(Socket, ChallengeA, Cookie) -&gt;
<a name="recv_challenge_reply-last_expr"/><a name="642"/>  642: <b>    case gen_tcp:recv</b>(Socket, 0) of
<a name="643"/>  643: 	{ok,[$r,CB3,CB2,CB1,CB0 | SumB]=Data} when length(SumB) == 16 -&gt;
<a name="644"/>  644: 	    SumA = gen_digest(ChallengeA, Cookie),
<a name="645"/>  645: 	    ChallengeB = ?u32(CB3,CB2,CB1,CB0),
<a name="646"/>  646: 	    if SumB == SumA -&gt;
<a name="647"/>  647: 		    {ok,ChallengeB};
<a name="648"/>  648: 	       true -&gt;
<a name="649"/>  649: 		    {error,Data}
<a name="650"/>  650: 	    end;
<a name="651"/>  651: 	Err -&gt;
<a name="652"/>  652:             {error,Err}
<a name="653"/>  653:     end.
<a name="654"/>  654: 
<a name="send_challenge_ack-2"/><a name="655"/>  655: <b>send_challenge_ack</b>(Socket, Digest) -&gt;
<a name="send_challenge_ack-last_expr"/><a name="656"/>  656: <b>    ?to_port</b>(Socket, [$a,Digest]).
<a name="657"/>  657: 
<a name="recv_challenge_ack-3"/><a name="658"/>  658: <b>recv_challenge_ack</b>(Socket, ChallengeB, CookieA) -&gt;
<a name="recv_challenge_ack-last_expr"/><a name="659"/>  659: <b>    case gen_tcp:recv</b>(Socket, 0) of
<a name="660"/>  660: 	{ok,[$a | SumB]} when length(SumB) == 16 -&gt;
<a name="661"/>  661: 	    SumA = gen_digest(ChallengeB, CookieA),
<a name="662"/>  662: 	    if SumB == SumA -&gt;
<a name="663"/>  663: 		    ok;
<a name="664"/>  664: 	       true -&gt;
<a name="665"/>  665: 		    ?shutdown(bad_challenge_ack)
<a name="666"/>  666: 	    end
<a name="667"/>  667:     end.
<a name="668"/>  668: 
<a name="send_name-3"/><a name="669"/>  669: <b>send_name</b>(Socket, MyNode0, AssumedVersion) -&gt;
<a name="670"/>  670:     Flags = ?COMPULSORY_DFLAGS bor ?DFLAG_MANDATORY_25_DIGEST,
<a name="send_name-last_expr"/><a name="671"/>  671: <b>    send_name</b>(Socket, MyNode0, AssumedVersion, Flags).
<a name="672"/>  672: 
<a name="send_name-4"/><a name="673"/>  673: <b>send_name</b>(Socket, MyNode0, AssumedVersion, Flags) -&gt;
<a name="674"/>  674:     MyNode = atom_to_list(MyNode0),
<a name="send_name-last_expr"/><a name="675"/>  675: <b>    if </b>(AssumedVersion =:= ?DIST_VER_LOW) -&gt;
<a name="676"/>  676:             ok = ?to_port(Socket, [&lt;&lt;$n,?DIST_VER_HIGH:16,Flags:32&gt;&gt;|MyNode]),
<a name="677"/>  677:             $n;
<a name="678"/>  678: 
<a name="679"/>  679:        (AssumedVersion &gt; ?DIST_VER_LOW) -&gt;
<a name="680"/>  680:             Creation = erts_internal:get_creation(),
<a name="681"/>  681:             NameLen = length(MyNode),
<a name="682"/>  682:             ok = ?to_port(Socket, [&lt;&lt;$N, Flags:64,
<a name="683"/>  683:                                      Creation:32,NameLen:16&gt;&gt;|MyNode]),
<a name="684"/>  684:             $N
<a name="685"/>  685:     end.
<a name="686"/>  686: 
<a name="recv_name-1"/><a name="687"/>  687: <b>recv_name</b>(Socket) -&gt;
<a name="recv_name-last_expr"/><a name="688"/>  688: <b>    case gen_tcp:recv</b>(Socket, 0) of
<a name="689"/>  689: 	{ok,Data} -&gt;
<a name="690"/>  690: 	    get_name(Data);
<a name="691"/>  691: 	Res -&gt;
<a name="692"/>  692: 	    ?shutdown({no_node,Res})
<a name="693"/>  693:     end.
<a name="694"/>  694: 
<a name="get_name-1"/><a name="695"/>  695: <b>get_name</b>([$N, F7,F6,F5,F4,F3,F2,F1,F0,
<a name="696"/>  696:           _C3,_C2,_C1,_C0, NLen1,NLen2 | OtherNode]) -&gt;
<a name="697"/>  697:     &lt;&lt;Flags:64&gt;&gt; = &lt;&lt;F7,F6,F5,F4,F3,F2,F1,F0&gt;&gt;,
<a name="698"/>  698:     true = (Flags band ?DFLAG_HANDSHAKE_23) =/= 0,
<a name="699"/>  699:     &lt;&lt;NameLen:16&gt;&gt; = &lt;&lt;NLen1,NLen2&gt;&gt;,
<a name="700"/>  700:     NameLen = length(OtherNode),
<a name="701"/>  701:     {list_to_atom(OtherNode), Flags};
<a name="702"/>  702: <b>get_name</b>(Data) -&gt;
<a name="get_name-last_expr"/><a name="703"/>  703: <b>    ?shutdown</b>(Data).
<a name="704"/>  704: 
<a name="705"/>  705: <i>%%</i>
<a name="706"/>  706: <i>%% The communication with EPMD follows</i>
<a name="707"/>  707: <i>%%</i>
<a name="get_epmd_port-0"/><a name="708"/>  708: <b>get_epmd_port</b>() -&gt;
<a name="get_epmd_port-last_expr"/><a name="709"/>  709: <b>    case init:get_argument</b>(epmd_port) of
<a name="710"/>  710:         {ok, [[PortStr|_]|_]} when is_list(PortStr) -&gt;
<a name="711"/>  711:             list_to_integer(PortStr);
<a name="712"/>  712:         error -&gt;
<a name="713"/>  713:             4369 % Default epmd port
<a name="714"/>  714:     end.
<a name="715"/>  715: 
<a name="do_register_node-2"/><a name="716"/>  716: <b>do_register_node</b>(NodeName, TcpPort) -&gt;
<a name="do_register_node-last_expr"/><a name="717"/>  717: <b>    case gen_tcp:connect</b>({127,0,0,1}, get_epmd_port(), []) of
<a name="718"/>  718: 	{ok, Socket} -&gt;
<a name="719"/>  719: 	    {N0,_} = split(NodeName),
<a name="720"/>  720: 	    Name = atom_to_list(N0),
<a name="721"/>  721: 	    Extra = &quot;&quot;,
<a name="722"/>  722: 	    Elen = length(Extra),
<a name="723"/>  723: 	    Len = 1+2+1+1+2+2+2+length(Name)+2+Elen,
<a name="724"/>  724: 	    gen_tcp:send(Socket, [?int16(Len), $x,
<a name="725"/>  725: 				  ?int16(TcpPort),
<a name="726"/>  726: 				  $M,
<a name="727"/>  727: 				  0,
<a name="728"/>  728: 				  ?int16(?DIST_VER_HIGH),
<a name="729"/>  729: 				  ?int16(?DIST_VER_LOW),
<a name="730"/>  730: 				  ?int16(length(Name)),
<a name="731"/>  731: 				  Name,
<a name="732"/>  732: 				  ?int16(Elen),
<a name="733"/>  733: 				  Extra]),
<a name="734"/>  734: 	    case wait_for_reg_reply(Socket, []) of
<a name="735"/>  735: 		{error, epmd_close} -&gt;
<a name="736"/>  736: 		    exit(epmd_broken);
<a name="737"/>  737: 		Other -&gt;
<a name="738"/>  738: 		    Other
<a name="739"/>  739: 	    end;
<a name="740"/>  740: 	Error -&gt;
<a name="741"/>  741: 	    Error
<a name="742"/>  742:     end.
<a name="743"/>  743: 
<a name="wait_for_reg_reply-2"/><a name="744"/>  744: <b>wait_for_reg_reply</b>(Socket, SoFar) -&gt;
<a name="wait_for_reg_reply-last_expr"/><a name="745"/>  745:     receive
<a name="746"/>  746: 	{tcp, Socket, Data0} -&gt;
<a name="747"/>  747: 	    case SoFar ++ Data0 of
<a name="748"/>  748: 		[$v, Result, A, B, C, D] -&gt;
<a name="749"/>  749: 		    case Result of
<a name="750"/>  750: 			0 -&gt;
<a name="751"/>  751: 			    {alive, Socket, ?u32(A, B, C, D)};
<a name="752"/>  752: 			_ -&gt;
<a name="753"/>  753: 			    {error, duplicate_name}
<a name="754"/>  754: 		    end;
<a name="755"/>  755: 		[$y, Result, A, B] -&gt;
<a name="756"/>  756: 		    case Result of
<a name="757"/>  757: 			0 -&gt;
<a name="758"/>  758: 			    {alive, Socket, ?u16(A, B)};
<a name="759"/>  759: 			_ -&gt;
<a name="760"/>  760: 			    {error, duplicate_name}
<a name="761"/>  761: 		    end;
<a name="762"/>  762: 		Data when length(Data) &lt; 4 -&gt;
<a name="763"/>  763: 		    wait_for_reg_reply(Socket, Data);
<a name="764"/>  764: 		Garbage -&gt;
<a name="765"/>  765: 		    {error, {garbage_from_epmd, Garbage}}
<a name="766"/>  766: 	    end;
<a name="767"/>  767: 	{tcp_closed, Socket} -&gt;
<a name="768"/>  768: 	    {error, epmd_close}
<a name="769"/>  769:     after 10000 -&gt;
<a name="770"/>  770: 	    gen_tcp:close(Socket),
<a name="771"/>  771: 	    {error, no_reg_reply_from_epmd}
<a name="772"/>  772:     end.
<a name="773"/>  773: 
<a name="774"/>  774: 
<a name="register_node-2"/><a name="775"/>  775: <b>register_node</b>(NodeName, ListenSocket) -&gt;
<a name="776"/>  776:     {ok,{_,TcpPort}} = inet:sockname(ListenSocket),
<a name="register_node-last_expr"/><a name="777"/>  777: <b>    case do_register_node</b>(NodeName, TcpPort) of
<a name="778"/>  778: 	{alive, Socket, _Creation} -&gt;
<a name="779"/>  779: 	    Socket;
<a name="780"/>  780: 	Other -&gt;
<a name="781"/>  781: 	    exit(Other)
<a name="782"/>  782:     end.
<a name="783"/>  783: 
<a name="784"/>  784: 
<a name="785"/>  785: <i>%%</i>
<a name="786"/>  786: <i>%% Utilities</i>
<a name="787"/>  787: <i>%%</i>
<a name="788"/>  788: 
<a name="789"/>  789: <i>%% Split a nodename</i>
<a name="split-2"/><a name="790"/>  790: <b>split</b>([$@|T],A) -&gt;
<a name="791"/>  791:     {lists:reverse(A),T};
<a name="792"/>  792: <b>split</b>([H|T],A) -&gt;
<a name="split-last_expr"/><a name="793"/>  793: <b>    split</b>(T,[H|A]).
<a name="794"/>  794: 
<a name="split-1"/><a name="795"/>  795: <b>split</b>(Atom) -&gt;
<a name="796"/>  796:     {A,B} = split(atom_to_list(Atom),[]),
<a name="split-last_expr"/><a name="797"/>  797: <b>    {list_to_atom</b>(A),list_to_atom(B)}.
<a name="798"/>  798: 
<a name="799"/>  799: <i>%% Build a distribution message that will make rex answer</i>
<a name="build_rex_message-2"/><a name="800"/>  800: <b>build_rex_message</b>(Cookie,OurName) -&gt;
<a name="build_rex_message-last_expr"/><a name="801"/>  801: <b>    [?PASS_THROUGH,term_to_binary</b>({6,self(),Cookie,rex}),
<a name="802"/>  802:      term_to_binary({'$gen_cast',
<a name="803"/>  803: 		     {cast,
<a name="804"/>  804: 		      erlang,
<a name="805"/>  805: 		      send,
<a name="806"/>  806: 		      [{regname, OurName}, &quot;hello world&quot;],
<a name="807"/>  807:                       self()}})].
<a name="808"/>  808: 
<a name="809"/>  809: <i>%% Receive a distribution message    </i>
<a name="recv_message-1"/><a name="810"/>  810: <b>recv_message</b>(Socket) -&gt;
<a name="recv_message-last_expr"/><a name="811"/>  811: <b>    case gen_tcp:recv</b>(Socket, 0) of
<a name="812"/>  812:         {ok,[]} -&gt;
<a name="813"/>  813:             recv_message(Socket);  %% a tick, ignore
<a name="814"/>  814: 	{ok,Data} -&gt;
<a name="815"/>  815: 	    B0 = list_to_binary(Data),
<a name="816"/>  816: 	    &lt;&lt;?PASS_THROUGH, B1/binary&gt;&gt; = B0,
<a name="817"/>  817: 	    {Header,Siz} = binary_to_term(B1,[used]),
<a name="818"/>  818: 	    &lt;&lt;_:Siz/binary,B2/binary&gt;&gt; = B1,
<a name="819"/>  819: 	    Message = case (catch binary_to_term(B2)) of
<a name="820"/>  820: 			  {'EXIT', _} -&gt;
<a name="821"/>  821: 			      {could_not_digest_message,B2};
<a name="822"/>  822: 			  Other -&gt;
<a name="823"/>  823: 			      Other
<a name="824"/>  824: 		      end,
<a name="825"/>  825: 	    {Header, Message};
<a name="826"/>  826: 	Res -&gt;
<a name="827"/>  827: 	    exit({no_message,Res})
<a name="828"/>  828:     end. 
<a name="829"/>  829: 
<a name="830"/>  830: <i>%% Build a nodename</i>
<a name="join-2"/><a name="831"/>  831: <b>join</b>(Name,Host) -&gt;
<a name="join-last_expr"/><a name="832"/>  832: <b>    list_to_atom</b>(atom_to_list(Name) ++ &quot;@&quot; ++ atom_to_list(Host)).
</pre>
</body>
</html>
