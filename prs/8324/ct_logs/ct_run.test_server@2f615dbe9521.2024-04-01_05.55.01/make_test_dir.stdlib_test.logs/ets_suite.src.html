<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/lib/stdlib/make_test_dir/stdlib_test/ets_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%</i>
<a name="2"/>    2: <i>%% %CopyrightBegin%</i>
<a name="3"/>    3: <i>%%</i>
<a name="4"/>    4: <i>%% Copyright Ericsson AB 1996-2023. All Rights Reserved.</i>
<a name="5"/>    5: <i>%%</i>
<a name="6"/>    6: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="7"/>    7: <i>%% you may not use this file except in compliance with the License.</i>
<a name="8"/>    8: <i>%% You may obtain a copy of the License at</i>
<a name="9"/>    9: <i>%%</i>
<a name="10"/>   10: <i>%%     http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="11"/>   11: <i>%%</i>
<a name="12"/>   12: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="13"/>   13: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="14"/>   14: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="15"/>   15: <i>%% See the License for the specific language governing permissions and</i>
<a name="16"/>   16: <i>%% limitations under the License.</i>
<a name="17"/>   17: <i>%%</i>
<a name="18"/>   18: <i>%% %CopyrightEnd%</i>
<a name="19"/>   19: <i>%%</i>
<a name="20"/>   20: <b>-module</b>(ets_SUITE).
<a name="21"/>   21: 
<a name="22"/>   22: <b>-export</b>([all/0, suite/0,groups/0,init_per_suite/1, end_per_suite/1,
<a name="23"/>   23: 	 init_per_group/2,end_per_group/2]).
<a name="24"/>   24: <b>-export</b>([default/1,setbag/1,badnew/1,verybadnew/1,named/1,keypos2/1,
<a name="25"/>   25: 	 privacy/1]).
<a name="26"/>   26: <b>-export</b>([empty/1,badinsert/1]).
<a name="27"/>   27: <b>-export</b>([badlookup/1,lookup_order/1]).
<a name="28"/>   28: <b>-export</b>([delete_elem/1,delete_tab/1,delete_large_tab/1,
<a name="29"/>   29: 	 delete_large_named_table/1,
<a name="30"/>   30: 	 evil_delete/1,baddelete/1,match_delete/1,table_leak/1]).
<a name="31"/>   31: <b>-export</b>([match_delete3/1]).
<a name="32"/>   32: <b>-export</b>([firstnext/1,firstnext_concurrent/1]).
<a name="33"/>   33: <b>-export</b>([slot/1]).
<a name="34"/>   34: <b>-export</b>([hash_clash/1]).
<a name="35"/>   35: <b>-export</b>([match1/1, match2/1, match_object/1, match_object2/1]).
<a name="36"/>   36: <b>-export</b>([dups/1, misc1/1, safe_fixtable/1, info/1, tab2list/1]).
<a name="37"/>   37: <b>-export</b>([info_binary_stress/1]).
<a name="38"/>   38: <b>-export</b>([info_whereis_busy/1]).
<a name="39"/>   39: <b>-export</b>([insert_trap_delete/1, insert_trap_rename/1]).
<a name="40"/>   40: <b>-export</b>([tab2file/1, tab2file2/1, tabfile_ext1/1,
<a name="41"/>   41: 	 tabfile_ext2/1, tabfile_ext3/1, tabfile_ext4/1, badfile/1]).
<a name="42"/>   42: <b>-export</b>([heavy_lookup/1, heavy_lookup_element/1, heavy_concurrent/1]).
<a name="43"/>   43: <b>-export</b>([lookup_element_mult/1, lookup_element_default/1]).
<a name="44"/>   44: <b>-export</b>([foldl_ordered/1, foldr_ordered/1, foldl/1, foldr/1, fold_empty/1]).
<a name="45"/>   45: <b>-export</b>([t_delete_object/1, t_init_table/1, t_whitebox/1,
<a name="46"/>   46:          select_bound_chunk/1, t_delete_all_objects/1, t_test_ms/1,
<a name="47"/>   47:          t_delete_all_objects_trap/1,
<a name="48"/>   48: 	 t_select_delete/1,t_select_replace/1,t_select_replace_next_bug/1,
<a name="49"/>   49:          t_select_pam_stack_overflow_bug/1,
<a name="50"/>   50:          t_select_flatmap_term_copy_bug/1,
<a name="51"/>   51:          t_select_hashmap_term_copy_bug/1,
<a name="52"/>   52:          t_ets_dets/1]).
<a name="53"/>   53: <b>-export</b>([t_insert_list/1, t_insert_list_bag/1, t_insert_list_duplicate_bag/1,
<a name="54"/>   54:          t_insert_list_set/1, t_insert_list_delete_set/1,
<a name="55"/>   55:          t_insert_list_parallel/1, t_insert_list_delete_parallel/1,
<a name="56"/>   56:          t_insert_list_kill_process/1,
<a name="57"/>   57:          t_insert_list_insert_order_preserved/1]).
<a name="58"/>   58: <b>-export</b>([test_table_size_concurrency/1,test_table_memory_concurrency/1,
<a name="59"/>   59:          test_delete_table_while_size_snapshot/1, test_delete_table_while_size_snapshot_helper/1,
<a name="60"/>   60:          test_decentralized_counters_setting/1]).
<a name="61"/>   61: 
<a name="62"/>   62: <b>-export</b>([ordered/1, ordered_match/1, interface_equality/1,
<a name="63"/>   63: 	 fixtable_next/1, fixtable_iter_bag/1,
<a name="64"/>   64:          fixtable_insert/1, rename/1, rename_unnamed/1, evil_rename/1,
<a name="65"/>   65: 	 update_element/1, update_counter/1, evil_update_counter/1, partly_bound/1, match_heavy/1]).
<a name="66"/>   66: <b>-export</b>([update_counter_with_default/1]).
<a name="67"/>   67: <b>-export</b>([update_counter_with_default_bad_pos/1]).
<a name="68"/>   68: <b>-export</b>([update_counter_table_growth/1]).
<a name="69"/>   69: <b>-export</b>([member/1]).
<a name="70"/>   70: <b>-export</b>([memory/1]).
<a name="71"/>   71: <b>-export</b>([select_fail/1]).
<a name="72"/>   72: <b>-export</b>([t_insert_new/1]).
<a name="73"/>   73: <b>-export</b>([t_repair_continuation/1]).
<a name="74"/>   74: <b>-export</b>([t_match_spec_run/1]).
<a name="75"/>   75: <b>-export</b>([t_bucket_disappears/1]).
<a name="76"/>   76: <b>-export</b>([t_named_select/1]).
<a name="77"/>   77: <b>-export</b>([select_fixtab_owner_change/1]).
<a name="78"/>   78: <b>-export</b>([otp_5340/1]).
<a name="79"/>   79: <b>-export</b>([otp_6338/1]).
<a name="80"/>   80: <b>-export</b>([otp_6842_select_1000/1]).
<a name="81"/>   81: <b>-export</b>([select_mbuf_trapping/1]).
<a name="82"/>   82: <b>-export</b>([otp_7665/1]).
<a name="83"/>   83: <b>-export</b>([meta_wb/1]).
<a name="84"/>   84: <b>-export</b>([grow_shrink/1, grow_pseudo_deleted/1, shrink_pseudo_deleted/1]).
<a name="85"/>   85: <b>-export</b>([meta_lookup_unnamed_read/1, meta_lookup_unnamed_write/1,
<a name="86"/>   86: 	 meta_lookup_named_read/1, meta_lookup_named_write/1,
<a name="87"/>   87: 	 meta_newdel_unnamed/1, meta_newdel_named/1]).
<a name="88"/>   88: <b>-export</b>([smp_insert/1, smp_fixed_delete/1, smp_unfix_fix/1, smp_select_delete/1,
<a name="89"/>   89:          smp_ordered_iteration/1,
<a name="90"/>   90:          smp_select_replace/1, otp_8166/1, otp_8732/1, delete_unfix_race/1]).
<a name="91"/>   91: <b>-export</b>([throughput_benchmark/0,
<a name="92"/>   92:          throughput_benchmark/1,
<a name="93"/>   93:          test_throughput_benchmark/1,
<a name="94"/>   94:          long_throughput_benchmark/1,
<a name="95"/>   95:          lookup_catree_par_vs_seq_init_benchmark/0]).
<a name="96"/>   96: <b>-export</b>([exit_large_table_owner/1,
<a name="97"/>   97: 	 exit_many_large_table_owner/1,
<a name="98"/>   98: 	 exit_many_tables_owner/1,
<a name="99"/>   99: 	 exit_many_many_tables_owner/1]).
<a name="100"/>  100: <b>-export</b>([write_concurrency/1, heir/1, give_away/1, setopts/1]).
<a name="101"/>  101: <b>-export</b>([bad_table/1, types/1]).
<a name="102"/>  102: <b>-export</b>([otp_9932/1]).
<a name="103"/>  103: <b>-export</b>([otp_9423/1]).
<a name="104"/>  104: <b>-export</b>([otp_10182/1]).
<a name="105"/>  105: <b>-export</b>([compress_magic_ref/1]).
<a name="106"/>  106: <b>-export</b>([ets_all/1]).
<a name="107"/>  107: <b>-export</b>([massive_ets_all/1]).
<a name="108"/>  108: <b>-export</b>([take/1]).
<a name="109"/>  109: <b>-export</b>([whereis_table/1]).
<a name="110"/>  110: <b>-export</b>([ms_excessive_nesting/1]).
<a name="111"/>  111: <b>-export</b>([error_info/1]).
<a name="112"/>  112: 
<a name="113"/>  113: <b>-export</b>([init_per_testcase/2, end_per_testcase/2]).
<a name="114"/>  114: <i>%% Convenience for manual testing</i>
<a name="115"/>  115: <b>-export</b>([random_test/0]).
<a name="116"/>  116: 
<a name="117"/>  117: <b>-export</b>([t_select_reverse/1]).
<a name="118"/>  118: 
<a name="119"/>  119: <b>-include_lib</b>(&quot;stdlib/include/ms_transform.hrl&quot;). % ets:fun2ms
<a name="120"/>  120: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="121"/>  121: <b>-include_lib</b>(&quot;common_test/include/ct_event.hrl&quot;).
<a name="122"/>  122: 
<a name="123"/>  123: <b>-define</b>(m(A,B), assert_eq(A,B)).
<a name="124"/>  124: <b>-define</b>(heap_binary_size, 64).
<a name="125"/>  125: 
<a name="init_per_testcase-2"/><a name="126"/>  126: <b>init_per_testcase</b>(Case, Config) -&gt;
<a name="127"/>  127:     rand:seed(default),
<a name="128"/>  128:     io:format(&quot;*** SEED: ~p ***\n&quot;, [rand:export_seed()]),
<a name="129"/>  129:     start_spawn_logger(),
<a name="130"/>  130:     wait_for_test_procs(), %% Ensure previous case cleaned up
<a name="init_per_testcase-last_expr"/><a name="131"/>  131:     [{test_case, Case} | Config].
<a name="132"/>  132: 
<a name="end_per_testcase-2"/><a name="133"/>  133: <b>end_per_testcase</b>(_Func, _Config) -&gt;
<a name="end_per_testcase-last_expr"/><a name="134"/>  134: <b>    wait_for_test_procs</b>(true).
<a name="135"/>  135: 
<a name="136"/>  136: 
<a name="137"/>  137: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="138"/>  138: 
<a name="suite-0"/><a name="139"/>  139: <b>suite</b>() -&gt;
<a name="suite-last_expr"/><a name="140"/>  140:     [{ct_hooks,[ts_install_cth]},
<a name="141"/>  141:      {timetrap,{minutes,30}}].
<a name="142"/>  142: 
<a name="all-0"/><a name="143"/>  143: <b>all</b>() -&gt;
<a name="all-last_expr"/><a name="144"/>  144:     [{group, new}, {group, insert}, {group, lookup},
<a name="145"/>  145:      {group, delete}, firstnext, firstnext_concurrent, slot, hash_clash,
<a name="146"/>  146:      {group, match}, t_match_spec_run,
<a name="147"/>  147:      {group, lookup_element}, {group, misc}, {group, files},
<a name="148"/>  148:      {group, heavy}, {group, insert_list}, ordered, ordered_match,
<a name="149"/>  149:      interface_equality, fixtable_next, fixtable_iter_bag, fixtable_insert,
<a name="150"/>  150:      rename, rename_unnamed, evil_rename, update_element,
<a name="151"/>  151:      update_counter, evil_update_counter,
<a name="152"/>  152:      update_counter_with_default,
<a name="153"/>  153:      update_counter_with_default_bad_pos,
<a name="154"/>  154:      partly_bound,
<a name="155"/>  155:      update_counter_table_growth,
<a name="156"/>  156:      match_heavy, {group, fold}, member, t_delete_object,
<a name="157"/>  157:      select_bound_chunk,
<a name="158"/>  158:      t_init_table, t_whitebox, t_delete_all_objects,
<a name="159"/>  159:      t_delete_all_objects_trap,
<a name="160"/>  160:      t_test_ms, t_select_delete, t_select_replace,
<a name="161"/>  161:      t_select_replace_next_bug,
<a name="162"/>  162:      t_select_pam_stack_overflow_bug,
<a name="163"/>  163:      t_select_flatmap_term_copy_bug,
<a name="164"/>  164:      t_select_hashmap_term_copy_bug,
<a name="165"/>  165:      t_ets_dets, memory, t_select_reverse, t_bucket_disappears,
<a name="166"/>  166:      t_named_select, select_fixtab_owner_change,
<a name="167"/>  167:      select_fail, t_insert_new, t_repair_continuation,
<a name="168"/>  168:      otp_5340, otp_6338, otp_6842_select_1000, otp_7665,
<a name="169"/>  169:      select_mbuf_trapping,
<a name="170"/>  170:      otp_8732, meta_wb, grow_shrink, grow_pseudo_deleted,
<a name="171"/>  171:      shrink_pseudo_deleted, {group, meta_smp}, smp_insert,
<a name="172"/>  172:      smp_fixed_delete, smp_unfix_fix, smp_select_replace,
<a name="173"/>  173:      smp_ordered_iteration,
<a name="174"/>  174:      smp_select_delete, otp_8166, exit_large_table_owner,
<a name="175"/>  175:      exit_many_large_table_owner, exit_many_tables_owner,
<a name="176"/>  176:      exit_many_many_tables_owner, write_concurrency, heir,
<a name="177"/>  177:      give_away, setopts, bad_table, types,
<a name="178"/>  178:      otp_10182,
<a name="179"/>  179:      otp_9932,
<a name="180"/>  180:      otp_9423,
<a name="181"/>  181:      compress_magic_ref,
<a name="182"/>  182:      ets_all,
<a name="183"/>  183:      massive_ets_all,
<a name="184"/>  184:      take,
<a name="185"/>  185:      whereis_table,
<a name="186"/>  186:      delete_unfix_race,
<a name="187"/>  187:      test_throughput_benchmark,
<a name="188"/>  188:      {group, benchmark},
<a name="189"/>  189:      test_table_size_concurrency,
<a name="190"/>  190:      test_table_memory_concurrency,
<a name="191"/>  191:      test_delete_table_while_size_snapshot,
<a name="192"/>  192:      test_decentralized_counters_setting,
<a name="193"/>  193:      ms_excessive_nesting,
<a name="194"/>  194:      error_info
<a name="195"/>  195:     ].
<a name="196"/>  196: 
<a name="197"/>  197: 
<a name="groups-0"/><a name="198"/>  198: <b>groups</b>() -&gt;
<a name="groups-last_expr"/><a name="199"/>  199:     [{new, [],
<a name="200"/>  200:       [default, setbag, badnew, verybadnew, named, keypos2,
<a name="201"/>  201:        privacy]},
<a name="202"/>  202:      {insert, [], [empty, badinsert]},
<a name="203"/>  203:      {lookup, [], [badlookup, lookup_order]},
<a name="204"/>  204:      {lookup_element, [], [lookup_element_mult, lookup_element_default]},
<a name="205"/>  205:      {delete, [],
<a name="206"/>  206:       [delete_elem, delete_tab, delete_large_tab,
<a name="207"/>  207:        delete_large_named_table, evil_delete, table_leak,
<a name="208"/>  208:        baddelete, match_delete, match_delete3]},
<a name="209"/>  209:      {match, [],
<a name="210"/>  210:       [match1, match2, match_object, match_object2]},
<a name="211"/>  211:      {misc, [],
<a name="212"/>  212:       [misc1, safe_fixtable, info, info_binary_stress, info_whereis_busy, dups, tab2list]},
<a name="213"/>  213:      {files, [],
<a name="214"/>  214:       [tab2file, tab2file2, tabfile_ext1,
<a name="215"/>  215:        tabfile_ext2, tabfile_ext3, tabfile_ext4, badfile]},
<a name="216"/>  216:      {heavy, [],
<a name="217"/>  217:       [heavy_lookup, heavy_lookup_element, heavy_concurrent]},
<a name="218"/>  218:      {fold, [],
<a name="219"/>  219:       [foldl_ordered, foldr_ordered, foldl, foldr,
<a name="220"/>  220:        fold_empty]},
<a name="221"/>  221:      {meta_smp, [],
<a name="222"/>  222:       [meta_lookup_unnamed_read, meta_lookup_unnamed_write,
<a name="223"/>  223:        meta_lookup_named_read, meta_lookup_named_write,
<a name="224"/>  224:        meta_newdel_unnamed, meta_newdel_named]},
<a name="225"/>  225:      {benchmark, [],
<a name="226"/>  226:       [long_throughput_benchmark]},
<a name="227"/>  227:      {insert_list, [],
<a name="228"/>  228:       [t_insert_list, t_insert_list_set, t_insert_list_bag,
<a name="229"/>  229:        t_insert_list_duplicate_bag, t_insert_list_delete_set,
<a name="230"/>  230:        t_insert_list_parallel, t_insert_list_delete_parallel,
<a name="231"/>  231:        t_insert_list_kill_process,
<a name="232"/>  232:        t_insert_list_insert_order_preserved,
<a name="233"/>  233:        insert_trap_delete,
<a name="234"/>  234:        insert_trap_rename]}].
<a name="235"/>  235: 
<a name="init_per_suite-1"/><a name="236"/>  236: <b>init_per_suite</b>(Config) -&gt;
<a name="237"/>  237:     erts_debug:set_internal_state(available_internal_state, true),
<a name="init_per_suite-last_expr"/><a name="238"/>  238: <b>    case erts_debug:set_internal_state</b>(ets_force_trap, true) of
<a name="239"/>  239:         ok -&gt;
<a name="240"/>  240:             [{ets_force_trap, true} | Config];
<a name="241"/>  241:         notsup -&gt;
<a name="242"/>  242:             Config
<a name="243"/>  243:     end.
<a name="244"/>  244: 
<a name="end_per_suite-1"/><a name="245"/>  245: <b>end_per_suite</b>(_Config) -&gt;
<a name="246"/>  246:     stop_spawn_logger(),
<a name="247"/>  247:     erts_debug:set_internal_state(ets_force_trap, false),
<a name="248"/>  248:     catch erts_debug:set_internal_state(available_internal_state, false),
<a name="end_per_suite-last_expr"/><a name="249"/>  249:     ok.
<a name="250"/>  250: 
<a name="init_per_group-2"/><a name="251"/>  251: <b>init_per_group</b>(benchmark, Config) -&gt;
<a name="252"/>  252:     P = self(),
<a name="253"/>  253:     %% Spawn owner of ETS table that is alive until end_per_group is run
<a name="254"/>  254:     EtsProcess =
<a name="255"/>  255:         spawn(
<a name="256"/>  256:           fun()-&gt;
<a name="257"/>  257:                   Tab = ets:new(ets_benchmark_result_summary_tab, [public]),
<a name="258"/>  258:                   P ! {the_table, Tab},
<a name="259"/>  259:                   receive
<a name="260"/>  260:                       kill -&gt; ok
<a name="261"/>  261:                   end
<a name="262"/>  262:           end),
<a name="263"/>  263:     Tab = receive {the_table, T} -&gt; T end,
<a name="264"/>  264:     CounterNames = [nr_of_benchmarks,
<a name="265"/>  265:                     total_throughput,
<a name="266"/>  266:                     nr_of_set_benchmarks,
<a name="267"/>  267:                     total_throughput_set,
<a name="268"/>  268:                     nr_of_ordered_set_benchmarks,
<a name="269"/>  269:                     total_throughput_ordered_set],
<a name="270"/>  270:     lists:foreach(fun(CtrName) -&gt;
<a name="271"/>  271:                           ets:insert(Tab, {CtrName, 0.0})
<a name="272"/>  272:                   end,
<a name="273"/>  273:                   CounterNames),
<a name="274"/>  274:     [{ets_benchmark_result_summary_tab, Tab},
<a name="275"/>  275:      {ets_benchmark_result_summary_tab_process, EtsProcess} | Config];
<a name="276"/>  276: <b>init_per_group</b>(_GroupName, Config) -&gt;
<a name="init_per_group-last_expr"/><a name="277"/>  277:     Config.
<a name="278"/>  278: 
<a name="end_per_group-2"/><a name="279"/>  279: <b>end_per_group</b>(benchmark, Config) -&gt;
<a name="280"/>  280:     T = proplists:get_value(ets_benchmark_result_summary_tab, Config),
<a name="281"/>  281:     EtsProcess = proplists:get_value(ets_benchmark_result_summary_tab_process, Config),
<a name="282"/>  282:     Report = 
<a name="283"/>  283:         fun(NOfBenchmarksCtr, TotThroughputCtr, Name) -&gt;
<a name="284"/>  284:                 Average =
<a name="285"/>  285:                     case {ets:lookup_element(T, TotThroughputCtr, 2),
<a name="286"/>  286:                           ets:lookup_element(T, NOfBenchmarksCtr, 2)} of
<a name="287"/>  287:                         {0.0, 0.0} -&gt;
<a name="288"/>  288:                             0;
<a name="289"/>  289:                         {TotThrp, NBench} -&gt;
<a name="290"/>  290:                             TotThrp / NBench
<a name="291"/>  291:                     end,
<a name="292"/>  292:                 io:format(&quot;~p ~p~n&quot;, [Name, Average]),
<a name="293"/>  293:                 ct_event:notify(
<a name="294"/>  294:                   #event{name = benchmark_data, 
<a name="295"/>  295:                          data = [{suite,&quot;ets_bench&quot;},
<a name="296"/>  296:                                  {name, Name},
<a name="297"/>  297:                                  {value, Average}]})
<a name="298"/>  298:         end,
<a name="299"/>  299:     Report(nr_of_benchmarks,
<a name="300"/>  300:            total_throughput,
<a name="301"/>  301:            &quot;Average Throughput&quot;),
<a name="302"/>  302:     Report(nr_of_set_benchmarks,
<a name="303"/>  303:            total_throughput_set,
<a name="304"/>  304:            &quot;Average Throughput Set&quot;),
<a name="305"/>  305:     Report(nr_of_ordered_set_benchmarks,
<a name="306"/>  306:            total_throughput_ordered_set,
<a name="307"/>  307:            &quot;Average Throughput Ordered Set&quot;),
<a name="308"/>  308:     ets:delete(T),
<a name="309"/>  309:     EtsProcess ! kill,
<a name="310"/>  310:     Config;
<a name="311"/>  311: <b>end_per_group</b>(_GroupName, Config) -&gt;
<a name="end_per_group-last_expr"/><a name="312"/>  312:     Config.
<a name="313"/>  313: 
<a name="314"/>  314: 
<a name="315"/>  315: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="316"/>  316: 
<a name="317"/>  317: <i>%% Test that a disappearing bucket during select of a non-fixed table works.</i>
<a name="t_bucket_disappears-1"/><a name="318"/>  318: <b>t_bucket_disappears</b>(Config) when is_list(Config) -&gt;
<a name="t_bucket_disappears-last_expr"/><a name="319"/>  319: <b>    repeat_for_opts</b>(fun t_bucket_disappears_do/1).
<a name="320"/>  320: 
<a name="t_bucket_disappears_do-1"/><a name="321"/>  321: <b>t_bucket_disappears_do</b>(Opts) -&gt;
<a name="322"/>  322:     EtsMem = etsmem(),
<a name="323"/>  323:     ets_new(abcd, [named_table, public, {keypos, 2} | Opts]),
<a name="324"/>  324:     ets:insert(abcd, {abcd,1,2}),
<a name="325"/>  325:     ets:insert(abcd, {abcd,2,2}),
<a name="326"/>  326:     ets:insert(abcd, {abcd,3,2}),
<a name="327"/>  327:     {_, Cont} = ets:select(abcd, [{{'_', '$1', '_'},
<a name="328"/>  328: 				   [{'&lt;', '$1', {const, 10}}],
<a name="329"/>  329: 				   ['$1']}], 1),
<a name="330"/>  330:     ets:delete(abcd, 2),
<a name="331"/>  331:     ets:select(Cont),
<a name="332"/>  332:     true = ets:delete(abcd),
<a name="t_bucket_disappears_do-last_expr"/><a name="333"/>  333: <b>    verify_etsmem</b>(EtsMem).
<a name="334"/>  334: 
<a name="335"/>  335: <i>%% OTP-21: Test that select/1 fails if named table was deleted and recreated</i>
<a name="336"/>  336: <i>%%         and succeeds if table was renamed.</i>
<a name="t_named_select-1"/><a name="337"/>  337: <b>t_named_select</b>(_Config) -&gt;
<a name="t_named_select-last_expr"/><a name="338"/>  338: <b>    repeat_for_opts</b>(fun t_named_select_do/1).
<a name="339"/>  339: 
<a name="t_named_select_do-1"/><a name="340"/>  340: <b>t_named_select_do</b>(Opts) -&gt;
<a name="341"/>  341:     EtsMem = etsmem(),
<a name="342"/>  342:     T = t_name_tid_select,
<a name="343"/>  343:     ets_new(T, [named_table | Opts]),
<a name="344"/>  344:     ets:insert(T, {1,11}),
<a name="345"/>  345:     ets:insert(T, {2,22}),
<a name="346"/>  346:     ets:insert(T, {3,33}),
<a name="347"/>  347:     MS = [{{'$1', 22}, [], ['$1']}],
<a name="348"/>  348:     {[2], Cont1} = ets:select(T, MS, 1),
<a name="349"/>  349:     ets:delete(T),
<a name="350"/>  350:     {'EXIT',{badarg,_}} = (catch ets:select(Cont1)),
<a name="351"/>  351:     ets_new(T, [named_table | Opts]),
<a name="352"/>  352:     {'EXIT',{badarg,_}} = (catch ets:select(Cont1)),
<a name="353"/>  353: 
<a name="354"/>  354:     true = ets:insert_new(T, {1,22}),
<a name="355"/>  355:     true = ets:insert_new(T, {2,22}),
<a name="356"/>  356:     true = ets:insert_new(T, {4,22}),
<a name="357"/>  357:     {[A,B], Cont2} = ets:select(T, MS, 2),
<a name="358"/>  358:     ets:rename(T, abcd),
<a name="359"/>  359:     {[C], '$end_of_table'} = ets:select(Cont2),
<a name="360"/>  360:     7 = A + B + C,
<a name="361"/>  361: 
<a name="362"/>  362:     true = ets:delete(abcd),
<a name="t_named_select_do-last_expr"/><a name="363"/>  363: <b>    verify_etsmem</b>(EtsMem).
<a name="364"/>  364: 
<a name="365"/>  365: 
<a name="366"/>  366: <i>%% Verify select and friends release fixtab as they should</i>
<a name="367"/>  367: <i>%% even when owneship is changed between traps.</i>
<a name="select_fixtab_owner_change-1"/><a name="368"/>  368: <b>select_fixtab_owner_change</b>(_Config) -&gt;
<a name="369"/>  369:     T = ets:new(xxx, [protected]),
<a name="370"/>  370:     NKeys = 2000,
<a name="371"/>  371:     [ets:insert(T,{K,K band 7}) || K &lt;- lists:seq(1,NKeys)],
<a name="372"/>  372: 
<a name="373"/>  373:     %% Buddy and Papa will ping-pong table ownership between them
<a name="374"/>  374:     %% and the aim is to give Buddy the table when he is
<a name="375"/>  375:     %% in the middle of a yielding select* call.
<a name="376"/>  376:     {Buddy,_} = spawn_opt(fun() -&gt; sfoc_buddy_loop(T, 1, undefined) end,
<a name="377"/>  377:                           [link,monitor]),
<a name="378"/>  378: 
<a name="379"/>  379:     sfoc_papa_loop(T, Buddy),
<a name="380"/>  380: 
<a name="381"/>  381:     receive {'DOWN', _, process, Buddy, _} -&gt; ok end,
<a name="382"/>  382:     ets:delete(T),
<a name="select_fixtab_owner_change-last_expr"/><a name="383"/>  383:     ok.
<a name="384"/>  384: 
<a name="sfoc_buddy_loop-3"/><a name="385"/>  385: <b>sfoc_buddy_loop</b>(T, I, State0) -&gt;
<a name="sfoc_buddy_loop-last_expr"/><a name="386"/>  386:     receive
<a name="387"/>  387:         {'ETS-TRANSFER', T, Papa, _} -&gt;
<a name="388"/>  388:             ets:give_away(T, Papa, State0),
<a name="389"/>  389:             case State0 of
<a name="390"/>  390:                 done -&gt;
<a name="391"/>  391:                     ok;
<a name="392"/>  392:                 _ -&gt;
<a name="393"/>  393:                     State1 = sfoc_traverse(T, I, State0),
<a name="394"/>  394:                     %% Verify no fixation left
<a name="395"/>  395:                     {I, false} = {I, ets:info(T, safe_fixed_monotonic_time)},
<a name="396"/>  396:                     sfoc_buddy_loop(T, I+1, State1)
<a name="397"/>  397:             end
<a name="398"/>  398:     end.
<a name="399"/>  399: 
<a name="sfoc_papa_loop-2"/><a name="400"/>  400: <b>sfoc_papa_loop</b>(T, Buddy) -&gt;
<a name="401"/>  401:     ets:give_away(T, Buddy, &quot;Catch!&quot;),
<a name="sfoc_papa_loop-last_expr"/><a name="402"/>  402:     receive
<a name="403"/>  403:         {'ETS-TRANSFER', T, Buddy, State} -&gt;
<a name="404"/>  404:             case State of
<a name="405"/>  405:                 done -&gt;
<a name="406"/>  406:                     ok;
<a name="407"/>  407:                 _ -&gt;
<a name="408"/>  408:                     sfoc_papa_loop(T, Buddy)
<a name="409"/>  409:             end
<a name="410"/>  410:     end.
<a name="411"/>  411: 
<a name="sfoc_traverse-3"/><a name="412"/>  412: <b>sfoc_traverse</b>(T, 1, S) -&gt;
<a name="413"/>  413:     ets:select(T, [{{'$1',7}, [], ['$1']}]), S;
<a name="414"/>  414: <b>sfoc_traverse</b>(T, 2, S) -&gt;
<a name="415"/>  415:     0 = ets:select_count(T, [{{'$1',7}, [], [false]}]), S;
<a name="416"/>  416: <b>sfoc_traverse</b>(T, 3, _) -&gt;
<a name="417"/>  417:     Limit = ets:info(T, size) div 2,
<a name="418"/>  418:     {_, Continuation} = ets:select(T, [{{'$1',7}, [], ['$1']}],
<a name="419"/>  419:                                    Limit),
<a name="420"/>  420:     Continuation;
<a name="421"/>  421: <b>sfoc_traverse</b>(_T, 4, Continuation) -&gt;
<a name="422"/>  422:     _ = ets:select(Continuation),
<a name="sfoc_traverse-last_expr"/><a name="423"/>  423:     done.
<a name="424"/>  424: 
<a name="425"/>  425: <i>%% Check ets:match_spec_run/2.</i>
<a name="t_match_spec_run-1"/><a name="426"/>  426: <b>t_match_spec_run</b>(Config) when is_list(Config) -&gt;
<a name="427"/>  427:     ct:timetrap({minutes,30}), %% valgrind needs a lot
<a name="428"/>  428:     init_externals(),
<a name="429"/>  429:     EtsMem = etsmem(),
<a name="430"/>  430: 
<a name="431"/>  431:     t_match_spec_run_test([{1},{2},{3}],
<a name="432"/>  432: 			  [{{'$1'},[{'&gt;','$1',1}],['$1']}],
<a name="433"/>  433: 			  [2,3]),
<a name="434"/>  434: 
<a name="435"/>  435:     Huge = [{X} || X &lt;- lists:seq(1,2500)],
<a name="436"/>  436:     L = lists:seq(2476,2500),
<a name="437"/>  437:     t_match_spec_run_test(Huge, [{{'$1'},[{'&gt;','$1',2475}],['$1']}], L),
<a name="438"/>  438: 
<a name="439"/>  439:     L2 = [{X*16#FFFFFFF} || X &lt;- L],
<a name="440"/>  440:     t_match_spec_run_test(Huge,
<a name="441"/>  441: 			  [{{'$1'}, [{'&gt;','$1',2475}], [{{{'*','$1',16#FFFFFFF}}}]}],
<a name="442"/>  442: 			  L2),
<a name="443"/>  443: 
<a name="444"/>  444:     t_match_spec_run_test(Huge, [{{'$1'}, [{'=:=',{'rem','$1',500},0}], ['$1']}],
<a name="445"/>  445: 			  [500,1000,1500,2000,2500]),
<a name="446"/>  446: 
<a name="447"/>  447:     %% More matching fun with several match clauses and guards,
<a name="448"/>  448:     %% applied to a variety of terms.
<a name="449"/>  449:     Fun = fun(Term) -&gt;
<a name="450"/>  450: 		  CTerm = {const, Term},
<a name="451"/>  451: 
<a name="452"/>  452: 		  N_List = [{Term, &quot;0&quot;, &quot;v-element&quot;},
<a name="453"/>  453: 			    {&quot;=hidden_node&quot;, &quot;0&quot;, Term},
<a name="454"/>  454: 			    {&quot;0&quot;, Term, Term},
<a name="455"/>  455: 			    {&quot;something&quot;, Term, &quot;something else&quot;},
<a name="456"/>  456: 			    {&quot;guard and res&quot;, Term, 872346},
<a name="457"/>  457: 			    {Term, {'and',Term,'again'}, 3.14},
<a name="458"/>  458: 			    {Term, {'and',Term,'again'}, &quot;m&amp;g&quot;},
<a name="459"/>  459: 			    {Term, {'and',Term,'again'}, &quot;m&amp;g&amp;r&quot;},
<a name="460"/>  460: 			    {[{second,Term}, 'and', &quot;tail&quot;], Term, ['and',&quot;tail&quot;]}],
<a name="461"/>  461: 
<a name="462"/>  462: 		  N_MS = [{{'$1','$2','$3'},
<a name="463"/>  463: 			   [{'=:=','$1',CTerm}, {'=:=','$2',{const,&quot;0&quot;}}],
<a name="464"/>  464: 			   [{{&quot;Guard only for $1&quot;,'$3'}}]},
<a name="465"/>  465: 
<a name="466"/>  466: 			  {{'$3','$1','$4'},
<a name="467"/>  467: 			   [{'=:=','$3',&quot;=hidden_node&quot;}, {'=:=','$1',{const,&quot;0&quot;}}],
<a name="468"/>  468: 			   [{{&quot;Result only for $4&quot;,'$4'}}]},
<a name="469"/>  469: 
<a name="470"/>  470: 			  {{'$2','$1','$1'},
<a name="471"/>  471: 			   [{'=:=','$2',{const,&quot;0&quot;}}],
<a name="472"/>  472: 			   [{{&quot;Match only for $1&quot;,'$2'}}]},
<a name="473"/>  473: 
<a name="474"/>  474: 			  {{'$2',Term,['$3'|'_']},
<a name="475"/>  475: 			   [{is_list,'$2'},{'=:=','$3',$s}],
<a name="476"/>  476: 			   [{{&quot;Matching term&quot;,'$2'}}]},
<a name="477"/>  477: 
<a name="478"/>  478: 			  {{'$1','$2',872346},
<a name="479"/>  479: 			   [{'=:=','$2',CTerm}, {is_list,'$1'}],
<a name="480"/>  480: 			   [{{&quot;Guard and result&quot;,'$2'}}]},
<a name="481"/>  481: 
<a name="482"/>  482: 			  {{'$1', {'and','$1','again'}, '$2'},
<a name="483"/>  483: 			   [{is_float,'$2'}],
<a name="484"/>  484: 			   [{{&quot;Match and result&quot;,'$1'}}]},
<a name="485"/>  485: 
<a name="486"/>  486: 			  {{'$1', {'and','$1','again'}, '$2'},
<a name="487"/>  487: 			   [{'=:=','$1',CTerm}, {'=:=', '$2', &quot;m&amp;g&quot;}],
<a name="488"/>  488: 			   [{{&quot;Match and guard&quot;,'$2'}}]},
<a name="489"/>  489: 
<a name="490"/>  490: 			  {{'$1', {'and','$1','again'}, &quot;m&amp;g&amp;r&quot;},
<a name="491"/>  491: 			   [{'=:=','$1',CTerm}],
<a name="492"/>  492: 			   [{{&quot;Match, guard and result&quot;,'$1'}}]},
<a name="493"/>  493: 
<a name="494"/>  494: 			  {{'$1', '$2', '$3'},
<a name="495"/>  495: 			   [{'=:=','$1',[{{second,'$2'}} | '$3']}],
<a name="496"/>  496: 			   [{{&quot;Building guard&quot;}}]}
<a name="497"/>  497: 			 ],
<a name="498"/>  498: 
<a name="499"/>  499: 		  N_Result = [{&quot;Guard only for $1&quot;, &quot;v-element&quot;},
<a name="500"/>  500: 			      {&quot;Result only for $4&quot;, Term},
<a name="501"/>  501: 			      {&quot;Match only for $1&quot;, &quot;0&quot;},
<a name="502"/>  502: 			      {&quot;Matching term&quot;,&quot;something&quot;},
<a name="503"/>  503: 			      {&quot;Guard and result&quot;,Term},
<a name="504"/>  504: 			      {&quot;Match and result&quot;,Term},
<a name="505"/>  505: 			      {&quot;Match and guard&quot;,&quot;m&amp;g&quot;},
<a name="506"/>  506: 			      {&quot;Match, guard and result&quot;,Term},
<a name="507"/>  507: 			      {&quot;Building guard&quot;}],
<a name="508"/>  508: 
<a name="509"/>  509: 		  F = fun(N_MS_Perm) -&gt;
<a name="510"/>  510: 			      t_match_spec_run_test(N_List, N_MS_Perm, N_Result)
<a name="511"/>  511: 		      end,
<a name="512"/>  512: 		  repeat_for_permutations(F, N_MS)
<a name="513"/>  513: 	  end,
<a name="514"/>  514:     test_terms(Fun, skip_refc_check),
<a name="515"/>  515: 
<a name="t_match_spec_run-last_expr"/><a name="516"/>  516: <b>    verify_etsmem</b>(EtsMem).
<a name="517"/>  517: 
<a name="t_match_spec_run_test-3"/><a name="518"/>  518: <b>t_match_spec_run_test</b>(List, MS, Result) -&gt;
<a name="519"/>  519: 
<a name="520"/>  520:     %%io:format(&quot;ms = ~p\n&quot;,[MS]),
<a name="521"/>  521: 
<a name="522"/>  522:     ?m(Result, ets:match_spec_run(List, ets:match_spec_compile(MS))),
<a name="523"/>  523: 
<a name="524"/>  524:     %% Check that ets:select agree
<a name="525"/>  525:     Tab = ets:new(xxx, [bag]),
<a name="526"/>  526:     ets:insert(Tab, List),
<a name="527"/>  527:     SRes = lists:sort(Result),
<a name="528"/>  528:     ?m(SRes, lists:sort(ets:select(Tab, MS))),
<a name="529"/>  529:     ets:delete(Tab),
<a name="530"/>  530: 
<a name="531"/>  531:     %% Check that tracing agree
<a name="532"/>  532:     Self = self(),
<a name="533"/>  533:     {Tracee, MonRef} = my_spawn_monitor(fun() -&gt; ms_tracee(Self, List) end),
<a name="534"/>  534:     receive {Tracee, ready} -&gt; ok end,
<a name="535"/>  535: 
<a name="536"/>  536:     MST = lists:map(fun(Clause) -&gt; ms_clause_ets_to_trace(Clause) end, MS),
<a name="537"/>  537: 
<a name="538"/>  538:     %%io:format(&quot;MS = ~p\nMST= ~p\n&quot;,[MS,MST]),
<a name="539"/>  539: 
<a name="540"/>  540:     erlang:trace_pattern({?MODULE,ms_tracee_dummy,'_'}, MST , [local]),
<a name="541"/>  541:     erlang:trace(Tracee, true, [call]),
<a name="542"/>  542:     Tracee ! start,
<a name="543"/>  543:     TRes = ms_tracer_collect(Tracee, MonRef, []),
<a name="544"/>  544:     case TRes of
<a name="545"/>  545: 	SRes -&gt; ok;
<a name="546"/>  546: 	_ -&gt;
<a name="547"/>  547: 	    io:format(&quot;TRACE MATCH FAILED\n&quot;),
<a name="548"/>  548: 	    io:format(&quot;Input = ~p\nMST = ~p\nExpected = ~p\nGot = ~p\n&quot;, [List, MST, SRes, TRes]),
<a name="549"/>  549: 	    ct:fail(&quot;TRACE MATCH FAILED&quot;)
<a name="550"/>  550:     end,
<a name="t_match_spec_run_test-last_expr"/><a name="551"/>  551:     ok.
<a name="552"/>  552: 
<a name="553"/>  553: 
<a name="554"/>  554: 
<a name="ms_tracer_collect-3"/><a name="555"/>  555: <b>ms_tracer_collect</b>(Tracee, Ref, Acc) -&gt;
<a name="ms_tracer_collect-last_expr"/><a name="556"/>  556:     receive
<a name="557"/>  557: 	{trace, Tracee, call, _Args, [Msg]} -&gt;
<a name="558"/>  558: 	    ms_tracer_collect(Tracee, Ref, [Msg | Acc]);
<a name="559"/>  559: 
<a name="560"/>  560: 	{'DOWN', Ref, process, Tracee, _} -&gt;
<a name="561"/>  561: 	    TDRef = erlang:trace_delivered(Tracee),
<a name="562"/>  562: 	    ms_tracer_collect(Tracee, TDRef, Acc);
<a name="563"/>  563: 
<a name="564"/>  564: 	{trace_delivered, Tracee, Ref} -&gt;
<a name="565"/>  565: 	    lists:sort(Acc);
<a name="566"/>  566: 
<a name="567"/>  567: 	Other -&gt;
<a name="568"/>  568: 	    io:format(&quot;Unexpected message = ~p\n&quot;, [Other]),
<a name="569"/>  569: 	    ct:fail(&quot;Unexpected tracer msg&quot;)
<a name="570"/>  570:     end.
<a name="571"/>  571: 
<a name="572"/>  572: 
<a name="ms_tracee-2"/><a name="573"/>  573: <b>ms_tracee</b>(Parent, CallArgList) -&gt;
<a name="574"/>  574:     Parent ! {self(), ready},
<a name="575"/>  575:     receive start -&gt; ok end,
<a name="576"/>  576:     F = fun({A1}) -&gt;
<a name="577"/>  577:                 ms_tracee_dummy(A1);
<a name="578"/>  578:            ({A1,A2}) -&gt;
<a name="579"/>  579:                    ms_tracee_dummy(A1, A2);
<a name="580"/>  580:            ({A1,A2,A3}) -&gt;
<a name="581"/>  581:                 ms_tracee_dummy(A1, A2, A3);
<a name="582"/>  582:            ({A1,A2,A3,A4}) -&gt;
<a name="583"/>  583:                 ms_tracee_dummy(A1, A2, A3, A4)
<a name="584"/>  584:         end,
<a name="ms_tracee-last_expr"/><a name="585"/>  585: <b>    lists:foreach</b>(F, CallArgList).
<a name="586"/>  586: 
<a name="ms_tracee_dummy-1"/><a name="ms_tracee_dummy-last_expr"/><a name="587"/>  587: <b>ms_tracee_dummy</b>(_) -&gt; ok.
<a name="ms_tracee_dummy-2"/><a name="ms_tracee_dummy-last_expr"/><a name="588"/>  588: <b>ms_tracee_dummy</b>(_,_) -&gt; ok.
<a name="ms_tracee_dummy-3"/><a name="ms_tracee_dummy-last_expr"/><a name="589"/>  589: <b>ms_tracee_dummy</b>(_,_,_) -&gt; ok.
<a name="ms_tracee_dummy-4"/><a name="ms_tracee_dummy-last_expr"/><a name="590"/>  590: <b>ms_tracee_dummy</b>(_,_,_,_) -&gt; ok.
<a name="591"/>  591: 
<a name="ms_clause_ets_to_trace-1"/><a name="592"/>  592: <b>ms_clause_ets_to_trace</b>({Head, Guard, Body}) -&gt;
<a name="ms_clause_ets_to_trace-last_expr"/><a name="593"/>  593: <b>    {tuple_to_list</b>(Head), Guard, [{message, Body}]}.
<a name="594"/>  594: 
<a name="assert_eq-2"/><a name="595"/>  595: <b>assert_eq</b>(A,A) -&gt; ok;
<a name="596"/>  596: <b>assert_eq</b>(A,B) -&gt;
<a name="597"/>  597:     io:format(&quot;FAILED MATCH:\n~p\n =/=\n~p\n&quot;,[A,B]),
<a name="assert_eq-last_expr"/><a name="598"/>  598: <b>    ct:fail</b>(&quot;assert_eq failed&quot;).
<a name="599"/>  599: 
<a name="600"/>  600: 
<a name="601"/>  601: <i>%% Test ets:repair_continuation/2.</i>
<a name="t_repair_continuation-1"/><a name="602"/>  602: <b>t_repair_continuation</b>(Config) when is_list(Config) -&gt;
<a name="t_repair_continuation-last_expr"/><a name="603"/>  603: <b>    repeat_for_opts</b>(fun t_repair_continuation_do/1).
<a name="604"/>  604: 
<a name="605"/>  605: 
<a name="t_repair_continuation_do-1"/><a name="606"/>  606: <b>t_repair_continuation_do</b>(OptsIn) -&gt;
<a name="607"/>  607:     EtsMem = etsmem(),
<a name="608"/>  608:     MS = [{'_',[],[true]}],
<a name="609"/>  609:     MS2 = [{{{'$1','_'},'_'},[],['$1']}],
<a name="610"/>  610:     run_if_valid_opts(
<a name="611"/>  611:       [ordered_set|OptsIn],
<a name="612"/>  612:       fun(Opts) -&gt;
<a name="613"/>  613: 	     T = ets_new(x, Opts),
<a name="614"/>  614: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt; ets:insert(T,{N,N}), F(N-1,F) end,
<a name="615"/>  615: 	     F(1000,F),
<a name="616"/>  616: 	     {_,C} = ets:select(T,MS,5),
<a name="617"/>  617: 	     C2 = erlang:setelement(5,C,&lt;&lt;&gt;&gt;),
<a name="618"/>  618: 	     {'EXIT',{badarg,_}} = (catch ets:select(C2)),
<a name="619"/>  619: 	     C3 = ets:repair_continuation(C2,MS),
<a name="620"/>  620: 	     {[true,true,true,true,true],_} = ets:select(C3),
<a name="621"/>  621: 	     {[true,true,true,true,true],_} = ets:select(C),
<a name="622"/>  622: 	     true = ets:delete(T)
<a name="623"/>  623:       end),
<a name="624"/>  624:     run_if_valid_opts(
<a name="625"/>  625:       [ordered_set|OptsIn],
<a name="626"/>  626:       fun(Opts) -&gt;
<a name="627"/>  627: 	     T = ets_new(x, Opts),
<a name="628"/>  628: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt; ets:insert(T,{N,N}), F(N-1,F) end,
<a name="629"/>  629: 	     F(1000,F),
<a name="630"/>  630: 	     {_,C} = ets:select(T,MS,1001),
<a name="631"/>  631: 	     C = '$end_of_table',
<a name="632"/>  632: 	     C3 = ets:repair_continuation(C,MS),
<a name="633"/>  633: 	     '$end_of_table' = ets:select(C3),
<a name="634"/>  634: 	     '$end_of_table' = ets:select(C),
<a name="635"/>  635: 	     true = ets:delete(T)
<a name="636"/>  636:       end),
<a name="637"/>  637: 
<a name="638"/>  638:     run_if_valid_opts(
<a name="639"/>  639:       [ordered_set|OptsIn],
<a name="640"/>  640:       fun(Opts) -&gt;
<a name="641"/>  641: 	     T = ets_new(x, Opts),
<a name="642"/>  642: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt;
<a name="643"/>  643: 			 ets:insert(T,{integer_to_list(N),N}),
<a name="644"/>  644: 			 F(N-1,F)
<a name="645"/>  645: 		 end,
<a name="646"/>  646: 	     F(1000,F),
<a name="647"/>  647: 	     {_,C} = ets:select(T,MS,5),
<a name="648"/>  648: 	     C2 = erlang:setelement(5,C,&lt;&lt;&gt;&gt;),
<a name="649"/>  649: 	     {'EXIT',{badarg,_}} = (catch ets:select(C2)),
<a name="650"/>  650: 	     C3 = ets:repair_continuation(C2,MS),
<a name="651"/>  651: 	     {[true,true,true,true,true],_} = ets:select(C3),
<a name="652"/>  652: 	     {[true,true,true,true,true],_} = ets:select(C),
<a name="653"/>  653: 	     true = ets:delete(T)
<a name="654"/>  654:       end),
<a name="655"/>  655:     run_if_valid_opts(
<a name="656"/>  656:       [ordered_set|OptsIn],
<a name="657"/>  657:       fun(Opts) -&gt;
<a name="658"/>  658: 	     T = ets_new(x, Opts),
<a name="659"/>  659: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt;
<a name="660"/>  660: 			 ets:insert(T,{{integer_to_list(N),N},N}),
<a name="661"/>  661: 			 F(N-1,F)
<a name="662"/>  662: 		 end,
<a name="663"/>  663: 	     F(1000,F),
<a name="664"/>  664: 	     {_,C} = ets:select(T,MS2,5),
<a name="665"/>  665: 	     C2 = erlang:setelement(5,C,&lt;&lt;&gt;&gt;),
<a name="666"/>  666: 	     {'EXIT',{badarg,_}} = (catch ets:select(C2)),
<a name="667"/>  667: 	     C3 = ets:repair_continuation(C2,MS2),
<a name="668"/>  668: 	     {[_,_,_,_,_],_} = ets:select(C3),
<a name="669"/>  669: 	     {[_,_,_,_,_],_} = ets:select(C),
<a name="670"/>  670: 	     true = ets:delete(T)
<a name="671"/>  671:       end),
<a name="672"/>  672: 
<a name="673"/>  673:     (fun() -&gt;
<a name="674"/>  674: 	     T = ets_new(x,[set|OptsIn]),
<a name="675"/>  675: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt;
<a name="676"/>  676: 			 ets:insert(T,{N,N}),
<a name="677"/>  677: 			 F(N-1,F)
<a name="678"/>  678: 		 end,
<a name="679"/>  679: 	     F(1000,F),
<a name="680"/>  680: 	     {_,C} = ets:select(T,MS,5),
<a name="681"/>  681: 	     C2 = erlang:setelement(4,C,&lt;&lt;&gt;&gt;),
<a name="682"/>  682: 	     {'EXIT',{badarg,_}} = (catch ets:select(C2)),
<a name="683"/>  683: 	     C3 = ets:repair_continuation(C2,MS),
<a name="684"/>  684: 	     {[true,true,true,true,true],_} = ets:select(C3),
<a name="685"/>  685: 	     {[true,true,true,true,true],_} = ets:select(C),
<a name="686"/>  686: 	     true = ets:delete(T)
<a name="687"/>  687:      end)(),
<a name="688"/>  688:     (fun() -&gt;
<a name="689"/>  689: 	     T = ets_new(x,[set|OptsIn]),
<a name="690"/>  690: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt;
<a name="691"/>  691: 			 ets:insert(T,{integer_to_list(N),N}),
<a name="692"/>  692: 			 F(N-1,F)
<a name="693"/>  693: 		 end,
<a name="694"/>  694: 	     F(1000,F),
<a name="695"/>  695: 	     {_,C} = ets:select(T,MS,5),
<a name="696"/>  696: 	     C2 = erlang:setelement(4,C,&lt;&lt;&gt;&gt;),
<a name="697"/>  697: 	     {'EXIT',{badarg,_}} = (catch ets:select(C2)),
<a name="698"/>  698: 	     C3 = ets:repair_continuation(C2,MS),
<a name="699"/>  699: 	     {[true,true,true,true,true],_} = ets:select(C3),
<a name="700"/>  700: 	     {[true,true,true,true,true],_} = ets:select(C),
<a name="701"/>  701: 	     true = ets:delete(T)
<a name="702"/>  702:      end)(),
<a name="703"/>  703:     (fun() -&gt;
<a name="704"/>  704: 	     T = ets_new(x,[bag|OptsIn]),
<a name="705"/>  705: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt;
<a name="706"/>  706: 			 ets:insert(T,{integer_to_list(N),N}),
<a name="707"/>  707: 			 F(N-1,F)
<a name="708"/>  708: 		 end,
<a name="709"/>  709: 	     F(1000,F),
<a name="710"/>  710: 	     {_,C} = ets:select(T,MS,5),
<a name="711"/>  711: 	     C2 = erlang:setelement(4,C,&lt;&lt;&gt;&gt;),
<a name="712"/>  712: 	     {'EXIT',{badarg,_}} = (catch ets:select(C2)),
<a name="713"/>  713: 	     C3 = ets:repair_continuation(C2,MS),
<a name="714"/>  714: 	     {[true,true,true,true,true],_} = ets:select(C3),
<a name="715"/>  715: 	     {[true,true,true,true,true],_} = ets:select(C),
<a name="716"/>  716: 	     true = ets:delete(T)
<a name="717"/>  717:      end)(),
<a name="718"/>  718:     (fun() -&gt;
<a name="719"/>  719: 	     T = ets_new(x,[duplicate_bag|OptsIn]),
<a name="720"/>  720: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt;
<a name="721"/>  721: 			 ets:insert(T,{integer_to_list(N),N}),
<a name="722"/>  722: 			 F(N-1,F)
<a name="723"/>  723: 		 end,
<a name="724"/>  724: 	     F(1000,F),
<a name="725"/>  725: 	     {_,C} = ets:select(T,MS,5),
<a name="726"/>  726: 	     C2 = erlang:setelement(4,C,&lt;&lt;&gt;&gt;),
<a name="727"/>  727: 	     {'EXIT',{badarg,_}} = (catch ets:select(C2)),
<a name="728"/>  728: 	     C3 = ets:repair_continuation(C2,MS),
<a name="729"/>  729: 	     {[true,true,true,true,true],_} = ets:select(C3),
<a name="730"/>  730: 	     {[true,true,true,true,true],_} = ets:select(C),
<a name="731"/>  731: 	     true = ets:delete(T)
<a name="732"/>  732:      end)(),
<a name="733"/>  733:     false = ets:is_compiled_ms(&lt;&lt;&gt;&gt;),
<a name="734"/>  734:     true = ets:is_compiled_ms(ets:match_spec_compile(MS)),
<a name="t_repair_continuation_do-last_expr"/><a name="735"/>  735: <b>    verify_etsmem</b>(EtsMem).
<a name="736"/>  736: 
<a name="737"/>  737: 
<a name="738"/>  738: <i>%% Test correct default vaules of a new ets table.</i>
<a name="default-1"/><a name="739"/>  739: <b>default</b>(Config) when is_list(Config) -&gt;
<a name="740"/>  740:     %% Default should be set,protected
<a name="741"/>  741:     EtsMem = etsmem(),
<a name="742"/>  742:     Def = ets_new(def,[]),
<a name="743"/>  743:     set = ets:info(Def,type),
<a name="744"/>  744:     protected = ets:info(Def,protection),
<a name="745"/>  745:     Compressed = erlang:system_info(ets_always_compress),
<a name="746"/>  746:     Compressed = ets:info(Def,compressed),
<a name="747"/>  747:     Self = self(),
<a name="748"/>  748:     Self = ets:info(Def,owner),
<a name="749"/>  749:     none = ets:info(Def, heir),
<a name="750"/>  750:     false = ets:info(Def,named_table),
<a name="751"/>  751:     ets:delete(Def),
<a name="default-last_expr"/><a name="752"/>  752: <b>    verify_etsmem</b>(EtsMem).
<a name="753"/>  753: 
<a name="754"/>  754: <i>%% Test that select fails even if nothing can match.</i>
<a name="select_fail-1"/><a name="755"/>  755: <b>select_fail</b>(Config) when is_list(Config) -&gt;
<a name="756"/>  756:     EtsMem = etsmem(),
<a name="757"/>  757:     repeat_for_opts(fun select_fail_do/1,
<a name="758"/>  758:                     [all_types,write_concurrency]),
<a name="select_fail-last_expr"/><a name="759"/>  759: <b>    verify_etsmem</b>(EtsMem).
<a name="760"/>  760: 
<a name="select_fail_do-1"/><a name="761"/>  761: <b>select_fail_do</b>(Opts) -&gt;
<a name="762"/>  762:     T = ets_new(x,Opts),
<a name="763"/>  763:     ets:insert(T,{a,a}),
<a name="764"/>  764:     case (catch
<a name="765"/>  765: 	      ets:select(T,[{{a,'_'},[],[{snuffla}]}])) of
<a name="766"/>  766: 	{'EXIT',{badarg,_}} -&gt;
<a name="767"/>  767: 	    ok;
<a name="768"/>  768: 	Else0 -&gt;
<a name="769"/>  769: 	    exit({type,ets:info(T,type),
<a name="770"/>  770: 		  expected,'EXIT',got,Else0})
<a name="771"/>  771:     end,
<a name="772"/>  772:     case (catch
<a name="773"/>  773: 	      ets:select(T,[{{b,'_'},[],[{snuffla}]}])) of
<a name="774"/>  774: 	{'EXIT',{badarg,_}} -&gt;
<a name="775"/>  775: 	    ok;
<a name="776"/>  776: 	Else1 -&gt;
<a name="777"/>  777: 	    exit({type,ets:info(T,type),
<a name="778"/>  778: 		  expected,'EXIT',got,Else1})
<a name="779"/>  779:     end,
<a name="select_fail_do-last_expr"/><a name="780"/>  780: <b>    ets:delete</b>(T).
<a name="781"/>  781: 
<a name="782"/>  782: 
<a name="783"/>  783: <b>-define</b>(S(T),ets:info(T,memory)).
<a name="784"/>  784: 
<a name="785"/>  785: <i>%% Whitebox test of ets:info(X, memory).</i>
<a name="memory-1"/><a name="786"/>  786: <b>memory</b>(Config) when is_list(Config) -&gt;
<a name="787"/>  787:     ok = chk_normal_tab_struct_size(),
<a name="788"/>  788:     repeat_for_opts(fun memory_do/1, [compressed]),
<a name="memory-last_expr"/><a name="789"/>  789: <b>    catch erts_debug:set_internal_state</b>(available_internal_state, false).
<a name="790"/>  790: 
<a name="memory_do-1"/><a name="791"/>  791: <b>memory_do</b>(Opts) -&gt;
<a name="792"/>  792:     L = [T1,T2,T3,T4] = fill_sets_int(1000,Opts),
<a name="793"/>  793:     XR1 = case mem_mode(T1) of
<a name="794"/>  794: 	      {normal,_} -&gt;     {13836, 15346, 15346, 15346+6};
<a name="795"/>  795: 	      {compressed,4} -&gt; {11041, 12551, 12551, 12551+1};
<a name="796"/>  796: 	      {compressed,8} -&gt; {10050, 11560, 11560, 11560}
<a name="797"/>  797: 	  end,
<a name="798"/>  798:     XRes1 = adjust_xmem(L, XR1, 1),
<a name="799"/>  799:     Res1 = {?S(T1),?S(T2),?S(T3),?S(T4)},
<a name="800"/>  800:     lists:foreach(fun(T) -&gt;
<a name="801"/>  801: 			  Before = ets:info(T,size),
<a name="802"/>  802: 			  Key = 2, %894, %%ets:first(T),
<a name="803"/>  803: 			  Objs = ets:lookup(T,Key),
<a name="804"/>  804: 			  ets:delete(T,Key),
<a name="805"/>  805: 			  io:format(&quot;deleted key ~p from ~p changed size ~p to ~p: ~p\n&quot;,
<a name="806"/>  806: 				    [Key, ets:info(T,type), Before, ets:info(T,size), Objs])
<a name="807"/>  807: 		  end,
<a name="808"/>  808: 		  L),
<a name="809"/>  809:     XR2 = case mem_mode(T1) of
<a name="810"/>  810: 	      {normal,_} -&gt;     {13826, 15337, 15337-9, 15337-3};
<a name="811"/>  811: 	      {compressed,4} -&gt; {11031, 12542, 12542-9, 12542-8};
<a name="812"/>  812: 	      {compressed,8} -&gt; {10040, 11551, 11551-9, 11551-9}
<a name="813"/>  813: 	  end,
<a name="814"/>  814:     XRes2 = adjust_xmem(L, XR2, 1),
<a name="815"/>  815:     Res2 = {?S(T1),?S(T2),?S(T3),?S(T4)},
<a name="816"/>  816:     lists:foreach(fun(T) -&gt;
<a name="817"/>  817: 			  Before = ets:info(T,size),
<a name="818"/>  818: 			  Key = 4, %802, %ets:first(T),
<a name="819"/>  819: 			  Objs = ets:lookup(T,Key),
<a name="820"/>  820: 			  ets:match_delete(T,{Key,'_'}),
<a name="821"/>  821: 			  io:format(&quot;match_deleted key ~p from ~p changed size ~p to ~p: ~p\n&quot;,
<a name="822"/>  822: 				    [Key, ets:info(T,type), Before, ets:info(T,size), Objs])
<a name="823"/>  823: 		  end,
<a name="824"/>  824: 		  L),
<a name="825"/>  825:     XR3 = case mem_mode(T1) of
<a name="826"/>  826: 	      {normal,_} -&gt;     {13816, 15328, 15328-18, 15328-12};
<a name="827"/>  827: 	      {compressed,4} -&gt; {11021, 12533, 12533-18, 12533-17};
<a name="828"/>  828: 	      {compressed,8} -&gt; {10030, 11542, 11542-18, 11542-18}
<a name="829"/>  829: 	  end,
<a name="830"/>  830:     XRes3 = adjust_xmem(L, XR3, 1),
<a name="831"/>  831:     Res3 = {?S(T1),?S(T2),?S(T3),?S(T4)},
<a name="832"/>  832:     lists:foreach(fun(T) -&gt;
<a name="833"/>  833: 			  ets:delete_all_objects(T)
<a name="834"/>  834: 		  end,
<a name="835"/>  835: 		  L),
<a name="836"/>  836:     XRes4 = adjust_xmem(L, {50, 256, 256, 256}, 0),
<a name="837"/>  837:     Res4 = {?S(T1),?S(T2),?S(T3),?S(T4)},
<a name="838"/>  838:     lists:foreach(fun(T) -&gt;
<a name="839"/>  839: 			  ets:delete(T)
<a name="840"/>  840: 		  end,
<a name="841"/>  841: 		  L),
<a name="842"/>  842:     L2 =  [T11,T12,T13,T14] = fill_sets_int(1000),
<a name="843"/>  843:     lists:foreach(fun(T) -&gt;
<a name="844"/>  844: 			  ets:select_delete(T,[{'_',[],[true]}])
<a name="845"/>  845: 		  end,
<a name="846"/>  846: 		  L2),
<a name="847"/>  847:     XRes5 = adjust_xmem(L2, {50, 256, 256, 256}, 0),
<a name="848"/>  848:     Res5 = {?S(T11),?S(T12),?S(T13),?S(T14)},
<a name="849"/>  849:     io:format(&quot;XRes1 = ~p~n&quot;
<a name="850"/>  850: 	      &quot; Res1 = ~p~n~n&quot;
<a name="851"/>  851: 	      &quot;XRes2 = ~p~n&quot;
<a name="852"/>  852: 	      &quot; Res2 = ~p~n~n&quot;
<a name="853"/>  853: 	      &quot;XRes3 = ~p~n&quot;
<a name="854"/>  854: 	      &quot; Res3 = ~p~n~n&quot;
<a name="855"/>  855: 	      &quot;XRes4 = ~p~n&quot;
<a name="856"/>  856: 	      &quot; Res4 = ~p~n~n&quot;
<a name="857"/>  857: 	      &quot;XRes5 = ~p~n&quot;
<a name="858"/>  858: 	      &quot; Res5 = ~p~n~n&quot;,
<a name="859"/>  859: 	      [XRes1, Res1,
<a name="860"/>  860: 	       XRes2, Res2,
<a name="861"/>  861: 	       XRes3, Res3,
<a name="862"/>  862: 	       XRes4, Res4,
<a name="863"/>  863: 	       XRes5, Res5]),
<a name="864"/>  864:     XRes1 = Res1,
<a name="865"/>  865:     XRes2 = Res2,
<a name="866"/>  866:     XRes3 = Res3,
<a name="867"/>  867:     XRes4 = Res4,
<a name="868"/>  868:     XRes5 = Res5,
<a name="memory_do-last_expr"/><a name="869"/>  869:     ok.
<a name="870"/>  870: 
<a name="mem_mode-1"/><a name="871"/>  871: <b>mem_mode</b>(T) -&gt;
<a name="mem_mode-last_expr"/><a name="872"/>  872: <b>    {case ets:info</b>(T,compressed) of
<a name="873"/>  873: 	 true -&gt; compressed;
<a name="874"/>  874: 	 false -&gt; normal
<a name="875"/>  875:      end,
<a name="876"/>  876:      erlang:system_info(wordsize)}.
<a name="877"/>  877: 
<a name="chk_normal_tab_struct_size-0"/><a name="878"/>  878: <b>chk_normal_tab_struct_size</b>() -&gt;
<a name="879"/>  879:     System = {os:type(),
<a name="880"/>  880: 	      os:version(),
<a name="881"/>  881: 	      erlang:system_info(wordsize),
<a name="882"/>  882: 	      erlang:system_info(smp_support),
<a name="883"/>  883: 	      erlang:system_info(heap_type)},
<a name="884"/>  884:     io:format(&quot;System = ~p~n&quot;, [System]),
<a name="chk_normal_tab_struct_size-last_expr"/><a name="885"/>  885:     ok.
<a name="886"/>  886: 
<a name="adjust_xmem-3"/><a name="887"/>  887: <b>adjust_xmem</b>([_T1,_T2,_T3,_T4], {A0,B0,C0,D0} = _Mem0, EstCnt) -&gt;
<a name="888"/>  888:     %% Adjust for 64-bit, smp, and os:
<a name="889"/>  889:     %%   Table struct size may differ.
<a name="890"/>  890: 
<a name="891"/>  891:     {TabSz, EstSz} = erts_debug:get_internal_state('DbTable_words'),
<a name="892"/>  892:     HTabSz = TabSz + EstCnt*EstSz,
<a name="893"/>  893:     OrdSetExtra = case erlang:system_info(wordsize) of
<a name="894"/>  894:                       8 -&gt; 40; % larger stack on 64 bit architectures
<a name="895"/>  895:                       _ -&gt; 0
<a name="896"/>  896:                   end,
<a name="adjust_xmem-last_expr"/><a name="897"/>  897:     {A0+TabSz+OrdSetExtra, B0+HTabSz, C0+HTabSz, D0+HTabSz}.
<a name="898"/>  898: 
<a name="899"/>  899: <i>%% Misc. whitebox tests</i>
<a name="t_whitebox-1"/><a name="900"/>  900: <b>t_whitebox</b>(Config) when is_list(Config) -&gt;
<a name="901"/>  901:     EtsMem = etsmem(),
<a name="902"/>  902:     repeat_for_opts(fun whitebox_1/1),
<a name="903"/>  903:     repeat_for_opts(fun whitebox_1/1),
<a name="904"/>  904:     repeat_for_opts(fun whitebox_1/1),
<a name="905"/>  905:     repeat_for_opts(fun whitebox_2/1),
<a name="906"/>  906:     repeat_for_opts(fun whitebox_2/1),
<a name="907"/>  907:     repeat_for_opts(fun whitebox_2/1),
<a name="t_whitebox-last_expr"/><a name="908"/>  908: <b>    verify_etsmem</b>(EtsMem).
<a name="909"/>  909: 
<a name="whitebox_1-1"/><a name="910"/>  910: <b>whitebox_1</b>(Opts) -&gt;
<a name="911"/>  911:     T=ets_new(x,[bag | Opts]),
<a name="912"/>  912:     ets:insert(T,[{du,glade},{ta,en}]),
<a name="913"/>  913:     ets:insert(T,[{hej,hopp2},{du,glade2},{ta,en2}]),
<a name="914"/>  914:     {_,C}=ets:match(T,{ta,'$1'},1),
<a name="915"/>  915:     ets:select(C),
<a name="916"/>  916:     ets:match(C),
<a name="917"/>  917:     ets:delete(T),
<a name="whitebox_1-last_expr"/><a name="918"/>  918:     ok.
<a name="919"/>  919: 
<a name="whitebox_2-1"/><a name="920"/>  920: <b>whitebox_2</b>(OptsIn) -&gt;
<a name="921"/>  921:     run_if_valid_opts(
<a name="922"/>  922:       [ordered_set, {keypos,2} | OptsIn],
<a name="923"/>  923:       fun (Opts) -&gt;
<a name="924"/>  924:               T = ets_new(x, Opts),
<a name="925"/>  925:               0 = ets:select_delete(T,[{{hej},[],[true]}]),
<a name="926"/>  926:               0 = ets:select_delete(T,[{{hej,hopp},[],[true]}]),
<a name="927"/>  927:               ets:delete(T)
<a name="928"/>  928:       end),
<a name="929"/>  929: 
<a name="930"/>  930:     T2 = ets_new(x,[set, {keypos,2}| OptsIn]),
<a name="931"/>  931:     0 = ets:select_delete(T2,[{{hej},[],[true]}]),
<a name="932"/>  932:     0 = ets:select_delete(T2,[{{hej,hopp},[],[true]}]),
<a name="933"/>  933:     ets:delete(T2),
<a name="whitebox_2-last_expr"/><a name="934"/>  934:     ok.
<a name="935"/>  935: 
<a name="select_bound_chunk-1"/><a name="936"/>  936: <b>select_bound_chunk</b>(_Config) -&gt;
<a name="select_bound_chunk-last_expr"/><a name="937"/>  937: <b>    repeat_for_opts</b>(fun select_bound_chunk_do/1, [all_types]).
<a name="938"/>  938: 
<a name="select_bound_chunk_do-1"/><a name="939"/>  939: <b>select_bound_chunk_do</b>(Opts) -&gt;
<a name="940"/>  940:     T = ets_new(x, Opts),
<a name="941"/>  941:     ets:insert(T, [{key, 1}]),
<a name="942"/>  942:     {[{key, 1}], '$end_of_table'} = ets:select(T, [{{key,1},[],['$_']}], 100000),
<a name="select_bound_chunk_do-last_expr"/><a name="943"/>  943:     ok.
<a name="944"/>  944: 
<a name="945"/>  945: 
<a name="946"/>  946: <i>%% Test ets:to/from_dets.</i>
<a name="t_ets_dets-1"/><a name="947"/>  947: <b>t_ets_dets</b>(Config) when is_list(Config) -&gt;
<a name="t_ets_dets-last_expr"/><a name="948"/>  948: <b>    repeat_for_opts</b>(fun(Opts) -&gt; t_ets_dets(Config,Opts) end).
<a name="949"/>  949: 
<a name="t_ets_dets-2"/><a name="950"/>  950: <b>t_ets_dets</b>(Config, Opts) -&gt;
<a name="951"/>  951:     Fname = gen_dets_filename(Config,1),
<a name="952"/>  952:     (catch file:delete(Fname)),
<a name="953"/>  953:     {ok,DTab} = dets:open_file(testdets_1,
<a name="954"/>  954: 			       [{file, Fname}]),
<a name="955"/>  955:     ETab = ets_new(x,Opts),
<a name="956"/>  956:     filltabint(ETab,3000),
<a name="957"/>  957:     DTab = ets:to_dets(ETab,DTab),
<a name="958"/>  958:     ets:delete_all_objects(ETab),
<a name="959"/>  959:     0 = ets:info(ETab,size),
<a name="960"/>  960:     true = ets:from_dets(ETab,DTab),
<a name="961"/>  961:     3000 = ets:info(ETab,size),
<a name="962"/>  962:     ets:delete(ETab),
<a name="963"/>  963:     check_badarg(catch ets:to_dets(ETab,DTab),
<a name="964"/>  964: 		 ets, to_dets, [ETab,DTab]),
<a name="965"/>  965:     check_badarg(catch ets:from_dets(ETab,DTab),
<a name="966"/>  966: 		 ets, from_dets, [ETab,DTab]),
<a name="967"/>  967:     ETab2 = ets_new(x,Opts),
<a name="968"/>  968:     filltabint(ETab2,3000),
<a name="969"/>  969:     dets:close(DTab),
<a name="970"/>  970:     check_badarg(catch ets:to_dets(ETab2,DTab),
<a name="971"/>  971: 		 ets, to_dets, [ETab2,DTab]),
<a name="972"/>  972:     check_badarg(catch ets:from_dets(ETab2,DTab),
<a name="973"/>  973: 		 ets, from_dets, [ETab2,DTab]),
<a name="974"/>  974:     ets:delete(ETab2),
<a name="975"/>  975:     (catch file:delete(Fname)),
<a name="t_ets_dets-last_expr"/><a name="976"/>  976:     ok.
<a name="977"/>  977: 
<a name="check_badarg-4"/><a name="978"/>  978: <b>check_badarg</b>({'EXIT', {badarg, [{M,F,Args,_} | _]}}, M, F, Args) -&gt;
<a name="check_badarg-last_expr"/><a name="979"/>  979:     true.
<a name="980"/>  980: 
<a name="981"/>  981: <i>%% Test ets:delete_all_objects/1.</i>
<a name="t_delete_all_objects-1"/><a name="982"/>  982: <b>t_delete_all_objects</b>(Config) when is_list(Config) -&gt;
<a name="983"/>  983:     EtsMem = etsmem(),
<a name="984"/>  984:     repeat_for_opts_all_set_table_types(fun t_delete_all_objects_do/1),
<a name="t_delete_all_objects-last_expr"/><a name="985"/>  985: <b>    verify_etsmem</b>(EtsMem).
<a name="986"/>  986: 
<a name="get_kept_objects-1"/><a name="987"/>  987: <b>get_kept_objects</b>(T) -&gt;
<a name="get_kept_objects-last_expr"/><a name="988"/>  988: <b>    case ets:info</b>(T,stats) of
<a name="989"/>  989: 	{_,_,_,_,_,_,KO,_}  -&gt;
<a name="990"/>  990: 	    KO;
<a name="991"/>  991:         _ -&gt;
<a name="992"/>  992:             0
<a name="993"/>  993:     end.
<a name="994"/>  994: 
<a name="t_delete_all_objects_do-1"/><a name="995"/>  995: <b>t_delete_all_objects_do</b>(Opts) -&gt;
<a name="996"/>  996:     KeyRange = 40_000,
<a name="997"/>  997:     T=ets_new(x, Opts, KeyRange),
<a name="998"/>  998:     filltabint(T,KeyRange),
<a name="999"/>  999:     O=ets:first(T),
<a name="1000"/> 1000:     ets:next(T,O),
<a name="1001"/> 1001:     ets:safe_fixtable(T,true),
<a name="1002"/> 1002:     true = ets:delete_all_objects(T),
<a name="1003"/> 1003:     '$end_of_table' = ets:next(T,O),
<a name="1004"/> 1004:     0 = ets:info(T,size),
<a name="1005"/> 1005:     case ets:info(T,type) of
<a name="1006"/> 1006:         ordered_set -&gt; ok;
<a name="1007"/> 1007:         _ -&gt; KeyRange = get_kept_objects(T)
<a name="1008"/> 1008:     end,
<a name="1009"/> 1009:     ets:safe_fixtable(T,false),
<a name="1010"/> 1010:     0 = ets:info(T,size),
<a name="1011"/> 1011:     0 = get_kept_objects(T),
<a name="1012"/> 1012:     filltabint(T, KeyRange),
<a name="1013"/> 1013:     KeyRange = ets:info(T,size),
<a name="1014"/> 1014:     true = ets:delete_all_objects(T),
<a name="1015"/> 1015:     0 = ets:info(T,size),
<a name="1016"/> 1016:     ets:delete(T),
<a name="1017"/> 1017: 
<a name="1018"/> 1018:     %% Test delete_all_objects is atomic
<a name="1019"/> 1019:     T2 = ets_new(t_delete_all_objects, [public | Opts]),
<a name="1020"/> 1020:     Self = self(),
<a name="1021"/> 1021:     Inserters = [spawn_link(fun() -&gt; inserter(T2, 1, Self) end) || _ &lt;- [1,2,3,4]],
<a name="1022"/> 1022:     [receive {Ipid, running} -&gt; ok end || Ipid &lt;- Inserters],
<a name="1023"/> 1023:     
<a name="1024"/> 1024:     ets:delete_all_objects(T2),
<a name="1025"/> 1025:     erlang:yield(),
<a name="1026"/> 1026:     [Ipid ! stop || Ipid &lt;- Inserters],
<a name="1027"/> 1027:     Result = [receive {Ipid, stopped, Highest} -&gt; {Ipid,Highest} end || Ipid &lt;- Inserters],
<a name="1028"/> 1028:     
<a name="1029"/> 1029:     %% Verify unbroken sequences of objects inserted _after_ ets:delete_all_objects.
<a name="1030"/> 1030:     Sum = lists:foldl(fun({Ipid, Highest}, AccSum) -&gt;
<a name="1031"/> 1031:                               %% ets:fun2ms(fun({{K,Ipid}}) when K =&lt; Highest -&gt; true end),
<a name="1032"/> 1032:                               AliveMS = [{{{'$1',Ipid}},[{'=&lt;','$1',{const,Highest}}],[true]}],
<a name="1033"/> 1033:                               Alive = ets:select_count(T2, AliveMS),
<a name="1034"/> 1034:                               Lowest = Highest - (Alive-1),
<a name="1035"/> 1035: 
<a name="1036"/> 1036:                               %% ets:fun2ms(fun({{K,Ipid}}) when K &lt; Lowest -&gt; true end)
<a name="1037"/> 1037:                               DeletedMS = [{{{'$1',Ipid}},[{'&lt;','$1',{const,Lowest}}],[true]}],
<a name="1038"/> 1038:                               0 = ets:select_count(T2, DeletedMS),
<a name="1039"/> 1039:                               AccSum + Alive
<a name="1040"/> 1040:                       end,
<a name="1041"/> 1041:                       0,
<a name="1042"/> 1042:                       Result),
<a name="1043"/> 1043:     ok = case ets:info(T2, size) of
<a name="1044"/> 1044:              Sum -&gt; ok;
<a name="1045"/> 1045:              Size -&gt;
<a name="1046"/> 1046:                  io:format(&quot;Sum = ~p\nSize = ~p\n&quot;, [Sum, Size]),
<a name="1047"/> 1047:                  {Sum,Size}
<a name="1048"/> 1048:          end,
<a name="1049"/> 1049: 
<a name="t_delete_all_objects_do-last_expr"/><a name="1050"/> 1050: <b>    ets:delete</b>(T2).
<a name="1051"/> 1051: 
<a name="inserter-3"/><a name="1052"/> 1052: <b>inserter</b>(T, Next, Papa) -&gt;
<a name="1053"/> 1053:     Wait = case Next of
<a name="1054"/> 1054:                10*1000 -&gt;
<a name="1055"/> 1055:                    Papa ! {self(), running},
<a name="1056"/> 1056:                    0;
<a name="1057"/> 1057:                100*1000 -&gt; %% We most often don't reach this far
<a name="1058"/> 1058:                    io:format(&quot;Inserter ~p reached ~p objects\n&quot;,
<a name="1059"/> 1059:                              [self(), Next]),
<a name="1060"/> 1060:                    infinity;
<a name="1061"/> 1061:                _ -&gt;
<a name="1062"/> 1062:                    0
<a name="1063"/> 1063:            end,
<a name="1064"/> 1064:                 
<a name="1065"/> 1065:     ets:insert(T, {{Next, self()}}),
<a name="inserter-last_expr"/><a name="1066"/> 1066:     receive
<a name="1067"/> 1067:         stop -&gt;
<a name="1068"/> 1068:             Papa ! {self(), stopped, Next},
<a name="1069"/> 1069:             ok
<a name="1070"/> 1070:     after Wait -&gt;
<a name="1071"/> 1071:             inserter(T, Next+1, Papa)
<a name="1072"/> 1072:     end.
<a name="1073"/> 1073: 
<a name="1074"/> 1074: 
<a name="1075"/> 1075: <i>%% Poke table during delete_all_objects</i>
<a name="t_delete_all_objects_trap-1"/><a name="1076"/> 1076: <b>t_delete_all_objects_trap</b>(Config) when is_list(Config) -&gt;
<a name="1077"/> 1077:     EtsMem = etsmem(),
<a name="1078"/> 1078:     repeat_for_opts_all_set_table_types(
<a name="1079"/> 1079:       fun(Opts) -&gt;
<a name="1080"/> 1080:               delete_all_objects_trap(Opts, unfix),
<a name="1081"/> 1081:               delete_all_objects_trap(Opts, exit),
<a name="1082"/> 1082:               delete_all_objects_trap(Opts, rename)
<a name="1083"/> 1083:       end),
<a name="1084"/> 1084:     verify_etsmem(EtsMem),
<a name="t_delete_all_objects_trap-last_expr"/><a name="1085"/> 1085:     ok.
<a name="1086"/> 1086: 
<a name="delete_all_objects_trap-2"/><a name="1087"/> 1087: <b>delete_all_objects_trap</b>(Opts, Mode) -&gt;
<a name="1088"/> 1088:     io:format(&quot;Opts = ~p\nMode = ~p\n&quot;, [Opts, Mode]),
<a name="1089"/> 1089:     Tester = self(),
<a name="1090"/> 1090:     KeyRange = 50_000,
<a name="1091"/> 1091:     TableName = delete_all_objects_trap,
<a name="1092"/> 1092:     {Tref,T} =
<a name="1093"/> 1093:         case Mode of
<a name="1094"/> 1094:             rename -&gt;
<a name="1095"/> 1095:                 TableName = ets_new(TableName, [named_table,public|Opts], KeyRange),
<a name="1096"/> 1096:                 {ets:whereis(TableName), TableName};
<a name="1097"/> 1097:             _ -&gt;
<a name="1098"/> 1098:                 Tid = ets_new(x, Opts, KeyRange),
<a name="1099"/> 1099:                 {Tid,Tid}
<a name="1100"/> 1100:         end,
<a name="1101"/> 1101:     filltabint(T, KeyRange),
<a name="1102"/> 1102:     KeyRange = ets:info(T,size),
<a name="1103"/> 1103:     FixerFun =
<a name="1104"/> 1104:         fun() -&gt;
<a name="1105"/> 1105:                 erlang:trace(Tester, true, [running]),
<a name="1106"/> 1106:                 case Mode of
<a name="1107"/> 1107:                     rename -&gt; ok;
<a name="1108"/> 1108:                     _ -&gt; ets:safe_fixtable(T, true)
<a name="1109"/> 1109:                 end,
<a name="1110"/> 1110:                 io:format(&quot;Wait for ets:delete_all_objects/1 to yield...\n&quot;, []),
<a name="1111"/> 1111:                 Tester ! {ready, self()},
<a name="1112"/> 1112:                 repeat_while(
<a name="1113"/> 1113:                   fun() -&gt;
<a name="1114"/> 1114:                           case receive_any() of
<a name="1115"/> 1115:                               {trace, Tester, out, {ets,internal_delete_all,2}} -&gt;
<a name="1116"/> 1116:                                   false;
<a name="1117"/> 1117:                               &quot;delete_all_objects done&quot; -&gt;
<a name="1118"/> 1118:                                   ct:fail(&quot;No trap detected&quot;);
<a name="1119"/> 1119:                               _M -&gt;
<a name="1120"/> 1120:                                   %%io:format(&quot;Ignored msg: ~p\n&quot;, [_M]),
<a name="1121"/> 1121:                                   true
<a name="1122"/> 1122:                           end
<a name="1123"/> 1123:                   end),
<a name="1124"/> 1124:                 case Mode of
<a name="1125"/> 1125:                     unfix -&gt;
<a name="1126"/> 1126:                         io:format(&quot;Unfix table and then exit...\n&quot;,[]),
<a name="1127"/> 1127:                         ets:safe_fixtable(T, false);
<a name="1128"/> 1128:                     exit -&gt;
<a name="1129"/> 1129:                         %%io:format(&quot;Exit and do auto-unfix...\n&quot;,[]),
<a name="1130"/> 1130:                         exit;
<a name="1131"/> 1131:                     rename -&gt;
<a name="1132"/> 1132:                         %%io:format(&quot;Rename table...\n&quot;,[]),
<a name="1133"/> 1133:                         renamed = ets:rename(T, renamed)
<a name="1134"/> 1134:                 end
<a name="1135"/> 1135:         end,
<a name="1136"/> 1136:     {Fixer, Mon} = spawn_opt(FixerFun, [link, monitor]),
<a name="1137"/> 1137:     {ready, Fixer} = receive_any(),
<a name="1138"/> 1138:     true = ets:delete_all_objects(T),
<a name="1139"/> 1139:     Fixer ! &quot;delete_all_objects done&quot;,
<a name="1140"/> 1140:     0 = ets:info(Tref,size),
<a name="1141"/> 1141:     {'DOWN', Mon, process, Fixer, normal} = receive_any(),
<a name="1142"/> 1142:     0 = get_kept_objects(Tref),
<a name="1143"/> 1143:     false = ets:info(Tref,safe_fixed),
<a name="1144"/> 1144:     ets:delete(Tref),
<a name="delete_all_objects_trap-last_expr"/><a name="1145"/> 1145:     ok.
<a name="1146"/> 1146: 
<a name="1147"/> 1147: 
<a name="1148"/> 1148: <i>%% Test ets:delete_object/2.</i>
<a name="t_delete_object-1"/><a name="1149"/> 1149: <b>t_delete_object</b>(Config) when is_list(Config) -&gt;
<a name="1150"/> 1150:     EtsMem = etsmem(),
<a name="1151"/> 1151:     repeat_for_opts(fun t_delete_object_do/1),
<a name="t_delete_object-last_expr"/><a name="1152"/> 1152: <b>    verify_etsmem</b>(EtsMem).
<a name="1153"/> 1153: 
<a name="t_delete_object_do-1"/><a name="1154"/> 1154: <b>t_delete_object_do</b>(Opts) -&gt;
<a name="1155"/> 1155:     T = ets_new(x,Opts),
<a name="1156"/> 1156:     filltabint(T,4000),
<a name="1157"/> 1157:     del_one_by_one_set(T,1,4001),
<a name="1158"/> 1158:     filltabint(T,4000),
<a name="1159"/> 1159:     del_one_by_one_set(T,4000,0),
<a name="1160"/> 1160:     filltabint(T,4000),
<a name="1161"/> 1161:     First = ets:first(T),
<a name="1162"/> 1162:     Next = ets:next(T,First),
<a name="1163"/> 1163:     ets:safe_fixtable(T,true),
<a name="1164"/> 1164:     ets:delete_object(T,{First, integer_to_list(First)}),
<a name="1165"/> 1165:     Next = ets:next(T,First),
<a name="1166"/> 1166:     3999 = ets:info(T,size),
<a name="1167"/> 1167:     1 = get_kept_objects(T),
<a name="1168"/> 1168:     ets:safe_fixtable(T,false),
<a name="1169"/> 1169:     3999 = ets:info(T,size),
<a name="1170"/> 1170:     0 = get_kept_objects(T),
<a name="1171"/> 1171:     ets:delete(T),
<a name="1172"/> 1172:     run_if_valid_opts(
<a name="1173"/> 1173:       [ordered_set | Opts],
<a name="1174"/> 1174:       fun (Opts1) -&gt;
<a name="1175"/> 1175:               T1 = ets_new(x, Opts1),
<a name="1176"/> 1176:               filltabint(T1,4000),
<a name="1177"/> 1177:               del_one_by_one_set(T1,1,4001),
<a name="1178"/> 1178:               filltabint(T1,4000),
<a name="1179"/> 1179:               del_one_by_one_set(T1,4000,0),
<a name="1180"/> 1180:               ets:delete(T1)
<a name="1181"/> 1181:       end),
<a name="1182"/> 1182:     T2 = ets_new(x,[bag | Opts]),
<a name="1183"/> 1183:     filltabint2(T2,4000),
<a name="1184"/> 1184:     del_one_by_one_bag(T2,1,4001),
<a name="1185"/> 1185:     filltabint2(T2,4000),
<a name="1186"/> 1186:     del_one_by_one_bag(T2,4000,0),
<a name="1187"/> 1187:     ets:delete(T2),
<a name="1188"/> 1188:     T3 = ets_new(x,[duplicate_bag | Opts]),
<a name="1189"/> 1189:     filltabint3(T3,4000),
<a name="1190"/> 1190:     del_one_by_one_dbag_1(T3,1,4001),
<a name="1191"/> 1191:     filltabint3(T3,4000),
<a name="1192"/> 1192:     del_one_by_one_dbag_1(T3,4000,0),
<a name="1193"/> 1193:     filltabint(T3,4000),
<a name="1194"/> 1194:     filltabint3(T3,4000),
<a name="1195"/> 1195:     del_one_by_one_dbag_2(T3,1,4001),
<a name="1196"/> 1196:     filltabint(T3,4000),
<a name="1197"/> 1197:     filltabint3(T3,4000),
<a name="1198"/> 1198:     del_one_by_one_dbag_2(T3,4000,0),
<a name="1199"/> 1199: 
<a name="1200"/> 1200:     filltabint2(T3,4000),
<a name="1201"/> 1201:     filltabint(T3,4000),
<a name="1202"/> 1202:     del_one_by_one_dbag_3(T3,4000,0),
<a name="1203"/> 1203:     ets:delete(T3),
<a name="t_delete_object_do-last_expr"/><a name="1204"/> 1204:     ok.
<a name="1205"/> 1205: 
<a name="make_init_fun-1"/><a name="1206"/> 1206: <b>make_init_fun</b>(N) when N &gt; 4000-&gt;
<a name="1207"/> 1207:     fun(read) -&gt;
<a name="1208"/> 1208: 	    end_of_input;
<a name="1209"/> 1209:        (close) -&gt;
<a name="1210"/> 1210: 	    exit(close_not_expected)
<a name="1211"/> 1211:     end;
<a name="1212"/> 1212: <b>make_init_fun</b>(N) -&gt;
<a name="make_init_fun-last_expr"/><a name="1213"/> 1213: <b>    fun</b>(read) -&gt;
<a name="1214"/> 1214: 	    case N rem 2 of
<a name="1215"/> 1215: 		0 -&gt;
<a name="1216"/> 1216: 		    {[{N, integer_to_list(N)}, {N, integer_to_list(N)}],
<a name="1217"/> 1217: 		     make_init_fun(N + 1)};
<a name="1218"/> 1218: 		1 -&gt;
<a name="1219"/> 1219: 		    {[], make_init_fun(N + 1)}
<a name="1220"/> 1220: 	    end;
<a name="1221"/> 1221:        (close) -&gt;
<a name="1222"/> 1222: 	    exit(close_not_expected)
<a name="1223"/> 1223:     end.
<a name="1224"/> 1224: 
<a name="1225"/> 1225: <i>%% Test ets:init_table/2.</i>
<a name="t_init_table-1"/><a name="1226"/> 1226: <b>t_init_table</b>(Config) when is_list(Config)-&gt;
<a name="1227"/> 1227:     EtsMem = etsmem(),
<a name="1228"/> 1228:     repeat_for_opts(fun t_init_table_do/1),
<a name="t_init_table-last_expr"/><a name="1229"/> 1229: <b>    verify_etsmem</b>(EtsMem).
<a name="1230"/> 1230: 
<a name="t_init_table_do-1"/><a name="1231"/> 1231: <b>t_init_table_do</b>(Opts) -&gt;
<a name="1232"/> 1232:     T = ets_new(x,[duplicate_bag | Opts]),
<a name="1233"/> 1233:     filltabint(T,4000),
<a name="1234"/> 1234:     ets:init_table(T, make_init_fun(1)),
<a name="1235"/> 1235:     del_one_by_one_dbag_1(T,4000,0),
<a name="1236"/> 1236:     ets:delete(T),
<a name="t_init_table_do-last_expr"/><a name="1237"/> 1237:     ok.
<a name="1238"/> 1238: 
<a name="do_fill_dbag_using_lists-2"/><a name="1239"/> 1239: <b>do_fill_dbag_using_lists</b>(T,0) -&gt;
<a name="1240"/> 1240:     T;
<a name="1241"/> 1241: <b>do_fill_dbag_using_lists</b>(T,N) -&gt;
<a name="1242"/> 1242:     ets:insert(T,[{N,integer_to_list(N)},
<a name="1243"/> 1243: 		  {N + N rem 2,integer_to_list(N + N rem 2)}]),
<a name="do_fill_dbag_using_lists-last_expr"/><a name="1244"/> 1244: <b>    do_fill_dbag_using_lists</b>(T,N - 1). 
<a name="1245"/> 1245: 
<a name="1246"/> 1246: 
<a name="1247"/> 1247: <i>%% Test the insert_new function.</i>
<a name="t_insert_new-1"/><a name="1248"/> 1248: <b>t_insert_new</b>(Config) when is_list(Config) -&gt;
<a name="1249"/> 1249:     EtsMem = etsmem(),
<a name="1250"/> 1250:     L = fill_sets_int(1000) ++ fill_sets_int(1000,[{write_concurrency,true}]),
<a name="1251"/> 1251:     lists:foreach(fun(Tab) -&gt;
<a name="1252"/> 1252: 			  false = ets:insert_new(Tab,{2,&quot;2&quot;}),
<a name="1253"/> 1253: 			  true = ets:insert_new(Tab,{2002,&quot;2002&quot;}),
<a name="1254"/> 1254: 			  false = ets:insert_new(Tab,{2002,&quot;2002&quot;}),
<a name="1255"/> 1255: 			  true = ets:insert(Tab,{2002,&quot;2002&quot;}),
<a name="1256"/> 1256: 			  false =  ets:insert_new(Tab,[{2002,&quot;2002&quot;}]),
<a name="1257"/> 1257: 			  false =  ets:insert_new(Tab,[{2002,&quot;2002&quot;},
<a name="1258"/> 1258: 						       {2003,&quot;2003&quot;}]),
<a name="1259"/> 1259: 			  false =  ets:insert_new(Tab,[{2001,&quot;2001&quot;},
<a name="1260"/> 1260: 						       {2002,&quot;2002&quot;},
<a name="1261"/> 1261: 						       {2003,&quot;2003&quot;}]),
<a name="1262"/> 1262: 			  false =  ets:insert_new(Tab,[{2001,&quot;2001&quot;},
<a name="1263"/> 1263: 						       {2002,&quot;2002&quot;}]),
<a name="1264"/> 1264: 			  true =  ets:insert_new(Tab,[{2001,&quot;2001&quot;},
<a name="1265"/> 1265: 						      {2003,&quot;2003&quot;}]),
<a name="1266"/> 1266: 			  false = ets:insert_new(Tab,{2001,&quot;2001&quot;}),
<a name="1267"/> 1267: 			  false = ets:insert_new(Tab,{2002,&quot;2002&quot;}),
<a name="1268"/> 1268: 			  false = ets:insert_new(Tab,{2003,&quot;2003&quot;}),
<a name="1269"/> 1269: 			  true = ets:insert_new(Tab,{2004,&quot;2004&quot;}),
<a name="1270"/> 1270: 			  true = ets:insert_new(Tab,{2000,&quot;2000&quot;}),
<a name="1271"/> 1271: 			  true = ets:insert_new(Tab,[{2005,&quot;2005&quot;},
<a name="1272"/> 1272: 						     {2006,&quot;2006&quot;},
<a name="1273"/> 1273: 						     {2007,&quot;2007&quot;}]),
<a name="1274"/> 1274: 			  Num =
<a name="1275"/> 1275: 			      case ets:info(Tab,type) of
<a name="1276"/> 1276: 				  bag -&gt;
<a name="1277"/> 1277: 				      true =
<a name="1278"/> 1278: 					  ets:insert(Tab,{2004,&quot;2004-2&quot;}),
<a name="1279"/> 1279: 				      false =
<a name="1280"/> 1280: 					  ets:insert_new(Tab,{2004,&quot;2004-3&quot;}),
<a name="1281"/> 1281: 				      1009;
<a name="1282"/> 1282: 				  duplicate_bag -&gt;
<a name="1283"/> 1283: 				      true =
<a name="1284"/> 1284: 					  ets:insert(Tab,{2004,&quot;2004&quot;}),
<a name="1285"/> 1285: 				      false =
<a name="1286"/> 1286: 					  ets:insert_new(Tab,{2004,&quot;2004&quot;}),
<a name="1287"/> 1287: 				      1010;
<a name="1288"/> 1288: 				  _ -&gt;
<a name="1289"/> 1289: 				      1008
<a name="1290"/> 1290: 			      end,
<a name="1291"/> 1291: 			  Num = ets:info(Tab,size),
<a name="1292"/> 1292: 			  List = ets:tab2list(Tab),
<a name="1293"/> 1293: 			  ets:delete_all_objects(Tab),
<a name="1294"/> 1294: 			  true = ets:insert_new(Tab,List),
<a name="1295"/> 1295: 			  false = ets:insert_new(Tab,List),
<a name="1296"/> 1296: 			  ets:delete(Tab)
<a name="1297"/> 1297: 		  end,
<a name="1298"/> 1298: 		  L),
<a name="t_insert_new-last_expr"/><a name="1299"/> 1299: <b>    verify_etsmem</b>(EtsMem).
<a name="1300"/> 1300: 
<a name="1301"/> 1301: <i>%% Test ets:insert/2 with list of objects into duplicate bag table.</i>
<a name="t_insert_list-1"/><a name="1302"/> 1302: <b>t_insert_list</b>(Config) when is_list(Config) -&gt;
<a name="1303"/> 1303:     EtsMem = etsmem(),
<a name="1304"/> 1304:     repeat_for_opts(fun t_insert_list_do/1),
<a name="t_insert_list-last_expr"/><a name="1305"/> 1305: <b>    verify_etsmem</b>(EtsMem).
<a name="1306"/> 1306: 
<a name="t_insert_list_do-1"/><a name="1307"/> 1307: <b>t_insert_list_do</b>(Opts) -&gt;
<a name="1308"/> 1308:     T = ets_new(x,[duplicate_bag | Opts]),
<a name="1309"/> 1309:     do_fill_dbag_using_lists(T,4000),
<a name="1310"/> 1310:     del_one_by_one_dbag_2(T,4000,0),
<a name="t_insert_list_do-last_expr"/><a name="1311"/> 1311: <b>    ets:delete</b>(T).
<a name="1312"/> 1312: 
<a name="1313"/> 1313: <i>% Insert a long list twice in a bag</i>
<a name="t_insert_list_bag-1"/><a name="1314"/> 1314: <b>t_insert_list_bag</b>(Config) when is_list(Config) -&gt;
<a name="1315"/> 1315:     EtsMem = etsmem(),
<a name="1316"/> 1316:     repeat_for_opts(fun t_insert_list_bag_do/1,
<a name="1317"/> 1317:                     [write_concurrency, compressed]),
<a name="t_insert_list_bag-last_expr"/><a name="1318"/> 1318: <b>    verify_etsmem</b>(EtsMem).
<a name="1319"/> 1319: 
<a name="t_insert_list_bag_do-1"/><a name="1320"/> 1320: <b>t_insert_list_bag_do</b>(Opts) -&gt;
<a name="1321"/> 1321:     T = ets:new(t, [bag | Opts]),
<a name="1322"/> 1322:     ListSize = 25000,
<a name="1323"/> 1323:     List = [ {N} || N &lt;- lists:seq(1, ListSize)],
<a name="1324"/> 1324:     ets:insert(T, List),
<a name="1325"/> 1325:     ets:insert(T, List),
<a name="1326"/> 1326:     ListSize = ets:info(T, size),
<a name="1327"/> 1327: 
<a name="1328"/> 1328:     %% Insert different sized objects to better test (compressed) object comparison
<a name="1329"/> 1329:     List2 = [begin Bits=(N rem 71), {N div 7, &lt;&lt;N:Bits&gt;&gt;} end || {N} &lt;- List],
<a name="1330"/> 1330:     ets:insert(T, List2),
<a name="1331"/> 1331:     List2Sz = ListSize * 2,
<a name="1332"/> 1332:     List2Sz = ets:info(T, size),
<a name="1333"/> 1333:     ets:delete(T),
<a name="t_insert_list_bag_do-last_expr"/><a name="1334"/> 1334:     ok.
<a name="1335"/> 1335: 
<a name="1336"/> 1336: <i>% Insert a long list twice in a duplicate_bag</i>
<a name="t_insert_list_duplicate_bag-1"/><a name="1337"/> 1337: <b>t_insert_list_duplicate_bag</b>(Config) when is_list(Config) -&gt;
<a name="1338"/> 1338:     EtsMem = etsmem(),
<a name="1339"/> 1339:     T = ets:new(t, [duplicate_bag]),
<a name="1340"/> 1340:     ListSize = 25000,
<a name="1341"/> 1341:     List = [ {N} || N &lt;- lists:seq(1, ListSize)],
<a name="1342"/> 1342:     ets:insert(T, List),
<a name="1343"/> 1343:     ets:insert(T, List),
<a name="1344"/> 1344:     DoubleListSize = ListSize * 2,
<a name="1345"/> 1345:     DoubleListSize = ets:info(T, size),
<a name="1346"/> 1346:     ets:delete(T),
<a name="t_insert_list_duplicate_bag-last_expr"/><a name="1347"/> 1347: <b>    verify_etsmem</b>(EtsMem).
<a name="1348"/> 1348: 
<a name="1349"/> 1349: <i>%% Test ets:insert/2 with list of objects into set tables.</i>
<a name="t_insert_list_set-1"/><a name="1350"/> 1350: <b>t_insert_list_set</b>(Config) when is_list(Config) -&gt;
<a name="1351"/> 1351:     EtsMem = etsmem(),
<a name="1352"/> 1352:     repeat_for_opts(fun t_insert_list_set_do/1, [set_types]),
<a name="t_insert_list_set-last_expr"/><a name="1353"/> 1353: <b>    verify_etsmem</b>(EtsMem).
<a name="1354"/> 1354: 
<a name="t_insert_list_set_do-1"/><a name="1355"/> 1355: <b>t_insert_list_set_do</b>(Opts) -&gt;
<a name="1356"/> 1356:     Nr = 2,
<a name="1357"/> 1357:     t_insert_list_set_do(Opts, fun ets_insert_with_check/2, Nr, 1, Nr+1),
<a name="1358"/> 1358:     t_insert_list_set_do(Opts, fun ets_insert_with_check/2, Nr*2, 2, Nr*2),
<a name="1359"/> 1359:     InsertNewWithCheck =
<a name="1360"/> 1360:         fun(T,E) -&gt;
<a name="1361"/> 1361:                 Res = ets:insert_new(T,E),
<a name="1362"/> 1362:                 Seq = element(1, lists:nth(1, E)),
<a name="1363"/> 1363:                 case Seq rem 2 =:= 0 of
<a name="1364"/> 1364:                     true -&gt; Res = false;
<a name="1365"/> 1365:                     false -&gt; Res = true
<a name="1366"/> 1366:                 end
<a name="1367"/> 1367:         end,
<a name="1368"/> 1368:     t_insert_list_set_do(Opts, InsertNewWithCheck, Nr, 1, Nr),
<a name="1369"/> 1369:     t_insert_list_set_do(Opts, fun ets:insert_new/2, Nr*2, 2, Nr*2),
<a name="t_insert_list_set_do-last_expr"/><a name="1370"/> 1370:     ok.
<a name="1371"/> 1371: 
<a name="t_insert_list_set_do-5"/><a name="1372"/> 1372: <b>t_insert_list_set_do</b>(Opts, InsertFun, Nr, Step, ExpectedSize) -&gt;
<a name="1373"/> 1373:     T = ets_new(x,Opts),
<a name="1374"/> 1374:     [InsertFun(T,[{X,X}, {X+1,X}]) || X &lt;- lists:seq(1,Nr,Step)],
<a name="1375"/> 1375:     ExpectedSize = ets:info(T,size),
<a name="t_insert_list_set_do-last_expr"/><a name="1376"/> 1376: <b>    ets:delete</b>(T).
<a name="1377"/> 1377: 
<a name="1378"/> 1378: <i>%% Test ets:insert/2 with list of objects into set tables in parallel.</i>
<a name="t_insert_list_parallel-1"/><a name="1379"/> 1379: <b>t_insert_list_parallel</b>(Config) when is_list(Config) -&gt;
<a name="1380"/> 1380:     EtsMem = etsmem(),
<a name="1381"/> 1381:     repeat_for_opts(fun t_insert_list_parallel_do/1, [[public], set_types]),
<a name="t_insert_list_parallel-last_expr"/><a name="1382"/> 1382: <b>    verify_etsmem</b>(EtsMem).
<a name="1383"/> 1383: 
<a name="ets_insert_with_check-2"/><a name="1384"/> 1384: <b>ets_insert_with_check</b>(Table, ToInsert) -&gt;
<a name="1385"/> 1385:     true = ets:insert(Table, ToInsert),
<a name="ets_insert_with_check-last_expr"/><a name="1386"/> 1386:     true.
<a name="1387"/> 1387: 
<a name="ets_insert_new_with_check-2"/><a name="1388"/> 1388: <b>ets_insert_new_with_check</b>(Table, ToInsert) -&gt;
<a name="1389"/> 1389:     ExpectedRes =
<a name="1390"/> 1390:         case put(is_first_insert_for_list, true) of
<a name="1391"/> 1391:             undefined -&gt; true;
<a name="1392"/> 1392:             true -&gt; false
<a name="1393"/> 1393:         end,
<a name="1394"/> 1394:     ExpectedRes = ets:insert_new(Table, ToInsert),
<a name="ets_insert_new_with_check-last_expr"/><a name="1395"/> 1395:     ExpectedRes.
<a name="1396"/> 1396: 
<a name="t_insert_list_parallel_do-1"/><a name="1397"/> 1397: <b>t_insert_list_parallel_do</b>(Opts) -&gt;
<a name="t_insert_list_parallel_do-last_expr"/><a name="1398"/> 1398: <b>    [</b>(fun(I) -&gt;
<a name="1399"/> 1399:              t_insert_list_parallel_do(Opts, I, 2, 100, 500),
<a name="1400"/> 1400:              t_insert_list_parallel_do(Opts, I, 10, 100, 100),
<a name="1401"/> 1401:              t_insert_list_parallel_do(Opts, I, 1000, 100, 10),
<a name="1402"/> 1402:              t_insert_list_parallel_do(Opts, I, 50000, 3, 1)
<a name="1403"/> 1403:       end)(InsertFun) || InsertFun &lt;- [fun ets_insert_with_check/2,
<a name="1404"/> 1404:                                        fun ets_insert_new_with_check/2]].
<a name="1405"/> 1405: 
<a name="t_insert_list_parallel_do-5"/><a name="1406"/> 1406: <b>t_insert_list_parallel_do</b>(Opts, InsertFun, ListLength, NrOfProcesses, NrOfInsertsPerProcess) -&gt;
<a name="1407"/> 1407:     T = ets_new(x,Opts),
<a name="1408"/> 1408:     t_insert_list_parallel_do_helper(self(), T, 0, InsertFun, ListLength, NrOfProcesses, NrOfInsertsPerProcess),
<a name="1409"/> 1409:     receive done -&gt; ok end,
<a name="1410"/> 1410:     ExpectedSize = ListLength * NrOfProcesses,
<a name="1411"/> 1411:     ExpectedSize = length(ets:match_object(T, {'$0', '$1'})),
<a name="1412"/> 1412:     ExpectedSize = ets:info(T, size),
<a name="1413"/> 1413:     ets:delete(T),
<a name="t_insert_list_parallel_do-last_expr"/><a name="1414"/> 1414:     ok.
<a name="1415"/> 1415: 
<a name="t_insert_list_delete_parallel-1"/><a name="1416"/> 1416: <b>t_insert_list_delete_parallel</b>(Config) when is_list(Config) -&gt;
<a name="1417"/> 1417:     EtsMem = etsmem(),
<a name="1418"/> 1418:     repeat_for_opts(fun t_insert_list_delete_parallel_do/1, [[public], set_types]),
<a name="t_insert_list_delete_parallel-last_expr"/><a name="1419"/> 1419: <b>    verify_etsmem</b>(EtsMem).
<a name="1420"/> 1420: 
<a name="t_insert_list_delete_parallel_do-1"/><a name="1421"/> 1421: <b>t_insert_list_delete_parallel_do</b>(Opts) -&gt;
<a name="1422"/> 1422:     [(fun(I) -&gt;
<a name="1423"/> 1423:               t_insert_list_delete_parallel_do(Opts, I, 30, 32, 1000000),
<a name="1424"/> 1424:               t_insert_list_delete_parallel_do(Opts, I, 300, 8, 1000000),
<a name="1425"/> 1425:               t_insert_list_delete_parallel_do(Opts, I, 3000, 4, 1000000),
<a name="1426"/> 1426:               t_insert_list_delete_parallel_do(Opts, I, 9000, 4, 1000000)
<a name="1427"/> 1427:       end)(InsertFun) || InsertFun &lt;- [fun ets_insert_with_check/2,
<a name="1428"/> 1428:                                        fun ets_insert_new_with_check/2]],
<a name="t_insert_list_delete_parallel_do-last_expr"/><a name="1429"/> 1429:     ok.
<a name="1430"/> 1430: 
<a name="t_insert_list_delete_parallel_do-5"/><a name="1431"/> 1431: <b>t_insert_list_delete_parallel_do</b>(Opts, InsertFun, ListLength, NrOfProcesses, NrOfInsertsPerProcess) -&gt;
<a name="1432"/> 1432:     T = ets_new(x,Opts),
<a name="1433"/> 1433:     CompletedInsertsCtr = counters:new(1,[]),
<a name="1434"/> 1434:     NewInsertFun =
<a name="1435"/> 1435:         fun(Table, ToInsert) -&gt;
<a name="1436"/> 1436:                 try
<a name="1437"/> 1437:                     InsertFun(Table, ToInsert),
<a name="1438"/> 1438:                     counters:add(CompletedInsertsCtr, 1, 1)
<a name="1439"/> 1439:                 catch
<a name="1440"/> 1440:                     error:badarg -&gt; put(stop,yes)
<a name="1441"/> 1441:                 end
<a name="1442"/> 1442:         end,
<a name="1443"/> 1443:     Self = self(),
<a name="1444"/> 1444:     spawn(fun()-&gt;
<a name="1445"/> 1445:                   t_insert_list_parallel_do_helper(self(), T, 0, NewInsertFun, ListLength, NrOfProcesses, NrOfInsertsPerProcess),
<a name="1446"/> 1446:                   receive done -&gt; Self ! done_parallel_insert end
<a name="1447"/> 1447:           end),
<a name="1448"/> 1448:     receive after 3 -&gt; ok end,
<a name="1449"/> 1449:     spawn(fun()-&gt;
<a name="1450"/> 1450:                   spawn(fun()-&gt;
<a name="1451"/> 1451:                                 receive after 7 -&gt; ok end,
<a name="1452"/> 1452:                                 ets:delete(T),
<a name="1453"/> 1453:                                 Self ! done_delete
<a name="1454"/> 1454:                         end)
<a name="1455"/> 1455:           end),
<a name="1456"/> 1456:     receive done_delete -&gt; ok end,
<a name="1457"/> 1457:     receive done_parallel_insert -&gt; ok end,
<a name="t_insert_list_delete_parallel_do-last_expr"/><a name="1458"/> 1458: <b>    io:format</b>(&quot;~p/~p completed&quot;,
<a name="1459"/> 1459:               [counters:get(CompletedInsertsCtr, 1),
<a name="1460"/> 1460:                NrOfProcesses * NrOfInsertsPerProcess]).
<a name="1461"/> 1461: 
<a name="1462"/> 1462: 
<a name="t_insert_list_parallel_do_helper-7"/><a name="1463"/> 1463: <b>t_insert_list_parallel_do_helper</b>(Parent, T, StartKey, InsertFun, ListLength, 1, NrOfInsertsPerProcess) -&gt;
<a name="1464"/> 1464:     try
<a name="1465"/> 1465:         repeat(fun()-&gt;
<a name="1466"/> 1466:                        case get(stop) of
<a name="1467"/> 1467:                            yes -&gt; throw(end_repeat);
<a name="1468"/> 1468:                            _ -&gt; ok
<a name="1469"/> 1469:                        end,
<a name="1470"/> 1470:                        InsertFun(T,[{X,X} || X &lt;- lists:seq(StartKey,StartKey+ListLength-1,1)])
<a name="1471"/> 1471:                end, NrOfInsertsPerProcess)
<a name="1472"/> 1472:     catch
<a name="1473"/> 1473:         throw:end_repeat -&gt; ok
<a name="1474"/> 1474:     end,
<a name="1475"/> 1475:     Parent ! done;
<a name="1476"/> 1476: <b>t_insert_list_parallel_do_helper</b>(Parent, T, StartKey, InsertFun, ListLength, NrOfProcesses, NrOfInsertsPerProcess) -&gt;
<a name="1477"/> 1477:     Self = self(),
<a name="1478"/> 1478:     spawn(fun() -&gt;
<a name="1479"/> 1479:                   t_insert_list_parallel_do_helper(Self,
<a name="1480"/> 1480:                                                    T,
<a name="1481"/> 1481:                                                    StartKey,
<a name="1482"/> 1482:                                                    InsertFun,
<a name="1483"/> 1483:                                                    ListLength,
<a name="1484"/> 1484:                                                    NrOfProcesses div 2,
<a name="1485"/> 1485:                                                    NrOfInsertsPerProcess) end),
<a name="1486"/> 1486:     spawn(fun() -&gt;
<a name="1487"/> 1487:                   t_insert_list_parallel_do_helper(Self,
<a name="1488"/> 1488:                                                    T,
<a name="1489"/> 1489:                                                    StartKey + ListLength*(NrOfProcesses div 2),
<a name="1490"/> 1490:                                                    InsertFun,
<a name="1491"/> 1491:                                                    ListLength,
<a name="1492"/> 1492:                                                    (NrOfProcesses div 2) + (NrOfProcesses rem 2),
<a name="1493"/> 1493:                                                    NrOfInsertsPerProcess)
<a name="1494"/> 1494:           end),
<a name="1495"/> 1495:     receive done -&gt; ok end,
<a name="1496"/> 1496:     receive done -&gt; ok end,
<a name="t_insert_list_parallel_do_helper-last_expr"/><a name="1497"/> 1497:     Parent ! done.
<a name="1498"/> 1498: 
<a name="t_insert_list_delete_set-1"/><a name="1499"/> 1499: <b>t_insert_list_delete_set</b>(Config) when is_list(Config) -&gt;
<a name="1500"/> 1500:     EtsMem = etsmem(),
<a name="1501"/> 1501:     repeat_for_opts(fun t_insert_list_delete_set_do/1, [[public],set_types]),
<a name="t_insert_list_delete_set-last_expr"/><a name="1502"/> 1502: <b>    verify_etsmem</b>(EtsMem).
<a name="1503"/> 1503: 
<a name="t_insert_list_delete_set_do-1"/><a name="1504"/> 1504: <b>t_insert_list_delete_set_do</b>(Opts) -&gt;
<a name="1505"/> 1505:     [(fun(I) -&gt;
<a name="1506"/> 1506:               t_insert_list_delete_set_do(Opts, I, 1000000, 1, 1),
<a name="1507"/> 1507:               t_insert_list_delete_set_do(Opts, I, 100000, 10, 5),
<a name="1508"/> 1508:               t_insert_list_delete_set_do(Opts, I, 10000, 100, 50),
<a name="1509"/> 1509:               t_insert_list_delete_set_do(Opts, I, 1000, 1000, 500)
<a name="1510"/> 1510:       end)(InsertFun) || InsertFun &lt;- [fun ets_insert_with_check/2,
<a name="1511"/> 1511:                                        fun ets_insert_new_with_check/2]],
<a name="t_insert_list_delete_set_do-last_expr"/><a name="1512"/> 1512:     ok.
<a name="1513"/> 1513: 
<a name="1514"/> 1514: 
<a name="t_insert_list_delete_set_do-5"/><a name="1515"/> 1515: <b>t_insert_list_delete_set_do</b>(Opts, InsertFun, ListLength, NrOfTables, NrOfInserts) -&gt;
<a name="1516"/> 1516:     CompletedInsertsCtr = counters:new(1,[]),
<a name="1517"/> 1517:     Parent = self(),
<a name="1518"/> 1518:     [(fun() -&gt;
<a name="1519"/> 1519:               T = ets_new(x,Opts),
<a name="1520"/> 1520:               spawn(
<a name="1521"/> 1521:                 fun() -&gt;
<a name="1522"/> 1522:                         try
<a name="1523"/> 1523:                             repeat(
<a name="1524"/> 1524:                               fun() -&gt;
<a name="1525"/> 1525:                                       InsertFun(T,[{Z,Z} ||
<a name="1526"/> 1526:                                                       Z &lt;- lists:seq(1,ListLength)]),
<a name="1527"/> 1527:                                       counters:add(CompletedInsertsCtr, 1, 1)%,
<a name="1528"/> 1528:                               end, NrOfInserts)
<a name="1529"/> 1529:                         catch
<a name="1530"/> 1530:                             error:badarg -&gt; ok
<a name="1531"/> 1531:                         end,
<a name="1532"/> 1532:                         Parent ! done
<a name="1533"/> 1533:                 end),
<a name="1534"/> 1534:               receive after 1 -&gt; ok end,
<a name="1535"/> 1535:               ets:delete(T)
<a name="1536"/> 1536:       end)() || _ &lt;- lists:seq(1,NrOfTables)],
<a name="1537"/> 1537:     [receive done -&gt; ok end || _ &lt;- lists:seq(1,NrOfTables)],
<a name="t_insert_list_delete_set_do-last_expr"/><a name="1538"/> 1538: <b>    io:format</b>(&quot;~p/~p completed&quot;,
<a name="1539"/> 1539:               [counters:get(CompletedInsertsCtr, 1),
<a name="1540"/> 1540:                NrOfTables * NrOfInserts]).
<a name="1541"/> 1541: 
<a name="1542"/> 1542: 
<a name="t_insert_list_kill_process-1"/><a name="1543"/> 1543: <b>t_insert_list_kill_process</b>(Config) when is_list(Config) -&gt;
<a name="1544"/> 1544:     EtsMem = etsmem(),
<a name="1545"/> 1545:     repeat_for_opts(fun t_insert_list_kill_process_do/1, [[public], set_types]),
<a name="t_insert_list_kill_process-last_expr"/><a name="1546"/> 1546: <b>    verify_etsmem</b>(EtsMem).
<a name="1547"/> 1547: 
<a name="1548"/> 1548: 
<a name="t_insert_list_kill_process_do-1"/><a name="1549"/> 1549: <b>t_insert_list_kill_process_do</b>(Opts) -&gt;
<a name="1550"/> 1550:     [(fun(I) -&gt;
<a name="1551"/> 1551:               [(fun(Time) -&gt;
<a name="1552"/> 1552:                         T = ets_new(x,Opts),
<a name="1553"/> 1553:                         List = lists:seq(1,600000),
<a name="1554"/> 1554:                         TupleList = [{E,E} || E &lt;- List],
<a name="1555"/> 1555:                         Pid = spawn(fun() -&gt; I(T, TupleList) end),
<a name="1556"/> 1556:                         receive after Time -&gt; ok end,
<a name="1557"/> 1557:                         exit(Pid, kill),
<a name="1558"/> 1558:                         ets:delete(T)
<a name="1559"/> 1559:                 end)(TheTime) || TheTime &lt;- [1,3,5] ++ lists:seq(7,29,7)]
<a name="1560"/> 1560:       end)(InsertFun) || InsertFun &lt;- [fun ets:insert/2,
<a name="1561"/> 1561:                                        fun ets:insert_new/2]],
<a name="t_insert_list_kill_process_do-last_expr"/><a name="1562"/> 1562:     ok.
<a name="1563"/> 1563: 
<a name="t_insert_list_insert_order_preserved-1"/><a name="1564"/> 1564: <b>t_insert_list_insert_order_preserved</b>(Config) when is_list(Config) -&gt;
<a name="1565"/> 1565:     insert_list_insert_order_preserved(bag),
<a name="1566"/> 1566:     insert_list_insert_order_preserved(duplicate_bag),
<a name="t_insert_list_insert_order_preserved-last_expr"/><a name="1567"/> 1567:     ok.
<a name="1568"/> 1568: 
<a name="insert_list_insert_order_preserved-1"/><a name="1569"/> 1569: <b>insert_list_insert_order_preserved</b>(Type) -&gt;
<a name="1570"/> 1570:     Tab = ets:new(?FUNCTION_NAME, [Type]),
<a name="1571"/> 1571:     K = a,
<a name="1572"/> 1572:     Values1 = [{K, 1}, {K, 2}, {K, 3}],
<a name="1573"/> 1573:     Values2 = [{K, 4}, {K, 5}, {K, 6}],
<a name="1574"/> 1574:     ets:insert(Tab, Values1),
<a name="1575"/> 1575:     ets:insert(Tab, Values2),
<a name="1576"/> 1576:     [{K, 1}, {K, 2}, {K, 3}, {K, 4}, {K, 5}, {K, 6}] = ets:lookup(Tab, K),
<a name="1577"/> 1577: 
<a name="1578"/> 1578:     ets:delete(Tab, K),
<a name="1579"/> 1579:     [] = ets:lookup(Tab, K),
<a name="1580"/> 1580: 
<a name="1581"/> 1581:     %% Insert order in duplicate_bag depended on reductions left
<a name="1582"/> 1582:     ITERATIONS_PER_RED = 8,
<a name="1583"/> 1583:     NTuples = 4000 * ITERATIONS_PER_RED + 10,
<a name="1584"/> 1584:     LongList = [{K, V} || V &lt;- lists:seq(1, NTuples)],
<a name="1585"/> 1585:     ets:insert(Tab, LongList),
<a name="1586"/> 1586:     LongList = ets:lookup(Tab, K),
<a name="1587"/> 1587: 
<a name="insert_list_insert_order_preserved-last_expr"/><a name="1588"/> 1588: <b>    ets:delete</b>(Tab).
<a name="1589"/> 1589: 
<a name="1590"/> 1590: <i>%% Test interface of ets:test_ms/2.</i>
<a name="t_test_ms-1"/><a name="1591"/> 1591: <b>t_test_ms</b>(Config) when is_list(Config) -&gt;
<a name="1592"/> 1592:     EtsMem = etsmem(),
<a name="1593"/> 1593:     {ok,[a,b]} = ets:test_ms({a,b},
<a name="1594"/> 1594: 			     [{{'$1','$2'},[{'&lt;','$1','$2'}],['$$']}]),
<a name="1595"/> 1595:     {ok,false} = ets:test_ms({a,b},
<a name="1596"/> 1596: 			     [{{'$1','$2'},[{'&gt;','$1','$2'}],['$$']}]),
<a name="1597"/> 1597:     Tpl = {a,gb_sets:new()},
<a name="1598"/> 1598:     {ok,Tpl} = ets:test_ms(Tpl, [{{'_','_'},  [], ['$_']}]), % OTP-10190
<a name="1599"/> 1599:     {error,[{error,String}]} = ets:test_ms({a,b},
<a name="1600"/> 1600: 					   [{{'$1','$2'},
<a name="1601"/> 1601: 					     [{'flurp','$1','$2'}],
<a name="1602"/> 1602: 					     ['$$']}]),
<a name="1603"/> 1603:     true = (if is_list(String) -&gt; true; true -&gt; false end),
<a name="t_test_ms-last_expr"/><a name="1604"/> 1604: <b>    verify_etsmem</b>(EtsMem).
<a name="1605"/> 1605: 
<a name="1606"/> 1606: <i>%% Test the select reverse BIFs.</i>
<a name="t_select_reverse-1"/><a name="1607"/> 1607: <b>t_select_reverse</b>(Config) when is_list(Config) -&gt;
<a name="1608"/> 1608:     Table = ets_new(xxx, [ordered_set]),
<a name="1609"/> 1609:     filltabint(Table,1000),
<a name="1610"/> 1610:     A = lists:reverse(ets:select(Table,[{{'$1', '_'},
<a name="1611"/> 1611: 					 [{'&gt;',
<a name="1612"/> 1612: 					   {'rem',
<a name="1613"/> 1613: 					    '$1', 5},
<a name="1614"/> 1614: 					   2}],
<a name="1615"/> 1615: 					 ['$_']}])),
<a name="1616"/> 1616:     A = ets:select_reverse(Table,[{{'$1', '_'},
<a name="1617"/> 1617: 				   [{'&gt;',
<a name="1618"/> 1618: 				     {'rem',
<a name="1619"/> 1619: 				      '$1', 5},
<a name="1620"/> 1620: 				     2}],
<a name="1621"/> 1621: 				   ['$_']}]),
<a name="1622"/> 1622:     A = reverse_chunked(Table,[{{'$1', '_'},
<a name="1623"/> 1623: 				[{'&gt;',
<a name="1624"/> 1624: 				  {'rem',
<a name="1625"/> 1625: 				   '$1', 5},
<a name="1626"/> 1626: 				  2}],
<a name="1627"/> 1627: 				['$_']}],3),
<a name="1628"/> 1628:     %% A set/bag/duplicate_bag should get the same result regardless
<a name="1629"/> 1629:     %% of select or select_reverse
<a name="1630"/> 1630:     Table2 = ets_new(xxx, [set]),
<a name="1631"/> 1631:     filltabint(Table2,1000),
<a name="1632"/> 1632:     Table3 = ets_new(xxx, [bag]),
<a name="1633"/> 1633:     filltabint(Table3,1000),
<a name="1634"/> 1634:     Table4 = ets_new(xxx, [duplicate_bag]),
<a name="1635"/> 1635:     filltabint(Table4,1000),
<a name="1636"/> 1636:     lists:map(fun(Tab) -&gt;
<a name="1637"/> 1637: 		      B = ets:select(Tab,[{{'$1', '_'},
<a name="1638"/> 1638: 					   [{'&gt;',
<a name="1639"/> 1639: 					     {'rem',
<a name="1640"/> 1640: 					      '$1', 5},
<a name="1641"/> 1641: 					     2}],
<a name="1642"/> 1642: 					   ['$_']}]),
<a name="1643"/> 1643: 		      B = ets:select_reverse(Tab,[{{'$1', '_'},
<a name="1644"/> 1644: 						   [{'&gt;',
<a name="1645"/> 1645: 						     {'rem',
<a name="1646"/> 1646: 						      '$1', 5},
<a name="1647"/> 1647: 						     2}],
<a name="1648"/> 1648: 						   ['$_']}])
<a name="1649"/> 1649: 	      end,[Table2, Table3, Table4]),
<a name="t_select_reverse-last_expr"/><a name="1650"/> 1650:     ok.
<a name="1651"/> 1651: 
<a name="1652"/> 1652: 
<a name="1653"/> 1653: 
<a name="reverse_chunked-3"/><a name="1654"/> 1654: <b>reverse_chunked</b>(T,MS,N) -&gt;
<a name="reverse_chunked-last_expr"/><a name="1655"/> 1655: <b>    do_reverse_chunked</b>(ets:select_reverse(T,MS,N),[]).
<a name="1656"/> 1656: 
<a name="do_reverse_chunked-2"/><a name="1657"/> 1657: <b>do_reverse_chunked</b>('$end_of_table',Acc) -&gt;
<a name="1658"/> 1658:     lists:reverse(Acc);
<a name="1659"/> 1659: <b>do_reverse_chunked</b>({L,C},Acc) -&gt;
<a name="1660"/> 1660:     NewAcc = lists:reverse(L)++Acc,
<a name="do_reverse_chunked-last_expr"/><a name="1661"/> 1661: <b>    do_reverse_chunked</b>(ets:select_reverse(C), NewAcc).
<a name="1662"/> 1662: 
<a name="1663"/> 1663: 
<a name="1664"/> 1664: <i>%% Test the ets:select_delete/2 and ets:select_count/2 BIFs.</i>
<a name="t_select_delete-1"/><a name="1665"/> 1665: <b>t_select_delete</b>(Config) when is_list(Config) -&gt;
<a name="1666"/> 1666:     ct:timetrap({minutes,30}), %% valgrind needs a lot
<a name="1667"/> 1667:     EtsMem = etsmem(),
<a name="1668"/> 1668:     Tables = fill_sets_int(10000) ++ fill_sets_int(10000,[{write_concurrency,true}]),
<a name="1669"/> 1669:     lists:foreach
<a name="1670"/> 1670:       (fun(Table) -&gt;
<a name="1671"/> 1671: 	       4000 = ets:select_count(Table,[{{'$1', '_'},
<a name="1672"/> 1672: 					       [{'&gt;',
<a name="1673"/> 1673: 						 {'rem',
<a name="1674"/> 1674: 						  '$1', 5},
<a name="1675"/> 1675: 						 2}],
<a name="1676"/> 1676: 					       [true]}]),
<a name="1677"/> 1677: 	       4000 = ets:select_delete(Table,[{{'$1', '_'},
<a name="1678"/> 1678: 						[{'&gt;',
<a name="1679"/> 1679: 						  {'rem',
<a name="1680"/> 1680: 						   '$1', 5},
<a name="1681"/> 1681: 						  2}],
<a name="1682"/> 1682: 						[true]}]),
<a name="1683"/> 1683: 	       check(Table,
<a name="1684"/> 1684: 		     fun({N,_}) when (N rem 5) =&lt; 2 -&gt;
<a name="1685"/> 1685: 			     true;
<a name="1686"/> 1686: 			(_) -&gt;
<a name="1687"/> 1687: 			     false
<a name="1688"/> 1688: 		     end,
<a name="1689"/> 1689: 		     6000)
<a name="1690"/> 1690: 
<a name="1691"/> 1691:        end,
<a name="1692"/> 1692:        Tables),
<a name="1693"/> 1693:     lists:foreach
<a name="1694"/> 1694:       (fun(Table) -&gt;
<a name="1695"/> 1695: 	       ets:select_delete(Table,[{'_',[],[true]}]),
<a name="1696"/> 1696: 	       xfilltabint(Table,4000),
<a name="1697"/> 1697: 	       successive_delete(Table,1,4001,bound),
<a name="1698"/> 1698: 	       0 = ets:info(Table,size),
<a name="1699"/> 1699: 	       xfilltabint(Table,4000),
<a name="1700"/> 1700: 	       successive_delete(Table,4000,0, bound),
<a name="1701"/> 1701: 	       0 = ets:info(Table,size),
<a name="1702"/> 1702: 	       xfilltabint(Table,4000),
<a name="1703"/> 1703: 	       successive_delete(Table,1,4001,unbound),
<a name="1704"/> 1704: 	       0 = ets:info(Table,size),
<a name="1705"/> 1705: 	       xfilltabint(Table,4000),
<a name="1706"/> 1706: 	       successive_delete(Table,4000,0, unbound),
<a name="1707"/> 1707: 	       0 = ets:info(Table,size)
<a name="1708"/> 1708: 
<a name="1709"/> 1709:        end,
<a name="1710"/> 1710:        Tables),
<a name="1711"/> 1711:     lists:foreach
<a name="1712"/> 1712:       (fun(Table) -&gt;
<a name="1713"/> 1713: 	       F = case ets:info(Table,type) of
<a name="1714"/> 1714: 		       X when X == bag; X == duplicate_bag -&gt;
<a name="1715"/> 1715: 			   2;
<a name="1716"/> 1716: 		       _ -&gt; 
<a name="1717"/> 1717: 			   1
<a name="1718"/> 1718: 		   end,
<a name="1719"/> 1719: 	       xfilltabstr(Table, 4000),
<a name="1720"/> 1720: 	       1000 = ets:select_count(Table,
<a name="1721"/> 1721: 				       [{{[$3 | '$1'], '_'},
<a name="1722"/> 1722: 					 [{'==',
<a name="1723"/> 1723: 					   {'length', '$1'},
<a name="1724"/> 1724: 					   3}],[true]}]) div F,
<a name="1725"/> 1725: 	       1000 = ets:select_delete(Table,
<a name="1726"/> 1726: 					[{{[$3 | '$1'], '_'},
<a name="1727"/> 1727: 					  [{'==',
<a name="1728"/> 1728: 					    {'length', '$1'},
<a name="1729"/> 1729: 					    3}],[true]}]) div F,
<a name="1730"/> 1730: 	       check(Table, fun({[3,_,_,_],_}) -&gt; false;
<a name="1731"/> 1731: 			       (_) -&gt; true
<a name="1732"/> 1732: 			    end, 3000*F),
<a name="1733"/> 1733: 	       8 = ets:select_count(Table,
<a name="1734"/> 1734: 				    [{{&quot;7&quot;,'_'},[],[false]},
<a name="1735"/> 1735: 				     {{['_'], '_'},
<a name="1736"/> 1736: 				      [],[true]}]) div F,
<a name="1737"/> 1737: 	       8 = ets:select_delete(Table,
<a name="1738"/> 1738: 				     [{{&quot;7&quot;,'_'},[],[false]},
<a name="1739"/> 1739: 				      {{['_'], '_'},
<a name="1740"/> 1740: 				       [],[true]}]) div F,
<a name="1741"/> 1741: 	       check(Table, fun({&quot;7&quot;,_}) -&gt; true;
<a name="1742"/> 1742: 			       ({[_],_}) -&gt; false;
<a name="1743"/> 1743: 			       (_) -&gt; true
<a name="1744"/> 1744: 			    end, 2992*F),
<a name="1745"/> 1745: 	       xfilltabstr(Table, 4000),
<a name="1746"/> 1746: 	       %% This happens to be interesting for other select types too
<a name="1747"/> 1747: 	       200 = length(ets:select(Table,
<a name="1748"/> 1748: 				       [{{[$3,'_','_'],'_'},
<a name="1749"/> 1749: 					 [],[true]},
<a name="1750"/> 1750: 					{{[$1,'_','_'],'_'},
<a name="1751"/> 1751: 					 [],[true]}])) div F,
<a name="1752"/> 1752: 	       200 = ets:select_count(Table,
<a name="1753"/> 1753: 				      [{{[$3,'_','_'],'_'},
<a name="1754"/> 1754: 					[],[true]},
<a name="1755"/> 1755: 				       {{[$1,'_','_'],'_'},
<a name="1756"/> 1756: 					[],[true]}]) div F,
<a name="1757"/> 1757: 	       200 = length(element(1,ets:select(Table,
<a name="1758"/> 1758: 						 [{{[$3,'_','_'],'_'},
<a name="1759"/> 1759: 						   [],[true]},
<a name="1760"/> 1760: 						  {{[$1,'_','_'],'_'},
<a name="1761"/> 1761: 						   [],[true]}],
<a name="1762"/> 1762: 						 1000))) div F,
<a name="1763"/> 1763: 	       200 = length(
<a name="1764"/> 1764: 		       ets:select_reverse(Table,
<a name="1765"/> 1765: 					  [{{[$3,'_','_'],'_'},
<a name="1766"/> 1766: 					    [],[true]},
<a name="1767"/> 1767: 					   {{[$1,'_','_'],'_'},
<a name="1768"/> 1768: 					    [],[true]}])) div F,
<a name="1769"/> 1769: 	       200 = length(
<a name="1770"/> 1770: 		       element(1,
<a name="1771"/> 1771: 			       ets:select_reverse
<a name="1772"/> 1772: 				 (Table,
<a name="1773"/> 1773: 				  [{{[$3,'_','_'],'_'},
<a name="1774"/> 1774: 				    [],[true]},
<a name="1775"/> 1775: 				   {{[$1,'_','_'],'_'},
<a name="1776"/> 1776: 				    [],[true]}],
<a name="1777"/> 1777: 				  1000))) div F,
<a name="1778"/> 1778: 	       200 = ets:select_delete(Table,
<a name="1779"/> 1779: 				       [{{[$3,'_','_'],'_'},
<a name="1780"/> 1780: 					 [],[true]},
<a name="1781"/> 1781: 					{{[$1,'_','_'],'_'},
<a name="1782"/> 1782: 					 [],[true]}]) div F,
<a name="1783"/> 1783: 	       0 = ets:select_count(Table,
<a name="1784"/> 1784: 				    [{{[$3,'_','_'],'_'},
<a name="1785"/> 1785: 				      [],[true]},
<a name="1786"/> 1786: 				     {{[$1,'_','_'],'_'},
<a name="1787"/> 1787: 				      [],[true]}]) div F,
<a name="1788"/> 1788: 	       check(Table, fun({[$3,_,_],_}) -&gt; false;
<a name="1789"/> 1789: 			       ({[$1,_,_],_}) -&gt; false;
<a name="1790"/> 1790: 			       (_) -&gt; true
<a name="1791"/> 1791: 			    end, 3800*F)
<a name="1792"/> 1792:        end,
<a name="1793"/> 1793:        Tables),
<a name="1794"/> 1794:     lists:foreach(fun(Tab) -&gt; ets:delete(Tab) end,Tables),
<a name="t_select_delete-last_expr"/><a name="1795"/> 1795: <b>    verify_etsmem</b>(EtsMem).
<a name="1796"/> 1796: 
<a name="1797"/> 1797: <i>%% Tests the ets:select_replace/2 BIF</i>
<a name="t_select_replace-1"/><a name="1798"/> 1798: <b>t_select_replace</b>(Config) when is_list(Config) -&gt;
<a name="1799"/> 1799:     EtsMem = etsmem(),
<a name="1800"/> 1800:     repeat_for_opts(fun do_select_replace/1),
<a name="t_select_replace-last_expr"/><a name="1801"/> 1801: <b>    verify_etsmem</b>(EtsMem).
<a name="1802"/> 1802: 
<a name="do_select_replace-1"/><a name="1803"/> 1803: <b>do_select_replace</b>(Opts) -&gt;
<a name="1804"/> 1804:     Tables = fill_sets_intup(10000, Opts),
<a name="1805"/> 1805: 
<a name="1806"/> 1806:     TestFun = fun (Table, TableType) when TableType =:= bag -&gt;
<a name="1807"/> 1807:                       % Operation not supported; bag implementation
<a name="1808"/> 1808:                       % presented both semantic consistency and performance issues.
<a name="1809"/> 1809:                       10000 = ets:select_delete(Table, [{'_',[],[true]}]);
<a name="1810"/> 1810: 
<a name="1811"/> 1811:                   (Table, TableType) -&gt;
<a name="1812"/> 1812:                       % Invalid replacement doesn't keep the key
<a name="1813"/> 1813:                       MatchSpec1 = [{{{'$1','$3'}, '$2'},
<a name="1814"/> 1814:                                      [{'=:=', {'band', '$1', 2#11}, 2#11},
<a name="1815"/> 1815:                                       {'=/=', {'hd', '$2'}, $x}],
<a name="1816"/> 1816:                                      [{{{{'$2','$3'}}, '$1'}}]}],
<a name="1817"/> 1817:                       {'EXIT',{badarg,_}} = (catch ets:select_replace(Table, MatchSpec1)),
<a name="1818"/> 1818: 
<a name="1819"/> 1819:                       % Invalid replacement doesn't keep the key (even though it would be the same value)
<a name="1820"/> 1820:                       MatchSpec2 = [{{{'$1','$3'}, '$2'},
<a name="1821"/> 1821:                                      [{'=:=', {'band', '$1', 2#11}, 2#11}],
<a name="1822"/> 1822:                                      [{{{{{'+', '$1', 0},'$3'}}, '$2'}}]},
<a name="1823"/> 1823:                                     {{{'$1','$3'}, '$2'},
<a name="1824"/> 1824:                                      [{'=/=', {'band', '$1', 2#11}, 2#11}],
<a name="1825"/> 1825:                                      [{{{{{'-', '$1', 0},'$3'}}, '$2'}}]}],
<a name="1826"/> 1826:                       {'EXIT',{badarg,_}} = (catch ets:select_replace(Table, MatchSpec2)),
<a name="1827"/> 1827: 
<a name="1828"/> 1828:                       % Invalid replacement changes key to float equivalent
<a name="1829"/> 1829:                       MatchSpec3 = [{{{'$1','$3'}, '$2'},
<a name="1830"/> 1830:                                      [{'=:=', {'band', '$1', 2#11}, 2#11},
<a name="1831"/> 1831:                                       {'=/=', {'hd', '$2'}, $x}],
<a name="1832"/> 1832:                                      [{{{{{'*', '$1', 1.0},'$3'}}, '$2'}}]}],
<a name="1833"/> 1833:                       {'EXIT',{badarg,_}} = (catch ets:select_replace(Table, MatchSpec3)),
<a name="1834"/> 1834: 
<a name="1835"/> 1835:                       % Replacements are differently-sized tuples
<a name="1836"/> 1836:                       MatchSpec4_A = [{{{'$1','$3'},'$2'},
<a name="1837"/> 1837:                                        [{'&lt;', {'rem', '$1', 5}, 2}],
<a name="1838"/> 1838:                                        [{{{{'$1','$3'}}, [$x | '$2'], stuff}}]}],
<a name="1839"/> 1839:                       MatchSpec4_B = [{{{'$1','$3'},'$2','_'},
<a name="1840"/> 1840:                                        [],
<a name="1841"/> 1841:                                        [{{{{'$1','$3'}},'$2'}}]}],
<a name="1842"/> 1842:                       4000 = ets:select_replace(Table, MatchSpec4_A),
<a name="1843"/> 1843:                       4000 = ets:select_replace(Table, MatchSpec4_B),
<a name="1844"/> 1844: 
<a name="1845"/> 1845:                       % Replacement is the same tuple
<a name="1846"/> 1846:                       MatchSpec5 = [{{{'$1','$3'}, '$2'},
<a name="1847"/> 1847:                                      [{'&gt;', {'rem', '$1', 5}, 3}],
<a name="1848"/> 1848:                                      ['$_']}],
<a name="1849"/> 1849:                       2000 = ets:select_replace(Table, MatchSpec5),
<a name="1850"/> 1850: 
<a name="1851"/> 1851:                       % Replacement reconstructs an equal tuple
<a name="1852"/> 1852:                       MatchSpec6 = [{{{'$1','$3'}, '$2'},
<a name="1853"/> 1853:                                      [{'&gt;', {'rem', '$1', 5}, 3}],
<a name="1854"/> 1854:                                      [{{{{'$1','$3'}}, '$2'}}]}],
<a name="1855"/> 1855:                       2000 = ets:select_replace(Table, MatchSpec6),
<a name="1856"/> 1856: 
<a name="1857"/> 1857:                       % Replacement uses {element,KeyPos,T} for key
<a name="1858"/> 1858:                       2000 = ets:select_replace(Table,
<a name="1859"/> 1859:                                                 [{{{'$1','$3'}, '$2'},
<a name="1860"/> 1860:                                                   [{'&gt;', {'rem', '$1', 5}, 3}],
<a name="1861"/> 1861:                                                   [{{{element, 1, '$_'}, '$2'}}]}]),
<a name="1862"/> 1862: 
<a name="1863"/> 1863:                       % Replacement uses wrong {element,KeyPos,T} for key
<a name="1864"/> 1864:                       {'EXIT',{badarg,_}} = (catch ets:select_replace(Table,
<a name="1865"/> 1865:                                                                      [{{{'$1','$3'}, '$2'},
<a name="1866"/> 1866:                                                                        [],
<a name="1867"/> 1867:                                                                        [{{{element, 2, '$_'}, '$2'}}]}])),
<a name="1868"/> 1868: 
<a name="1869"/> 1869:                       check(Table,
<a name="1870"/> 1870:                             fun ({{N,_}, [$x, C | _]}) when ((N rem 5) &lt; 2) -&gt; (C &gt;= $0) andalso (C =&lt; $9);
<a name="1871"/> 1871:                                 ({{N,_}, [C | _]}) when is_float(N) -&gt; (C &gt;= $0) andalso (C =&lt; $9);
<a name="1872"/> 1872:                                 ({{N,_}, [C | _]}) when ((N rem 5) &gt; 3) -&gt; (C &gt;= $0) andalso (C =&lt; $9);
<a name="1873"/> 1873:                                 ({_, [C | _]}) -&gt; (C &gt;= $0) andalso (C =&lt; $9)
<a name="1874"/> 1874:                             end,
<a name="1875"/> 1875:                             10000),
<a name="1876"/> 1876: 
<a name="1877"/> 1877:                       % Replace unbound range (&gt;)
<a name="1878"/> 1878:                       MatchSpec7 = [{{{'$1','$3'}, '$2'},
<a name="1879"/> 1879:                                      [{'&gt;', '$1', 7000}],
<a name="1880"/> 1880:                                      [{{{{'$1','$3'}}, {{gt_range, '$2'}}}}]}],
<a name="1881"/> 1881:                       3000 = ets:select_replace(Table, MatchSpec7),
<a name="1882"/> 1882: 
<a name="1883"/> 1883:                       % Replace unbound range (&lt;)
<a name="1884"/> 1884:                       MatchSpec8 = [{{{'$1','$3'}, '$2'},
<a name="1885"/> 1885:                                      [{'&lt;', '$1', 3000}],
<a name="1886"/> 1886:                                      [{{{{'$1','$3'}}, {{le_range, '$2'}}}}]}],
<a name="1887"/> 1887:                       case TableType of
<a name="1888"/> 1888:                           ordered_set -&gt;   2999 = ets:select_replace(Table, MatchSpec8);
<a name="1889"/> 1889:                           set -&gt;           2999 = ets:select_replace(Table, MatchSpec8);
<a name="1890"/> 1890:                           duplicate_bag -&gt; 2998 = ets:select_replace(Table, MatchSpec8)
<a name="1891"/> 1891:                       end,
<a name="1892"/> 1892: 
<a name="1893"/> 1893:                       % Replace bound range
<a name="1894"/> 1894:                       MatchSpec9 = [{{{'$1','$3'}, '$2'},
<a name="1895"/> 1895:                                      [{'&gt;=', '$1', 3001},
<a name="1896"/> 1896:                                       {'&lt;', '$1', 7000}],
<a name="1897"/> 1897:                                      [{{{{'$1','$3'}}, {{range, '$2'}}}}]}],
<a name="1898"/> 1898:                       case TableType of
<a name="1899"/> 1899:                           ordered_set -&gt;   3999 = ets:select_replace(Table, MatchSpec9);
<a name="1900"/> 1900:                           set -&gt;           3999 = ets:select_replace(Table, MatchSpec9);
<a name="1901"/> 1901:                           duplicate_bag -&gt; 3998 = ets:select_replace(Table, MatchSpec9)
<a name="1902"/> 1902:                       end,
<a name="1903"/> 1903: 
<a name="1904"/> 1904:                       % Replace particular keys
<a name="1905"/> 1905:                       MatchSpec10 = [{{{'$1','$3'}, '$2'},
<a name="1906"/> 1906:                                      [{'==', '$1', 3000}],
<a name="1907"/> 1907:                                      [{{{{'$1','$3'}}, {{specific1, '$2'}}}}]},
<a name="1908"/> 1908:                                     {{{'$1','$3'}, '$2'},
<a name="1909"/> 1909:                                      [{'==', '$1', 7000}],
<a name="1910"/> 1910:                                      [{{{{'$1','$3'}}, {{specific2, '$2'}}}}]}],
<a name="1911"/> 1911:                       case TableType of
<a name="1912"/> 1912:                           ordered_set -&gt;   2 = ets:select_replace(Table, MatchSpec10);
<a name="1913"/> 1913:                           set -&gt;           2 = ets:select_replace(Table, MatchSpec10);
<a name="1914"/> 1914:                           duplicate_bag -&gt; 4 = ets:select_replace(Table, MatchSpec10)
<a name="1915"/> 1915:                       end,
<a name="1916"/> 1916: 
<a name="1917"/> 1917:                       check(Table,
<a name="1918"/> 1918:                             fun ({{N,_}, {gt_range, _}}) -&gt; N &gt; 7000;
<a name="1919"/> 1919:                                 ({{N,_}, {le_range, _}}) -&gt; N &lt; 3000;
<a name="1920"/> 1920:                                 ({{N,_}, {range, _}}) -&gt; (N &gt;= 3001) andalso (N &lt; 7000);
<a name="1921"/> 1921:                                 ({{N,_}, {specific1, _}}) -&gt; N == 3000;
<a name="1922"/> 1922:                                 ({{N,_}, {specific2, _}}) -&gt; N == 7000
<a name="1923"/> 1923:                             end,
<a name="1924"/> 1924:                             10000),
<a name="1925"/> 1925: 
<a name="1926"/> 1926:                       10000 = ets:select_delete(Table, [{'_',[],[true]}]),
<a name="1927"/> 1927:                       check(Table, fun (_) -&gt; false end, 0)
<a name="1928"/> 1928:               end,
<a name="1929"/> 1929: 
<a name="1930"/> 1930:     lists:foreach(
<a name="1931"/> 1931:       fun(Table) -&gt;
<a name="1932"/> 1932:               TestFun(Table, ets:info(Table, type)),
<a name="1933"/> 1933:               ets:delete(Table)
<a name="1934"/> 1934:       end,
<a name="1935"/> 1935:       Tables),
<a name="1936"/> 1936: 
<a name="1937"/> 1937:     %% Test key-safe match-specs are accepted
<a name="1938"/> 1938:     BigNum = (123 bsl 123),
<a name="1939"/> 1939:     RefcBin = list_to_binary(lists:seq(1,?heap_binary_size+1)),
<a name="1940"/> 1940:     Terms = [a, &quot;hej&quot;, 123, 1.23, BigNum , &lt;&lt;&quot;123&quot;&gt;&gt;, RefcBin, TestFun, self()],
<a name="1941"/> 1941:     EqPairs = fun(X,Y) -&gt;
<a name="1942"/> 1942:                       [{ '$1', '$1'},
<a name="1943"/> 1943:                        { {X, Y}, {{X, Y}}},
<a name="1944"/> 1944:                        { {'$1', Y}, {{'$1', Y}}},
<a name="1945"/> 1945:                        { {{X, Y}}, {{{{X, Y}}}}},
<a name="1946"/> 1946:                        { {X}, {{X}}},
<a name="1947"/> 1947:                        { X, {const, X}},
<a name="1948"/> 1948:                        { {X,Y}, {const, {X,Y}}},
<a name="1949"/> 1949:                        { {X}, {const, {X}}},
<a name="1950"/> 1950:                        { {X, Y}, {{X, {const, Y}}}},
<a name="1951"/> 1951:                        { {X, {Y,'$1'}}, {{{const, X}, {{Y,'$1'}}}}},
<a name="1952"/> 1952:                        { [X, Y | '$1'], [X, Y | '$1']},
<a name="1953"/> 1953:                        { [{X, '$1'}, Y], [{{X, '$1'}}, Y]},
<a name="1954"/> 1954:                        { [{X, Y} | '$1'], [{const, {X, Y}} | '$1']},
<a name="1955"/> 1955:                        { [$p,$r,$e,$f,$i,$x | '$1'], [$p,$r,$e,$f,$i,$x | '$1']},
<a name="1956"/> 1956:                        { {[{X,Y}]}, {{[{{X,Y}}]}}},
<a name="1957"/> 1957:                        { {[{X,Y}]}, {{{const, [{X,Y}]}}}},
<a name="1958"/> 1958:                        { {[{X,Y}]}, {{[{const,{X,Y}}]}}}
<a name="1959"/> 1959:                       ]
<a name="1960"/> 1960:               end,
<a name="1961"/> 1961: 
<a name="1962"/> 1962:     T2 = ets:new(x, Opts),
<a name="1963"/> 1963:     [lists:foreach(fun({A, B}) -&gt;
<a name="1964"/> 1964:                            %% just check that matchspec is accepted
<a name="1965"/> 1965:                            0 = ets:select_replace(T2, [{{A, '$2', '$3'}, [], [{{B, '$3', '$2'}}]}])
<a name="1966"/> 1966:                    end,
<a name="1967"/> 1967:                    EqPairs(X,Y)) || X &lt;- Terms, Y &lt;- Terms],
<a name="1968"/> 1968: 
<a name="1969"/> 1969:     %% Test key-unsafe matchspecs are rejected
<a name="1970"/> 1970:     NeqPairs = fun(X, Y) -&gt;
<a name="1971"/> 1971:                       [{'$1', '$2'},
<a name="1972"/> 1972:                        {{X, Y}, {X, Y}},
<a name="1973"/> 1973:                        {{{X, Y}}, {{{X, Y}}}},
<a name="1974"/> 1974:                        {{X}, {{{X}}}},
<a name="1975"/> 1975:                        {{const, X}, {const, X}},
<a name="1976"/> 1976:                        {{const, {X,Y}}, {const, {X,Y}}},
<a name="1977"/> 1977:                        {'$1', {const, '$1'}},
<a name="1978"/> 1978:                        {{X}, {const, {{X}}}},
<a name="1979"/> 1979:                        {{X, {Y,'$1'}}, {{{const, X}, {Y,'$1'}}}},
<a name="1980"/> 1980:                        {[X, Y | '$1'], [X, Y]},
<a name="1981"/> 1981:                        {[X, Y], [X, Y | '$1']},
<a name="1982"/> 1982:                        {[{X, '$1'}, Y], [{X, '$1'}, Y]},
<a name="1983"/> 1983:                        {[$p,$r,$e,$f,$i,$x | '$1'], [$p,$r,$e,$f,$I,$x | '$1']},
<a name="1984"/> 1984:                        { {[{X,Y}]}, {{[{X,Y}]}}},
<a name="1985"/> 1985:                        { {[{X,Y}]}, {{{const, [{{X,Y}}]}}}},
<a name="1986"/> 1986:                        { {[{X,Y}]}, {{[{const,{{X,Y}}}]}}},
<a name="1987"/> 1987:                        {'_', '_'},
<a name="1988"/> 1988:                        {'$_', '$_'},
<a name="1989"/> 1989:                        {'$$', '$$'},
<a name="1990"/> 1990:                        {#{}, #{}},
<a name="1991"/> 1991:                        {#{X =&gt; '$1'}, #{X =&gt; '$1'}}
<a name="1992"/> 1992:                       ]
<a name="1993"/> 1993:               end,
<a name="1994"/> 1994: 
<a name="1995"/> 1995:     [lists:foreach(fun({A, B}) -&gt;
<a name="1996"/> 1996:                            %% just check that matchspec is rejected
<a name="1997"/> 1997:                            {'EXIT',{badarg,_}} = (catch ets:select_replace(T2, [{{A, '$2', '$3'}, [], [{{B, '$3', '$2'}}]}]))
<a name="1998"/> 1998:                    end,
<a name="1999"/> 1999:                    NeqPairs(X,Y)) || X &lt;- Terms, Y &lt;- Terms],
<a name="2000"/> 2000: 
<a name="2001"/> 2001: 
<a name="2002"/> 2002:     %% Wrap entire tuple with 'const'
<a name="2003"/> 2003:     [[begin
<a name="2004"/> 2004:           Old = {Key, 1, 2},
<a name="2005"/> 2005:           ets:insert(T2, Old),
<a name="2006"/> 2006:           1 = ets:select_replace(T2, [{Old, [], [{const, New}]}]),
<a name="2007"/> 2007:           [New] = ets:lookup(T2, Key),
<a name="2008"/> 2008:           ets:delete(T2, Key)
<a name="2009"/> 2009:       end || New &lt;- [{Key, 1, 2}, {Key, 3, 4}, {Key, 1}, {Key, 1, 2, 3}, {Key}]
<a name="2010"/> 2010:      ]
<a name="2011"/> 2011:      || Key &lt;- [{1, tuple}, {nested, {tuple, {a,b}}} | Terms]],
<a name="2012"/> 2012: 
<a name="2013"/> 2013:     %% 'const' wrap does not work with maps or variables in keys
<a name="2014"/> 2014:     [[begin
<a name="2015"/> 2015:           Old = {Key, 1, 2},
<a name="2016"/> 2016:           {'EXIT',{badarg,_}} = (catch ets:select_replace(T2, [{Old, [], [{const, New}]}]))
<a name="2017"/> 2017:       end || New &lt;- [{Key, 1, 2}, {Key, 3, 4}, {Key, 1}, {Key, 1, 2, 3}, {Key}]
<a name="2018"/> 2018:      ]
<a name="2019"/> 2019:      || Key &lt;- [#{a =&gt; 1}, {nested, #{a =&gt; 1}}, '$1']],
<a name="2020"/> 2020: 
<a name="2021"/> 2021: 
<a name="2022"/> 2022:     ets:delete(T2),
<a name="do_select_replace-last_expr"/><a name="2023"/> 2023:     ok.
<a name="2024"/> 2024: 
<a name="2025"/> 2025: <i>%% OTP-15346: Bug caused select_replace of bound key to corrupt static stack</i>
<a name="2026"/> 2026: <i>%% used by ets:next and ets:prev.</i>
<a name="t_select_replace_next_bug-1"/><a name="2027"/> 2027: <b>t_select_replace_next_bug</b>(Config) when is_list(Config) -&gt;
<a name="2028"/> 2028:     T = ets:new(k, [ordered_set]),
<a name="2029"/> 2029:     [ets:insert(T, {I, value}) || I &lt;- lists:seq(1,10)],
<a name="2030"/> 2030:     1 = ets:first(T),
<a name="2031"/> 2031: 
<a name="2032"/> 2032:     %% Make sure select_replace does not leave pointer
<a name="2033"/> 2033:     %% to deallocated {2,value} in static stack.
<a name="2034"/> 2034:     MS = [{{2,value}, [], [{{2,&quot;new_value&quot;}}]}],
<a name="2035"/> 2035:     1 = ets:select_replace(T, MS),
<a name="2036"/> 2036: 
<a name="2037"/> 2037:     %% This would crash or give wrong result at least on DEBUG emulator
<a name="2038"/> 2038:     %% where deallocated memory is overwritten.
<a name="2039"/> 2039:     2 = ets:next(T, 1),
<a name="2040"/> 2040: 
<a name="t_select_replace_next_bug-last_expr"/><a name="2041"/> 2041: <b>    ets:delete</b>(T).
<a name="2042"/> 2042: 
<a name="2043"/> 2043: 
<a name="2044"/> 2044: <i>%% OTP-17379</i>
<a name="t_select_pam_stack_overflow_bug-1"/><a name="2045"/> 2045: <b>t_select_pam_stack_overflow_bug</b>(_Config) -&gt;
<a name="2046"/> 2046:     T = ets:new(k, []),
<a name="2047"/> 2047:     ets:insert(T,[{x,17}]),
<a name="2048"/> 2048:     [{x,18}] = ets:select(T,[{{x,17}, [], [{{{element,1,'$_'},{const,18}}}]}]),
<a name="2049"/> 2049:     ets:delete(T),
<a name="t_select_pam_stack_overflow_bug-last_expr"/><a name="2050"/> 2050:     ok.
<a name="2051"/> 2051: 
<a name="2052"/> 2052: <i>%% When a variable was used as key in ms body, the matched value would</i>
<a name="2053"/> 2053: <i>%% not be copied to the heap of the calling process.</i>
<a name="t_select_flatmap_term_copy_bug-1"/><a name="2054"/> 2054: <b>t_select_flatmap_term_copy_bug</b>(_Config) -&gt;
<a name="2055"/> 2055:     T = ets:new(a,[]),
<a name="2056"/> 2056:     ets:insert(T, {list_to_binary(lists:duplicate(36,$a))}),
<a name="2057"/> 2057:     V1 = ets:select(T, [{{'$1'},[],[#{ '$1' =&gt; a }]}]),
<a name="2058"/> 2058:     erlang:garbage_collect(),
<a name="2059"/> 2059:     V1 = ets:select(T, [{{'$1'},[],[#{ '$1' =&gt; a }]}]),
<a name="2060"/> 2060:     erlang:garbage_collect(),
<a name="2061"/> 2061:     V2 = ets:select(T, [{{'$1'},[],[#{ a =&gt; '$1' }]}]),
<a name="2062"/> 2062:     erlang:garbage_collect(),
<a name="2063"/> 2063:     V2 = ets:select(T, [{{'$1'},[],[#{ a =&gt; '$1' }]}]),
<a name="2064"/> 2064:     erlang:garbage_collect(),
<a name="2065"/> 2065:     V3 = ets:select(T, [{{'$1'},[],[#{ '$1' =&gt; '$1' }]}]),
<a name="2066"/> 2066:     erlang:garbage_collect(),
<a name="2067"/> 2067:     V3 = ets:select(T, [{{'$1'},[],[#{ '$1' =&gt; '$1' }]}]),
<a name="2068"/> 2068:     erlang:garbage_collect(),
<a name="2069"/> 2069:     V4 = ets:select(T, [{{'$1'},[],[#{ a =&gt; a }]}]),
<a name="2070"/> 2070:     erlang:garbage_collect(),
<a name="2071"/> 2071:     V4 = ets:select(T, [{{'$1'},[],[#{ a =&gt; a }]}]),
<a name="2072"/> 2072:     erlang:garbage_collect(),
<a name="2073"/> 2073:     ets:delete(T),
<a name="t_select_flatmap_term_copy_bug-last_expr"/><a name="2074"/> 2074:     ok.
<a name="2075"/> 2075: 
<a name="2076"/> 2076: <i>%% When a variable was used as key or value in ms body,</i>
<a name="2077"/> 2077: <i>%% the matched value would not be copied to the heap of</i>
<a name="2078"/> 2078: <i>%% the calling process.</i>
<a name="t_select_hashmap_term_copy_bug-1"/><a name="2079"/> 2079: <b>t_select_hashmap_term_copy_bug</b>(_Config) -&gt;
<a name="2080"/> 2080: 
<a name="2081"/> 2081:     T = ets:new(a,[]),
<a name="2082"/> 2082:     Dollar1 = list_to_binary(lists:duplicate(36,$a)),
<a name="2083"/> 2083:     ets:insert(T, {Dollar1}),
<a name="2084"/> 2084: 
<a name="2085"/> 2085:     {LargeMapSize, FlatmapSize} =
<a name="2086"/> 2086:         case erlang:system_info(emu_type) of
<a name="2087"/> 2087:             debug -&gt; {40, 3};
<a name="2088"/> 2088:             _ -&gt; {250, 32}
<a name="2089"/> 2089:         end,
<a name="2090"/> 2090: 
<a name="2091"/> 2091:     LM = maps:from_keys(lists:seq(1,LargeMapSize), 1),
<a name="2092"/> 2092: 
<a name="2093"/> 2093:     lists:foreach(
<a name="2094"/> 2094:       fun(Key) -&gt;
<a name="2095"/> 2095:               V = ets:select(T, [{{'$1'},[], [LM#{ Key =&gt; '$1' }]}]),
<a name="2096"/> 2096:               erlang:garbage_collect(),
<a name="2097"/> 2097:               V = ets:select(T, [{{'$1'},[], [LM#{ Key =&gt; '$1' }]}]),
<a name="2098"/> 2098:               erlang:garbage_collect(),
<a name="2099"/> 2099: 
<a name="2100"/> 2100:               V = [LM#{ Key =&gt; Dollar1 }]
<a name="2101"/> 2101:       end, maps:keys(LM)),
<a name="2102"/> 2102:     
<a name="2103"/> 2103:     %% Create a hashmap with enough keys before and after the '$1' for it to
<a name="2104"/> 2104:     %% remain a hashmap when we remove those keys.
<a name="2105"/> 2105:     LMWithDollar = make_lm_with_dollar(LM#{ '$1' =&gt; a }, LargeMapSize, FlatmapSize),
<a name="2106"/> 2106: 
<a name="2107"/> 2107:     %% Test that hashmap with '$1' in first position works
<a name="2108"/> 2108:     %% We rely on that fact that maps:keys return the keys
<a name="2109"/> 2109:     %% in iteration order.
<a name="2110"/> 2110:     lists:foldl(
<a name="2111"/> 2111:       fun
<a name="2112"/> 2112:           (Key, M = #{ '$1' := A }) when map_size(M) &gt; FlatmapSize -&gt;
<a name="2113"/> 2113: 
<a name="2114"/> 2114:               V = ets:select(T, [{{'$1'},[], [M]}]),
<a name="2115"/> 2115:               erlang:garbage_collect(),
<a name="2116"/> 2116:               V = ets:select(T, [{{'$1'},[], [M]}]),
<a name="2117"/> 2117:               erlang:garbage_collect(),
<a name="2118"/> 2118: 
<a name="2119"/> 2119:               V = [(maps:remove('$1',M))#{ Dollar1 =&gt; A }],
<a name="2120"/> 2120: 
<a name="2121"/> 2121:               maps:remove(Key, M);
<a name="2122"/> 2122:           (_, M) when map_size(M) &gt; FlatmapSize -&gt;
<a name="2123"/> 2123:               M
<a name="2124"/> 2124:       end, LMWithDollar, maps:keys(LMWithDollar)),
<a name="2125"/> 2125: 
<a name="2126"/> 2126:     %% Test that hashmap with '$1' in last position works
<a name="2127"/> 2127:     %% We rely on that fact that maps:keys return the keys
<a name="2128"/> 2128:     %% in iteration order.
<a name="2129"/> 2129:     lists:foldl(
<a name="2130"/> 2130:       fun
<a name="2131"/> 2131:           (Key, M = #{ '$1' := A }) -&gt;
<a name="2132"/> 2132: 
<a name="2133"/> 2133:               V = ets:select(T, [{{'$1'},[], [M]}]),
<a name="2134"/> 2134:               erlang:garbage_collect(),
<a name="2135"/> 2135:               V = ets:select(T, [{{'$1'},[], [M]}]),
<a name="2136"/> 2136:               erlang:garbage_collect(),
<a name="2137"/> 2137: 
<a name="2138"/> 2138:               V = [(maps:remove('$1',M))#{ Dollar1 =&gt; A }],
<a name="2139"/> 2139: 
<a name="2140"/> 2140:               maps:remove(Key, M);
<a name="2141"/> 2141:           (_, M) when map_size(M) &gt; FlatmapSize -&gt;
<a name="2142"/> 2142:               M
<a name="2143"/> 2143:       end, LMWithDollar, lists:reverse(maps:keys(LMWithDollar))),
<a name="2144"/> 2144:     
<a name="2145"/> 2145:     %% Test hashmap with a key-value pair that are variable
<a name="2146"/> 2146:     V3 = ets:select(T, [{{'$1'},[], [LM#{ '$1' =&gt; '$1' }]}]),
<a name="2147"/> 2147:     erlang:garbage_collect(),
<a name="2148"/> 2148:     V3 = ets:select(T, [{{'$1'},[], [LM#{ '$1' =&gt; '$1' }]}]),
<a name="2149"/> 2149:     erlang:garbage_collect(),
<a name="2150"/> 2150: 
<a name="2151"/> 2151:     V3 = [LM#{ Dollar1 =&gt; Dollar1 }],
<a name="2152"/> 2152: 
<a name="2153"/> 2153:     %% Test hashmap with all constant keys and values
<a name="2154"/> 2154:     V4 = ets:select(T, [{{'$1'},[], [LM#{ a =&gt; a }]}]),
<a name="2155"/> 2155:     erlang:garbage_collect(),
<a name="2156"/> 2156:     V4 = ets:select(T, [{{'$1'},[], [LM#{ a =&gt; a }]}]),
<a name="2157"/> 2157:     erlang:garbage_collect(),
<a name="2158"/> 2158: 
<a name="2159"/> 2159:     V4 = [LM#{ a =&gt; a }],
<a name="2160"/> 2160: 
<a name="2161"/> 2161:     ets:delete(T),
<a name="t_select_hashmap_term_copy_bug-last_expr"/><a name="2162"/> 2162:     ok.
<a name="2163"/> 2163: 
<a name="2164"/> 2164: <i>%% Create a hashmap that always has FlatmapSize keys before and after '$1'.</i>
<a name="2165"/> 2165: <i>%% Since the atom index of '$1' is used as hash, we cannot know before the</i>
<a name="2166"/> 2166: <i>%% code is run where exactly it will be placed, so in the rare cases when</i>
<a name="2167"/> 2167: <i>%% there isn't enough keys in the map, we insert more until there are enough.</i>
<a name="make_lm_with_dollar-3"/><a name="2168"/> 2168: <b>make_lm_with_dollar</b>(Map, LargeMapSize, FlatmapSize) -&gt;
<a name="2169"/> 2169:     {KeysBefore, KeysAfter} = lists:splitwith(fun erlang:is_integer/1, maps:keys(Map)),
<a name="make_lm_with_dollar-last_expr"/><a name="2170"/> 2170: <b>    if length</b>(KeysBefore) =&lt; FlatmapSize;
<a name="2171"/> 2171:        length(KeysAfter) - 1 =&lt; FlatmapSize -&gt;
<a name="2172"/> 2172:             NewMap = maps:from_keys(lists:seq(LargeMapSize, LargeMapSize*2), 1),
<a name="2173"/> 2173:             make_lm_with_dollar(maps:merge(Map, NewMap), LargeMapSize*2, FlatmapSize);
<a name="2174"/> 2174:        true -&gt;
<a name="2175"/> 2175:             Map
<a name="2176"/> 2176:     end.
<a name="2177"/> 2177: 
<a name="2178"/> 2178: <i>%% Test that partly bound keys gives faster matches.</i>
<a name="partly_bound-1"/><a name="2179"/> 2179: <b>partly_bound</b>(Config) when is_list(Config) -&gt;
<a name="partly_bound-last_expr"/><a name="2180"/> 2180: <b>    case os:type</b>() of
<a name="2181"/> 2181: 	{win32,_} -&gt;
<a name="2182"/> 2182: 	    {skip,&quot;Inaccurate measurements on Windows&quot;};
<a name="2183"/> 2183: 	_ -&gt;
<a name="2184"/> 2184: 	    EtsMem = etsmem(),
<a name="2185"/> 2185: 	    dont_make_worse(),
<a name="2186"/> 2186: 	    make_better(),
<a name="2187"/> 2187: 	    verify_etsmem(EtsMem)
<a name="2188"/> 2188:     end.
<a name="2189"/> 2189: 
<a name="dont_make_worse-0"/><a name="2190"/> 2190: <b>dont_make_worse</b>() -&gt;
<a name="dont_make_worse-last_expr"/><a name="2191"/> 2191: <b>    seventyfive_percent_success</b>(fun dont_make_worse_sub/0, 0, 0, 10).
<a name="2192"/> 2192: 
<a name="dont_make_worse_sub-0"/><a name="2193"/> 2193: <b>dont_make_worse_sub</b>() -&gt;
<a name="2194"/> 2194:     T = build_table([a,b],[a,b],15000),
<a name="2195"/> 2195:     T1 = time_match_object(T,{'_',a,a,1500}, [{{a,a,1500},a,a,1500}]),
<a name="2196"/> 2196:     T2 = time_match_object(T,{{a,a,'_'},a,a,1500},
<a name="2197"/> 2197: 			   [{{a,a,1500},a,a,1500}]),
<a name="2198"/> 2198:     ets:delete(T),
<a name="2199"/> 2199:     true = (T1 &gt; T2),
<a name="dont_make_worse_sub-last_expr"/><a name="2200"/> 2200:     ok.
<a name="2201"/> 2201: 
<a name="make_better-0"/><a name="2202"/> 2202: <b>make_better</b>() -&gt;
<a name="2203"/> 2203:     fifty_percent_success(fun make_better_sub2/0, 0, 0, 10),
<a name="make_better-last_expr"/><a name="2204"/> 2204: <b>    fifty_percent_success</b>(fun make_better_sub1/0, 0, 0, 10).
<a name="2205"/> 2205: 
<a name="make_better_sub1-0"/><a name="2206"/> 2206: <b>make_better_sub1</b>() -&gt;
<a name="2207"/> 2207:     T = build_table2([a,b],[a,b],15000),
<a name="2208"/> 2208:     T1 = time_match_object(T,{'_',1500,a,a}, [{{1500,a,a},1500,a,a}]),
<a name="2209"/> 2209:     T2 = time_match_object(T,{{1500,a,'_'},1500,a,a},
<a name="2210"/> 2210: 			   [{{1500,a,a},1500,a,a}]),
<a name="2211"/> 2211:     ets:delete(T),
<a name="2212"/> 2212:     io:format(&quot;~p&gt;~p~n&quot;,[(T1 / 100),T2]),
<a name="2213"/> 2213:     true = ((T1 / 100) &gt; T2), % More marginal than needed.
<a name="make_better_sub1-last_expr"/><a name="2214"/> 2214:     ok.
<a name="2215"/> 2215: 
<a name="make_better_sub2-0"/><a name="2216"/> 2216: <b>make_better_sub2</b>() -&gt;
<a name="2217"/> 2217:     T = build_table2([a,b],[a,b],15000),
<a name="2218"/> 2218:     T1 = time_match(T,{'$1',1500,a,a}),
<a name="2219"/> 2219:     T2 = time_match(T,{{1500,a,'$1'},1500,a,a}),
<a name="2220"/> 2220:     ets:delete(T),
<a name="2221"/> 2221:     io:format(&quot;~p&gt;~p~n&quot;,[(T1 / 100),T2]),
<a name="2222"/> 2222:     true = ((T1 / 100) &gt; T2), % More marginal than needed.
<a name="make_better_sub2-last_expr"/><a name="2223"/> 2223:     ok.
<a name="2224"/> 2224: 
<a name="2225"/> 2225: 
<a name="2226"/> 2226: <i>%% Heavy random matching, comparing set with ordered_set.</i>
<a name="match_heavy-1"/><a name="2227"/> 2227: <b>match_heavy</b>(Config) when is_list(Config) -&gt;
<a name="2228"/> 2228:     PrivDir = proplists:get_value(priv_dir,Config),
<a name="2229"/> 2229:     DataDir = proplists:get_value(data_dir, Config),
<a name="2230"/> 2230:     %% Easier to have in process dictionary when manually
<a name="2231"/> 2231:     %% running the test function.
<a name="2232"/> 2232:     put(where_to_read,DataDir),
<a name="2233"/> 2233:     put(where_to_write,PrivDir),
<a name="2234"/> 2234:     random_test(),
<a name="2235"/> 2235:     drop_match(),
<a name="match_heavy-last_expr"/><a name="2236"/> 2236:     ok.
<a name="2237"/> 2237: 
<a name="2238"/> 2238: <i>%%% Extra safety for the very low probability that this is not</i>
<a name="2239"/> 2239: <i>%%% caught by the random test (Statistically impossible???) </i>
<a name="drop_match-0"/><a name="2240"/> 2240: <b>drop_match</b>() -&gt;
<a name="2241"/> 2241:     EtsMem = etsmem(),
<a name="2242"/> 2242:     T = build_table([a,b],[a],1500),
<a name="2243"/> 2243:     [{{a,a,1},a,a,1},{{b,a,1},b,a,1}] =
<a name="2244"/> 2244: 	ets:match_object(T, {'_','_','_',1}),
<a name="2245"/> 2245:     true = ets:delete(T),
<a name="drop_match-last_expr"/><a name="2246"/> 2246: <b>    verify_etsmem</b>(EtsMem).
<a name="2247"/> 2247: 
<a name="2248"/> 2248: 
<a name="2249"/> 2249: 
<a name="ets_match-2"/><a name="2250"/> 2250: <b>ets_match</b>(Tab,Expr) -&gt;
<a name="ets_match-last_expr"/><a name="2251"/> 2251: <b>    case rand:uniform</b>(2) of
<a name="2252"/> 2252: 	1 -&gt;
<a name="2253"/> 2253: 	    ets:match(Tab,Expr);
<a name="2254"/> 2254: 	_ -&gt;
<a name="2255"/> 2255: 	    match_chunked(Tab,Expr)
<a name="2256"/> 2256:     end.
<a name="2257"/> 2257: 
<a name="match_chunked-2"/><a name="2258"/> 2258: <b>match_chunked</b>(Tab,Expr) -&gt;
<a name="match_chunked-last_expr"/><a name="2259"/> 2259: <b>    match_chunked_collect</b>(ets:match(Tab,Expr,
<a name="2260"/> 2260: 				    rand:uniform(1999) + 1)).
<a name="match_chunked_collect-1"/><a name="2261"/> 2261: <b>match_chunked_collect</b>('$end_of_table') -&gt;
<a name="2262"/> 2262:     [];
<a name="2263"/> 2263: <b>match_chunked_collect</b>({Results, Continuation}) -&gt;
<a name="match_chunked_collect-last_expr"/><a name="2264"/> 2264: <b>    Results ++ match_chunked_collect</b>(ets:match(Continuation)).
<a name="2265"/> 2265: 
<a name="ets_match_object-2"/><a name="2266"/> 2266: <b>ets_match_object</b>(Tab,Expr) -&gt;
<a name="ets_match_object-last_expr"/><a name="2267"/> 2267: <b>    case rand:uniform</b>(2) of
<a name="2268"/> 2268: 	1 -&gt;
<a name="2269"/> 2269: 	    ets:match_object(Tab,Expr);
<a name="2270"/> 2270: 	_ -&gt;
<a name="2271"/> 2271: 	    match_object_chunked(Tab,Expr)
<a name="2272"/> 2272:     end.
<a name="2273"/> 2273: 
<a name="match_object_chunked-2"/><a name="2274"/> 2274: <b>match_object_chunked</b>(Tab,Expr) -&gt;
<a name="match_object_chunked-last_expr"/><a name="2275"/> 2275: <b>    match_object_chunked_collect</b>(ets:match_object(Tab,Expr,
<a name="2276"/> 2276: 						  rand:uniform(1999) + 1)).
<a name="match_object_chunked_collect-1"/><a name="2277"/> 2277: <b>match_object_chunked_collect</b>('$end_of_table') -&gt;
<a name="2278"/> 2278:     [];
<a name="2279"/> 2279: <b>match_object_chunked_collect</b>({Results, Continuation}) -&gt;
<a name="match_object_chunked_collect-last_expr"/><a name="2280"/> 2280: <b>    Results ++ match_object_chunked_collect</b>(ets:match_object(Continuation)).
<a name="2281"/> 2281: 
<a name="2282"/> 2282: 
<a name="2283"/> 2283: 
<a name="random_test-0"/><a name="2284"/> 2284: <b>random_test</b>() -&gt;
<a name="2285"/> 2285:     ReadDir = get(where_to_read),
<a name="2286"/> 2286:     WriteDir = get(where_to_write),
<a name="2287"/> 2287:     (catch file:make_dir(WriteDir)),
<a name="2288"/> 2288:     case file:consult(filename:join([ReadDir,&quot;preset_random_seed.txt&quot;])) of
<a name="2289"/> 2289: 	{ok,[X]} -&gt;
<a name="2290"/> 2290: 	    rand:seed(X);
<a name="2291"/> 2291: 	_ -&gt;
<a name="2292"/> 2292: 	    rand:seed(default)
<a name="2293"/> 2293:     end,
<a name="2294"/> 2294:     Seed = rand:export_seed(),
<a name="2295"/> 2295:     {ok,F} = file:open(filename:join([WriteDir,&quot;last_random_seed.txt&quot;]),
<a name="2296"/> 2296: 		       [write]),
<a name="2297"/> 2297:     io:format(F,&quot;~p. ~n&quot;,[Seed]),
<a name="2298"/> 2298:     file:close(F),
<a name="2299"/> 2299:     io:format(&quot;Random seed ~p written to ~s, copy to ~s to rerun with &quot;
<a name="2300"/> 2300: 	      &quot;same seed.&quot;,[Seed, 
<a name="2301"/> 2301: 			    filename:join([WriteDir, &quot;last_random_seed.txt&quot;]),
<a name="2302"/> 2302: 			    filename:join([ReadDir, 
<a name="2303"/> 2303: 					   &quot;preset_random_seed.txt&quot;])]),
<a name="random_test-last_expr"/><a name="2304"/> 2304: <b>    do_random_test</b>().
<a name="2305"/> 2305: 
<a name="do_random_test-0"/><a name="2306"/> 2306: <b>do_random_test</b>() -&gt;
<a name="2307"/> 2307:     EtsMem = etsmem(),
<a name="2308"/> 2308:     OrdSet = ets_new(xxx,[ordered_set]),
<a name="2309"/> 2309:     Set = ets_new(xxx,[]),
<a name="2310"/> 2310:     do_n_times(fun() -&gt;
<a name="2311"/> 2311: 		       Key = create_random_string(25),
<a name="2312"/> 2312: 		       Value = create_random_tuple(25),
<a name="2313"/> 2313: 		       ets:insert(OrdSet,{Key,Value}),
<a name="2314"/> 2314: 		       ets:insert(Set,{Key,Value})
<a name="2315"/> 2315: 	       end, 5000),
<a name="2316"/> 2316:     io:format(&quot;~nData inserted~n&quot;),
<a name="2317"/> 2317:     do_n_times(fun() -&gt;
<a name="2318"/> 2318: 		       I = rand:uniform(25),
<a name="2319"/> 2319: 		       Key = create_random_string(I) ++ '_',
<a name="2320"/> 2320: 		       L1 = ets_match_object(OrdSet,{Key,'_'}),
<a name="2321"/> 2321: 		       L2 = lists:sort(ets_match_object(Set,{Key,'_'})),
<a name="2322"/> 2322: 		       case L1 == L2 of
<a name="2323"/> 2323: 			   false -&gt;
<a name="2324"/> 2324: 			       io:format(&quot;~p != ~p~n&quot;,
<a name="2325"/> 2325: 					 [L1,L2]),
<a name="2326"/> 2326: 			       exit({not_eq, L1, L2});
<a name="2327"/> 2327: 			   true -&gt;
<a name="2328"/> 2328: 			       ok
<a name="2329"/> 2329: 		       end
<a name="2330"/> 2330: 	       end,
<a name="2331"/> 2331: 	       2000),
<a name="2332"/> 2332:     io:format(&quot;~nData matched~n&quot;),
<a name="2333"/> 2333:     ets:match_delete(OrdSet,'_'),
<a name="2334"/> 2334:     ets:match_delete(Set,'_'),
<a name="2335"/> 2335:     do_n_times(fun() -&gt;
<a name="2336"/> 2336: 		       Value = create_random_string(25),
<a name="2337"/> 2337: 		       Key = create_random_tuple(25),
<a name="2338"/> 2338: 		       ets:insert(OrdSet,{Key,Value}),
<a name="2339"/> 2339: 		       ets:insert(Set,{Key,Value})
<a name="2340"/> 2340: 	       end, 2000),
<a name="2341"/> 2341:     io:format(&quot;~nData inserted~n&quot;),
<a name="2342"/> 2342:     (fun() -&gt;
<a name="2343"/> 2343: 	     Key = list_to_tuple(lists:duplicate(25,'_')),
<a name="2344"/> 2344: 	     L1 = ets_match_object(OrdSet,{Key,'_'}),
<a name="2345"/> 2345: 	     L2 = lists:sort(ets_match_object(Set,{Key,'_'})),
<a name="2346"/> 2346: 	     2000 = length(L1),
<a name="2347"/> 2347: 	     case L1 == L2 of
<a name="2348"/> 2348: 		 false -&gt;
<a name="2349"/> 2349: 		     io:format(&quot;~p != ~p~n&quot;,
<a name="2350"/> 2350: 			       [L1,L2]),
<a name="2351"/> 2351: 		     exit({not_eq, L1, L2});
<a name="2352"/> 2352: 		 true -&gt;
<a name="2353"/> 2353: 		     ok
<a name="2354"/> 2354: 	     end
<a name="2355"/> 2355:      end)(),
<a name="2356"/> 2356:     (fun() -&gt;
<a name="2357"/> 2357: 	     Key = {'$1','$2','$3','$4',
<a name="2358"/> 2358: 		    '$5','$6','$7','$8',
<a name="2359"/> 2359: 		    '$9','$10','$11','$12',
<a name="2360"/> 2360: 		    '$13','$14','$15','$16',
<a name="2361"/> 2361: 		    '$17','$18','$19','$20',
<a name="2362"/> 2362: 		    '$21','$22','$23','$24',
<a name="2363"/> 2363: 		    '$25'},
<a name="2364"/> 2364: 	     L1 = ets_match_object(OrdSet,{Key,'_'}),
<a name="2365"/> 2365: 	     L2 = lists:sort(ets_match_object(Set,{Key,'_'})),
<a name="2366"/> 2366: 	     2000 = length(L1),
<a name="2367"/> 2367: 	     case L1 == L2 of
<a name="2368"/> 2368: 		 false -&gt;
<a name="2369"/> 2369: 		     io:format(&quot;~p != ~p~n&quot;,
<a name="2370"/> 2370: 			       [L1,L2]),
<a name="2371"/> 2371: 		     exit({not_eq, L1, L2});
<a name="2372"/> 2372: 		 true -&gt;
<a name="2373"/> 2373: 		     ok
<a name="2374"/> 2374: 	     end
<a name="2375"/> 2375:      end)(),
<a name="2376"/> 2376:     (fun() -&gt;
<a name="2377"/> 2377: 	     Key = {'$1','$2','$3','$4',
<a name="2378"/> 2378: 		    '$5','$6','$7','$8',
<a name="2379"/> 2379: 		    '$9','$10','$11','$12',
<a name="2380"/> 2380: 		    '$13','$14','$15','$16',
<a name="2381"/> 2381: 		    '$17','$18','$19','$20',
<a name="2382"/> 2382: 		    '$21','$22','$23','$24',
<a name="2383"/> 2383: 		    '$25'},
<a name="2384"/> 2384: 	     L1 = ets_match(OrdSet,{Key,'_'}),
<a name="2385"/> 2385: 	     L2 = lists:sort(ets_match(Set,{Key,'_'})),
<a name="2386"/> 2386: 	     2000 = length(L1),
<a name="2387"/> 2387: 	     case L1 == L2 of
<a name="2388"/> 2388: 		 false -&gt;
<a name="2389"/> 2389: 		     io:format(&quot;~p != ~p~n&quot;,
<a name="2390"/> 2390: 			       [L1,L2]),
<a name="2391"/> 2391: 		     exit({not_eq, L1, L2});
<a name="2392"/> 2392: 		 true -&gt;
<a name="2393"/> 2393: 		     ok
<a name="2394"/> 2394: 	     end
<a name="2395"/> 2395:      end)(),
<a name="2396"/> 2396:     ets:match_delete(OrdSet,'_'),
<a name="2397"/> 2397:     ets:match_delete(Set,'_'),
<a name="2398"/> 2398:     do_n_times(fun() -&gt;
<a name="2399"/> 2399: 		       Value = create_random_string(25),
<a name="2400"/> 2400: 		       Key = create_random_tuple(25),
<a name="2401"/> 2401: 		       ets:insert(OrdSet,{Key,Value}),
<a name="2402"/> 2402: 		       ets:insert(Set,{Key,Value})
<a name="2403"/> 2403: 	       end, 2000),
<a name="2404"/> 2404:     io:format(&quot;~nData inserted~n&quot;),
<a name="2405"/> 2405:     do_n_times(fun() -&gt;
<a name="2406"/> 2406: 		       Key = create_partly_bound_tuple(25),
<a name="2407"/> 2407: 		       L1 = ets_match_object(OrdSet,{Key,'_'}),
<a name="2408"/> 2408: 		       L2 = lists:sort(ets_match_object(Set,{Key,'_'})),
<a name="2409"/> 2409: 		       case L1 == L2 of
<a name="2410"/> 2410: 			   false -&gt;
<a name="2411"/> 2411: 			       io:format(&quot;~p != ~p~n&quot;,
<a name="2412"/> 2412: 					 [L1,L2]),
<a name="2413"/> 2413: 			       exit({not_eq, L1, L2});
<a name="2414"/> 2414: 			   true -&gt;
<a name="2415"/> 2415: 			       ok
<a name="2416"/> 2416: 		       end
<a name="2417"/> 2417: 	       end,
<a name="2418"/> 2418: 	       2000),
<a name="2419"/> 2419:     do_n_times(fun() -&gt;
<a name="2420"/> 2420: 		       Key = create_partly_bound_tuple2(25),
<a name="2421"/> 2421: 		       L1 = ets_match_object(OrdSet,{Key,'_'}),
<a name="2422"/> 2422: 		       L2 = lists:sort(ets_match_object(Set,{Key,'_'})),
<a name="2423"/> 2423: 		       case L1 == L2 of
<a name="2424"/> 2424: 			   false -&gt;
<a name="2425"/> 2425: 			       io:format(&quot;~p != ~p~n&quot;,
<a name="2426"/> 2426: 					 [L1,L2]),
<a name="2427"/> 2427: 			       exit({not_eq, L1, L2});
<a name="2428"/> 2428: 			   true -&gt;
<a name="2429"/> 2429: 			       ok
<a name="2430"/> 2430: 		       end
<a name="2431"/> 2431: 	       end,
<a name="2432"/> 2432: 	       2000),
<a name="2433"/> 2433:     do_n_times(fun() -&gt;
<a name="2434"/> 2434: 		       Key = create_partly_bound_tuple2(25),
<a name="2435"/> 2435: 		       L1 = ets_match(OrdSet,{Key,'_'}),
<a name="2436"/> 2436: 		       L2 = lists:sort(ets_match(Set,{Key,'_'})),
<a name="2437"/> 2437: 		       case L1 == L2 of
<a name="2438"/> 2438: 			   false -&gt;
<a name="2439"/> 2439: 			       io:format(&quot;~p != ~p~n&quot;,
<a name="2440"/> 2440: 					 [L1,L2]),
<a name="2441"/> 2441: 			       exit({not_eq, L1, L2});
<a name="2442"/> 2442: 			   true -&gt;
<a name="2443"/> 2443: 			       ok
<a name="2444"/> 2444: 		       end
<a name="2445"/> 2445: 	       end,
<a name="2446"/> 2446: 	       2000),
<a name="2447"/> 2447:     io:format(&quot;~nData matched~n&quot;),
<a name="2448"/> 2448:     ets:match_delete(OrdSet,'_'),
<a name="2449"/> 2449:     ets:match_delete(Set,'_'),
<a name="2450"/> 2450:     do_n_times(fun() -&gt;
<a name="2451"/> 2451: 		       do_n_times(fun() -&gt;
<a name="2452"/> 2452: 					  Value =
<a name="2453"/> 2453: 					      create_random_string(25),
<a name="2454"/> 2454: 					  Key = create_random_tuple(25),
<a name="2455"/> 2455: 					  ets:insert(OrdSet,{Key,Value}),
<a name="2456"/> 2456: 					  ets:insert(Set,{Key,Value})
<a name="2457"/> 2457: 				  end, 500),
<a name="2458"/> 2458: 		       io:format(&quot;~nData inserted~n&quot;),
<a name="2459"/> 2459: 		       do_n_times(fun() -&gt;
<a name="2460"/> 2460: 					  Key =
<a name="2461"/> 2461: 					      create_partly_bound_tuple(25),
<a name="2462"/> 2462: 					  ets:match_delete(OrdSet,{Key,'_'}),
<a name="2463"/> 2463: 					  ets:match_delete(Set,{Key,'_'}),
<a name="2464"/> 2464: 					  L1 = ets:info(OrdSet,size),
<a name="2465"/> 2465: 					  L2 = ets:info(Set,size),
<a name="2466"/> 2466: 					  [] = ets_match_object(OrdSet,
<a name="2467"/> 2467: 								{Key,'_'}),
<a name="2468"/> 2468: 					  case L1 == L2 of
<a name="2469"/> 2469: 					      false -&gt;
<a name="2470"/> 2470: 						  io:format(&quot;~p != ~p &quot;
<a name="2471"/> 2471: 							    &quot;(deleted ~p)~n&quot;,
<a name="2472"/> 2472: 							    [L1,L2,Key]),
<a name="2473"/> 2473: 						  exit({not_eq, L1, L2,
<a name="2474"/> 2474: 							{deleted,Key}});
<a name="2475"/> 2475: 					      true -&gt;
<a name="2476"/> 2476: 						  ok
<a name="2477"/> 2477: 					  end
<a name="2478"/> 2478: 				  end,
<a name="2479"/> 2479: 				  50),
<a name="2480"/> 2480: 		       io:format(&quot;~nData deleted~n&quot;)
<a name="2481"/> 2481: 	       end,
<a name="2482"/> 2482: 	       10),
<a name="2483"/> 2483:     ets:delete(OrdSet),
<a name="2484"/> 2484:     ets:delete(Set),
<a name="do_random_test-last_expr"/><a name="2485"/> 2485: <b>    verify_etsmem</b>(EtsMem).
<a name="2486"/> 2486: 
<a name="2487"/> 2487: <i>%% Test various variants of update_element.</i>
<a name="update_element-1"/><a name="2488"/> 2488: <b>update_element</b>(Config) when is_list(Config) -&gt;
<a name="2489"/> 2489:     EtsMem = etsmem(),
<a name="2490"/> 2490:     repeat_for_opts(fun update_element_opts/1),
<a name="update_element-last_expr"/><a name="2491"/> 2491: <b>    verify_etsmem</b>(EtsMem).
<a name="2492"/> 2492: 
<a name="update_element_opts-1"/><a name="2493"/> 2493: <b>update_element_opts</b>(Opts) -&gt;
<a name="2494"/> 2494:     TupleCases = [{{key,val}, 1 ,2},
<a name="2495"/> 2495: 		  {{val,key}, 2, 1},
<a name="2496"/> 2496: 		  {{key,val}, 1 ,[2]},
<a name="2497"/> 2497: 		  {{key,val,val}, 1, [2,3]},
<a name="2498"/> 2498: 		  {{val,key,val,val}, 2, [3,4,1]},
<a name="2499"/> 2499: 		  {{val,val,key,val}, 3, [1,4,1,2]}, % update pos1 twice
<a name="2500"/> 2500: 		  {{val,val,val,key}, 4, [2,1,2,3]}],% update pos2 twice
<a name="2501"/> 2501: 
<a name="2502"/> 2502:     lists:foreach(fun({Tuple,KeyPos,UpdPos}) -&gt; update_element_opts(Tuple,KeyPos,UpdPos,Opts) end,
<a name="2503"/> 2503: 		  TupleCases),
<a name="2504"/> 2504: 
<a name="update_element_opts-last_expr"/><a name="2505"/> 2505: <b>    update_element_neg</b>(Opts).
<a name="2506"/> 2506: 
<a name="2507"/> 2507: 
<a name="2508"/> 2508: 
<a name="update_element_opts-4"/><a name="2509"/> 2509: <b>update_element_opts</b>(Tuple,KeyPos,UpdPos,Opts) -&gt;
<a name="2510"/> 2510:     Set = ets_new(set,[{keypos,KeyPos} | Opts]),
<a name="2511"/> 2511:     update_element(Set,Tuple,KeyPos,UpdPos),
<a name="2512"/> 2512:     true = ets:delete(Set),
<a name="2513"/> 2513: 
<a name="2514"/> 2514:     run_if_valid_opts(
<a name="2515"/> 2515:       [ordered_set,{keypos,KeyPos} | Opts],
<a name="2516"/> 2516:       fun (OptsOrdSet) -&gt;
<a name="2517"/> 2517:               OrdSet = ets_new(ordered_set, OptsOrdSet),
<a name="2518"/> 2518:               update_element(OrdSet,Tuple,KeyPos,UpdPos),
<a name="2519"/> 2519:               true = ets:delete(OrdSet)
<a name="2520"/> 2520:       end),
<a name="update_element_opts-last_expr"/><a name="2521"/> 2521:     ok.
<a name="2522"/> 2522: 
<a name="update_element-4"/><a name="2523"/> 2523: <b>update_element</b>(T,Tuple,KeyPos,UpdPos) -&gt;
<a name="2524"/> 2524:     KeyList = [17,&quot;seventeen&quot;,&lt;&lt;&quot;seventeen&quot;&gt;&gt;,{17},list_to_binary(lists:seq(1,100)),make_ref(), self()],
<a name="update_element-last_expr"/><a name="2525"/> 2525: <b>    lists:foreach</b>(fun(Key) -&gt;
<a name="2526"/> 2526: 			  TupleWithKey = setelement(KeyPos,Tuple,Key),
<a name="2527"/> 2527: 			  update_element_do(T,TupleWithKey,Key,UpdPos)
<a name="2528"/> 2528: 		  end,
<a name="2529"/> 2529: 		  KeyList).
<a name="2530"/> 2530: 
<a name="update_element_do-4"/><a name="2531"/> 2531: <b>update_element_do</b>(Tab,Tuple,Key,UpdPos) -&gt;
<a name="2532"/> 2532: 
<a name="2533"/> 2533:     %% Strategy: Step around in Values array and call ets:update_element for the values.
<a name="2534"/> 2534:     %% Take Length number of steps of size 1, then of size 2, ..., Length-1.
<a name="2535"/> 2535:     %% This will try all combinations of {fromValue,toValue}
<a name="2536"/> 2536:     %%
<a name="2537"/> 2537:     %% IMPORTANT: size(Values) must be a prime number for this to work!!!
<a name="2538"/> 2538: 
<a name="2539"/> 2539:     Big32 = 16#12345678,
<a name="2540"/> 2540:     Big64 = 16#123456789abcdef0,
<a name="2541"/> 2541:     RefcBin = list_to_binary(lists:seq(1,100)),
<a name="2542"/> 2542:     BigMap1 = maps:from_list([{N,N} || N &lt;- lists:seq(1,33)]),
<a name="2543"/> 2543:     BigMap2 = BigMap1#{key =&gt; RefcBin, RefcBin =&gt; value},
<a name="2544"/> 2544:     Values = { 623, -27, Big32, -Big32, Big64, -Big64, Big32*Big32,
<a name="2545"/> 2545: 	       -Big32*Big32, Big32*Big64, -Big32*Big64, Big64*Big64, -Big64*Big64,
<a name="2546"/> 2546: 	       &quot;A&quot;, &quot;Sverker&quot;, [], {12,-132}, {},
<a name="2547"/> 2547: 	       &lt;&lt;45,232,0,12,133&gt;&gt;, &lt;&lt;234,12,23&gt;&gt;, RefcBin,
<a name="2548"/> 2548: 	       (fun(X) -&gt; X*Big32 end),
<a name="2549"/> 2549: 	       make_ref(), make_ref(), self(), ok, update_element,
<a name="2550"/> 2550:                #{a =&gt; value, &quot;hello&quot; =&gt; &quot;world&quot;, 1.0 =&gt; RefcBin },
<a name="2551"/> 2551:                BigMap1, BigMap2},
<a name="2552"/> 2552:     Length = tuple_size(Values),
<a name="2553"/> 2553:     29 = Length,
<a name="2554"/> 2554: 
<a name="2555"/> 2555:     PosValArgF = fun(ToIx, ResList, [Pos | PosTail], Rand, MeF) -&gt;
<a name="2556"/> 2556: 			 NextIx = (ToIx+Rand) rem Length,
<a name="2557"/> 2557: 			 MeF(NextIx, [{Pos,element(ToIx+1,Values)} | ResList], PosTail, Rand, MeF);
<a name="2558"/> 2558: 
<a name="2559"/> 2559: 		    (_ToIx, ResList, [], _Rand, _MeF) -&gt;
<a name="2560"/> 2560: 			 ResList;
<a name="2561"/> 2561: 
<a name="2562"/> 2562: 		    (ToIx, [], Pos, _Rand, _MeF) -&gt;
<a name="2563"/> 2563: 			 {Pos, element(ToIx+1,Values)}   % single {pos,value} arg
<a name="2564"/> 2564: 		 end,
<a name="2565"/> 2565: 
<a name="2566"/> 2566:     UpdateF = fun(ToIx,Rand) -&gt;
<a name="2567"/> 2567:                       PosValArg = PosValArgF(ToIx,[],UpdPos,Rand,PosValArgF),
<a name="2568"/> 2568:                       %%io:format(&quot;update_element(~p)~n&quot;,[PosValArg]),
<a name="2569"/> 2569:                       ArgHash = erlang:phash2({Tab,Key,PosValArg}),
<a name="2570"/> 2570:                       true = ets:update_element(Tab, Key, PosValArg),
<a name="2571"/> 2571:                       ArgHash = erlang:phash2({Tab,Key,PosValArg}),
<a name="2572"/> 2572:                       NewTuple = update_tuple(PosValArg,Tuple),
<a name="2573"/> 2573:                       [NewTuple] = ets:lookup(Tab,Key),
<a name="2574"/> 2574:                       [begin
<a name="2575"/> 2575:                            Elem = element(I, NewTuple),
<a name="2576"/> 2576:                            Elem = ets:lookup_element(Tab, Key, I)
<a name="2577"/> 2577:                        end
<a name="2578"/> 2578:                        || I &lt;- lists:seq(1, tuple_size(NewTuple))]
<a name="2579"/> 2579: 	      end,
<a name="2580"/> 2580: 
<a name="2581"/> 2581:     LoopF = fun(_FromIx, Incr, _Times, Checksum, _MeF) when Incr &gt;= Length -&gt;
<a name="2582"/> 2582: 		    Checksum; % done
<a name="2583"/> 2583: 
<a name="2584"/> 2584: 	       (FromIx, Incr, 0, Checksum, MeF) -&gt;
<a name="2585"/> 2585: 		    MeF(FromIx, Incr+1, Length, Checksum, MeF);
<a name="2586"/> 2586: 
<a name="2587"/> 2587: 	       (FromIx, Incr, Times, Checksum, MeF) -&gt;
<a name="2588"/> 2588: 		    ToIx = (FromIx + Incr) rem Length,
<a name="2589"/> 2589: 		    UpdateF(ToIx,Checksum),
<a name="2590"/> 2590: 		    if
<a name="2591"/> 2591: 			Incr =:= 0 -&gt; UpdateF(ToIx,Checksum);  % extra update to same value
<a name="2592"/> 2592: 			true -&gt; true
<a name="2593"/> 2593: 		    end,
<a name="2594"/> 2594: 		    MeF(ToIx, Incr, Times-1, Checksum+ToIx+1, MeF)
<a name="2595"/> 2595: 	    end,
<a name="2596"/> 2596: 
<a name="2597"/> 2597:     FirstTuple = Tuple,
<a name="2598"/> 2598:     true = ets:insert(Tab,FirstTuple),
<a name="2599"/> 2599:     [FirstTuple] = ets:lookup(Tab,Key),
<a name="2600"/> 2600: 
<a name="2601"/> 2601:     Checksum = LoopF(0, 1, Length, 0, LoopF),
<a name="2602"/> 2602:     Checksum = (Length-1)*Length*(Length+1) div 2,  % if Length is a prime
<a name="update_element_do-last_expr"/><a name="2603"/> 2603:     ok.
<a name="2604"/> 2604: 
<a name="update_tuple-2"/><a name="2605"/> 2605: <b>update_tuple</b>({Pos,Val}, Tpl) -&gt;
<a name="2606"/> 2606:     setelement(Pos, Tpl, Val);
<a name="2607"/> 2607: <b>update_tuple</b>([{Pos,Val} | Tail], Tpl) -&gt;
<a name="2608"/> 2608:     update_tuple(Tail,setelement(Pos, Tpl, Val));
<a name="2609"/> 2609: <b>update_tuple</b>([], Tpl) -&gt;
<a name="update_tuple-last_expr"/><a name="2610"/> 2610:     Tpl.
<a name="2611"/> 2611: 
<a name="2612"/> 2612: 
<a name="2613"/> 2613: 
<a name="update_element_neg-1"/><a name="2614"/> 2614: <b>update_element_neg</b>(Opts) -&gt;
<a name="2615"/> 2615:     Set = ets_new(set,Opts),
<a name="2616"/> 2616:     update_element_neg_do(Set),
<a name="2617"/> 2617:     ets:delete(Set),
<a name="2618"/> 2618:     {'EXIT',{badarg,_}} = (catch ets:update_element(Set,key,{2,1})),
<a name="2619"/> 2619: 
<a name="2620"/> 2620:     run_if_valid_opts(
<a name="2621"/> 2621:       [ordered_set | Opts],
<a name="2622"/> 2622:       fun(OptsOrdSet) -&gt;
<a name="2623"/> 2623:               OrdSet = ets_new(ordered_set, OptsOrdSet),
<a name="2624"/> 2624:               update_element_neg_do(OrdSet),
<a name="2625"/> 2625:               ets:delete(OrdSet),
<a name="2626"/> 2626:               {'EXIT',{badarg,_}} = (catch ets:update_element(OrdSet,key,{2,1}))
<a name="2627"/> 2627:       end),
<a name="2628"/> 2628: 
<a name="2629"/> 2629:     Bag = ets_new(bag,[bag | Opts]),
<a name="2630"/> 2630:     DBag = ets_new(duplicate_bag,[duplicate_bag | Opts]),
<a name="2631"/> 2631:     {'EXIT',{badarg,_}} = (catch ets:update_element(Bag,key,{2,1})),
<a name="2632"/> 2632:     {'EXIT',{badarg,_}} = (catch ets:update_element(DBag,key,{2,1})),
<a name="2633"/> 2633:     true = ets:delete(Bag),
<a name="2634"/> 2634:     true = ets:delete(DBag),
<a name="update_element_neg-last_expr"/><a name="2635"/> 2635:     ok.
<a name="2636"/> 2636: 
<a name="2637"/> 2637: 
<a name="update_element_neg_do-1"/><a name="2638"/> 2638: <b>update_element_neg_do</b>(T) -&gt;
<a name="2639"/> 2639:     Object = {key, 0, &quot;Hej&quot;},
<a name="2640"/> 2640:     true = ets:insert(T,Object),
<a name="2641"/> 2641: 
<a name="2642"/> 2642:     UpdateF = fun(Arg3) -&gt;
<a name="2643"/> 2643: 		      ArgHash = erlang:phash2({T,key,Arg3}),
<a name="2644"/> 2644: 		      {'EXIT',{badarg,_}} = (catch ets:update_element(T,key,Arg3)),
<a name="2645"/> 2645: 		      ArgHash = erlang:phash2({T,key,Arg3}),
<a name="2646"/> 2646: 		      [Object] = ets:lookup(T,key)
<a name="2647"/> 2647: 	      end,
<a name="2648"/> 2648: 
<a name="2649"/> 2649:     %% List of invalid {Pos,Value} tuples
<a name="2650"/> 2650:     InvList = [false, {2}, {2,1,false}, {false,1}, {0,1}, {1,1}, {-1,1}, {4,1}],
<a name="2651"/> 2651: 
<a name="2652"/> 2652:     lists:foreach(UpdateF, InvList),
<a name="2653"/> 2653:     lists:foreach(fun(InvTpl) -&gt; UpdateF([{2,1},InvTpl]) end, InvList),
<a name="2654"/> 2654:     lists:foreach(fun(InvTpl) -&gt; UpdateF([InvTpl,{2,1}]) end, InvList),
<a name="2655"/> 2655:     lists:foreach(fun(InvTpl) -&gt; UpdateF([{2,1},{3,&quot;Hello&quot;},InvTpl]) end, InvList),
<a name="2656"/> 2656:     lists:foreach(fun(InvTpl) -&gt; UpdateF([{3,&quot;Hello&quot;},{2,1},InvTpl]) end, InvList),
<a name="2657"/> 2657:     lists:foreach(fun(InvTpl) -&gt; UpdateF([{2,1},InvTpl,{3,&quot;Hello&quot;}]) end, InvList),
<a name="2658"/> 2658:     lists:foreach(fun(InvTpl) -&gt; UpdateF([InvTpl,{3,&quot;Hello&quot;},{2,1}]) end, InvList),
<a name="2659"/> 2659:     UpdateF([{2,1} | {3,1}]),
<a name="2660"/> 2660:     lists:foreach(fun(InvTpl) -&gt; UpdateF([{2,1} | InvTpl]) end, InvList),
<a name="2661"/> 2661: 
<a name="2662"/> 2662:     true = ets:update_element(T,key,[]),
<a name="2663"/> 2663:     false = ets:update_element(T,false,[]),
<a name="2664"/> 2664:     false = ets:update_element(T,false,{2,1}),
<a name="2665"/> 2665:     ets:delete(T,key),
<a name="2666"/> 2666:     false = ets:update_element(T,key,{2,1}),
<a name="update_element_neg_do-last_expr"/><a name="2667"/> 2667:     ok.
<a name="2668"/> 2668: 
<a name="2669"/> 2669: 
<a name="2670"/> 2670: <i>%% test various variants of update_counter.</i>
<a name="update_counter-1"/><a name="2671"/> 2671: <b>update_counter</b>(Config) when is_list(Config) -&gt;
<a name="2672"/> 2672:     EtsMem = etsmem(),
<a name="2673"/> 2673:     repeat_for_opts(fun update_counter_do/1),
<a name="update_counter-last_expr"/><a name="2674"/> 2674: <b>    verify_etsmem</b>(EtsMem).
<a name="2675"/> 2675: 
<a name="update_counter_do-1"/><a name="2676"/> 2676: <b>update_counter_do</b>(Opts) -&gt;
<a name="2677"/> 2677:     Set = ets_new(set,Opts),
<a name="2678"/> 2678:     update_counter_for(Set),
<a name="2679"/> 2679:     ets:delete_all_objects(Set),
<a name="2680"/> 2680:     ets:safe_fixtable(Set, true),
<a name="2681"/> 2681:     update_counter_for(Set),
<a name="2682"/> 2682:     ets:safe_fixtable(Set, false),
<a name="2683"/> 2683:     ets:delete(Set),
<a name="2684"/> 2684: 
<a name="2685"/> 2685:     run_if_valid_opts(
<a name="2686"/> 2686:       [ordered_set | Opts],
<a name="2687"/> 2687:       fun (OptsOrdSet) -&gt;
<a name="2688"/> 2688:               OrdSet = ets_new(ordered_set, OptsOrdSet),
<a name="2689"/> 2689:               update_counter_for(OrdSet),
<a name="2690"/> 2690:               ets:delete_all_objects(OrdSet),
<a name="2691"/> 2691:               ets:safe_fixtable(OrdSet, true),
<a name="2692"/> 2692:               update_counter_for(OrdSet),
<a name="2693"/> 2693:               ets:safe_fixtable(OrdSet, false),
<a name="2694"/> 2694:               ets:delete(OrdSet)
<a name="2695"/> 2695:       end),
<a name="2696"/> 2696: 
<a name="update_counter_do-last_expr"/><a name="2697"/> 2697: <b>    update_counter_neg</b>(Opts).
<a name="2698"/> 2698: 
<a name="update_counter_for-1"/><a name="2699"/> 2699: <b>update_counter_for</b>(T) -&gt;
<a name="2700"/> 2700:     ets:insert(T,{a,1,1}),
<a name="2701"/> 2701:     101 = ets:update_counter(T,a,100),
<a name="2702"/> 2702:     [{a,101,1}] = ets:lookup(T,a),
<a name="2703"/> 2703:     101 = ets:update_counter(T,a,{3,100}),
<a name="2704"/> 2704:     [{a,101,101}] = ets:lookup(T,a),
<a name="2705"/> 2705: 
<a name="2706"/> 2706: 
<a name="2707"/> 2707:     LooperF = fun(Obj, 0, _, _) -&gt;
<a name="2708"/> 2708: 		      Obj;
<a name="2709"/> 2709: 
<a name="2710"/> 2710: 		 (Obj, Times, Arg3, Myself) -&gt;
<a name="2711"/> 2711: 		      {NewObj, Ret} = uc_mimic(Obj,Arg3),
<a name="2712"/> 2712: 		      ArgHash = erlang:phash2({T,a,Arg3}),
<a name="2713"/> 2713: 		      %%io:format(&quot;update_counter(~p, ~p, ~p) expecting ~p\n&quot;,[T,a,Arg3,Ret]),
<a name="2714"/> 2714:                       [DefaultObj] = ets:lookup(T, a),
<a name="2715"/> 2715: 		      Ret = ets:update_counter(T,a,Arg3),
<a name="2716"/> 2716:                       Ret = ets:update_counter(T, b, Arg3, DefaultObj),   % Use other key
<a name="2717"/> 2717: 		      ArgHash = erlang:phash2({T,a,Arg3}),
<a name="2718"/> 2718: 		      %%io:format(&quot;NewObj=~p~n &quot;,[NewObj]),
<a name="2719"/> 2719: 		      [NewObj] = ets:lookup(T,a),
<a name="2720"/> 2720:                       true = ets:lookup(T, b) =:= [setelement(1, NewObj, b)],
<a name="2721"/> 2721:                       ets:delete(T, b),
<a name="2722"/> 2722: 		      Myself(NewObj,Times-1,Arg3,Myself)
<a name="2723"/> 2723: 	      end,
<a name="2724"/> 2724: 
<a name="2725"/> 2725:     LoopF = fun(Obj, Times, Arg3) -&gt;
<a name="2726"/> 2726: 		    %%io:format(&quot;Loop start:\nObj = ~p\nArg3=~p\n&quot;,[Obj,Arg3]),
<a name="2727"/> 2727: 		    LooperF(Obj,Times,Arg3,LooperF)
<a name="2728"/> 2728: 	    end,
<a name="2729"/> 2729: 
<a name="2730"/> 2730:     SmallMax32 = (1 bsl 27) - 1,
<a name="2731"/> 2731:     SmallMax64 = (1 bsl (27+32)) - 1,
<a name="2732"/> 2732:     Big1Max32 = (1 bsl 32) - 1,
<a name="2733"/> 2733:     Big1Max64 = (1 bsl 64) - 1,
<a name="2734"/> 2734: 
<a name="2735"/> 2735:     Steps = 100,
<a name="2736"/> 2736:     Obj0 = {a,0,0,0,0},
<a name="2737"/> 2737:     ets:insert(T,Obj0),
<a name="2738"/> 2738:     Obj1 = LoopF(Obj0, Steps, {2,(SmallMax32 div Steps)*2}),
<a name="2739"/> 2739:     Obj2 = LoopF(Obj1, Steps, {3,(SmallMax64 div Steps)*2}),
<a name="2740"/> 2740:     Obj3 = LoopF(Obj2, Steps, {4,(Big1Max32 div Steps)*2}),
<a name="2741"/> 2741:     Obj4 = LoopF(Obj3, Steps, {5,(Big1Max64 div Steps)*2}),
<a name="2742"/> 2742: 
<a name="2743"/> 2743:     Obj5 = LoopF(Obj4, Steps, {2,-(SmallMax32 div Steps)*4}),
<a name="2744"/> 2744:     Obj6 = LoopF(Obj5, Steps, {3,-(SmallMax64 div Steps)*4}),
<a name="2745"/> 2745:     Obj7 = LoopF(Obj6, Steps, {4,-(Big1Max32 div Steps)*4}),
<a name="2746"/> 2746:     Obj8 = LoopF(Obj7, Steps, {5,-(Big1Max64 div Steps)*4}),
<a name="2747"/> 2747: 
<a name="2748"/> 2748:     Obj9 = LoopF(Obj8, Steps, {2,(SmallMax32 div Steps)*2}),
<a name="2749"/> 2749:     ObjA = LoopF(Obj9, Steps, {3,(SmallMax64 div Steps)*2}),
<a name="2750"/> 2750:     ObjB = LoopF(ObjA, Steps, {4,(Big1Max32 div Steps)*2}),
<a name="2751"/> 2751:     Obj0 = LoopF(ObjB, Steps, {5,(Big1Max64 div Steps)*2}),
<a name="2752"/> 2752: 
<a name="2753"/> 2753:     %% back at zero, same trip again with lists
<a name="2754"/> 2754: 
<a name="2755"/> 2755:     Obj4 = LoopF(Obj0,Steps,[{2, (SmallMax32 div Steps)*2},
<a name="2756"/> 2756: 			     {3, (SmallMax64 div Steps)*2},
<a name="2757"/> 2757: 			     {4, (Big1Max32 div Steps)*2},
<a name="2758"/> 2758: 			     {5, (Big1Max64 div Steps)*2}]),
<a name="2759"/> 2759: 
<a name="2760"/> 2760:     Obj8 = LoopF(Obj4,Steps,[{4, -(Big1Max32 div Steps)*4},
<a name="2761"/> 2761: 			     {2, -(SmallMax32 div Steps)*4},
<a name="2762"/> 2762: 			     {5, -(Big1Max64 div Steps)*4},
<a name="2763"/> 2763: 			     {3, -(SmallMax64 div Steps)*4}]),
<a name="2764"/> 2764: 
<a name="2765"/> 2765:     Obj0 = LoopF(Obj8,Steps,[{5, (Big1Max64 div Steps)*2},
<a name="2766"/> 2766: 			     {2, (SmallMax32 div Steps)*2},
<a name="2767"/> 2767: 			     {4, (Big1Max32 div Steps)*2},
<a name="2768"/> 2768: 			     {3, (SmallMax64 div Steps)*2}]),
<a name="2769"/> 2769: 
<a name="2770"/> 2770:     %% make them shift size at the same time
<a name="2771"/> 2771:     ObjC = LoopF(Obj0,Steps,[{5, (Big1Max64 div Steps)*2},
<a name="2772"/> 2772: 			     {3, (Big1Max64 div Steps)*2 + 1},
<a name="2773"/> 2773: 			     {2, -(Big1Max64 div Steps)*2},
<a name="2774"/> 2774: 			     {4, -(Big1Max64 div Steps)*2 + 1}]),
<a name="2775"/> 2775: 
<a name="2776"/> 2776:     %% update twice in same list
<a name="2777"/> 2777:     ObjD = LoopF(ObjC,Steps,[{5, -(Big1Max64 div Steps) + 1},
<a name="2778"/> 2778: 			     {3, -(Big1Max64 div Steps)*2 - 1},
<a name="2779"/> 2779: 			     {5, -(Big1Max64 div Steps) - 1},
<a name="2780"/> 2780: 			     {4, (Big1Max64 div Steps)*2 - 1}]),
<a name="2781"/> 2781: 
<a name="2782"/> 2782:     Obj0 = LoopF(ObjD,Steps,[{2, (Big1Max64 div Steps) - 1},
<a name="2783"/> 2783: 			     {4, Big1Max64*2},
<a name="2784"/> 2784: 			     {2, (Big1Max64 div Steps) + 1},
<a name="2785"/> 2785: 			     {4, -Big1Max64*2}]),
<a name="2786"/> 2786: 
<a name="2787"/> 2787:     %% warping with list
<a name="2788"/> 2788:     ObjE = LoopF(Obj0,1000,
<a name="2789"/> 2789: 		 [{3,SmallMax32*4 div 5,SmallMax32*2,-SmallMax32*2},
<a name="2790"/> 2790: 		  {5,-SmallMax64*4 div 7,-SmallMax64*2,SmallMax64*2},
<a name="2791"/> 2791: 		  {4,-Big1Max32*4 div 11,-Big1Max32*2,Big1Max32*2},
<a name="2792"/> 2792: 		  {2,Big1Max64*4 div 13,Big1Max64*2,-Big1Max64*2}]),
<a name="2793"/> 2793: 
<a name="2794"/> 2794:     %% warping without list
<a name="2795"/> 2795:     ObjF = LoopF(ObjE,1000,{3,SmallMax32*4 div 5,SmallMax32*2,-SmallMax32*2}),
<a name="2796"/> 2796:     ObjG = LoopF(ObjF,1000,{5,-SmallMax64*4 div 7,-SmallMax64*2,SmallMax64*2}),
<a name="2797"/> 2797:     ObjH = LoopF(ObjG,1000,{4,-Big1Max32*4 div 11,-Big1Max32*2,Big1Max32*2}),
<a name="2798"/> 2798:     ObjI = LoopF(ObjH,1000,{2,Big1Max64*4 div 13,Big1Max64*2,-Big1Max64*2}),
<a name="2799"/> 2799: 
<a name="2800"/> 2800:     %% mixing it up
<a name="2801"/> 2801:     LoopF(ObjI,1000,
<a name="2802"/> 2802: 	  [{3,SmallMax32*4 div 5,SmallMax32*2,-SmallMax32*2},
<a name="2803"/> 2803: 	   {5,-SmallMax64*4 div 3},
<a name="2804"/> 2804: 	   {3,-SmallMax32*4 div 11},
<a name="2805"/> 2805: 	   {5,0},
<a name="2806"/> 2806: 	   {4,1},
<a name="2807"/> 2807: 	   {5,-SmallMax64*4 div 7,-SmallMax64*2,SmallMax64*2},
<a name="2808"/> 2808: 	   {2,Big1Max64*4 div 13,Big1Max64*2,-Big1Max64*2}]),
<a name="update_counter_for-last_expr"/><a name="2809"/> 2809:     ok.
<a name="2810"/> 2810: 
<a name="2811"/> 2811: <i>%% uc_mimic works kind of like the real ets:update_counter</i>
<a name="2812"/> 2812: <i>%% Obj = Tuple in ets</i>
<a name="2813"/> 2813: <i>%% Pits = {Pos,Incr} | {Pos,Incr,Thres,Warp}</i>
<a name="2814"/> 2814: <i>%% Returns {Updated tuple in ets, Return value from update_counter}</i>
<a name="uc_mimic-2"/><a name="2815"/> 2815: <b>uc_mimic</b>(Obj, Pits) when is_tuple(Pits) -&gt;
<a name="2816"/> 2816:     Pos = element(1,Pits),
<a name="2817"/> 2817:     NewObj = setelement(Pos, Obj, uc_adder(element(Pos,Obj),Pits)),
<a name="2818"/> 2818:     {NewObj, element(Pos,NewObj)};
<a name="2819"/> 2819: 
<a name="2820"/> 2820: <b>uc_mimic</b>(Obj, PitsList) when is_list(PitsList) -&gt;
<a name="2821"/> 2821:     {NewObj,ValList} = uc_mimic(Obj,PitsList,[]),
<a name="uc_mimic-last_expr"/><a name="2822"/> 2822: <b>    {NewObj,lists:reverse</b>(ValList)}.
<a name="2823"/> 2823: 
<a name="uc_mimic-3"/><a name="2824"/> 2824: <b>uc_mimic</b>(Obj, [], Acc) -&gt;
<a name="2825"/> 2825:     {Obj,Acc};
<a name="2826"/> 2826: <b>uc_mimic</b>(Obj, [Pits|Tail], Acc) -&gt;
<a name="2827"/> 2827:     {NewObj,NewVal} = uc_mimic(Obj,Pits),
<a name="uc_mimic-last_expr"/><a name="2828"/> 2828: <b>    uc_mimic</b>(NewObj,Tail,[NewVal|Acc]).
<a name="2829"/> 2829: 
<a name="uc_adder-2"/><a name="2830"/> 2830: <b>uc_adder</b>(Init, {_Pos, Add}) -&gt;
<a name="2831"/> 2831:     Init + Add;
<a name="2832"/> 2832: <b>uc_adder</b>(Init, {_Pos, Add, Thres, Warp}) -&gt;
<a name="uc_adder-last_expr"/><a name="2833"/> 2833:     case Init + Add of
<a name="2834"/> 2834: 	X when X &gt; Thres, Add &gt; 0 -&gt;
<a name="2835"/> 2835: 	    Warp;
<a name="2836"/> 2836: 	Y when Y &lt; Thres, Add &lt; 0 -&gt;
<a name="2837"/> 2837: 	    Warp;
<a name="2838"/> 2838: 	Z -&gt;
<a name="2839"/> 2839: 	    Z
<a name="2840"/> 2840:     end.
<a name="2841"/> 2841: 
<a name="update_counter_neg-1"/><a name="2842"/> 2842: <b>update_counter_neg</b>(Opts) -&gt;
<a name="2843"/> 2843:     Set = ets_new(set,Opts),
<a name="2844"/> 2844:     update_counter_neg_for(Set),
<a name="2845"/> 2845:     ets:delete(Set),
<a name="2846"/> 2846:     {'EXIT',{badarg,_}} = (catch ets:update_counter(Set,key,1)),
<a name="2847"/> 2847: 
<a name="2848"/> 2848:     run_if_valid_opts(
<a name="2849"/> 2849:       [ordered_set | Opts],
<a name="2850"/> 2850:       fun (OptsOrdSet) -&gt;
<a name="2851"/> 2851:               OrdSet = ets_new(ordered_set, OptsOrdSet),
<a name="2852"/> 2852:               update_counter_neg_for(OrdSet),
<a name="2853"/> 2853:               ets:delete(OrdSet),
<a name="2854"/> 2854:               {'EXIT',{badarg,_}} = (catch ets:update_counter(OrdSet,key,1))
<a name="2855"/> 2855:       end),
<a name="2856"/> 2856: 
<a name="2857"/> 2857:     Bag = ets_new(bag,[bag | Opts]),
<a name="2858"/> 2858:     DBag = ets_new(duplicate_bag,[duplicate_bag | Opts]),
<a name="2859"/> 2859:     {'EXIT',{badarg,_}} = (catch ets:update_counter(Bag,key,1)),
<a name="2860"/> 2860:     {'EXIT',{badarg,_}} = (catch ets:update_counter(DBag,key,1)),
<a name="2861"/> 2861:     true = ets:delete(Bag),
<a name="2862"/> 2862:     true = ets:delete(DBag),
<a name="update_counter_neg-last_expr"/><a name="2863"/> 2863:     ok.
<a name="2864"/> 2864: 
<a name="update_counter_neg_for-1"/><a name="2865"/> 2865: <b>update_counter_neg_for</b>(T) -&gt;
<a name="2866"/> 2866:     Object = {key,0,false,1},
<a name="2867"/> 2867:     true = ets:insert(T,Object),
<a name="2868"/> 2868: 
<a name="2869"/> 2869:     UpdateF = fun(Arg3) -&gt;
<a name="2870"/> 2870: 		      ArgHash = erlang:phash2({T,key,Arg3}),
<a name="2871"/> 2871: 		      {'EXIT',{badarg,_}} = (catch ets:update_counter(T,key,Arg3)),
<a name="2872"/> 2872: 		      ArgHash = erlang:phash2({T,key,Arg3}),
<a name="2873"/> 2873: 		      [Object] = ets:lookup(T,key)
<a name="2874"/> 2874: 	      end,
<a name="2875"/> 2875: 
<a name="2876"/> 2876:     %% List of invalid arg3-tuples
<a name="2877"/> 2877:     InvList = [false, {2}, {2,false}, {false,1},
<a name="2878"/> 2878: 	       {0,1}, {-1,1}, % BUG &lt; R12B-2
<a name="2879"/> 2879: 	       {1,1}, {3,1}, {5,1}, {2,1,100}, {2,1,100,0,false}, {2,1,false,0}, {2,1,0,false}],
<a name="2880"/> 2880: 
<a name="2881"/> 2881:     lists:foreach(UpdateF, InvList),
<a name="2882"/> 2882:     lists:foreach(fun(Inv) -&gt; UpdateF([{2,1},Inv]) end, InvList),
<a name="2883"/> 2883:     lists:foreach(fun(Inv) -&gt; UpdateF([Inv,{2,1}]) end, InvList),
<a name="2884"/> 2884:     lists:foreach(fun(Inv) -&gt; UpdateF([{2,1},{4,-100},Inv]) end, InvList),
<a name="2885"/> 2885:     lists:foreach(fun(Inv) -&gt; UpdateF([{4,100,50,0},{2,1},Inv]) end, InvList),
<a name="2886"/> 2886:     lists:foreach(fun(Inv) -&gt; UpdateF([{2,1},Inv,{4,100,50,0}]) end, InvList),
<a name="2887"/> 2887:     lists:foreach(fun(Inv) -&gt; UpdateF([Inv,{4,100,50,0},{2,1}]) end, InvList),
<a name="2888"/> 2888:     UpdateF([{2,1} | {4,1}]),
<a name="2889"/> 2889:     lists:foreach(fun(Inv) -&gt; UpdateF([{2,1} | Inv]) end, InvList),
<a name="2890"/> 2890: 
<a name="2891"/> 2891:     {'EXIT',{badarg,_}} = (catch ets:update_counter(T,false,1)),
<a name="2892"/> 2892:     ets:delete(T,key),
<a name="2893"/> 2893:     {'EXIT',{badarg,_}} = (catch ets:update_counter(T,key,1)),
<a name="update_counter_neg_for-last_expr"/><a name="2894"/> 2894:     ok.
<a name="2895"/> 2895: 
<a name="2896"/> 2896: 
<a name="evil_update_counter-1"/><a name="2897"/> 2897: <b>evil_update_counter</b>(Config) when is_list(Config) -&gt;
<a name="2898"/> 2898:     %% The code server uses ets table. Pre-load modules that might not be
<a name="2899"/> 2899:     %% already loaded.
<a name="2900"/> 2900:     gb_sets:module_info(),
<a name="2901"/> 2901:     math:module_info(),
<a name="2902"/> 2902:     ordsets:module_info(),
<a name="2903"/> 2903:     rand:module_info(),
<a name="2904"/> 2904: 
<a name="evil_update_counter-last_expr"/><a name="2905"/> 2905: <b>    repeat_for_opts</b>(fun evil_update_counter_do/1).
<a name="2906"/> 2906: 
<a name="evil_update_counter_do-1"/><a name="2907"/> 2907: <b>evil_update_counter_do</b>(Opts) -&gt;
<a name="2908"/> 2908:     EtsMem = etsmem(),
<a name="2909"/> 2909:     process_flag(trap_exit, true),
<a name="2910"/> 2910:     Pids = [my_spawn_link(fun() -&gt; evil_counter(I,Opts) end)  || I &lt;- lists:seq(1, 40)],
<a name="2911"/> 2911:     wait_for_all(gb_sets:from_list(Pids)),
<a name="2912"/> 2912:     verify_etsmem(EtsMem),
<a name="evil_update_counter_do-last_expr"/><a name="2913"/> 2913:     ok.
<a name="2914"/> 2914: 
<a name="wait_for_all-1"/><a name="2915"/> 2915: <b>wait_for_all</b>(Pids0) -&gt;
<a name="wait_for_all-last_expr"/><a name="2916"/> 2916: <b>    case gb_sets:is_empty</b>(Pids0) of
<a name="2917"/> 2917: 	true -&gt;
<a name="2918"/> 2918: 	    ok;
<a name="2919"/> 2919: 	false -&gt;
<a name="2920"/> 2920: 	    receive
<a name="2921"/> 2921: 		{'EXIT',Pid,normal} -&gt;
<a name="2922"/> 2922: 		    Pids = gb_sets:delete(Pid, Pids0),
<a name="2923"/> 2923: 		    wait_for_all(Pids);
<a name="2924"/> 2924: 		Other -&gt;
<a name="2925"/> 2925: 		    io:format(&quot;unexpected: ~p\n&quot;, [Other]),
<a name="2926"/> 2926: 		    ct:fail(failed)
<a name="2927"/> 2927: 	    end
<a name="2928"/> 2928:     end.
<a name="2929"/> 2929: 
<a name="evil_counter-2"/><a name="2930"/> 2930: <b>evil_counter</b>(I,Opts) -&gt;
<a name="2931"/> 2931:     T = ets_new(a, Opts),
<a name="2932"/> 2932:     Start0 = case I rem 3 of
<a name="2933"/> 2933: 		 0 -&gt; 16#12345678;
<a name="2934"/> 2934: 		 1 -&gt; 16#12345678FFFFFFFF;
<a name="2935"/> 2935: 		 2 -&gt; 16#7777777777FFFFFFFF863648726743
<a name="2936"/> 2936: 	     end,
<a name="2937"/> 2937:     Start = Start0 + rand:uniform(100000),
<a name="2938"/> 2938:     ets:insert(T, {dracula,Start}),
<a name="2939"/> 2939:     Iter = 40000 div syrup_factor(),
<a name="2940"/> 2940:     End = Start + Iter,
<a name="2941"/> 2941:     End = evil_counter_1(Iter, T),
<a name="evil_counter-last_expr"/><a name="2942"/> 2942: <b>    ets:delete</b>(T).
<a name="2943"/> 2943: 
<a name="evil_counter_1-2"/><a name="2944"/> 2944: <b>evil_counter_1</b>(0, T) -&gt;
<a name="2945"/> 2945:     [{dracula,Count}] = ets:lookup(T, dracula),
<a name="2946"/> 2946:     Count;
<a name="2947"/> 2947: <b>evil_counter_1</b>(Iter, T) -&gt;
<a name="2948"/> 2948:     ets:update_counter(T, dracula, 1),
<a name="evil_counter_1-last_expr"/><a name="2949"/> 2949: <b>    evil_counter_1</b>(Iter-1, T).
<a name="2950"/> 2950: 
<a name="update_counter_with_default-1"/><a name="2951"/> 2951: <b>update_counter_with_default</b>(Config) when is_list(Config) -&gt;
<a name="update_counter_with_default-last_expr"/><a name="2952"/> 2952: <b>    repeat_for_opts</b>(fun update_counter_with_default_do/1).
<a name="2953"/> 2953: 
<a name="update_counter_with_default_do-1"/><a name="2954"/> 2954: <b>update_counter_with_default_do</b>(Opts) -&gt;
<a name="2955"/> 2955:     T1 = ets_new(a, [set | Opts]),
<a name="2956"/> 2956:     %% Insert default object.
<a name="2957"/> 2957:     3 = ets:update_counter(T1, foo, 2, {beaufort,1}),
<a name="2958"/> 2958:     1 = ets:info(T1, size),
<a name="2959"/> 2959:     %% Increment.
<a name="2960"/> 2960:     5 = ets:update_counter(T1, foo, 2, {cabecou,1}),
<a name="2961"/> 2961:     1 = ets:info(T1, size),
<a name="2962"/> 2962:     %% Increment with list.
<a name="2963"/> 2963:     [9] = ets:update_counter(T1, foo, [{2,4}], {camembert,1}),
<a name="2964"/> 2964:     1 = ets:info(T1, size),
<a name="2965"/> 2965:     %% Same with non-immediate key.
<a name="2966"/> 2966:     3 = ets:update_counter(T1, {foo,bar}, 2, {{chaource,chevrotin},1}),
<a name="2967"/> 2967:     2 = ets:info(T1, size),
<a name="2968"/> 2968:     5 = ets:update_counter(T1, {foo,bar}, 2, {{cantal,comté},1}),
<a name="2969"/> 2969:     2 = ets:info(T1, size),
<a name="2970"/> 2970:     [9] = ets:update_counter(T1, {foo,bar}, [{2,4}], {{emmental,de,savoie},1}),
<a name="2971"/> 2971:     2 = ets:info(T1, size),
<a name="2972"/> 2972:     %% default counter is not an integer.
<a name="2973"/> 2973:     {'EXIT',{badarg,_}} = (catch ets:update_counter(T1, qux, 3, {saint,félicien})),
<a name="2974"/> 2974:     2 = ets:info(T1, size),
<a name="2975"/> 2975:     %% No third element in default value.
<a name="2976"/> 2976:     {'EXIT',{badarg,_}} = (catch ets:update_counter(T1, qux, [{3,1}], {roquefort,1})),
<a name="2977"/> 2977:     2 = ets:info(T1, size),
<a name="2978"/> 2978: 
<a name="2979"/> 2979:     %% Same with ordered set.
<a name="2980"/> 2980:     run_if_valid_opts(
<a name="2981"/> 2981:       [ordered_set | Opts],
<a name="2982"/> 2982:       fun (Opts2) -&gt;
<a name="2983"/> 2983:               T2 = ets_new(b, Opts2),
<a name="2984"/> 2984:               3 = ets:update_counter(T2, foo, 2, {maroilles,1}),
<a name="2985"/> 2985:               1 = ets:info(T2, size),
<a name="2986"/> 2986:               5 = ets:update_counter(T2, foo, 2, {mimolette,1}),
<a name="2987"/> 2987:               1 = ets:info(T2, size),
<a name="2988"/> 2988:               [9] = ets:update_counter(T2, foo, [{2,4}], {morbier,1}),
<a name="2989"/> 2989:               1 = ets:info(T2, size),
<a name="2990"/> 2990:               3 = ets:update_counter(T2, {foo,bar}, 2, {{laguiole},1}),
<a name="2991"/> 2991:               2 = ets:info(T2, size),
<a name="2992"/> 2992:               5 = ets:update_counter(T2, {foo,bar}, 2, {{saint,nectaire},1}),
<a name="2993"/> 2993:               2 = ets:info(T2, size),
<a name="2994"/> 2994:               [9] = ets:update_counter(T2, {foo,bar}, [{2,4}], {{rocamadour},1}),
<a name="2995"/> 2995:               2 = ets:info(T2, size),
<a name="2996"/> 2996:               %% Arithmetically-equal keys.
<a name="2997"/> 2997:               3 = ets:update_counter(T2, 1.0, 2, {1,1}),
<a name="2998"/> 2998:               3 = ets:info(T2, size),
<a name="2999"/> 2999:               5 = ets:update_counter(T2, 1, 2, {1,1}),
<a name="3000"/> 3000:               3 = ets:info(T2, size),
<a name="3001"/> 3001:               7 = ets:update_counter(T2, 1, 2, {1.0,1}),
<a name="3002"/> 3002:               3 = ets:info(T2, size),
<a name="3003"/> 3003:               %% Same with reversed type difference.
<a name="3004"/> 3004:               3 = ets:update_counter(T2, 2, 2, {2.0,1}),
<a name="3005"/> 3005:               4 = ets:info(T2, size),
<a name="3006"/> 3006:               5 = ets:update_counter(T2, 2.0, 2, {2.0,1}),
<a name="3007"/> 3007:               4 = ets:info(T2, size),
<a name="3008"/> 3008:               7 = ets:update_counter(T2, 2.0, 2, {2,1}),
<a name="3009"/> 3009:               4 = ets:info(T2, size),
<a name="3010"/> 3010:               %% default counter is not an integer.
<a name="3011"/> 3011:               {'EXIT',{badarg,_}} = (catch ets:update_counter(T2, qux, 3, {saint,félicien})),
<a name="3012"/> 3012:               4 = ets:info(T2, size),
<a name="3013"/> 3013:               %% No third element in default value.
<a name="3014"/> 3014:               {'EXIT',{badarg,_}} = (catch ets:update_counter(T2, qux, [{3,1}], {roquefort,1})),
<a name="3015"/> 3015:               4 = ets:info(T2, size)
<a name="3016"/> 3016:       end),
<a name="update_counter_with_default_do-last_expr"/><a name="3017"/> 3017:     ok.
<a name="3018"/> 3018: 
<a name="3019"/> 3019: <i>%% ERL-1125</i>
<a name="update_counter_with_default_bad_pos-1"/><a name="3020"/> 3020: <b>update_counter_with_default_bad_pos</b>(Config) when is_list(Config) -&gt;
<a name="update_counter_with_default_bad_pos-last_expr"/><a name="3021"/> 3021: <b>    repeat_for_all_ord_set_table_types</b>(fun update_counter_with_default_bad_pos_do/1).
<a name="3022"/> 3022: 
<a name="update_counter_with_default_bad_pos_do-1"/><a name="3023"/> 3023: <b>update_counter_with_default_bad_pos_do</b>(Opts) -&gt;
<a name="3024"/> 3024:     T = ets_new(a, Opts),
<a name="3025"/> 3025:     0 = ets:info(T, size),
<a name="3026"/> 3026:     ok = try ets:update_counter(T, 101065, {1, 1}, {101065, 0})
<a name="3027"/> 3027:          catch
<a name="3028"/> 3028:              error:badarg -&gt; ok;
<a name="3029"/> 3029:              Class:Reason -&gt; {Class, Reason}
<a name="3030"/> 3030:          end,
<a name="3031"/> 3031:     0 = ets:info(T, size),
<a name="update_counter_with_default_bad_pos_do-last_expr"/><a name="3032"/> 3032:     ok.
<a name="3033"/> 3033: 
<a name="update_counter_table_growth-1"/><a name="3034"/> 3034: <b>update_counter_table_growth</b>(_Config) -&gt;
<a name="update_counter_table_growth-last_expr"/><a name="3035"/> 3035: <b>    repeat_for_opts</b>(fun update_counter_table_growth_do/1).
<a name="3036"/> 3036: 
<a name="update_counter_table_growth_do-1"/><a name="3037"/> 3037: <b>update_counter_table_growth_do</b>(Opts) -&gt;
<a name="3038"/> 3038:     Set = ets_new(b, [set | Opts]),
<a name="3039"/> 3039:     [ets:update_counter(Set, N, {2, 1}, {N, 1}) || N &lt;- lists:seq(1,10000)],
<a name="3040"/> 3040: 
<a name="3041"/> 3041:     run_if_valid_opts(
<a name="3042"/> 3042:       [ordered_set | Opts],
<a name="3043"/> 3043:       fun(OptsOrdSet) -&gt;
<a name="3044"/> 3044:               OrdSet = ets_new(b, OptsOrdSet),
<a name="3045"/> 3045:               [ets:update_counter(OrdSet, N, {2, 1}, {N, 1})
<a name="3046"/> 3046:                || N &lt;- lists:seq(1,10000)]
<a name="3047"/> 3047:       end),
<a name="update_counter_table_growth_do-last_expr"/><a name="3048"/> 3048:     ok.
<a name="3049"/> 3049: 
<a name="3050"/> 3050: <i>%% Check that a first-next sequence always works on a fixed table.</i>
<a name="fixtable_next-1"/><a name="3051"/> 3051: <b>fixtable_next</b>(Config) when is_list(Config) -&gt;
<a name="fixtable_next-last_expr"/><a name="3052"/> 3052: <b>    repeat_for_opts</b>(fun fixtable_next_do/1,
<a name="3053"/> 3053:                     [write_concurrency,all_types]).
<a name="3054"/> 3054: 
<a name="fixtable_next_do-1"/><a name="3055"/> 3055: <b>fixtable_next_do</b>(Opts) -&gt;
<a name="3056"/> 3056:     EtsMem = etsmem(),
<a name="3057"/> 3057:     do_fixtable_next(ets_new(set,[public | Opts])),
<a name="fixtable_next_do-last_expr"/><a name="3058"/> 3058: <b>    verify_etsmem</b>(EtsMem).
<a name="3059"/> 3059: 
<a name="do_fixtable_next-1"/><a name="3060"/> 3060: <b>do_fixtable_next</b>(Tab) -&gt;
<a name="3061"/> 3061:     F = fun(X,T,FF) -&gt;
<a name="3062"/> 3062:                 case X of
<a name="3063"/> 3063:                     0 -&gt; true;
<a name="3064"/> 3064:                     _ -&gt;
<a name="3065"/> 3065:                         ets:insert(T, {X,
<a name="3066"/> 3066:                                        integer_to_list(X),
<a name="3067"/> 3067:                                        X rem 10}),
<a name="3068"/> 3068:                         FF(X-1,T,FF)
<a name="3069"/> 3069:                 end
<a name="3070"/> 3070:         end,
<a name="3071"/> 3071:     F(100,Tab,F),
<a name="3072"/> 3072:     ets:safe_fixtable(Tab,true),
<a name="3073"/> 3073:     First = ets:first(Tab),
<a name="3074"/> 3074:     ets:delete(Tab, First),
<a name="3075"/> 3075:     ets:next(Tab, First),
<a name="3076"/> 3076:     ets:match_delete(Tab,{'_','_','_'}),
<a name="3077"/> 3077:     '$end_of_table' = ets:next(Tab, First),
<a name="3078"/> 3078:     true = ets:info(Tab, fixed),
<a name="3079"/> 3079:     ets:safe_fixtable(Tab, false),
<a name="3080"/> 3080:     false = ets:info(Tab, fixed),
<a name="do_fixtable_next-last_expr"/><a name="3081"/> 3081: <b>    ets:delete</b>(Tab).
<a name="3082"/> 3082: 
<a name="3083"/> 3083: <i>%% Check that iteration of bags find all live objects and nothing else.</i>
<a name="fixtable_iter_bag-1"/><a name="3084"/> 3084: <b>fixtable_iter_bag</b>(Config) when is_list(Config) -&gt;
<a name="fixtable_iter_bag-last_expr"/><a name="3085"/> 3085: <b>    repeat_for_opts</b>(fun fixtable_iter_do/1,
<a name="3086"/> 3086:                     [write_concurrency,[bag,duplicate_bag]]).
<a name="3087"/> 3087: 
<a name="fixtable_iter_do-1"/><a name="3088"/> 3088: <b>fixtable_iter_do</b>(Opts) -&gt;
<a name="3089"/> 3089:     EtsMem = etsmem(),
<a name="3090"/> 3090:     do_fixtable_iter_bag(ets_new(fixtable_iter_bag,Opts)),
<a name="fixtable_iter_do-last_expr"/><a name="3091"/> 3091: <b>    verify_etsmem</b>(EtsMem).
<a name="3092"/> 3092: 
<a name="do_fixtable_iter_bag-1"/><a name="3093"/> 3093: <b>do_fixtable_iter_bag</b>(T) -&gt;
<a name="3094"/> 3094:     MaxValues = 4,
<a name="3095"/> 3095:     %% Create 1 to MaxValues objects for each key
<a name="3096"/> 3096:     %% and then delete every possible combination of those objects
<a name="3097"/> 3097:     %% in every possible order.
<a name="3098"/> 3098:     %% Then test iteration returns all live objects and nothing else.
<a name="3099"/> 3099: 
<a name="3100"/> 3100:     CrDelOps = [begin
<a name="3101"/> 3101:                     Values = lists:seq(1,N),
<a name="3102"/> 3102:                     %% All ways of deleting any number of the Values in any order
<a name="3103"/> 3103:                     Combos = combs(Values),
<a name="3104"/> 3104:                     DeleteOps = concat_lists([perms(C) || C &lt;- Combos]),
<a name="3105"/> 3105:                     {N, DeleteOps}
<a name="3106"/> 3106:                 end
<a name="3107"/> 3107:                 || N &lt;- lists:seq(1,MaxValues)],
<a name="3108"/> 3108: 
<a name="3109"/> 3109:     %%io:format(&quot;~p\n&quot;, [CrDelOps]),
<a name="3110"/> 3110: 
<a name="3111"/> 3111:     NKeys = lists:foldl(fun({_, DeleteOps}, Cnt) -&gt;
<a name="3112"/> 3112:                                Cnt + length(DeleteOps)
<a name="3113"/> 3113:                        end,
<a name="3114"/> 3114:                        0,
<a name="3115"/> 3115:                        CrDelOps),
<a name="3116"/> 3116: 
<a name="3117"/> 3117:     io:format(&quot;Create ~p keys\n&quot;, [NKeys]),
<a name="3118"/> 3118: 
<a name="3119"/> 3119:     %% Fixate even before inserts just to maintain small table size
<a name="3120"/> 3120:     %% and increase likelyhood of different keys in same bucket.
<a name="3121"/> 3121:     ets:safe_fixtable(T,true),
<a name="3122"/> 3122:     InsRes = [begin
<a name="3123"/> 3123:                   [begin
<a name="3124"/> 3124:                        Key = {NValues,ValueList},
<a name="3125"/> 3125:                        [begin
<a name="3126"/> 3126:                             Tpl = {Key, V},
<a name="3127"/> 3127:                             %%io:format(&quot;Insert object ~p&quot;, [Tpl]),
<a name="3128"/> 3128:                             ets:insert(T, Tpl),
<a name="3129"/> 3129:                             Tpl
<a name="3130"/> 3130:                         end
<a name="3131"/> 3131:                         || V &lt;- lists:seq(1,NValues)]
<a name="3132"/> 3132:                    end
<a name="3133"/> 3133:                    || ValueList &lt;- DeleteOps]
<a name="3134"/> 3134:               end
<a name="3135"/> 3135:               || {NValues, DeleteOps} &lt;- CrDelOps],
<a name="3136"/> 3136: 
<a name="3137"/> 3137:     Inserted = lists:flatten(InsRes),
<a name="3138"/> 3138:     InSorted = lists:sort(Inserted),
<a name="3139"/> 3139:     InSorted = lists:usort(Inserted),  %% No duplicates
<a name="3140"/> 3140:     NObjs = length(Inserted),
<a name="3141"/> 3141: 
<a name="3142"/> 3142:     DelRes = [begin
<a name="3143"/> 3143:                   [begin
<a name="3144"/> 3144:                        Key = {NValues,ValueList},
<a name="3145"/> 3145:                        [begin
<a name="3146"/> 3146:                             Tpl = {Key, V},
<a name="3147"/> 3147:                             %%io:format(&quot;Delete object ~p&quot;, [Tpl]),
<a name="3148"/> 3148:                             ets:delete_object(T, Tpl),
<a name="3149"/> 3149:                             Tpl
<a name="3150"/> 3150:                         end
<a name="3151"/> 3151:                         || V &lt;- ValueList]
<a name="3152"/> 3152:                    end
<a name="3153"/> 3153:                    || ValueList &lt;- DeleteOps]
<a name="3154"/> 3154:               end
<a name="3155"/> 3155:               || {NValues, DeleteOps} &lt;- CrDelOps],
<a name="3156"/> 3156: 
<a name="3157"/> 3157:     Deleted = lists:flatten(DelRes),
<a name="3158"/> 3158:     DelSorted = lists:sort(Deleted),
<a name="3159"/> 3159:     DelSorted = lists:usort(Deleted),  %% No duplicates
<a name="3160"/> 3160:     NDels = length(Deleted),
<a name="3161"/> 3161:     
<a name="3162"/> 3162:     %% Nr of keys where all values were deleted.
<a name="3163"/> 3163:     NDeletedKeys = lists:sum([factorial(N) || N &lt;- lists:seq(1,MaxValues)]),
<a name="3164"/> 3164: 
<a name="3165"/> 3165:     CountKeysFun = fun Me(K1, Cnt) -&gt;
<a name="3166"/> 3166:                            case ets:next(T, K1) of
<a name="3167"/> 3167:                                '$end_of_table' -&gt;
<a name="3168"/> 3168:                                    Cnt;
<a name="3169"/> 3169:                                K2 -&gt;
<a name="3170"/> 3170:                                    Objs = ets:lookup(T, K2),
<a name="3171"/> 3171:                                    [{{NValues, ValueList}, _V} | _] = Objs,
<a name="3172"/> 3172:                                    ExpectedLive = NValues - length(ValueList),
<a name="3173"/> 3173:                                    ExpectedLive = length(Objs),
<a name="3174"/> 3174:                                    Me(K2, Cnt+1)
<a name="3175"/> 3175:                            end
<a name="3176"/> 3176:                    end,
<a name="3177"/> 3177: 
<a name="3178"/> 3178:     ExpectedKeys = NKeys - NDeletedKeys,
<a name="3179"/> 3179:     io:format(&quot;Expected keys: ~p\n&quot;, [ExpectedKeys]),
<a name="3180"/> 3180:     FoundKeys = CountKeysFun(ets:first(T), 1),
<a name="3181"/> 3181:     io:format(&quot;Found keys: ~p\n&quot;, [FoundKeys]),
<a name="3182"/> 3182:     ExpectedKeys = FoundKeys,
<a name="3183"/> 3183: 
<a name="3184"/> 3184:     ExpectedObjs = NObjs - NDels,
<a name="3185"/> 3185:     io:format(&quot;Expected objects: ~p\n&quot;, [ExpectedObjs]),
<a name="3186"/> 3186:     FoundObjs = ets:select_count(T, [{{'_','_'}, [], [true]}]),
<a name="3187"/> 3187:     io:format(&quot;Found objects: ~p\n&quot;, [FoundObjs]),
<a name="3188"/> 3188:     ExpectedObjs = FoundObjs,
<a name="3189"/> 3189: 
<a name="do_fixtable_iter_bag-last_expr"/><a name="3190"/> 3190: <b>    ets:delete</b>(T).
<a name="3191"/> 3191: 
<a name="3192"/> 3192: <i>%% All permutations of list</i>
<a name="perms-1"/><a name="3193"/> 3193: <b>perms</b>([]) -&gt; [[]];
<a name="perms-last_expr"/><a name="3194"/> 3194: <b>perms</b>(L)  -&gt; [[H|T] || H &lt;- L, T &lt;- perms(L--[H])].
<a name="3195"/> 3195: 
<a name="3196"/> 3196: <i>%% All combinations of picking the element (or not) from list</i>
<a name="combs-1"/><a name="3197"/> 3197: <b>combs</b>([]) -&gt; [[]];
<a name="3198"/> 3198: <b>combs</b>([H|T]) -&gt;
<a name="3199"/> 3199:     Tcombs = combs(T),
<a name="combs-last_expr"/><a name="3200"/> 3200:     Tcombs ++ [[H | C] || C &lt;- Tcombs].
<a name="3201"/> 3201: 
<a name="factorial-1"/><a name="3202"/> 3202: <b>factorial</b>(0) -&gt; 1;
<a name="3203"/> 3203: <b>factorial</b>(N) when N &gt; 0 -&gt;
<a name="factorial-last_expr"/><a name="3204"/> 3204: <b>    N * factorial</b>(N - 1).
<a name="3205"/> 3205: 
<a name="concat_lists-1"/><a name="3206"/> 3206: <b>concat_lists</b>([]) -&gt;
<a name="3207"/> 3207:     [];
<a name="3208"/> 3208: <b>concat_lists</b>([H|T]) -&gt;
<a name="concat_lists-last_expr"/><a name="3209"/> 3209: <b>    H ++ concat_lists</b>(T).
<a name="3210"/> 3210: 
<a name="3211"/> 3211: 
<a name="3212"/> 3212: <i>%% Check inserts of deleted keys in fixed bags.</i>
<a name="fixtable_insert-1"/><a name="3213"/> 3213: <b>fixtable_insert</b>(Config) when is_list(Config) -&gt;
<a name="3214"/> 3214:     Combos = [[Type,{write_concurrency,WC}] || Type&lt;- [bag,duplicate_bag],
<a name="3215"/> 3215: 					       WC &lt;- [false,true]],
<a name="3216"/> 3216:     lists:foreach(fun(Opts) -&gt; fixtable_insert_do(Opts) end,
<a name="3217"/> 3217: 		  Combos),
<a name="fixtable_insert-last_expr"/><a name="3218"/> 3218:     ok.
<a name="3219"/> 3219: 
<a name="fixtable_insert_do-1"/><a name="3220"/> 3220: <b>fixtable_insert_do</b>(Opts) -&gt;
<a name="3221"/> 3221:     io:format(&quot;Opts = ~p\n&quot;,[Opts]),
<a name="3222"/> 3222:     Ets = make_table(ets, Opts, [{a,1}, {a,2}, {b,1}, {b,2}]),
<a name="3223"/> 3223:     ets:safe_fixtable(Ets,true),
<a name="3224"/> 3224:     ets:match_delete(Ets,{b,1}),
<a name="3225"/> 3225:     First = ets:first(Ets),
<a name="3226"/> 3226:     Next = case First of
<a name="3227"/> 3227: 	       a -&gt; b;
<a name="3228"/> 3228: 	       b -&gt; a
<a name="3229"/> 3229: 	   end,
<a name="3230"/> 3230:     Next = ets:next(Ets,First),
<a name="3231"/> 3231:     ets:delete(Ets,Next),
<a name="3232"/> 3232:     '$end_of_table' = ets:next(Ets,First),
<a name="3233"/> 3233:     ets:insert(Ets, {Next,1}),
<a name="3234"/> 3234:     false = ets:insert_new(Ets, {Next,1}),
<a name="3235"/> 3235:     Next = ets:next(Ets,First),
<a name="3236"/> 3236:     '$end_of_table' = ets:next(Ets,Next),
<a name="3237"/> 3237:     ets:delete(Ets,Next),
<a name="3238"/> 3238:     '$end_of_table' = ets:next(Ets,First),
<a name="3239"/> 3239:     ets:insert(Ets, {Next,2}),
<a name="3240"/> 3240:     false = ets:insert_new(Ets, {Next,1}),
<a name="3241"/> 3241:     Next = ets:next(Ets,First),
<a name="3242"/> 3242:     '$end_of_table' = ets:next(Ets,Next),
<a name="3243"/> 3243:     ets:delete(Ets,First),
<a name="3244"/> 3244:     Next = ets:first(Ets),
<a name="3245"/> 3245:     '$end_of_table' = ets:next(Ets,Next),
<a name="3246"/> 3246:     ets:delete(Ets,Next),
<a name="3247"/> 3247:     '$end_of_table' = ets:next(Ets,First),
<a name="3248"/> 3248:     true = ets:insert_new(Ets,{Next,1}),
<a name="3249"/> 3249:     false = ets:insert_new(Ets,{Next,2}),
<a name="3250"/> 3250:     Next = ets:next(Ets,First),
<a name="3251"/> 3251:     ets:delete_object(Ets,{Next,1}),
<a name="3252"/> 3252:     '$end_of_table' = ets:next(Ets,First),
<a name="3253"/> 3253:     true = ets:insert_new(Ets,{Next,2}),
<a name="3254"/> 3254:     false = ets:insert_new(Ets,{Next,1}),
<a name="3255"/> 3255:     Next = ets:next(Ets,First),
<a name="3256"/> 3256:     ets:delete(Ets,First),
<a name="3257"/> 3257:     ets:safe_fixtable(Ets,false),
<a name="3258"/> 3258:     {'EXIT',{badarg,_}} = (catch ets:next(Ets,First)),
<a name="fixtable_insert_do-last_expr"/><a name="3259"/> 3259:     ok.
<a name="3260"/> 3260: 
<a name="3261"/> 3261: <i>%% Test the 'write_concurrency' option.</i>
<a name="write_concurrency-1"/><a name="3262"/> 3262: <b>write_concurrency</b>(Config) when is_list(Config) -&gt;
<a name="3263"/> 3263:     EtsMem = etsmem(),
<a name="3264"/> 3264:     Yes1 = ets_new(foo,[public,{write_concurrency,true}]),
<a name="3265"/> 3265:     Yes2 = ets_new(foo,[protected,{write_concurrency,true}]),
<a name="3266"/> 3266:     No1 = ets_new(foo,[private,{write_concurrency,true}]),
<a name="3267"/> 3267: 
<a name="3268"/> 3268:     Yes3 = ets_new(foo,[bag,public,{write_concurrency,true}]),
<a name="3269"/> 3269:     Yes4 = ets_new(foo,[bag,protected,{write_concurrency,true}]),
<a name="3270"/> 3270:     No2 = ets_new(foo,[bag,private,{write_concurrency,true}]),
<a name="3271"/> 3271: 
<a name="3272"/> 3272:     Yes5 = ets_new(foo,[duplicate_bag,public,{write_concurrency,true}]),
<a name="3273"/> 3273:     Yes6 = ets_new(foo,[duplicate_bag,protected,{write_concurrency,true}]),
<a name="3274"/> 3274:     No3 = ets_new(foo,[duplicate_bag,private,{write_concurrency,true}]),
<a name="3275"/> 3275: 
<a name="3276"/> 3276:     NoCentCtrs = {decentralized_counters,false},
<a name="3277"/> 3277:     Yes7 = ets_new(foo,[ordered_set,public,{write_concurrency,true},NoCentCtrs]),
<a name="3278"/> 3278:     Yes8 = ets_new(foo,[ordered_set,protected,{write_concurrency,true},NoCentCtrs]),
<a name="3279"/> 3279:     Yes9 = ets_new(foo,[ordered_set,{write_concurrency,true},NoCentCtrs]),
<a name="3280"/> 3280:     Yes10 = ets_new(foo,[{write_concurrency,true},ordered_set,public,NoCentCtrs]),
<a name="3281"/> 3281:     Yes11 = ets_new(foo,[{write_concurrency,true},ordered_set,protected,NoCentCtrs]),
<a name="3282"/> 3282:     Yes12 = ets_new(foo,[set,{write_concurrency,false},
<a name="3283"/> 3283:                          {write_concurrency,true},ordered_set,public,NoCentCtrs]),
<a name="3284"/> 3284:     Yes13 = ets_new(foo,[private,public,set,{write_concurrency,false},
<a name="3285"/> 3285:                          {write_concurrency,true},ordered_set,NoCentCtrs]),
<a name="3286"/> 3286:     Yes14 = ets_new(foo,[ordered_set,public,{write_concurrency,true}]),
<a name="3287"/> 3287:     No4 = ets_new(foo,[ordered_set,private,{write_concurrency,true}]),
<a name="3288"/> 3288:     No5 = ets_new(foo,[ordered_set,public,{write_concurrency,false}]),
<a name="3289"/> 3289:     No6 = ets_new(foo,[ordered_set,protected,{write_concurrency,false}]),
<a name="3290"/> 3290:     No7 = ets_new(foo,[ordered_set,private,{write_concurrency,false}]),
<a name="3291"/> 3291: 
<a name="3292"/> 3292:     No8 = ets_new(foo,[public,{write_concurrency,false}]),
<a name="3293"/> 3293:     No9 = ets_new(foo,[protected,{write_concurrency,false}]),
<a name="3294"/> 3294: 
<a name="3295"/> 3295:     YesMem = ets:info(Yes1,memory),
<a name="3296"/> 3296:     NoHashMem = ets:info(No1,memory),
<a name="3297"/> 3297:     YesTreeMem = ets:info(Yes7,memory),
<a name="3298"/> 3298:     YesYesTreeMem = ets:info(Yes14,memory),
<a name="3299"/> 3299:     NoTreeMem = ets:info(No4,memory),
<a name="3300"/> 3300: 
<a name="3301"/> 3301:     io:format(&quot;YesMem=~p NoHashMem=~p NoTreeMem=~p YesTreeMem=~p YesYesTreeMem=~p\n&quot;,
<a name="3302"/> 3302:               [YesMem,NoHashMem,NoTreeMem,YesTreeMem,YesYesTreeMem]),
<a name="3303"/> 3303: 
<a name="3304"/> 3304:     YesMem = ets:info(Yes2,memory),
<a name="3305"/> 3305:     YesMem = ets:info(Yes3,memory),
<a name="3306"/> 3306:     YesMem = ets:info(Yes4,memory),
<a name="3307"/> 3307:     YesMem = ets:info(Yes5,memory),
<a name="3308"/> 3308:     YesMem = ets:info(Yes6,memory),
<a name="3309"/> 3309:     NoHashMem = ets:info(No2,memory),
<a name="3310"/> 3310:     NoHashMem = ets:info(No3,memory),
<a name="3311"/> 3311:     YesTreeMem = ets:info(Yes7,memory),
<a name="3312"/> 3312:     YesTreeMem = ets:info(Yes8,memory),
<a name="3313"/> 3313:     YesTreeMem = ets:info(Yes9,memory),
<a name="3314"/> 3314:     YesTreeMem = ets:info(Yes10,memory),
<a name="3315"/> 3315:     YesTreeMem = ets:info(Yes11,memory),
<a name="3316"/> 3316:     YesTreeMem = ets:info(Yes12,memory),
<a name="3317"/> 3317:     YesTreeMem = ets:info(Yes13,memory),
<a name="3318"/> 3318:     NoTreeMem = ets:info(No4,memory),
<a name="3319"/> 3319:     NoTreeMem = ets:info(No5,memory),
<a name="3320"/> 3320:     NoTreeMem = ets:info(No6,memory),
<a name="3321"/> 3321:     NoTreeMem = ets:info(No7,memory),
<a name="3322"/> 3322:     NoHashMem = ets:info(No8,memory),
<a name="3323"/> 3323:     NoHashMem = ets:info(No9,memory),
<a name="3324"/> 3324: 
<a name="3325"/> 3325:     true = YesMem &gt; YesTreeMem,
<a name="3326"/> 3326: 
<a name="3327"/> 3327:     case erlang:system_info(schedulers) of
<a name="3328"/> 3328:         1 -&gt;
<a name="3329"/> 3329:             YesMem = NoHashMem,
<a name="3330"/> 3330:             YesTreeMem = NoTreeMem,
<a name="3331"/> 3331:             YesYesTreeMem = YesTreeMem;
<a name="3332"/> 3332:         NoSchedulers -&gt;
<a name="3333"/> 3333:             true = YesMem &gt; NoHashMem,
<a name="3334"/> 3334:             true = YesMem &gt; NoTreeMem,
<a name="3335"/> 3335: 
<a name="3336"/> 3336:             %% The memory of ordered_set with write concurrency is
<a name="3337"/> 3337:             %% smaller than without write concurrency on 64-bit systems with
<a name="3338"/> 3338:             %% few schedulers.
<a name="3339"/> 3339:             Bits = 8*erlang:system_info(wordsize),
<a name="3340"/> 3340:             if Bits =:= 32;
<a name="3341"/> 3341:                NoSchedulers &gt; 6 -&gt;
<a name="3342"/> 3342:                     true = YesTreeMem &gt;= NoTreeMem;
<a name="3343"/> 3343:                true -&gt;
<a name="3344"/> 3344:                     true = YesTreeMem &lt; NoTreeMem
<a name="3345"/> 3345:             end,
<a name="3346"/> 3346:             true = YesYesTreeMem &gt; YesTreeMem
<a name="3347"/> 3347:     end,
<a name="3348"/> 3348: 
<a name="3349"/> 3349:     {'EXIT',{badarg,_}} = (catch ets_new(foo,[public,{write_concurrency,foo}])),
<a name="3350"/> 3350:     {'EXIT',{badarg,_}} = (catch ets_new(foo,[public,{write_concurrency}])),
<a name="3351"/> 3351:     {'EXIT',{badarg,_}} = (catch ets_new(foo,[public,{write_concurrency,true,foo}])),
<a name="3352"/> 3352:     {'EXIT',{badarg,_}} = (catch ets_new(foo,[public,write_concurrency])),
<a name="3353"/> 3353: 
<a name="3354"/> 3354:     lists:foreach(fun(T) -&gt; ets:delete(T) end,
<a name="3355"/> 3355:         	  [Yes1,Yes2,Yes3,Yes4,Yes5,Yes6,Yes7,Yes8,Yes9,Yes10,Yes11,Yes12,Yes13,Yes14,
<a name="3356"/> 3356:         	   No1,No2,No3,No4,No5,No6,No7,No8,No9]),
<a name="3357"/> 3357:     verify_etsmem(EtsMem),
<a name="write_concurrency-last_expr"/><a name="3358"/> 3358:     ok.
<a name="3359"/> 3359: 
<a name="3360"/> 3360: 
<a name="3361"/> 3361: <i>%% The 'heir' option.</i>
<a name="heir-1"/><a name="3362"/> 3362: <b>heir</b>(Config) when is_list(Config) -&gt;
<a name="heir-last_expr"/><a name="3363"/> 3363: <b>    repeat_for_opts</b>(fun heir_do/1).
<a name="3364"/> 3364: 
<a name="heir_do-1"/><a name="3365"/> 3365: <b>heir_do</b>(Opts) -&gt;
<a name="3366"/> 3366:     EtsMem = etsmem(),
<a name="3367"/> 3367:     Master = self(),
<a name="3368"/> 3368: 
<a name="3369"/> 3369:     %% Different types of heir data and link/monitor relations
<a name="3370"/> 3370:     TestFun = fun(Arg) -&gt; {EtsMem,Arg} end,
<a name="3371"/> 3371:     Combos = [{Data,Mode} || Data&lt;-[foo_data, &lt;&lt;&quot;binary&quot;&gt;&gt;,
<a name="3372"/> 3372: 				    lists:seq(1,10), {17,TestFun,self()},
<a name="3373"/> 3373: 				    &quot;The busy heir&quot;],
<a name="3374"/> 3374: 			     Mode&lt;-[none,link,monitor]],
<a name="3375"/> 3375:     lists:foreach(fun({Data,Mode})-&gt; heir_1(Data,Mode,Opts) end,
<a name="3376"/> 3376: 		  Combos),
<a name="3377"/> 3377: 
<a name="3378"/> 3378:     %% No heir
<a name="3379"/> 3379:     {Founder1,MrefF1} = my_spawn_monitor(fun()-&gt;heir_founder(Master,foo_data,Opts)end),
<a name="3380"/> 3380:     Founder1 ! {go, none},
<a name="3381"/> 3381:     {&quot;No heir&quot;,Founder1} = receive_any(),
<a name="3382"/> 3382:     {'DOWN', MrefF1, process, Founder1, normal} = receive_any(),
<a name="3383"/> 3383:     undefined = ets:info(foo),
<a name="3384"/> 3384: 
<a name="3385"/> 3385:     %% An already dead heir
<a name="3386"/> 3386:     {Heir2,MrefH2} = my_spawn_monitor(fun()-&gt;die end),
<a name="3387"/> 3387:     {'DOWN', MrefH2, process, Heir2, normal} = receive_any(),
<a name="3388"/> 3388:     {Founder2,MrefF2} = my_spawn_monitor(fun()-&gt;heir_founder(Master,foo_data,Opts)end),
<a name="3389"/> 3389:     Founder2 ! {go, Heir2},
<a name="3390"/> 3390:     {&quot;No heir&quot;,Founder2} = receive_any(),
<a name="3391"/> 3391:     {'DOWN', MrefF2, process, Founder2, normal} = receive_any(),
<a name="3392"/> 3392:     undefined = ets:info(foo),
<a name="3393"/> 3393: 
<a name="3394"/> 3394:     %% When heir dies before founder
<a name="3395"/> 3395:     {Founder3,MrefF3} = my_spawn_monitor(fun()-&gt;heir_founder(Master,&quot;The dying heir&quot;,Opts)end),
<a name="3396"/> 3396:     {Heir3,MrefH3} = my_spawn_monitor(fun()-&gt;heir_heir(Founder3)end),
<a name="3397"/> 3397:     Founder3 ! {go, Heir3},
<a name="3398"/> 3398:     {'DOWN', MrefH3, process, Heir3, normal} = receive_any(),
<a name="3399"/> 3399:     Founder3 ! die_please,
<a name="3400"/> 3400:     {'DOWN', MrefF3, process, Founder3, normal} = receive_any(),
<a name="3401"/> 3401:     undefined = ets:info(foo),
<a name="3402"/> 3402: 
<a name="3403"/> 3403:     %% When heir dies and pid reused before founder dies
<a name="3404"/> 3404:     repeat_while(fun() -&gt;
<a name="3405"/> 3405: 			 NextPidIx = erts_debug:get_internal_state(next_pid),
<a name="3406"/> 3406: 			 {Founder4,MrefF4} = my_spawn_monitor(fun()-&gt;heir_founder(Master,&quot;The dying heir&quot;,Opts)end),
<a name="3407"/> 3407: 			 {Heir4,MrefH4} = my_spawn_monitor(fun()-&gt;heir_heir(Founder4)end),
<a name="3408"/> 3408: 			 Founder4 ! {go, Heir4},
<a name="3409"/> 3409: 			 {'DOWN', MrefH4, process, Heir4, normal} = receive_any(),
<a name="3410"/> 3410: 			 erts_debug:set_internal_state(next_pid, NextPidIx),
<a name="3411"/> 3411: 			 DoppelGanger = spawn_monitor_with_pid(Heir4,
<a name="3412"/> 3412: 							       fun()-&gt; die_please = receive_any() end),
<a name="3413"/> 3413: 			 Founder4 ! die_please,
<a name="3414"/> 3414: 			 {'DOWN', MrefF4, process, Founder4, normal} = receive_any(),
<a name="3415"/> 3415: 			 case DoppelGanger of
<a name="3416"/> 3416: 			     {Heir4,MrefH4_B} -&gt;
<a name="3417"/> 3417: 				 Heir4 ! die_please,
<a name="3418"/> 3418: 				 {'DOWN', MrefH4_B, process, Heir4, normal} = receive_any(),
<a name="3419"/> 3419: 				 undefined = ets:info(foo),
<a name="3420"/> 3420: 				 false;
<a name="3421"/> 3421: 			     failed -&gt;
<a name="3422"/> 3422: 				 io:format(&quot;Failed to spawn process with pid ~p\n&quot;, [Heir4]),
<a name="3423"/> 3423: 				 true % try again
<a name="3424"/> 3424: 			 end
<a name="3425"/> 3425: 		 end),
<a name="3426"/> 3426: 
<a name="heir_do-last_expr"/><a name="3427"/> 3427: <b>    verify_etsmem</b>(EtsMem).
<a name="3428"/> 3428: 
<a name="heir_founder-3"/><a name="3429"/> 3429: <b>heir_founder</b>(Master, HeirData, Opts) -&gt;
<a name="3430"/> 3430:     {go,Heir} = receive_any(),
<a name="3431"/> 3431:     HeirTpl = case Heir of
<a name="3432"/> 3432: 		  none -&gt; {heir,none};
<a name="3433"/> 3433: 		  _ -&gt; {heir, Heir, HeirData}
<a name="3434"/> 3434: 	      end,
<a name="3435"/> 3435:     T = ets_new(foo,[named_table, private, HeirTpl | Opts]),
<a name="3436"/> 3436:     true = ets:insert(T,{key,1}),
<a name="3437"/> 3437:     [{key,1}] = ets:lookup(T,key),
<a name="3438"/> 3438:     Self = self(),
<a name="3439"/> 3439:     Self = ets:info(T,owner),
<a name="heir_founder-last_expr"/><a name="3440"/> 3440: <b>    case ets:info</b>(T,heir) of
<a name="3441"/> 3441: 	none -&gt;
<a name="3442"/> 3442: 	    true = (Heir =:= none) orelse (not is_process_alive(Heir)),
<a name="3443"/> 3443: 	    Master ! {&quot;No heir&quot;,self()};
<a name="3444"/> 3444: 
<a name="3445"/> 3445: 	Heir -&gt;
<a name="3446"/> 3446: 	    true = is_process_alive(Heir),
<a name="3447"/> 3447: 	    Heir ! {table,T,HeirData},
<a name="3448"/> 3448: 	    die_please = receive_any()
<a name="3449"/> 3449:     end.
<a name="3450"/> 3450: 
<a name="3451"/> 3451: 
<a name="heir_heir-1"/><a name="3452"/> 3452: <b>heir_heir</b>(Founder) -&gt;
<a name="heir_heir-last_expr"/><a name="3453"/> 3453: <b>    heir_heir</b>(Founder, none).
<a name="heir_heir-2"/><a name="3454"/> 3454: <b>heir_heir</b>(Founder, Mode) -&gt;
<a name="3455"/> 3455:     {table,T,HeirData} = receive_any(),
<a name="3456"/> 3456:     {'EXIT',{badarg,_}} = (catch ets:lookup(T,key)),
<a name="3457"/> 3457:     case HeirData of
<a name="3458"/> 3458: 	&quot;The dying heir&quot; -&gt; exit(normal);
<a name="3459"/> 3459: 	_ -&gt; ok
<a name="3460"/> 3460:     end,
<a name="3461"/> 3461: 
<a name="3462"/> 3462:     Mref = case Mode of
<a name="3463"/> 3463: 	       link -&gt; process_flag(trap_exit, true),
<a name="3464"/> 3464: 		       link(Founder);
<a name="3465"/> 3465: 	       monitor -&gt; erlang:monitor(process,Founder);
<a name="3466"/> 3466: 	       none -&gt; ok
<a name="3467"/> 3467: 	   end,
<a name="3468"/> 3468:     Founder ! die_please,
<a name="3469"/> 3469:     Msg = case HeirData of
<a name="3470"/> 3470: 	      &quot;The busy heir&quot; -&gt; receive_any_spinning();
<a name="3471"/> 3471: 	      _ -&gt; receive_any()
<a name="3472"/> 3472: 	  end,
<a name="3473"/> 3473:     {'ETS-TRANSFER', T, Founder, HeirData} = Msg,
<a name="3474"/> 3474:     foo = T,
<a name="3475"/> 3475:     Self = self(),
<a name="3476"/> 3476:     Self = ets:info(T,owner),
<a name="3477"/> 3477:     Self = ets:info(T,heir),
<a name="3478"/> 3478:     [{key,1}] = ets:lookup(T,key),
<a name="3479"/> 3479:     true = ets:insert(T,{key,2}),
<a name="3480"/> 3480:     [{key,2}] = ets:lookup(T,key),
<a name="heir_heir-last_expr"/><a name="3481"/> 3481:     case Mode of % Verify that EXIT or DOWN comes after ETS-TRANSFER
<a name="3482"/> 3482: 	link -&gt;
<a name="3483"/> 3483: 	    {'EXIT',Founder,normal} = receive_any(),
<a name="3484"/> 3484: 	    process_flag(trap_exit, false);
<a name="3485"/> 3485: 	monitor -&gt;
<a name="3486"/> 3486: 	    {'DOWN', Mref, process, Founder, normal} = receive_any();
<a name="3487"/> 3487: 	none -&gt; ok
<a name="3488"/> 3488:     end.
<a name="3489"/> 3489: 
<a name="3490"/> 3490: 
<a name="heir_1-3"/><a name="3491"/> 3491: <b>heir_1</b>(HeirData,Mode,Opts) -&gt;
<a name="3492"/> 3492:     io:format(&quot;test with heir_data = ~p\n&quot;, [HeirData]),
<a name="3493"/> 3493:     Master = self(),
<a name="3494"/> 3494:     Founder = my_spawn_link(fun() -&gt; heir_founder(Master,HeirData,Opts) end),
<a name="3495"/> 3495:     io:format(&quot;founder spawned = ~p\n&quot;, [Founder]),
<a name="3496"/> 3496:     {Heir,Mref} = my_spawn_monitor(fun() -&gt; heir_heir(Founder,Mode) end),
<a name="3497"/> 3497:     io:format(&quot;heir spawned = ~p\n&quot;, [{Heir,Mref}]),
<a name="3498"/> 3498:     Founder ! {go, Heir},
<a name="heir_1-last_expr"/><a name="3499"/> 3499: <b>    {'DOWN', Mref, process, Heir, normal} = receive_any</b>().
<a name="3500"/> 3500: 
<a name="3501"/> 3501: <i>%% Test ets:give_way/3.</i>
<a name="give_away-1"/><a name="3502"/> 3502: <b>give_away</b>(Config) when is_list(Config) -&gt;
<a name="give_away-last_expr"/><a name="3503"/> 3503: <b>    repeat_for_opts</b>(fun give_away_do/1).
<a name="3504"/> 3504: 
<a name="give_away_do-1"/><a name="3505"/> 3505: <b>give_away_do</b>(Opts) -&gt;
<a name="3506"/> 3506:     T = ets_new(foo,[named_table, private | Opts]),
<a name="3507"/> 3507:     true = ets:insert(T,{key,1}),
<a name="3508"/> 3508:     [{key,1}] = ets:lookup(T,key),
<a name="3509"/> 3509:     Parent = self(),
<a name="3510"/> 3510: 
<a name="3511"/> 3511:     %% Give and then give back
<a name="3512"/> 3512:     {Receiver,Mref} = my_spawn_monitor(fun()-&gt; give_away_receiver(T,Parent) end),
<a name="3513"/> 3513:     give_me = receive_any(),
<a name="3514"/> 3514:     true = ets:give_away(T,Receiver,here_you_are),
<a name="3515"/> 3515:     {'EXIT',{badarg,_}} = (catch ets:lookup(T,key)),
<a name="3516"/> 3516:     Receiver ! give_back,
<a name="3517"/> 3517:     {'ETS-TRANSFER',T,Receiver,&quot;Tillbakakaka&quot;} = receive_any(),
<a name="3518"/> 3518:     [{key,2}] = ets:lookup(T,key),
<a name="3519"/> 3519:     {'DOWN', Mref, process, Receiver, normal} = receive_any(),
<a name="3520"/> 3520: 
<a name="3521"/> 3521:     %% Give and then let receiver keep it
<a name="3522"/> 3522:     true = ets:insert(T,{key,1}),
<a name="3523"/> 3523:     {Receiver3,Mref3} = my_spawn_monitor(fun()-&gt; give_away_receiver(T,Parent) end),
<a name="3524"/> 3524:     give_me = receive_any(),
<a name="3525"/> 3525:     true = ets:give_away(T,Receiver3,here_you_are),
<a name="3526"/> 3526:     {'EXIT',{badarg,_}} = (catch ets:lookup(T,key)),
<a name="3527"/> 3527:     Receiver3 ! die_please,
<a name="3528"/> 3528:     {'DOWN', Mref3, process, Receiver3, normal} = receive_any(),
<a name="3529"/> 3529:     undefined = ets:info(T),
<a name="3530"/> 3530: 
<a name="3531"/> 3531:     %% Give and then kill receiver to get back
<a name="3532"/> 3532:     T2 = ets_new(foo,[private | Opts]),
<a name="3533"/> 3533:     true = ets:insert(T2,{key,1}),
<a name="3534"/> 3534:     ets:setopts(T2,{heir,self(),&quot;Som en gummiboll...&quot;}),
<a name="3535"/> 3535:     {Receiver2,Mref2} = my_spawn_monitor(fun()-&gt; give_away_receiver(T2,Parent) end),
<a name="3536"/> 3536:     give_me = receive_any(),
<a name="3537"/> 3537:     true = ets:give_away(T2,Receiver2,here_you_are),
<a name="3538"/> 3538:     {'EXIT',{badarg,_}} = (catch ets:lookup(T2,key)),
<a name="3539"/> 3539:     Receiver2 ! die_please,
<a name="3540"/> 3540:     {'ETS-TRANSFER',T2,Receiver2,&quot;Som en gummiboll...&quot;} = receive_any(),
<a name="3541"/> 3541:     [{key,2}] = ets:lookup(T2,key),
<a name="3542"/> 3542:     {'DOWN', Mref2, process, Receiver2, normal} = receive_any(),
<a name="3543"/> 3543: 
<a name="3544"/> 3544:     %% Some negative testing
<a name="3545"/> 3545:     {'EXIT',{badarg,_}} = (catch ets:give_away(T2,Receiver,&quot;To a dead one&quot;)),
<a name="3546"/> 3546:     {'EXIT',{badarg,_}} = (catch ets:give_away(T2,self(),&quot;To myself&quot;)),
<a name="3547"/> 3547:     {'EXIT',{badarg,_}} = (catch ets:give_away(T2,&quot;not a pid&quot;,&quot;To wrong type&quot;)),
<a name="3548"/> 3548: 
<a name="3549"/> 3549:     true = ets:delete(T2),
<a name="3550"/> 3550:     {ReceiverNeg,MrefNeg} = my_spawn_monitor(fun()-&gt; give_away_receiver(T2,Parent) end),
<a name="3551"/> 3551:     give_me = receive_any(),
<a name="3552"/> 3552:     {'EXIT',{badarg,_}} = (catch ets:give_away(T2,ReceiverNeg,&quot;A deleted table&quot;)),
<a name="3553"/> 3553: 
<a name="3554"/> 3554:     T3 = ets_new(foo,[public | Opts]),
<a name="3555"/> 3555:     my_spawn_link(fun()-&gt; {'EXIT',{badarg,_}} = (catch ets:give_away(T3,ReceiverNeg,&quot;From non owner&quot;)),
<a name="3556"/> 3556: 			  Parent ! done
<a name="3557"/> 3557: 		  end),
<a name="3558"/> 3558:     done = receive_any(),
<a name="3559"/> 3559:     ReceiverNeg ! no_soup_for_you,
<a name="3560"/> 3560:     {'DOWN', MrefNeg, process, ReceiverNeg, normal} = receive_any(),
<a name="give_away_do-last_expr"/><a name="3561"/> 3561:     ok.
<a name="3562"/> 3562: 
<a name="give_away_receiver-2"/><a name="3563"/> 3563: <b>give_away_receiver</b>(T, Giver) -&gt;
<a name="3564"/> 3564:     {'EXIT',{badarg,_}} = (catch ets:lookup(T,key)),
<a name="3565"/> 3565:     Giver ! give_me,
<a name="give_away_receiver-last_expr"/><a name="3566"/> 3566: <b>    case receive_any</b>() of
<a name="3567"/> 3567: 	{'ETS-TRANSFER',T,Giver,here_you_are} -&gt;
<a name="3568"/> 3568: 	    [{key,1}] = ets:lookup(T,key),
<a name="3569"/> 3569: 	    true = ets:insert(T,{key,2}),
<a name="3570"/> 3570: 	    case receive_any() of
<a name="3571"/> 3571: 		give_back -&gt;
<a name="3572"/> 3572: 		    true = ets:give_away(T,Giver,&quot;Tillbakakaka&quot;),
<a name="3573"/> 3573: 		    {'EXIT',{badarg,_}} = (catch ets:lookup(T,key));
<a name="3574"/> 3574: 		die_please -&gt;
<a name="3575"/> 3575: 		    ok
<a name="3576"/> 3576: 	    end;
<a name="3577"/> 3577: 	no_soup_for_you -&gt;
<a name="3578"/> 3578: 	    ok
<a name="3579"/> 3579:     end.
<a name="3580"/> 3580: 
<a name="3581"/> 3581: 
<a name="3582"/> 3582: <i>%% Test ets:setopts/2.</i>
<a name="setopts-1"/><a name="3583"/> 3583: <b>setopts</b>(Config) when is_list(Config) -&gt;
<a name="setopts-last_expr"/><a name="3584"/> 3584: <b>    repeat_for_opts</b>(fun setopts_do/1, [write_concurrency,all_types]).
<a name="3585"/> 3585: 
<a name="setopts_do-1"/><a name="3586"/> 3586: <b>setopts_do</b>(Opts) -&gt;
<a name="3587"/> 3587:     Self = self(),
<a name="3588"/> 3588:     T = ets_new(foo,[named_table, private | Opts]),
<a name="3589"/> 3589:     none = ets:info(T,heir),
<a name="3590"/> 3590:     Heir = my_spawn_link(fun()-&gt;heir_heir(Self) end),
<a name="3591"/> 3591:     ets:setopts(T,{heir,Heir,&quot;Data&quot;}),
<a name="3592"/> 3592:     Heir = ets:info(T,heir),
<a name="3593"/> 3593:     ets:setopts(T,{heir,self(),&quot;Data&quot;}),
<a name="3594"/> 3594:     Self = ets:info(T,heir),
<a name="3595"/> 3595:     ets:setopts(T,[{heir,Heir,&quot;Data&quot;}]),
<a name="3596"/> 3596:     Heir = ets:info(T,heir),
<a name="3597"/> 3597:     ets:setopts(T,[{heir,none}]),
<a name="3598"/> 3598:     none = ets:info(T,heir),
<a name="3599"/> 3599: 
<a name="3600"/> 3600:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,[{heir,self(),&quot;Data&quot;},false])),
<a name="3601"/> 3601:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,{heir,self()})),
<a name="3602"/> 3602:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,{heir,false})),
<a name="3603"/> 3603:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,heir)),
<a name="3604"/> 3604:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,{heir,false,&quot;Data&quot;})),
<a name="3605"/> 3605:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,{false,self(),&quot;Data&quot;})),
<a name="3606"/> 3606: 
<a name="3607"/> 3607:     ets:setopts(T,{protection,protected}),
<a name="3608"/> 3608:     ets:setopts(T,{protection,public}),
<a name="3609"/> 3609:     ets:setopts(T,{protection,private}),
<a name="3610"/> 3610:     ets:setopts(T,[{protection,protected}]),
<a name="3611"/> 3611:     ets:setopts(T,[{protection,public}]),
<a name="3612"/> 3612:     ets:setopts(T,[{protection,private}]),
<a name="3613"/> 3613: 
<a name="3614"/> 3614:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,{protection})),
<a name="3615"/> 3615:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,{protection,false})),
<a name="3616"/> 3616:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,{protection,private,false})),
<a name="3617"/> 3617:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,protection)),
<a name="3618"/> 3618:     ets:delete(T),
<a name="3619"/> 3619:     unlink(Heir),
<a name="3620"/> 3620:     exit(Heir, bang),
<a name="setopts_do-last_expr"/><a name="3621"/> 3621:     ok.
<a name="3622"/> 3622: 
<a name="3623"/> 3623: <i>%% All kinds of operations with bad table argument.</i>
<a name="bad_table-1"/><a name="3624"/> 3624: <b>bad_table</b>(Config) when is_list(Config) -&gt;
<a name="3625"/> 3625: 
<a name="3626"/> 3626:     %% Open and close disk_log to stabilize etsmem.
<a name="3627"/> 3627:     Name = make_ref(),
<a name="3628"/> 3628:     File = filename:join([proplists:get_value(priv_dir, Config),&quot;bad_table.dummy&quot;]),
<a name="3629"/> 3629:     {ok, Name} = disk_log:open([{name, Name}, {file, File}]),
<a name="3630"/> 3630:     disk_log:close(Name),
<a name="3631"/> 3631:     file:delete(File),
<a name="3632"/> 3632: 
<a name="3633"/> 3633:     EtsMem = etsmem(),
<a name="3634"/> 3634: 
<a name="3635"/> 3635:     repeat_for_opts(fun(Opts) -&gt; bad_table_do(Opts,File) end,
<a name="3636"/> 3636: 		    [write_concurrency, all_types]),
<a name="3637"/> 3637:     verify_etsmem(EtsMem),
<a name="bad_table-last_expr"/><a name="3638"/> 3638:     ok.
<a name="3639"/> 3639: 
<a name="bad_table_do-2"/><a name="3640"/> 3640: <b>bad_table_do</b>(Opts, DummyFile) -&gt;
<a name="3641"/> 3641:     Parent = self(),
<a name="3642"/> 3642:     {Pid,Mref} = my_spawn_opt(fun()-&gt; ets_new(priv,[private,named_table | Opts]),
<a name="3643"/> 3643: 				      Priv = ets_new(priv,[private | Opts]),
<a name="3644"/> 3644: 				      ets_new(prot,[protected,named_table | Opts]),
<a name="3645"/> 3645: 				      Prot = ets_new(prot,[protected | Opts]),
<a name="3646"/> 3646: 				      Parent ! {self(),Priv,Prot},
<a name="3647"/> 3647: 				      die_please = receive_any()
<a name="3648"/> 3648: 			      end,
<a name="3649"/> 3649: 			      [link, monitor]),
<a name="3650"/> 3650:     {Pid,Priv,Prot} = receive_any(),
<a name="3651"/> 3651:     MatchSpec = {{key,'_'}, [], ['$$']},
<a name="3652"/> 3652:     Fun = fun(X,_) -&gt; X end,
<a name="3653"/> 3653:     OpList = [{delete,[key],update},
<a name="3654"/> 3654: 	      {delete_all_objects,[],update},
<a name="3655"/> 3655: 	      {delete_object,[{key,data}],update},
<a name="3656"/> 3656: 	      {first,[],read},
<a name="3657"/> 3657: 	      {foldl,[Fun, 0], read, tabarg_last},
<a name="3658"/> 3658: 	      {foldr,[Fun, 0], read, tabarg_last},
<a name="3659"/> 3659: 	      %%{from_dets,[DetsTab], update},
<a name="3660"/> 3660: 	      {give_away,[Pid, data], update},
<a name="3661"/> 3661: 	      %%{info, [], read},
<a name="3662"/> 3662: 	      %%{info, [safe_fixed], read},
<a name="3663"/> 3663: 	      %%{init_table,[Name, InitFun],update},
<a name="3664"/> 3664: 	      {insert, [{key,data}], update},
<a name="3665"/> 3665: 	      {insert_new, [{key,data}], update},
<a name="3666"/> 3666: 	      {insert_new, [[{key,data},{other,data}]], update},
<a name="3667"/> 3667: 	      {last, [], read},
<a name="3668"/> 3668: 	      {lookup, [key], read},
<a name="3669"/> 3669: 	      {lookup_element, [key, 2], read},
<a name="3670"/> 3670: 	      {match, [{}], read},
<a name="3671"/> 3671: 	      {match, [{},17], read},
<a name="3672"/> 3672: 	      {match_delete, [{}], update},
<a name="3673"/> 3673: 	      {match_object, [{}], read},
<a name="3674"/> 3674: 	      {match_object, [{},17], read},
<a name="3675"/> 3675: 	      {member,[key], read},
<a name="3676"/> 3676: 	      {next, [key], read},
<a name="3677"/> 3677: 	      {prev, [key], read},
<a name="3678"/> 3678: 	      {rename, [new_name], update},
<a name="3679"/> 3679: 	      {safe_fixtable, [true], read},
<a name="3680"/> 3680: 	      {select,[MatchSpec], read},
<a name="3681"/> 3681: 	      {select,[MatchSpec,17], read},
<a name="3682"/> 3682: 	      {select_count,[MatchSpec], read},
<a name="3683"/> 3683: 	      {select_delete,[MatchSpec], update},
<a name="3684"/> 3684: 	      {setopts, [{heir,none}], update},
<a name="3685"/> 3685: 	      {slot, [0], read},
<a name="3686"/> 3686: 	      {tab2file, [DummyFile], read, {return,{error,badtab}}},
<a name="3687"/> 3687: 	      {tab2file, [DummyFile,[]], read, {return,{error,badtab}}},
<a name="3688"/> 3688: 	      {tab2list, [], read},
<a name="3689"/> 3689: 	      %%{table,[], read},
<a name="3690"/> 3690: 	      %%{to_dets, [DetsTab], read},
<a name="3691"/> 3691: 	      {update_counter,[key,1], update},
<a name="3692"/> 3692: 	      {update_element,[key,{2,new_data}], update}
<a name="3693"/> 3693: 	     ],
<a name="3694"/> 3694:     Info = {Opts, Priv, Prot},
<a name="3695"/> 3695:     lists:foreach(fun(Op) -&gt; bad_table_op(Info, Op) end,
<a name="3696"/> 3696:                   OpList),
<a name="3697"/> 3697:     Pid ! die_please,
<a name="3698"/> 3698:     {'DOWN', Mref, process, Pid, normal} = receive_any(),
<a name="bad_table_do-last_expr"/><a name="3699"/> 3699:     ok.
<a name="3700"/> 3700: 
<a name="bad_table_op-2"/><a name="3701"/> 3701: <b>bad_table_op</b>({Opts,Priv,Prot}, Op) -&gt;
<a name="3702"/> 3702:     %%io:format(&quot;Doing Op=~p on ~p's\n&quot;,[Op,Type]),
<a name="3703"/> 3703:     T1 = ets_new(noname,Opts),
<a name="3704"/> 3704:     bad_table_call(noname,Op),
<a name="3705"/> 3705:     ets:delete(T1),
<a name="3706"/> 3706:     bad_table_call(T1,Op),
<a name="3707"/> 3707:     T2 = ets_new(named,[named_table | Opts]),
<a name="3708"/> 3708:     ets:delete(T2),
<a name="3709"/> 3709:     bad_table_call(named,Op),
<a name="3710"/> 3710:     bad_table_call(T2,Op),
<a name="3711"/> 3711:     bad_table_call(priv,Op),
<a name="3712"/> 3712:     bad_table_call(Priv,Op),
<a name="bad_table_op-last_expr"/><a name="3713"/> 3713: <b>    case element</b>(3,Op) of
<a name="3714"/> 3714: 	update -&gt;
<a name="3715"/> 3715: 	    bad_table_call(prot,Op),
<a name="3716"/> 3716: 	    bad_table_call(Prot,Op);
<a name="3717"/> 3717: 	read -&gt; ok
<a name="3718"/> 3718:     end.
<a name="3719"/> 3719: 
<a name="bad_table_call-2"/><a name="3720"/> 3720: <b>bad_table_call</b>(T,{F,Args,_}) -&gt;
<a name="3721"/> 3721:     {'EXIT',{badarg,_}} = (catch apply(ets, F, [T|Args]));
<a name="3722"/> 3722: <b>bad_table_call</b>(T,{F,Args,_,tabarg_last}) -&gt;
<a name="3723"/> 3723:     {'EXIT',{badarg,_}} = (catch apply(ets, F, Args++[T]));
<a name="3724"/> 3724: <b>bad_table_call</b>(T,{F,Args,_,{return,Return}}) -&gt;
<a name="bad_table_call-last_expr"/><a name="3725"/> 3725:     try
<a name="3726"/> 3726: 	Return = apply(ets, F, [T|Args])
<a name="3727"/> 3727:     catch
<a name="3728"/> 3728: 	error:badarg -&gt; ok
<a name="3729"/> 3729:     end.
<a name="3730"/> 3730: 
<a name="3731"/> 3731: 
<a name="3732"/> 3732: <i>%% Check rename of ets tables.</i>
<a name="rename-1"/><a name="3733"/> 3733: <b>rename</b>(Config) when is_list(Config) -&gt;
<a name="rename-last_expr"/><a name="3734"/> 3734: <b>    repeat_for_opts</b>(fun rename_do/1, [write_concurrency, all_types]).
<a name="3735"/> 3735: 
<a name="rename_do-1"/><a name="3736"/> 3736: <b>rename_do</b>(Opts) -&gt;
<a name="3737"/> 3737:     EtsMem = etsmem(),
<a name="3738"/> 3738:     ets_new(foobazz,[named_table, public | Opts]),
<a name="3739"/> 3739:     ets:insert(foobazz,{foo,bazz}),
<a name="3740"/> 3740:     ungermanbazz = ets:rename(foobazz,ungermanbazz),
<a name="3741"/> 3741:     {'EXIT',{badarg, _}} = (catch ets:lookup(foobazz,foo)),
<a name="3742"/> 3742:     [{foo,bazz}] = ets:lookup(ungermanbazz,foo),
<a name="3743"/> 3743:     {'EXIT',{badarg,_}} =  (catch ets:rename(ungermanbazz,&quot;no atom&quot;)),
<a name="3744"/> 3744:     ets:delete(ungermanbazz),
<a name="rename_do-last_expr"/><a name="3745"/> 3745: <b>    verify_etsmem</b>(EtsMem).
<a name="3746"/> 3746: 
<a name="3747"/> 3747: <i>%% Check rename of unnamed ets table.</i>
<a name="rename_unnamed-1"/><a name="3748"/> 3748: <b>rename_unnamed</b>(Config) when is_list(Config) -&gt;
<a name="rename_unnamed-last_expr"/><a name="3749"/> 3749: <b>    repeat_for_opts</b>(fun rename_unnamed_do/1,
<a name="3750"/> 3750:                     [write_concurrency,all_types]).
<a name="3751"/> 3751: 
<a name="rename_unnamed_do-1"/><a name="3752"/> 3752: <b>rename_unnamed_do</b>(Opts) -&gt;
<a name="3753"/> 3753:     EtsMem = etsmem(),
<a name="3754"/> 3754:     Tab = ets_new(bonkz,[public | Opts]),
<a name="3755"/> 3755:     {'EXIT',{badarg, _}} = (catch ets:insert(bonkz,{foo,bazz})),
<a name="3756"/> 3756:     bonkz = ets:info(Tab, name),
<a name="3757"/> 3757:     Tab = ets:rename(Tab, tjabonkz),
<a name="3758"/> 3758:     {'EXIT',{badarg, _}} = (catch ets:insert(tjabonkz,{foo,bazz})),
<a name="3759"/> 3759:     tjabonkz = ets:info(Tab, name),
<a name="3760"/> 3760:     ets:delete(Tab),
<a name="rename_unnamed_do-last_expr"/><a name="3761"/> 3761: <b>    verify_etsmem</b>(EtsMem).
<a name="3762"/> 3762: 
<a name="3763"/> 3763: <i>%% Rename a table with many fixations, and at the same time delete it.</i>
<a name="evil_rename-1"/><a name="3764"/> 3764: <b>evil_rename</b>(Config) when is_list(Config) -&gt;
<a name="3765"/> 3765:     EtsMem = etsmem(),
<a name="3766"/> 3766:     evil_rename_1(old_hash, new_hash, [public,named_table]),
<a name="3767"/> 3767:     evil_rename_1(old_tree, new_tree, [public,ordered_set,named_table]),
<a name="3768"/> 3768:     wait_for_test_procs(true),
<a name="evil_rename-last_expr"/><a name="3769"/> 3769: <b>    verify_etsmem</b>(EtsMem).
<a name="3770"/> 3770: 
<a name="evil_rename_1-3"/><a name="3771"/> 3771: <b>evil_rename_1</b>(Old, New, Flags) -&gt;
<a name="3772"/> 3772:     process_flag(trap_exit, true),
<a name="3773"/> 3773:     Old = ets_new(Old, Flags),
<a name="3774"/> 3774:     Fixer = fun() -&gt; ets:safe_fixtable(Old, true) end,
<a name="3775"/> 3775:     crazy_fixtable(15000, Fixer),
<a name="3776"/> 3776:     erlang:yield(),
<a name="3777"/> 3777:     New = ets:rename(Old, New),
<a name="3778"/> 3778:     erlang:yield(),
<a name="3779"/> 3779:     ets:delete(New),
<a name="evil_rename_1-last_expr"/><a name="3780"/> 3780:     ok.
<a name="3781"/> 3781: 
<a name="crazy_fixtable-2"/><a name="3782"/> 3782: <b>crazy_fixtable</b>(N, Fixer) -&gt;
<a name="3783"/> 3783:     Dracula = ets_new(count_dracula, [public]),
<a name="3784"/> 3784:     ets:insert(Dracula, {count,0}),
<a name="3785"/> 3785:     SpawnFun = fun() -&gt;
<a name="3786"/> 3786: 		       Fixer(),
<a name="3787"/> 3787: 		       case ets:update_counter(Dracula, count, 1) rem 15 of
<a name="3788"/> 3788: 			   0 -&gt; evil_creater_destroyer();
<a name="3789"/> 3789: 			   _ -&gt; erlang:hibernate(erlang, error, [dont_wake_me])
<a name="3790"/> 3790: 		       end
<a name="3791"/> 3791: 	       end,
<a name="3792"/> 3792:     crazy_fixtable_1(N, SpawnFun),
<a name="3793"/> 3793:     crazy_fixtable_wait(N, Dracula),
<a name="crazy_fixtable-last_expr"/><a name="3794"/> 3794:     Dracula.
<a name="3795"/> 3795: 
<a name="crazy_fixtable_wait-2"/><a name="3796"/> 3796: <b>crazy_fixtable_wait</b>(N, Dracula) -&gt;
<a name="crazy_fixtable_wait-last_expr"/><a name="3797"/> 3797: <b>    case ets:lookup</b>(Dracula, count) of
<a name="3798"/> 3798: 	[{count,N}] -&gt;
<a name="3799"/> 3799: 	    ets:delete(Dracula);
<a name="3800"/> 3800: 	Other -&gt;
<a name="3801"/> 3801: 	    io:format(&quot;~p\n&quot;, [Other]),
<a name="3802"/> 3802: 	    receive after 10 -&gt; ok end,
<a name="3803"/> 3803: 	    crazy_fixtable_wait(N, Dracula)
<a name="3804"/> 3804:     end.
<a name="3805"/> 3805: 
<a name="crazy_fixtable_1-2"/><a name="3806"/> 3806: <b>crazy_fixtable_1</b>(0, _) -&gt;
<a name="3807"/> 3807:     ok;
<a name="3808"/> 3808: <b>crazy_fixtable_1</b>(N, Fun) -&gt;
<a name="3809"/> 3809:     %%FIXME my_spawn_link(Fun),
<a name="3810"/> 3810:     my_spawn_link(Fun),
<a name="crazy_fixtable_1-last_expr"/><a name="3811"/> 3811: <b>    crazy_fixtable_1</b>(N-1, Fun).
<a name="3812"/> 3812: 
<a name="evil_creater_destroyer-0"/><a name="3813"/> 3813: <b>evil_creater_destroyer</b>() -&gt;
<a name="3814"/> 3814:     T1 = evil_create_fixed_tab(),
<a name="evil_creater_destroyer-last_expr"/><a name="3815"/> 3815: <b>    ets:delete</b>(T1).
<a name="3816"/> 3816: 
<a name="evil_create_fixed_tab-0"/><a name="3817"/> 3817: <b>evil_create_fixed_tab</b>() -&gt;
<a name="3818"/> 3818:     T = ets_new(arne, [public]),
<a name="3819"/> 3819:     ets:safe_fixtable(T, true),
<a name="evil_create_fixed_tab-last_expr"/><a name="3820"/> 3820:     T.
<a name="3821"/> 3821: 
<a name="3822"/> 3822: <i>%% Tests that the return values and errors are equal for set's and</i>
<a name="3823"/> 3823: <i>%% ordered_set's where applicable.</i>
<a name="interface_equality-1"/><a name="3824"/> 3824: <b>interface_equality</b>(Config) when is_list(Config) -&gt;
<a name="interface_equality-last_expr"/><a name="3825"/> 3825: <b>    repeat_for_opts</b>(fun interface_equality_do/1).
<a name="3826"/> 3826: 
<a name="interface_equality_do-1"/><a name="3827"/> 3827: <b>interface_equality_do</b>(Opts) -&gt;
<a name="3828"/> 3828:     EtsMem = etsmem(),
<a name="3829"/> 3829:     Set = ets_new(set,[set | Opts]),
<a name="3830"/> 3830:     OrderedSet = ets_new(ordered_set,
<a name="3831"/> 3831:                          replace_dbg_hash_fixed_nr_of_locks([ordered_set | Opts])),
<a name="3832"/> 3832:     F = fun(X,T,FF) -&gt; case X of
<a name="3833"/> 3833:                            0 -&gt; true;
<a name="3834"/> 3834:                            _ -&gt;
<a name="3835"/> 3835:                                ets:insert(T, {X,
<a name="3836"/> 3836:                                               integer_to_list(X),
<a name="3837"/> 3837:                                               X rem 10}),
<a name="3838"/> 3838:                                FF(X-1,T,FF)
<a name="3839"/> 3839:                        end
<a name="3840"/> 3840:         end,
<a name="3841"/> 3841:     F(100,Set,F),
<a name="3842"/> 3842:     F(100,OrderedSet,F),
<a name="3843"/> 3843:     equal_results(ets, insert, Set, OrderedSet, [{a,&quot;a&quot;}]),
<a name="3844"/> 3844:     equal_results(ets, insert, Set, OrderedSet, [{1,1,&quot;1&quot;}]),
<a name="3845"/> 3845:     equal_results(ets, lookup, Set, OrderedSet, [10]),
<a name="3846"/> 3846:     equal_results(ets, lookup, Set, OrderedSet, [1000]),
<a name="3847"/> 3847:     equal_results(ets, delete, Set, OrderedSet, [10]),
<a name="3848"/> 3848:     equal_results(ets, delete, Set, OrderedSet, [nott]),
<a name="3849"/> 3849:     equal_results(ets, lookup, Set, OrderedSet, [1000]),
<a name="3850"/> 3850:     equal_results(ets, insert, Set, OrderedSet, [10]),
<a name="3851"/> 3851:     equal_results(ets, next, Set, OrderedSet, ['$end_of_table']),
<a name="3852"/> 3852:     equal_results(ets, prev, Set, OrderedSet, ['$end_of_table']),
<a name="3853"/> 3853:     equal_results(ets, match, Set, OrderedSet, [{'_','_','_'}]),
<a name="3854"/> 3854:     equal_results(ets, match, Set, OrderedSet, [{'_','_','_','_'}]),
<a name="3855"/> 3855:     equal_results(ets, match, Set, OrderedSet, [{$3,$2,2}]),
<a name="3856"/> 3856:     equal_results(ets, match, Set, OrderedSet, ['_']),
<a name="3857"/> 3857:     equal_results(ets, match, Set, OrderedSet, ['$1']),
<a name="3858"/> 3858:     equal_results(ets, match, Set, OrderedSet, [{'_','$50',3}]),
<a name="3859"/> 3859:     equal_results(ets, match, Set, OrderedSet, [['_','$50',3]]),
<a name="3860"/> 3860:     equal_results(ets, match_delete, Set, OrderedSet, [{'_','_',4}]),
<a name="3861"/> 3861:     equal_results(ets, match_delete, Set, OrderedSet, [{'_','_',4}]),
<a name="3862"/> 3862:     equal_results(ets, match_object, Set, OrderedSet, [{'_','_',4}]),
<a name="3863"/> 3863:     equal_results(ets, match_object, Set, OrderedSet, [{'_','_',5}]),
<a name="3864"/> 3864:     equal_results(ets, match_object, Set, OrderedSet, [{'_','_',4}]),
<a name="3865"/> 3865:     equal_results(ets, match_object, Set, OrderedSet, ['_']),
<a name="3866"/> 3866:     equal_results(ets, match_object, Set, OrderedSet, ['$5011']),
<a name="3867"/> 3867:     equal_results(ets, match_delete, Set, OrderedSet, ['$20']),
<a name="3868"/> 3868:     equal_results(ets, lookup_element, Set, OrderedSet, [13,2]),
<a name="3869"/> 3869:     equal_results(ets, lookup_element, Set, OrderedSet, [13,4]),
<a name="3870"/> 3870:     equal_results(ets, lookup_element, Set, OrderedSet, [14,2]),
<a name="3871"/> 3871:     equal_results(ets, delete, Set, OrderedSet, []),
<a name="interface_equality_do-last_expr"/><a name="3872"/> 3872: <b>    verify_etsmem</b>(EtsMem).
<a name="3873"/> 3873: 
<a name="equal_results-5"/><a name="3874"/> 3874: <b>equal_results</b>(M, F, FirstArg1, FirstArg2 ,ACommon) -&gt;
<a name="3875"/> 3875:     Res = maybe_sort((catch apply(M,F, [FirstArg1 | ACommon]))),
<a name="equal_results-last_expr"/><a name="3876"/> 3876: <b>    Res = maybe_sort</b>((catch apply(M,F,[FirstArg2 | ACommon]))).
<a name="3877"/> 3877: 
<a name="maybe_sort-1"/><a name="3878"/> 3878: <b>maybe_sort</b>(L) when is_list(L) -&gt;
<a name="3879"/> 3879:     lists:sort(L);
<a name="3880"/> 3880: <b>maybe_sort</b>({'EXIT',{Reason, List}}) when is_list(List) -&gt;
<a name="3881"/> 3881:     {'EXIT',{Reason, lists:map(fun({Module, Function, _, _}) -&gt;
<a name="3882"/> 3882: 				       {Module, Function, '_'}
<a name="3883"/> 3883: 			       end,
<a name="3884"/> 3884: 			       List)}};
<a name="3885"/> 3885: <b>maybe_sort</b>(Any) -&gt;
<a name="maybe_sort-last_expr"/><a name="3886"/> 3886:     Any.
<a name="3887"/> 3887: 
<a name="3888"/> 3888: <i>%% Test match, match_object and match_delete in ordered set's.</i>
<a name="ordered_match-1"/><a name="3889"/> 3889: <b>ordered_match</b>(Config) when is_list(Config)-&gt;
<a name="ordered_match-last_expr"/><a name="3890"/> 3890: <b>    repeat_for_opts_extra_opt</b>(fun ordered_match_do/1, ordered_set).
<a name="3891"/> 3891: 
<a name="ordered_match_do-1"/><a name="3892"/> 3892: <b>ordered_match_do</b>(Opts) -&gt;
<a name="3893"/> 3893:     EtsMem = etsmem(),
<a name="3894"/> 3894:     F = fun(X,T,FF) -&gt; case X of
<a name="3895"/> 3895: 			   0 -&gt; true;
<a name="3896"/> 3896: 			   _ -&gt;
<a name="3897"/> 3897: 			       ets:insert(T, {X,
<a name="3898"/> 3898: 					      integer_to_list(X),
<a name="3899"/> 3899: 					      X rem 10,
<a name="3900"/> 3900: 					      X rem 100,
<a name="3901"/> 3901: 					      X rem 1000}),
<a name="3902"/> 3902: 			       FF(X-1,T,FF)
<a name="3903"/> 3903: 		       end
<a name="3904"/> 3904: 	end,
<a name="3905"/> 3905:     T1 = ets_new(xxx,[ordered_set| Opts]),
<a name="3906"/> 3906:     F(3000,T1,F),
<a name="3907"/> 3907:     [[3,3],[3,3],[3,3]] = ets:match(T1, {'_','_','$1','$2',3}),
<a name="3908"/> 3908:     F2 = fun(X,Rem,Res,FF) -&gt; case X of
<a name="3909"/> 3909: 				  0 -&gt; [];
<a name="3910"/> 3910: 				  _ -&gt;
<a name="3911"/> 3911: 				      case X rem Rem of
<a name="3912"/> 3912: 					  Res -&gt;
<a name="3913"/> 3913: 					      FF(X-1,Rem,Res,FF) ++
<a name="3914"/> 3914: 						  [{X,
<a name="3915"/> 3915: 						    integer_to_list(X),
<a name="3916"/> 3916: 						    X rem 10,
<a name="3917"/> 3917: 						    X rem 100,
<a name="3918"/> 3918: 						    X rem 1000}];
<a name="3919"/> 3919: 					  _ -&gt;
<a name="3920"/> 3920: 					      FF(X-1,Rem,Res,FF)
<a name="3921"/> 3921: 				      end
<a name="3922"/> 3922: 			      end
<a name="3923"/> 3923: 	 end,
<a name="3924"/> 3924:     OL1 = F2(3000,100,2,F2),
<a name="3925"/> 3925:     OL1 = ets:match_object(T1, {'_','_','_',2,'_'}),
<a name="3926"/> 3926:     true = ets:match_delete(T1,{'_','_','_',2,'_'}),
<a name="3927"/> 3927:     [] = ets:match_object(T1, {'_','_','_',2,'_'}),
<a name="3928"/> 3928:     OL2 = F2(3000,100,3,F2),
<a name="3929"/> 3929:     OL2 = ets:match_object(T1, {'_','_','_',3,'_'}),
<a name="3930"/> 3930:     ets:delete(T1),
<a name="ordered_match_do-last_expr"/><a name="3931"/> 3931: <b>    verify_etsmem</b>(EtsMem).
<a name="3932"/> 3932: 
<a name="3933"/> 3933: 
<a name="3934"/> 3934: <i>%% Test basic functionality in ordered_set's.</i>
<a name="ordered-1"/><a name="3935"/> 3935: <b>ordered</b>(Config) when is_list(Config) -&gt;
<a name="ordered-last_expr"/><a name="3936"/> 3936: <b>    repeat_for_opts_extra_opt</b>(fun ordered_do/1, ordered_set).
<a name="3937"/> 3937: 
<a name="ordered_do-1"/><a name="3938"/> 3938: <b>ordered_do</b>(Opts) -&gt;
<a name="3939"/> 3939:     EtsMem = etsmem(),
<a name="3940"/> 3940:     T = ets_new(oset, [ordered_set | Opts]),
<a name="3941"/> 3941:     InsList = [
<a name="3942"/> 3942: 	       25,26,27,28,
<a name="3943"/> 3943: 	       5,6,7,8,
<a name="3944"/> 3944: 	       21,22,23,24,
<a name="3945"/> 3945: 	       9,10,11,12,
<a name="3946"/> 3946: 	       1,2,3,4,
<a name="3947"/> 3947: 	       17,18,19,20,
<a name="3948"/> 3948: 	       13,14,15,16,
<a name="3949"/> 3949: 	       1 bsl 33
<a name="3950"/> 3950: 	      ],
<a name="3951"/> 3951:     lists:foreach(fun(X) -&gt;
<a name="3952"/> 3952: 			  ets:insert(T,{X,integer_to_list(X)})
<a name="3953"/> 3953: 		  end,
<a name="3954"/> 3954: 		  InsList),
<a name="3955"/> 3955:     IL2 = lists:map(fun(X) -&gt; {X,integer_to_list(X)} end, InsList),
<a name="3956"/> 3956:     L1 = pick_all_forward(T),
<a name="3957"/> 3957:     L2 = pick_all_backwards(T),
<a name="3958"/> 3958:     S1 = lists:sort(IL2),
<a name="3959"/> 3959:     S2 = lists:reverse(lists:sort(IL2)),
<a name="3960"/> 3960:     S1 = L1,
<a name="3961"/> 3961:     S2 = L2,
<a name="3962"/> 3962:     [{1,&quot;1&quot;}] = ets:slot(T,0),
<a name="3963"/> 3963:     [{28,&quot;28&quot;}] = ets:slot(T,27),
<a name="3964"/> 3964:     [{1 bsl 33,_}] = ets:slot(T,28),
<a name="3965"/> 3965:     27 = ets:prev(T,28),
<a name="3966"/> 3966:     [{7,&quot;7&quot;}] = ets:slot(T,6),
<a name="3967"/> 3967:     '$end_of_table' = ets:next(T,1 bsl 33),
<a name="3968"/> 3968:     [{12,&quot;12&quot;}] = ets:slot(T,11),
<a name="3969"/> 3969:     '$end_of_table' = ets:slot(T,29),
<a name="3970"/> 3970:     [{1,&quot;1&quot;}] = ets:slot(T,0),
<a name="3971"/> 3971:     28 = ets:prev(T,1 bsl 33),
<a name="3972"/> 3972:     1 = ets:next(T,0),
<a name="3973"/> 3973:     pick_all_forward(T),
<a name="3974"/> 3974:     [{7,&quot;7&quot;}] = ets:slot(T,6),
<a name="3975"/> 3975:     L2 = pick_all_backwards(T),
<a name="3976"/> 3976:     [{7,&quot;7&quot;}] = ets:slot(T,6),
<a name="3977"/> 3977:     ets:delete(T),
<a name="ordered_do-last_expr"/><a name="3978"/> 3978: <b>    verify_etsmem</b>(EtsMem).
<a name="3979"/> 3979: 
<a name="pick_all-3"/><a name="3980"/> 3980: <b>pick_all</b>(_T,'$end_of_table',_How) -&gt;
<a name="3981"/> 3981:     [];
<a name="3982"/> 3982: <b>pick_all</b>(T,Last,How) -&gt;
<a name="3983"/> 3983:     This = case How of
<a name="3984"/> 3984: 	       next -&gt;
<a name="3985"/> 3985: 		   ets:next(T,Last);
<a name="3986"/> 3986: 	       prev -&gt;
<a name="3987"/> 3987: 		   ets:prev(T,Last)
<a name="3988"/> 3988: 	   end,
<a name="3989"/> 3989:     [LastObj] = ets:lookup(T,Last),
<a name="pick_all-last_expr"/><a name="3990"/> 3990: <b>    [LastObj | pick_all</b>(T,This,How)].
<a name="3991"/> 3991: 
<a name="pick_all_forward-1"/><a name="3992"/> 3992: <b>pick_all_forward</b>(T) -&gt;
<a name="pick_all_forward-last_expr"/><a name="3993"/> 3993: <b>    pick_all</b>(T,ets:first(T),next).
<a name="pick_all_backwards-1"/><a name="3994"/> 3994: <b>pick_all_backwards</b>(T) -&gt;
<a name="pick_all_backwards-last_expr"/><a name="3995"/> 3995: <b>    pick_all</b>(T,ets:last(T),prev).
<a name="3996"/> 3996: 
<a name="3997"/> 3997: 
<a name="3998"/> 3998: 
<a name="3999"/> 3999: <i>%% Small test case for both set and bag type ets tables.</i>
<a name="setbag-1"/><a name="4000"/> 4000: <b>setbag</b>(Config) when is_list(Config) -&gt;
<a name="4001"/> 4001:     EtsMem = etsmem(),
<a name="4002"/> 4002:     lists:foreach(fun(SetType) -&gt; 
<a name="4003"/> 4003:                           Set = ets_new(SetType,[SetType]),
<a name="4004"/> 4004:                           Bag = ets_new(bag,[bag]),
<a name="4005"/> 4005:                           Key = {foo,bar},
<a name="4006"/> 4006:                           
<a name="4007"/> 4007:                           %% insert some value
<a name="4008"/> 4008:                           ets:insert(Set,{Key,val1}),
<a name="4009"/> 4009:                           ets:insert(Bag,{Key,val1}),
<a name="4010"/> 4010:                           
<a name="4011"/> 4011:                           %% insert new value for same key again
<a name="4012"/> 4012:                           ets:insert(Set,{Key,val2}),
<a name="4013"/> 4013:                           ets:insert(Bag,{Key,val2}),
<a name="4014"/> 4014:                           
<a name="4015"/> 4015:                           %% check
<a name="4016"/> 4016:                           [{Key,val2}] = ets:lookup(Set,Key),
<a name="4017"/> 4017:                           [{Key,val1},{Key,val2}] = ets:lookup(Bag,Key),
<a name="4018"/> 4018:                           
<a name="4019"/> 4019:                           true = ets:delete(Set),
<a name="4020"/> 4020:                           true = ets:delete(Bag)
<a name="4021"/> 4021:                   end, [set, cat_ord_set,stim_cat_ord_set,ordered_set]),
<a name="setbag-last_expr"/><a name="4022"/> 4022: <b>    verify_etsmem</b>(EtsMem).
<a name="4023"/> 4023: 
<a name="4024"/> 4024: <i>%% Test case to check proper return values for illegal ets_new() calls.</i>
<a name="badnew-1"/><a name="4025"/> 4025: <b>badnew</b>(Config) when is_list(Config) -&gt;
<a name="4026"/> 4026:     EtsMem = etsmem(),
<a name="4027"/> 4027:     {'EXIT',{badarg,_}} = (catch ets:new(12,[])),
<a name="4028"/> 4028:     {'EXIT',{badarg,_}} = (catch ets:new({a,b},[])),
<a name="4029"/> 4029:     {'EXIT',{badarg,_}} = (catch ets:new(name,[foo])),
<a name="4030"/> 4030:     {'EXIT',{badarg,_}} = (catch ets:new(name,{bag})),
<a name="4031"/> 4031:     {'EXIT',{badarg,_}} = (catch ets:new(name,bag)),
<a name="badnew-last_expr"/><a name="4032"/> 4032: <b>    verify_etsmem</b>(EtsMem).
<a name="4033"/> 4033: 
<a name="4034"/> 4034: <i>%% OTP-2314. Test case to check that a non-proper list does not</i>
<a name="4035"/> 4035: <i>%% crash the emulator.</i>
<a name="verybadnew-1"/><a name="4036"/> 4036: <b>verybadnew</b>(Config) when is_list(Config) -&gt;
<a name="4037"/> 4037:     EtsMem = etsmem(),
<a name="4038"/> 4038:     {'EXIT',{badarg,_}} = (catch ets:new(verybad,[set|protected])),
<a name="verybadnew-last_expr"/><a name="4039"/> 4039: <b>    verify_etsmem</b>(EtsMem).
<a name="4040"/> 4040: 
<a name="4041"/> 4041: <i>%% Small check to see if named tables work.</i>
<a name="named-1"/><a name="4042"/> 4042: <b>named</b>(Config) when is_list(Config) -&gt;
<a name="4043"/> 4043:     EtsMem = etsmem(),
<a name="4044"/> 4044:     Tab = make_table(foo,
<a name="4045"/> 4045: 		     [named_table],
<a name="4046"/> 4046: 		     [{key,val}]),
<a name="4047"/> 4047:     [{key,val}] = ets:lookup(foo,key),
<a name="4048"/> 4048:     true = ets:delete(Tab),
<a name="named-last_expr"/><a name="4049"/> 4049: <b>    verify_etsmem</b>(EtsMem).
<a name="4050"/> 4050: 
<a name="4051"/> 4051: <i>%% Test case to check if specified keypos works.</i>
<a name="keypos2-1"/><a name="4052"/> 4052: <b>keypos2</b>(Config) when is_list(Config) -&gt;
<a name="4053"/> 4053:     EtsMem = etsmem(),
<a name="4054"/> 4054:     lists:foreach(fun(SetType) -&gt; 
<a name="4055"/> 4055:                           Tab = make_table(foo,
<a name="4056"/> 4056:                                            [SetType,{keypos,2}],
<a name="4057"/> 4057:                                            [{val,key}, {val2,key}]),
<a name="4058"/> 4058:                           [{val2,key}] = ets:lookup(Tab,key),
<a name="4059"/> 4059:                           true = ets:delete(Tab)
<a name="4060"/> 4060:                   end, [set, cat_ord_set,stim_cat_ord_set,ordered_set]),
<a name="keypos2-last_expr"/><a name="4061"/> 4061: <b>    verify_etsmem</b>(EtsMem).
<a name="4062"/> 4062: 
<a name="4063"/> 4063: <i>%% Privacy check. Check that a named(public/private/protected) table</i>
<a name="4064"/> 4064: <i>%% cannot be read by the wrong process(es).</i>
<a name="privacy-1"/><a name="4065"/> 4065: <b>privacy</b>(Config) when is_list(Config) -&gt;
<a name="privacy-last_expr"/><a name="4066"/> 4066: <b>    repeat_for_opts</b>(fun privacy_do/1).
<a name="4067"/> 4067: 
<a name="privacy_do-1"/><a name="4068"/> 4068: <b>privacy_do</b>(Opts) -&gt;
<a name="4069"/> 4069:     EtsMem = etsmem(),
<a name="4070"/> 4070:     process_flag(trap_exit,true),
<a name="4071"/> 4071:     Parent = self(),
<a name="4072"/> 4072:     Owner = my_spawn_link(fun() -&gt; privacy_owner(Parent, Opts) end),
<a name="4073"/> 4073:     receive
<a name="4074"/> 4074: 	{'EXIT',Owner,Reason} -&gt;
<a name="4075"/> 4075: 	    exit({privacy_test,Reason});
<a name="4076"/> 4076: 	ok -&gt;
<a name="4077"/> 4077: 	    ok
<a name="4078"/> 4078:     end,
<a name="4079"/> 4079: 
<a name="4080"/> 4080:     privacy_check(pub,prot,priv),
<a name="4081"/> 4081: 
<a name="4082"/> 4082:     Owner ! {shift,1,{pub,prot,priv}},
<a name="4083"/> 4083:     receive
<a name="4084"/> 4084:         {Pub1,Prot1,Priv1} -&gt;
<a name="4085"/> 4085:             ok = privacy_check(Pub1,Prot1,Priv1),
<a name="4086"/> 4086:             Owner ! {shift,2,{Pub1,Prot1,Priv1}}
<a name="4087"/> 4087:     end,
<a name="4088"/> 4088: 
<a name="4089"/> 4089:     receive
<a name="4090"/> 4090:         {Pub2,Prot2,Priv2} -&gt;
<a name="4091"/> 4091:             ok = privacy_check(Pub2,Prot2,Priv2),
<a name="4092"/> 4092:             Owner ! {shift,0,{Pub2,Prot2,Priv2}}
<a name="4093"/> 4093:     end,
<a name="4094"/> 4094: 
<a name="4095"/> 4095:     receive
<a name="4096"/> 4096:         {Pub3,Prot3,Priv3} -&gt;
<a name="4097"/> 4097:             ok = privacy_check(Pub3,Prot3,Priv3)
<a name="4098"/> 4098:     end,
<a name="4099"/> 4099: 
<a name="4100"/> 4100:     Owner ! die,
<a name="4101"/> 4101:     receive {'EXIT',Owner,_} -&gt; ok end,
<a name="privacy_do-last_expr"/><a name="4102"/> 4102: <b>    verify_etsmem</b>(EtsMem).
<a name="4103"/> 4103: 
<a name="privacy_check-3"/><a name="4104"/> 4104: <b>privacy_check</b>(Pub,Prot,Priv) -&gt;
<a name="4105"/> 4105:     %% check read rights
<a name="4106"/> 4106:     [] = ets:lookup(Pub, foo),
<a name="4107"/> 4107:     [] = ets:lookup(Prot,foo),
<a name="4108"/> 4108:     {'EXIT',{badarg,_}} = (catch ets:lookup(Priv,foo)),
<a name="4109"/> 4109: 
<a name="4110"/> 4110:     %% check write rights
<a name="4111"/> 4111:     true = ets:insert(Pub, {1,foo}),
<a name="4112"/> 4112:     {'EXIT',{badarg,_}} = (catch ets:insert(Prot,{2,foo})),
<a name="4113"/> 4113:     {'EXIT',{badarg,_}} = (catch ets:insert(Priv,{3,foo})),
<a name="4114"/> 4114: 
<a name="4115"/> 4115:     %% check that it really wasn't written, either
<a name="4116"/> 4116:     [] = ets:lookup(Prot,foo),
<a name="privacy_check-last_expr"/><a name="4117"/> 4117:     ok.
<a name="4118"/> 4118: 
<a name="privacy_owner-2"/><a name="4119"/> 4119: <b>privacy_owner</b>(Boss, Opts) -&gt;
<a name="4120"/> 4120:     ets_new(pub, [public,named_table | Opts]),
<a name="4121"/> 4121:     ets_new(prot,[protected,named_table | Opts]),
<a name="4122"/> 4122:     ets_new(priv,[private,named_table | Opts]),
<a name="4123"/> 4123:     Boss ! ok,
<a name="privacy_owner-last_expr"/><a name="4124"/> 4124: <b>    privacy_owner_loop</b>(Boss).
<a name="4125"/> 4125: 
<a name="privacy_owner_loop-1"/><a name="4126"/> 4126: <b>privacy_owner_loop</b>(Boss) -&gt;
<a name="privacy_owner_loop-last_expr"/><a name="4127"/> 4127:     receive
<a name="4128"/> 4128: 	{shift,N,Pub_Prot_Priv} -&gt;
<a name="4129"/> 4129: 	    {Pub,Prot,Priv} = rotate_tuple(Pub_Prot_Priv, N),
<a name="4130"/> 4130: 
<a name="4131"/> 4131: 	    ets:setopts(Pub,{protection,public}),
<a name="4132"/> 4132: 	    ets:setopts(Prot,{protection,protected}),
<a name="4133"/> 4133: 	    ets:setopts(Priv,{protection,private}),
<a name="4134"/> 4134: 	    Boss ! {Pub,Prot,Priv},
<a name="4135"/> 4135: 	    privacy_owner_loop(Boss);
<a name="4136"/> 4136: 
<a name="4137"/> 4137: 	die -&gt; ok
<a name="4138"/> 4138:     end.
<a name="4139"/> 4139: 
<a name="rotate_tuple-2"/><a name="4140"/> 4140: <b>rotate_tuple</b>(Tuple, 0) -&gt;
<a name="4141"/> 4141:     Tuple;
<a name="4142"/> 4142: <b>rotate_tuple</b>(Tuple, N) -&gt;
<a name="4143"/> 4143:     [H|T] = tuple_to_list(Tuple),
<a name="rotate_tuple-last_expr"/><a name="4144"/> 4144: <b>    rotate_tuple</b>(list_to_tuple(T ++ [H]), N-1).
<a name="4145"/> 4145: 
<a name="4146"/> 4146: 
<a name="4147"/> 4147: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="4148"/> 4148: 
<a name="4149"/> 4149: 
<a name="4150"/> 4150: <i>%% Check lookup in an empty table and lookup of a non-existing key.</i>
<a name="empty-1"/><a name="4151"/> 4151: <b>empty</b>(Config) when is_list(Config) -&gt;
<a name="empty-last_expr"/><a name="4152"/> 4152: <b>    repeat_for_opts_all_table_types</b>(fun empty_do/1).
<a name="4153"/> 4153: 
<a name="empty_do-1"/><a name="4154"/> 4154: <b>empty_do</b>(Opts) -&gt;
<a name="4155"/> 4155:     EtsMem = etsmem(),
<a name="4156"/> 4156:     Tab = ets_new(foo,Opts),
<a name="4157"/> 4157:     [] = ets:lookup(Tab,key),
<a name="4158"/> 4158:     true = ets:insert(Tab,{key2,val}),
<a name="4159"/> 4159:     [] = ets:lookup(Tab,key),
<a name="4160"/> 4160:     true = ets:delete(Tab),
<a name="empty_do-last_expr"/><a name="4161"/> 4161: <b>    verify_etsmem</b>(EtsMem).
<a name="4162"/> 4162: 
<a name="4163"/> 4163: <i>%% Check proper return values for illegal insert operations.</i>
<a name="badinsert-1"/><a name="4164"/> 4164: <b>badinsert</b>(Config) when is_list(Config) -&gt;
<a name="badinsert-last_expr"/><a name="4165"/> 4165: <b>    repeat_for_opts_all_table_types</b>(fun badinsert_do/1).
<a name="4166"/> 4166: 
<a name="badinsert_do-1"/><a name="4167"/> 4167: <b>badinsert_do</b>(Opts) -&gt;
<a name="4168"/> 4168:     EtsMem = etsmem(),
<a name="4169"/> 4169:     {'EXIT',{badarg,_}} = (catch ets:insert(foo,{key,val})),
<a name="4170"/> 4170: 
<a name="4171"/> 4171:     Tab = ets_new(foo,Opts),
<a name="4172"/> 4172:     {'EXIT',{badarg,_}} = (catch ets:insert(Tab,{})),
<a name="4173"/> 4173: 
<a name="4174"/> 4174:     Tab3 = ets_new(foo,[{keypos,3}| Opts]),
<a name="4175"/> 4175:     {'EXIT',{badarg,_}} = (catch ets:insert(Tab3,{a,b})),
<a name="4176"/> 4176: 
<a name="4177"/> 4177:     {'EXIT',{badarg,_}} = (catch ets:insert(Tab,[key,val2])),
<a name="4178"/> 4178:     true = ets:delete(Tab),
<a name="4179"/> 4179:     true = ets:delete(Tab3),
<a name="badinsert_do-last_expr"/><a name="4180"/> 4180: <b>    verify_etsmem</b>(EtsMem).
<a name="4181"/> 4181: 
<a name="4182"/> 4182: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="4183"/> 4183: 
<a name="4184"/> 4184: 
<a name="4185"/> 4185: <i>%% Check proper return values from bad lookups in existing/non existing</i>
<a name="4186"/> 4186: <i>%% ets tables.</i>
<a name="badlookup-1"/><a name="4187"/> 4187: <b>badlookup</b>(Config) when is_list(Config) -&gt;
<a name="4188"/> 4188:     EtsMem = etsmem(),
<a name="4189"/> 4189:     {'EXIT',{badarg,_}} = (catch ets:lookup(foo,key)),
<a name="4190"/> 4190:     Tab = ets_new(foo,[]),
<a name="4191"/> 4191:     ets:delete(Tab),
<a name="4192"/> 4192:     {'EXIT',{badarg,_}} = (catch ets:lookup(Tab,key)),
<a name="badlookup-last_expr"/><a name="4193"/> 4193: <b>    verify_etsmem</b>(EtsMem).
<a name="4194"/> 4194: 
<a name="4195"/> 4195: <i>%% Test that lookup returns objects in order of insertion for bag and dbag.</i>
<a name="lookup_order-1"/><a name="4196"/> 4196: <b>lookup_order</b>(Config) when is_list(Config) -&gt;
<a name="4197"/> 4197:     EtsMem = etsmem(),
<a name="4198"/> 4198:     repeat_for_opts(fun lookup_order_do/1,
<a name="4199"/> 4199:                     [write_concurrency,[bag,duplicate_bag]]),
<a name="4200"/> 4200:     verify_etsmem(EtsMem),
<a name="lookup_order-last_expr"/><a name="4201"/> 4201:     ok.
<a name="4202"/> 4202: 
<a name="lookup_order_do-1"/><a name="4203"/> 4203: <b>lookup_order_do</b>(Opts) -&gt;
<a name="4204"/> 4204:     lookup_order_2(Opts, false),
<a name="lookup_order_do-last_expr"/><a name="4205"/> 4205: <b>    lookup_order_2</b>(Opts, true).
<a name="4206"/> 4206: 
<a name="lookup_order_2-2"/><a name="4207"/> 4207: <b>lookup_order_2</b>(Opts, Fixed) -&gt;
<a name="4208"/> 4208:     io:format(&quot;Opts=~p Fixed=~p\n&quot;,[Opts,Fixed]),
<a name="4209"/> 4209: 
<a name="4210"/> 4210:     A = 1, B = 2, C = 3,
<a name="4211"/> 4211:     ABC = [A,B,C],
<a name="4212"/> 4212:     Pair = [{A,B},{B,A},{A,C},{C,A},{B,C},{C,B}],
<a name="4213"/> 4213:     Combos = [{D1,D2,D3} || D1&lt;-ABC, D2&lt;-Pair, D3&lt;-Pair],
<a name="lookup_order_2-last_expr"/><a name="4214"/> 4214: <b>    lists:foreach</b>(fun({D1,{D2a,D2b},{D3a,D3b}}) -&gt;
<a name="4215"/> 4215: 			  T = ets_new(foo,Opts),
<a name="4216"/> 4216: 			  case Fixed of
<a name="4217"/> 4217: 			      true -&gt; ets:safe_fixtable(T,true);
<a name="4218"/> 4218: 			      false -&gt; ok
<a name="4219"/> 4219: 			  end,
<a name="4220"/> 4220: 			  S10 = {T,[],key},
<a name="4221"/> 4221: 			  S20 = check_insert(S10,A),
<a name="4222"/> 4222: 			  S30 = check_insert(S20,B),
<a name="4223"/> 4223: 			  S40 = check_insert(S30,C),
<a name="4224"/> 4224: 			  S50 = check_delete(S40,D1),
<a name="4225"/> 4225: 			  S55 = check_insert(S50,D1),
<a name="4226"/> 4226: 			  S60 = check_insert(S55,D1),
<a name="4227"/> 4227: 			  S70 = check_delete(S60,D2a),
<a name="4228"/> 4228: 			  S80 = check_delete(S70,D2b),
<a name="4229"/> 4229: 			  S90 = check_insert(S80,D2a),
<a name="4230"/> 4230: 			  SA0 = check_delete(S90,D3a),
<a name="4231"/> 4231: 			  SB0 = check_delete(SA0,D3b),
<a name="4232"/> 4232: 			  check_insert_new(SB0,D3b),
<a name="4233"/> 4233: 
<a name="4234"/> 4234: 			  true = ets:delete(T)
<a name="4235"/> 4235: 		  end,
<a name="4236"/> 4236: 		  Combos).
<a name="4237"/> 4237: 
<a name="4238"/> 4238: 
<a name="check_insert-2"/><a name="4239"/> 4239: <b>check_insert</b>({T,List0,Key},Val) -&gt;
<a name="4240"/> 4240:     %%io:format(&quot;insert ~p into ~p\n&quot;,[Val,List0]),
<a name="4241"/> 4241:     ets:insert(T,{Key,Val}),
<a name="4242"/> 4242:     List1 = case (ets:info(T,type) =:= bag andalso
<a name="4243"/> 4243: 		  lists:member({Key,Val},List0)) of
<a name="4244"/> 4244: 		true -&gt; List0;
<a name="4245"/> 4245: 		false -&gt; [{Key,Val} | List0]
<a name="4246"/> 4246: 	    end,
<a name="check_insert-last_expr"/><a name="4247"/> 4247: <b>    check_check</b>({T,List1,Key}).
<a name="4248"/> 4248: 
<a name="check_insert_new-2"/><a name="4249"/> 4249: <b>check_insert_new</b>({T,List0,Key},Val) -&gt;
<a name="4250"/> 4250:     %%io:format(&quot;insert_new ~p into ~p\n&quot;,[Val,List0]),
<a name="4251"/> 4251:     Ret = ets:insert_new(T,{Key,Val}),
<a name="4252"/> 4252:     Ret = (List0 =:= []),
<a name="4253"/> 4253:     List1 = case Ret of
<a name="4254"/> 4254: 		true -&gt; [{Key,Val}];
<a name="4255"/> 4255: 		false -&gt; List0
<a name="4256"/> 4256: 	    end,
<a name="check_insert_new-last_expr"/><a name="4257"/> 4257: <b>    check_check</b>({T,List1,Key}).
<a name="4258"/> 4258: 
<a name="4259"/> 4259: 
<a name="check_delete-2"/><a name="4260"/> 4260: <b>check_delete</b>({T,List0,Key},Val) -&gt;
<a name="4261"/> 4261:     %%io:format(&quot;delete ~p from ~p\n&quot;,[Val,List0]),
<a name="4262"/> 4262:     ets:delete_object(T,{Key,Val}),
<a name="4263"/> 4263:     List1 = lists:filter(fun(Obj) -&gt; Obj =/= {Key,Val} end,
<a name="4264"/> 4264: 			 List0),
<a name="check_delete-last_expr"/><a name="4265"/> 4265: <b>    check_check</b>({T,List1,Key}).
<a name="4266"/> 4266: 
<a name="check_check-1"/><a name="4267"/> 4267: <b>check_check</b>(S={T,List,Key}) -&gt;
<a name="4268"/> 4268:     case lists:reverse(ets:lookup(T,Key)) of
<a name="4269"/> 4269: 	List -&gt; ok;
<a name="4270"/> 4270:         ETS -&gt; io:format(&quot;check failed:\nETS: ~p\nCHK: ~p\n&quot;, [ETS,List]),
<a name="4271"/> 4271: 	       ct:fail(&quot;Invalid return value from ets:lookup&quot;)
<a name="4272"/> 4272:     end,
<a name="4273"/> 4273:     Items = ets:info(T,size),
<a name="4274"/> 4274:     Items = length(List),
<a name="check_check-last_expr"/><a name="4275"/> 4275:     S.
<a name="4276"/> 4276: 
<a name="fill_tab-2"/><a name="4277"/> 4277: <b>fill_tab</b>(Tab,Val) -&gt;
<a name="4278"/> 4278:     ets:insert(Tab,{key,Val}),
<a name="4279"/> 4279:     ets:insert(Tab,{{a,144},Val}),
<a name="4280"/> 4280:     ets:insert(Tab,{{a,key2},Val}),
<a name="4281"/> 4281:     ets:insert(Tab,{14,Val}),
<a name="fill_tab-last_expr"/><a name="4282"/> 4282:     ok.
<a name="4283"/> 4283: 
<a name="4284"/> 4284: 
<a name="4285"/> 4285: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="4286"/> 4286: 
<a name="lookup_element_default-1"/><a name="4287"/> 4287: <b>lookup_element_default</b>(Config) when is_list(Config) -&gt;
<a name="4288"/> 4288:     EtsMem = etsmem(),
<a name="4289"/> 4289: 
<a name="4290"/> 4290:     TabSet = ets_new(foo, [set]),
<a name="4291"/> 4291:     ets:insert(TabSet, {key, 42}),
<a name="4292"/> 4292:     42 = ets:lookup_element(TabSet, key, 2, 13),
<a name="4293"/> 4293:     13 = ets:lookup_element(TabSet, not_key, 2, 13),
<a name="4294"/> 4294:     {'EXIT',{badarg,_}} = catch ets:lookup_element(TabSet, key, 3, 13),
<a name="4295"/> 4295:     true = ets:delete(TabSet),
<a name="4296"/> 4296: 
<a name="4297"/> 4297:     TabOrderedSet = ets_new(foo, [ordered_set]),
<a name="4298"/> 4298:     ets:insert(TabOrderedSet, {key, 42}),
<a name="4299"/> 4299:     42 = ets:lookup_element(TabOrderedSet, key, 2, 13),
<a name="4300"/> 4300:     13 = ets:lookup_element(TabOrderedSet, not_key, 2, 13),
<a name="4301"/> 4301:     {'EXIT',{badarg,_}} = catch ets:lookup_element(TabOrderedSet, key, 3, 13),
<a name="4302"/> 4302:     true = ets:delete(TabOrderedSet),
<a name="4303"/> 4303: 
<a name="4304"/> 4304:     TabBag = ets_new(foo, [bag]),
<a name="4305"/> 4305:     ets:insert(TabBag, {key, 42}),
<a name="4306"/> 4306:     ets:insert(TabBag, {key, 43, 44}),
<a name="4307"/> 4307:     [42, 43] = ets:lookup_element(TabBag, key, 2, 13),
<a name="4308"/> 4308:     13 = ets:lookup_element(TabBag, not_key, 2, 13),
<a name="4309"/> 4309:     {'EXIT',{badarg,_}} = catch ets:lookup_element(TabBag, key, 3, 13),
<a name="4310"/> 4310:     true = ets:delete(TabBag),
<a name="4311"/> 4311: 
<a name="4312"/> 4312:     TabDuplicateBag = ets_new(foo, [duplicate_bag]),
<a name="4313"/> 4313:     ets:insert(TabDuplicateBag, {key, 42}),
<a name="4314"/> 4314:     ets:insert(TabDuplicateBag, {key, 42}),
<a name="4315"/> 4315:     ets:insert(TabDuplicateBag, {key, 43, 44}),
<a name="4316"/> 4316:     [42, 42, 43] = ets:lookup_element(TabDuplicateBag, key, 2, 13),
<a name="4317"/> 4317:     13 = ets:lookup_element(TabDuplicateBag, not_key, 2, 13),
<a name="4318"/> 4318:     {'EXIT',{badarg,_}} = catch ets:lookup_element(TabDuplicateBag, key, 3, 13),
<a name="4319"/> 4319:     true = ets:delete(TabDuplicateBag),
<a name="4320"/> 4320: 
<a name="lookup_element_default-last_expr"/><a name="4321"/> 4321: <b>    verify_etsmem</b>(EtsMem).
<a name="4322"/> 4322: 
<a name="4323"/> 4323: <i>%% OTP-2386. Multiple return elements.</i>
<a name="lookup_element_mult-1"/><a name="4324"/> 4324: <b>lookup_element_mult</b>(Config) when is_list(Config) -&gt;
<a name="lookup_element_mult-last_expr"/><a name="4325"/> 4325: <b>    repeat_for_opts</b>(fun lookup_element_mult_do/1).
<a name="4326"/> 4326: 
<a name="lookup_element_mult_do-1"/><a name="4327"/> 4327: <b>lookup_element_mult_do</b>(Opts) -&gt;
<a name="4328"/> 4328:     EtsMem = etsmem(),
<a name="4329"/> 4329:     T = ets_new(service, [bag, {keypos, 2} | Opts]),
<a name="4330"/> 4330:     D = lists:reverse(lem_data()),
<a name="4331"/> 4331:     lists:foreach(fun(X) -&gt; ets:insert(T, X) end, D),
<a name="4332"/> 4332:     ok = lem_crash_3(T),
<a name="4333"/> 4333:     ets:insert(T, {0, &quot;heap_key&quot;}),
<a name="4334"/> 4334:     ets:lookup_element(T, &quot;heap_key&quot;, 2),
<a name="4335"/> 4335:     true = ets:delete(T),
<a name="lookup_element_mult_do-last_expr"/><a name="4336"/> 4336: <b>    verify_etsmem</b>(EtsMem).
<a name="4337"/> 4337: 
<a name="lem_data-0"/><a name="4338"/> 4338: <b>lem_data</b>() -&gt;
<a name="lem_data-last_expr"/><a name="4339"/> 4339: <b>    [{service,'eddie2@boromir',{150,236,14,103},httpd88,self</b>()},
<a name="4340"/> 4340:      {service,'eddie2@boromir',{150,236,14,103},httpd80,self()},
<a name="4341"/> 4341:      {service,'eddie3@boromir',{150,236,14,107},httpd88,self()},
<a name="4342"/> 4342:      {service,'eddie3@boromir',{150,236,14,107},httpd80,self()},
<a name="4343"/> 4343:      {service,'eddie4@boromir',{150,236,14,108},httpd88,self()}].
<a name="4344"/> 4344: 
<a name="lem_crash-1"/><a name="4345"/> 4345: <b>lem_crash</b>(T) -&gt;
<a name="4346"/> 4346:     L = ets:lookup_element(T, 'eddie2@boromir', 3),
<a name="lem_crash-last_expr"/><a name="4347"/> 4347: <b>    {erlang:phash</b>(L, 256), L}.
<a name="4348"/> 4348: 
<a name="lem_crash_3-1"/><a name="4349"/> 4349: <b>lem_crash_3</b>(T) -&gt;
<a name="4350"/> 4350:     lem_crash(T),
<a name="4351"/> 4351:     io:format(&quot;Survived once~n&quot;),
<a name="4352"/> 4352:     lem_crash(T),
<a name="4353"/> 4353:     io:format(&quot;Survived twice~n&quot;),
<a name="4354"/> 4354:     lem_crash(T),
<a name="4355"/> 4355:     io:format(&quot;Survived all!~n&quot;),
<a name="lem_crash_3-last_expr"/><a name="4356"/> 4356:     ok.
<a name="4357"/> 4357: 
<a name="4358"/> 4358: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="4359"/> 4359: 
<a name="4360"/> 4360: 
<a name="4361"/> 4361: <i>%% Check delete of an element inserted in a `filled' table.</i>
<a name="delete_elem-1"/><a name="4362"/> 4362: <b>delete_elem</b>(Config) when is_list(Config) -&gt;
<a name="delete_elem-last_expr"/><a name="4363"/> 4363: <b>    repeat_for_opts</b>(fun delete_elem_do/1,
<a name="4364"/> 4364:                     [write_concurrency, all_types]).
<a name="4365"/> 4365: 
<a name="delete_elem_do-1"/><a name="4366"/> 4366: <b>delete_elem_do</b>(Opts) -&gt;
<a name="4367"/> 4367:     EtsMem = etsmem(),
<a name="4368"/> 4368:     Tab = ets_new(foo,Opts),
<a name="4369"/> 4369:     fill_tab(Tab,foo),
<a name="4370"/> 4370:     ets:insert(Tab,{{b,key},foo}),
<a name="4371"/> 4371:     ets:insert(Tab,{{c,key},foo}),
<a name="4372"/> 4372:     true = ets:delete(Tab,{b,key}),
<a name="4373"/> 4373:     [] = ets:lookup(Tab,{b,key}),
<a name="4374"/> 4374:     [{{c,key},foo}] = ets:lookup(Tab,{c,key}),
<a name="4375"/> 4375:     true = ets:delete(Tab),
<a name="delete_elem_do-last_expr"/><a name="4376"/> 4376: <b>    verify_etsmem</b>(EtsMem).
<a name="4377"/> 4377: 
<a name="4378"/> 4378: <i>%% Check that ets:delete() works and releases the name of the</i>
<a name="4379"/> 4379: <i>%% deleted table.</i>
<a name="delete_tab-1"/><a name="4380"/> 4380: <b>delete_tab</b>(Config) when is_list(Config) -&gt;
<a name="delete_tab-last_expr"/><a name="4381"/> 4381: <b>    repeat_for_opts</b>(fun delete_tab_do/1,
<a name="4382"/> 4382:                     [write_concurrency,all_types]).
<a name="4383"/> 4383: 
<a name="delete_tab_do-1"/><a name="4384"/> 4384: <b>delete_tab_do</b>(Opts) -&gt;
<a name="4385"/> 4385:     Name = foo,
<a name="4386"/> 4386:     EtsMem = etsmem(),
<a name="4387"/> 4387:     Name = ets_new(Name, [named_table | Opts]),
<a name="4388"/> 4388:     true = ets:delete(foo),
<a name="4389"/> 4389:     %% The name should be available again.
<a name="4390"/> 4390:     Name = ets_new(Name, [named_table | Opts]),
<a name="4391"/> 4391:     true = ets:delete(Name),
<a name="delete_tab_do-last_expr"/><a name="4392"/> 4392: <b>    verify_etsmem</b>(EtsMem).
<a name="4393"/> 4393: 
<a name="4394"/> 4394: <i>%% Check that ets:delete/1 works and that other processes can run.</i>
<a name="delete_large_tab-1"/><a name="4395"/> 4395: <b>delete_large_tab</b>(Config) when is_list(Config) -&gt;
<a name="4396"/> 4396:     ct:timetrap({minutes,60}), %% valgrind needs a lot
<a name="4397"/> 4397:     KeyRange = 16#ffffff,
<a name="4398"/> 4398:     Data = [{erlang:phash2(I, KeyRange),I} || I &lt;- lists:seq(1, 200000)],
<a name="4399"/> 4399:     EtsMem = etsmem(),
<a name="4400"/> 4400:     repeat_for_opts(fun(Opts) -&gt; delete_large_tab_do(Config,
<a name="4401"/> 4401:                                                      key_range(Opts,KeyRange),
<a name="4402"/> 4402:                                                      Data)
<a name="4403"/> 4403:                     end),
<a name="delete_large_tab-last_expr"/><a name="4404"/> 4404: <b>    verify_etsmem</b>(EtsMem).
<a name="4405"/> 4405: 
<a name="delete_large_tab_do-3"/><a name="4406"/> 4406: <b>delete_large_tab_do</b>(Config, Opts,Data) -&gt;
<a name="4407"/> 4407:     delete_large_tab_1(Config, foo_hash, Opts, Data, false),
<a name="4408"/> 4408:     run_if_valid_opts(
<a name="4409"/> 4409:       [ordered_set | Opts],
<a name="4410"/> 4410:       fun(OptsOrdSet) -&gt;
<a name="4411"/> 4411:               delete_large_tab_1(Config, foo_tree, OptsOrdSet, Data, false)
<a name="4412"/> 4412:       end),
<a name="4413"/> 4413:     run_if_valid_opts(
<a name="4414"/> 4414:       [stim_cat_ord_set | Opts],
<a name="4415"/> 4415:       fun(OptsCat) -&gt;
<a name="4416"/> 4416:               delete_large_tab_1(Config, foo_tree, OptsCat, Data, false)
<a name="4417"/> 4417:       end),
<a name="delete_large_tab_do-last_expr"/><a name="4418"/> 4418: <b>    delete_large_tab_1</b>(Config, foo_hash_fix, Opts, Data, true).
<a name="4419"/> 4419: 
<a name="4420"/> 4420: 
<a name="delete_large_tab_1-5"/><a name="4421"/> 4421: <b>delete_large_tab_1</b>(Config, Name, Flags, Data, Fix) -&gt;
<a name="delete_large_tab_1-last_expr"/><a name="4422"/> 4422: <b>    case is_redundant_opts_combo</b>(Flags) of
<a name="4423"/> 4423:         true -&gt; skip;
<a name="4424"/> 4424:         false -&gt;
<a name="4425"/> 4425:             delete_large_tab_2(Config, Name, Flags, Data, Fix)
<a name="4426"/> 4426:     end.
<a name="4427"/> 4427: 
<a name="delete_large_tab_2-5"/><a name="4428"/> 4428: <b>delete_large_tab_2</b>(Config, Name, Flags, Data, Fix) -&gt;
<a name="4429"/> 4429:     Tab = ets_new(Name, Flags),
<a name="4430"/> 4430:     ets:insert(Tab, Data),
<a name="4431"/> 4431: 
<a name="4432"/> 4432:     case Fix of
<a name="4433"/> 4433: 	false -&gt; ok;
<a name="4434"/> 4434: 	true -&gt;
<a name="4435"/> 4435: 	    true = ets:safe_fixtable(Tab, true),
<a name="4436"/> 4436: 	    lists:foreach(fun({K,_}) -&gt; ets:delete(Tab, K) end, Data)
<a name="4437"/> 4437:     end,
<a name="4438"/> 4438: 
<a name="4439"/> 4439:     {priority, Prio} = process_info(self(), priority),
<a name="4440"/> 4440:     Deleter = self(),
<a name="4441"/> 4441:     ForceTrap = proplists:get_bool(ets_force_trap, Config),
<a name="4442"/> 4442:     [SchedTracer]
<a name="4443"/> 4443: 	= start_loopers(1,
<a name="4444"/> 4444: 			Prio,
<a name="4445"/> 4445: 			fun (SC) -&gt;
<a name="4446"/> 4446: 				receive
<a name="4447"/> 4447: 				    {trace, Deleter, out, _} -&gt;
<a name="4448"/> 4448:                                         case {ets:info(Tab), SC, ForceTrap} of
<a name="4449"/> 4449:                                             {undefined, _, _} -&gt; ok;
<a name="4450"/> 4450:                                             {_, 0, true} -&gt;
<a name="4451"/> 4451:                                                 %% Forced first trap of ets:delete,
<a name="4452"/> 4452:                                                 %% tab still reachable
<a name="4453"/> 4453:                                                 ok
<a name="4454"/> 4454:                                         end,
<a name="4455"/> 4455:                                         SC+1;
<a name="4456"/> 4456: 				    {trace,
<a name="4457"/> 4457: 				     Deleter,
<a name="4458"/> 4458: 				     register,
<a name="4459"/> 4459: 				     delete_large_tab_done_marker}-&gt;
<a name="4460"/> 4460: 					Deleter ! {schedule_count, SC},
<a name="4461"/> 4461: 					exit(normal);
<a name="4462"/> 4462: 				    _ -&gt;
<a name="4463"/> 4463: 					SC
<a name="4464"/> 4464: 				end
<a name="4465"/> 4465: 			end,
<a name="4466"/> 4466: 			0),
<a name="4467"/> 4467:     SchedTracerMon = monitor(process, SchedTracer),
<a name="4468"/> 4468:     Loopers = start_loopers(erlang:system_info(schedulers),
<a name="4469"/> 4469: 			    Prio,
<a name="4470"/> 4470: 			    fun (_) -&gt; erlang:yield() end,
<a name="4471"/> 4471: 			    ok),
<a name="4472"/> 4472:     erlang:yield(),
<a name="4473"/> 4473:     1 = erlang:trace(self(),true,[running,procs,{tracer,SchedTracer}]),
<a name="4474"/> 4474:     true = ets:delete(Tab),
<a name="4475"/> 4475:     %% The register stuff is just a trace marker
<a name="4476"/> 4476:     true = register(delete_large_tab_done_marker, self()),
<a name="4477"/> 4477:     true = unregister(delete_large_tab_done_marker),
<a name="4478"/> 4478:     undefined = ets:info(Tab),
<a name="4479"/> 4479:     ok = stop_loopers(Loopers),
<a name="4480"/> 4480:     receive
<a name="4481"/> 4481: 	{schedule_count, N} -&gt;
<a name="4482"/> 4482: 	    io:format(&quot;~s: context switches: ~p&quot;, [Name,N]),
<a name="4483"/> 4483: 	    if
<a name="4484"/> 4484: 		N &gt;= 5 -&gt; ok;
<a name="4485"/> 4485: 		true -&gt; ct:fail(failed)
<a name="4486"/> 4486: 	    end
<a name="4487"/> 4487:     end,
<a name="4488"/> 4488:     receive {'DOWN',SchedTracerMon,process,SchedTracer,_} -&gt; ok end,
<a name="delete_large_tab_2-last_expr"/><a name="4489"/> 4489:     ok.
<a name="4490"/> 4490: 
<a name="4491"/> 4491: <i>%% Delete a large name table and try to create a new table with</i>
<a name="4492"/> 4492: <i>%% the same name in another process.</i>
<a name="delete_large_named_table-1"/><a name="4493"/> 4493: <b>delete_large_named_table</b>(Config) when is_list(Config) -&gt;
<a name="4494"/> 4494:     KeyRange = 16#ffffff,
<a name="4495"/> 4495:     Data = [{erlang:phash2(I, KeyRange),I} || I &lt;- lists:seq(1, 200000)],
<a name="4496"/> 4496:     EtsMem = etsmem(),
<a name="4497"/> 4497:     repeat_for_opts(fun(Opts) -&gt;
<a name="4498"/> 4498:                             delete_large_named_table_do(key_range(Opts,KeyRange),
<a name="4499"/> 4499:                                                         Data)
<a name="4500"/> 4500:                     end),
<a name="4501"/> 4501:     verify_etsmem(EtsMem),
<a name="delete_large_named_table-last_expr"/><a name="4502"/> 4502:     ok.
<a name="4503"/> 4503: 
<a name="delete_large_named_table_do-2"/><a name="4504"/> 4504: <b>delete_large_named_table_do</b>(Opts,Data) -&gt;
<a name="4505"/> 4505:     delete_large_named_table_1(foo_hash, [named_table | Opts], Data, false),
<a name="4506"/> 4506:     run_if_valid_opts(
<a name="4507"/> 4507:       [ordered_set,named_table | Opts],
<a name="4508"/> 4508:       fun(OptsOrdSet) -&gt;
<a name="4509"/> 4509:               delete_large_named_table_1(foo_tree, OptsOrdSet, Data, false)
<a name="4510"/> 4510:       end),
<a name="4511"/> 4511:     run_if_valid_opts(
<a name="4512"/> 4512:       [stim_cat_ord_set,named_table | Opts],
<a name="4513"/> 4513:       fun(OptsStimCat) -&gt;
<a name="4514"/> 4514:               delete_large_named_table_1(foo_tree, OptsStimCat, Data, false)
<a name="4515"/> 4515:       end),
<a name="delete_large_named_table_do-last_expr"/><a name="4516"/> 4516: <b>    delete_large_named_table_1</b>(foo_hash, [named_table | Opts], Data, true).
<a name="4517"/> 4517: 
<a name="delete_large_named_table_1-4"/><a name="4518"/> 4518: <b>delete_large_named_table_1</b>(Name, Flags, Data, Fix) -&gt;
<a name="delete_large_named_table_1-last_expr"/><a name="4519"/> 4519: <b>    case is_redundant_opts_combo</b>(Flags) of
<a name="4520"/> 4520:         true -&gt; skip;
<a name="4521"/> 4521:         false -&gt;
<a name="4522"/> 4522:             delete_large_named_table_2(Name, Flags, Data, Fix)
<a name="4523"/> 4523:     end.
<a name="4524"/> 4524: 
<a name="delete_large_named_table_2-4"/><a name="4525"/> 4525: <b>delete_large_named_table_2</b>(Name, Flags, Data, Fix) -&gt;
<a name="4526"/> 4526:     Tab = ets_new(Name, Flags),
<a name="4527"/> 4527:     ets:insert(Tab, Data),
<a name="4528"/> 4528: 
<a name="4529"/> 4529:     case Fix of
<a name="4530"/> 4530: 	false -&gt; ok;
<a name="4531"/> 4531: 	true -&gt;
<a name="4532"/> 4532: 	    true = ets:safe_fixtable(Tab, true),
<a name="4533"/> 4533: 	    lists:foreach(fun({K,_}) -&gt; ets:delete(Tab, K) end, Data)
<a name="4534"/> 4534:     end,
<a name="4535"/> 4535:     {Pid, MRef} = my_spawn_opt(fun() -&gt;
<a name="4536"/> 4536: 				       receive
<a name="4537"/> 4537: 					   ets_new -&gt;
<a name="4538"/> 4538: 					       ets_new(Name, [named_table])
<a name="4539"/> 4539: 				       end
<a name="4540"/> 4540: 			       end,
<a name="4541"/> 4541: 			       [link, monitor]),
<a name="4542"/> 4542:     true = ets:delete(Tab),
<a name="4543"/> 4543:     Pid ! ets_new,
<a name="4544"/> 4544:     receive {'DOWN',MRef,process,Pid,_} -&gt; ok end,
<a name="delete_large_named_table_2-last_expr"/><a name="4545"/> 4545:     ok.
<a name="4546"/> 4546: 
<a name="4547"/> 4547: <i>%% Delete a large table, and kill the process during the delete.</i>
<a name="evil_delete-1"/><a name="4548"/> 4548: <b>evil_delete</b>(Config) when is_list(Config) -&gt;
<a name="4549"/> 4549:     KeyRange = 100000,
<a name="4550"/> 4550:     Data = [{I,I*I} || I &lt;- lists:seq(1, KeyRange)],
<a name="evil_delete-last_expr"/><a name="4551"/> 4551: <b>    repeat_for_opts</b>(fun(Opts) -&gt;
<a name="4552"/> 4552:                             evil_delete_do(key_range(Opts,KeyRange),
<a name="4553"/> 4553:                                            Data)
<a name="4554"/> 4554:                     end).
<a name="4555"/> 4555: 
<a name="evil_delete_do-2"/><a name="4556"/> 4556: <b>evil_delete_do</b>(Opts,Data) -&gt;
<a name="4557"/> 4557:     EtsMem = etsmem(),
<a name="4558"/> 4558:     evil_delete_owner(foo_hash, Opts, Data, false),
<a name="4559"/> 4559:     verify_etsmem(EtsMem),
<a name="4560"/> 4560:     evil_delete_owner(foo_hash, Opts, Data, true),
<a name="4561"/> 4561:     verify_etsmem(EtsMem),
<a name="4562"/> 4562:     evil_delete_owner(foo_tree, [ordered_set | Opts], Data, false),
<a name="4563"/> 4563:     verify_etsmem(EtsMem),
<a name="4564"/> 4564:     evil_delete_owner(foo_catree, [stim_cat_ord_set | Opts], Data, false),
<a name="4565"/> 4565:     verify_etsmem(EtsMem),
<a name="4566"/> 4566:     TabA = evil_delete_not_owner(foo_hash, Opts, Data, false),
<a name="4567"/> 4567:     verify_etsmem(EtsMem),
<a name="4568"/> 4568:     TabB = evil_delete_not_owner(foo_hash, Opts, Data, true),
<a name="4569"/> 4569:     verify_etsmem(EtsMem),
<a name="4570"/> 4570:     TabC = evil_delete_not_owner(foo_tree, [ordered_set | Opts], Data, false),
<a name="4571"/> 4571:     verify_etsmem(EtsMem),
<a name="4572"/> 4572:     TabD = evil_delete_not_owner(foo_catree, [stim_cat_ord_set | Opts], Data, false),
<a name="4573"/> 4573:     verify_etsmem(EtsMem),
<a name="evil_delete_do-last_expr"/><a name="4574"/> 4574: <b>    lists:foreach</b>(fun(T) -&gt; undefined = ets:info(T) end,
<a name="4575"/> 4575: 		  [TabA,TabB,TabC,TabD]).
<a name="4576"/> 4576: 
<a name="evil_delete_not_owner-4"/><a name="4577"/> 4577: <b>evil_delete_not_owner</b>(Name, Flags, Data, Fix) -&gt;
<a name="evil_delete_not_owner-last_expr"/><a name="4578"/> 4578: <b>    case is_redundant_opts_combo</b>(Flags) of
<a name="4579"/> 4579:         true -&gt; skip;
<a name="4580"/> 4580:         false -&gt;
<a name="4581"/> 4581:             evil_delete_not_owner_1(Name, Flags, Data, Fix)
<a name="4582"/> 4582:     end.
<a name="4583"/> 4583: 
<a name="evil_delete_not_owner_1-4"/><a name="4584"/> 4584: <b>evil_delete_not_owner_1</b>(Name, Flags, Data, Fix) -&gt;
<a name="4585"/> 4585:     io:format(&quot;Not owner: ~p, fix = ~p&quot;, [Name,Fix]),
<a name="4586"/> 4586:     Tab = ets_new(Name, [public|Flags]),
<a name="4587"/> 4587:     ets:insert(Tab, Data),
<a name="4588"/> 4588:     case Fix of
<a name="4589"/> 4589: 	false -&gt; ok;
<a name="4590"/> 4590: 	true -&gt;
<a name="4591"/> 4591: 	    true = ets:safe_fixtable(Tab, true),
<a name="4592"/> 4592: 	    lists:foreach(fun({K,_}) -&gt; ets:delete(Tab, K) end, Data)
<a name="4593"/> 4593:     end,
<a name="4594"/> 4594:     Pid = my_spawn(fun() -&gt;
<a name="4595"/> 4595: 			   P = my_spawn_link(
<a name="4596"/> 4596: 				 fun() -&gt;
<a name="4597"/> 4597: 					 receive kill -&gt; ok end,
<a name="4598"/> 4598: 					 erlang:yield(),
<a name="4599"/> 4599: 					 exit(kill_linked_processes_now)
<a name="4600"/> 4600: 				 end),
<a name="4601"/> 4601: 			   erlang:yield(),
<a name="4602"/> 4602: 			   P ! kill,
<a name="4603"/> 4603: 			   true = ets:delete(Tab)
<a name="4604"/> 4604: 		   end),
<a name="4605"/> 4605:     Ref = erlang:monitor(process, Pid),
<a name="4606"/> 4606:     receive {'DOWN',Ref,_,_,_} -&gt; ok end,
<a name="evil_delete_not_owner_1-last_expr"/><a name="4607"/> 4607:     Tab.
<a name="4608"/> 4608: 
<a name="evil_delete_owner-4"/><a name="4609"/> 4609: <b>evil_delete_owner</b>(Name, Flags, Data, Fix) -&gt;
<a name="evil_delete_owner-last_expr"/><a name="4610"/> 4610: <b>    case is_redundant_opts_combo</b>(Flags) of
<a name="4611"/> 4611:         true -&gt; skip;
<a name="4612"/> 4612:         false -&gt;
<a name="4613"/> 4613:             evil_delete_owner_1(Name, Flags, Data, Fix)
<a name="4614"/> 4614:     end.
<a name="4615"/> 4615: 
<a name="evil_delete_owner_1-4"/><a name="4616"/> 4616: <b>evil_delete_owner_1</b>(Name, Flags, Data, Fix) -&gt;
<a name="4617"/> 4617:     Fun = fun() -&gt;
<a name="4618"/> 4618: 		  Tab = ets_new(Name, [public|Flags]),
<a name="4619"/> 4619: 		  ets:insert(Tab, Data),
<a name="4620"/> 4620: 		  case Fix of
<a name="4621"/> 4621: 		      false -&gt; ok;
<a name="4622"/> 4622: 		      true -&gt;
<a name="4623"/> 4623: 			  true = ets:safe_fixtable(Tab, true),
<a name="4624"/> 4624: 			  lists:foreach(fun({K,_}) -&gt;
<a name="4625"/> 4625: 						ets:delete(Tab, K)
<a name="4626"/> 4626: 					end, Data)
<a name="4627"/> 4627: 		  end,
<a name="4628"/> 4628: 		  erlang:yield(),
<a name="4629"/> 4629: 		  my_spawn_link(fun() -&gt;
<a name="4630"/> 4630: 					erlang:yield(),
<a name="4631"/> 4631: 					exit(kill_linked_processes_now)
<a name="4632"/> 4632: 				end),
<a name="4633"/> 4633: 		  true = ets:delete(Tab)
<a name="4634"/> 4634: 	  end,
<a name="4635"/> 4635:     Pid = my_spawn(Fun),
<a name="4636"/> 4636:     Ref = erlang:monitor(process, Pid),
<a name="evil_delete_owner_1-last_expr"/><a name="4637"/> 4637:     receive {'DOWN',Ref,_,_,_} -&gt; ok end.
<a name="4638"/> 4638: 
<a name="4639"/> 4639: 
<a name="exit_large_table_owner-1"/><a name="4640"/> 4640: <b>exit_large_table_owner</b>(Config) when is_list(Config) -&gt;
<a name="4641"/> 4641:     %%Data = [{erlang:phash2(I, 16#ffffff),I} || I &lt;- lists:seq(1, 500000)],
<a name="4642"/> 4642:     Laps = 500000 div syrup_factor(),
<a name="4643"/> 4643:     FEData = fun(Do) -&gt; repeat_while(fun(I) when I =:= Laps -&gt; {false,ok};
<a name="4644"/> 4644: 					(I) -&gt; Do({erlang:phash2(I, 16#ffffff),I}),
<a name="4645"/> 4645: 					       {true, I+1}
<a name="4646"/> 4646: 				     end, 1)
<a name="4647"/> 4647: 	     end,
<a name="4648"/> 4648:     EtsMem = etsmem(),
<a name="4649"/> 4649:     repeat_for_opts(fun(Opts) -&gt;
<a name="4650"/> 4650:                             exit_large_table_owner_do(Opts,
<a name="4651"/> 4651:                                                       FEData,
<a name="4652"/> 4652:                                                       Config)
<a name="4653"/> 4653:                     end),
<a name="exit_large_table_owner-last_expr"/><a name="4654"/> 4654: <b>    verify_etsmem</b>(EtsMem).
<a name="4655"/> 4655: 
<a name="exit_large_table_owner_do-3"/><a name="4656"/> 4656: <b>exit_large_table_owner_do</b>(Opts, FEData, Config) -&gt;
<a name="4657"/> 4657:     verify_rescheduling_exit(Config, FEData, [named_table | Opts], true, 1, 1),
<a name="exit_large_table_owner_do-last_expr"/><a name="4658"/> 4658: <b>    verify_rescheduling_exit</b>(Config, FEData, Opts, false, 1, 1).
<a name="4659"/> 4659: 
<a name="exit_many_large_table_owner-1"/><a name="4660"/> 4660: <b>exit_many_large_table_owner</b>(Config) when is_list(Config) -&gt;
<a name="4661"/> 4661:     ct:timetrap({minutes,30}), %% valgrind needs a lot
<a name="4662"/> 4662:     %%Data = [{erlang:phash2(I, 16#ffffff),I} || I &lt;- lists:seq(1, 500000)],
<a name="4663"/> 4663:     Laps = 500000 div syrup_factor(),
<a name="4664"/> 4664:     FEData = fun(Do) -&gt; repeat_while(fun(I) when I =:= Laps -&gt; {false,ok};
<a name="4665"/> 4665: 					(I) -&gt; Do({erlang:phash2(I, 16#ffffff),I}),
<a name="4666"/> 4666: 					       {true, I+1}
<a name="4667"/> 4667: 				     end, 1)
<a name="4668"/> 4668: 	     end,
<a name="4669"/> 4669:     EtsMem = etsmem(),
<a name="4670"/> 4670:     repeat_for_opts(fun(Opts) -&gt; exit_many_large_table_owner_do(Opts,FEData,Config) end),
<a name="exit_many_large_table_owner-last_expr"/><a name="4671"/> 4671: <b>    verify_etsmem</b>(EtsMem).
<a name="4672"/> 4672: 
<a name="exit_many_large_table_owner_do-3"/><a name="4673"/> 4673: <b>exit_many_large_table_owner_do</b>(Opts,FEData,Config) -&gt;
<a name="4674"/> 4674:     verify_rescheduling_exit(Config, FEData, Opts, true, 1, 4),
<a name="exit_many_large_table_owner_do-last_expr"/><a name="4675"/> 4675: <b>    verify_rescheduling_exit</b>(Config, FEData, [named_table | Opts], false, 1, 4).
<a name="4676"/> 4676: 
<a name="exit_many_tables_owner-1"/><a name="4677"/> 4677: <b>exit_many_tables_owner</b>(Config) when is_list(Config) -&gt;
<a name="4678"/> 4678:     NoData = fun(_Do) -&gt; ok end,
<a name="4679"/> 4679:     EtsMem = etsmem(),
<a name="4680"/> 4680:     verify_rescheduling_exit(Config, NoData, [named_table], false, 1000, 1),
<a name="4681"/> 4681:     verify_rescheduling_exit(Config, NoData, [named_table,{write_concurrency,true}], false, 1000, 1),
<a name="exit_many_tables_owner-last_expr"/><a name="4682"/> 4682: <b>    verify_etsmem</b>(EtsMem).
<a name="4683"/> 4683: 
<a name="exit_many_many_tables_owner-1"/><a name="4684"/> 4684: <b>exit_many_many_tables_owner</b>(Config) when is_list(Config) -&gt;
<a name="4685"/> 4685:     Data = [{erlang:phash2(I, 16#ffffff),I} || I &lt;- lists:seq(1, 50)],
<a name="4686"/> 4686:     FEData = fun(Do) -&gt; lists:foreach(Do, Data) end,
<a name="exit_many_many_tables_owner-last_expr"/><a name="4687"/> 4687: <b>    repeat_for_opts</b>(fun(Opts) -&gt; exit_many_many_tables_owner_do1(Opts,FEData,Config) end).
<a name="4688"/> 4688: 
<a name="exit_many_many_tables_owner_do1-3"/><a name="4689"/> 4689: <b>exit_many_many_tables_owner_do1</b>(Opts,FEData,Config) -&gt;
<a name="exit_many_many_tables_owner_do1-last_expr"/><a name="4690"/> 4690: <b>    case has_fixed_number_of_locks</b>(Opts) of
<a name="4691"/> 4691:         true -&gt;
<a name="4692"/> 4692:             %% Few memory hogging tables =&gt; not enough yielding for the test
<a name="4693"/> 4693:             io:format(&quot;Skip option combo ~p\n&quot;, [Opts]);
<a name="4694"/> 4694:         false -&gt;
<a name="4695"/> 4695:             exit_many_many_tables_owner_do2(Opts,FEData,Config)
<a name="4696"/> 4696:     end.
<a name="4697"/> 4697: 
<a name="exit_many_many_tables_owner_do2-3"/><a name="4698"/> 4698: <b>exit_many_many_tables_owner_do2</b>(Opts,FEData,Config) -&gt;
<a name="4699"/> 4699:     E = ets_new(tmp,Opts),
<a name="4700"/> 4700:     FEData(fun(Data) -&gt; ets:insert(E, Data) end),
<a name="4701"/> 4701:     Mem = ets:info(E,memory) * erlang:system_info(wordsize),
<a name="4702"/> 4702:     ets:delete(E),
<a name="4703"/> 4703: 
<a name="4704"/> 4704:     ct:log(&quot;Memory per table: ~p bytes&quot;,[Mem]),
<a name="4705"/> 4705: 
<a name="4706"/> 4706:     Tables =
<a name="4707"/> 4707:         case erlang:system_info(wordsize) of
<a name="4708"/> 4708:             8 -&gt;
<a name="4709"/> 4709:                 200;
<a name="4710"/> 4710:             4 -&gt;
<a name="4711"/> 4711:                 lists:min([200,2_000_000_000 div (Mem * 5)])
<a name="4712"/> 4712:         end,
<a name="4713"/> 4713: 
<a name="4714"/> 4714:     verify_rescheduling_exit(Config, FEData, [named_table | Opts], true, Tables, 5),
<a name="4715"/> 4715:     verify_rescheduling_exit(Config, FEData, Opts, false, Tables, 5),
<a name="4716"/> 4716:     wait_for_test_procs(),
<a name="4717"/> 4717:     EtsMem = etsmem(),
<a name="4718"/> 4718:     verify_rescheduling_exit(Config, FEData, Opts, true, Tables, 5),
<a name="4719"/> 4719:     verify_rescheduling_exit(Config, FEData, [named_table | Opts], false, Tables, 5),
<a name="exit_many_many_tables_owner_do2-last_expr"/><a name="4720"/> 4720: <b>    verify_etsmem</b>(EtsMem).
<a name="4721"/> 4721: 
<a name="4722"/> 4722: 
<a name="count_exit_sched-1"/><a name="4723"/> 4723: <b>count_exit_sched</b>(TP) -&gt;
<a name="count_exit_sched-last_expr"/><a name="4724"/> 4724:     receive
<a name="4725"/> 4725: 	{trace, TP, in_exiting, 0} -&gt;
<a name="4726"/> 4726: 	    count_exit_sched_out(TP, 1);
<a name="4727"/> 4727: 	{trace, TP, out_exiting, 0} -&gt;
<a name="4728"/> 4728: 	    count_exit_sched_in(TP, 1);
<a name="4729"/> 4729: 	{trace, TP, out_exited, 0} -&gt;
<a name="4730"/> 4730: 	    0
<a name="4731"/> 4731:     end.
<a name="4732"/> 4732: 
<a name="count_exit_sched_in-2"/><a name="4733"/> 4733: <b>count_exit_sched_in</b>(TP, N) -&gt;
<a name="count_exit_sched_in-last_expr"/><a name="4734"/> 4734:     receive
<a name="4735"/> 4735: 	{trace, TP, in_exiting, 0} -&gt;
<a name="4736"/> 4736: 	    count_exit_sched_out(TP, N);
<a name="4737"/> 4737: 	{trace, TP, _, _} = Msg -&gt;
<a name="4738"/> 4738: 	    exit({unexpected_trace_msg, Msg})
<a name="4739"/> 4739:     end.
<a name="4740"/> 4740: 
<a name="count_exit_sched_out-2"/><a name="4741"/> 4741: <b>count_exit_sched_out</b>(TP, N) -&gt;
<a name="count_exit_sched_out-last_expr"/><a name="4742"/> 4742:     receive
<a name="4743"/> 4743: 	{trace, TP, out_exiting, 0} -&gt;
<a name="4744"/> 4744: 	    count_exit_sched_in(TP, N+1);
<a name="4745"/> 4745: 	{trace, TP, out_exited, 0} -&gt;
<a name="4746"/> 4746: 	    N;
<a name="4747"/> 4747: 	{trace, TP, _, _} = Msg -&gt;
<a name="4748"/> 4748: 	    exit({unexpected_trace_msg, Msg})
<a name="4749"/> 4749:     end.
<a name="4750"/> 4750: 
<a name="vre_fix_tables-1"/><a name="4751"/> 4751: <b>vre_fix_tables</b>(Tab) -&gt;
<a name="4752"/> 4752:     Parent = self(),
<a name="4753"/> 4753:     Go = make_ref(),
<a name="4754"/> 4754:     my_spawn_link(fun () -&gt;
<a name="4755"/> 4755: 			  true = ets:safe_fixtable(Tab, true),
<a name="4756"/> 4756: 			  Parent ! Go,
<a name="4757"/> 4757: 			  receive infinity -&gt; ok end
<a name="4758"/> 4758: 		  end),
<a name="4759"/> 4759:     receive Go -&gt; ok end,
<a name="vre_fix_tables-last_expr"/><a name="4760"/> 4760:     ok.
<a name="4761"/> 4761: 
<a name="verify_rescheduling_exit-6"/><a name="4762"/> 4762: <b>verify_rescheduling_exit</b>(Config, ForEachData, Flags, Fix, NOTabs, NOProcs) -&gt;
<a name="4763"/> 4763:     NoFix = 5,
<a name="4764"/> 4764:     TestCase = atom_to_list(proplists:get_value(test_case, Config)),
<a name="4765"/> 4765:     Parent = self(),
<a name="4766"/> 4766:     KillMe = make_ref(),
<a name="4767"/> 4767:     PFun =
<a name="4768"/> 4768: 	fun () -&gt;
<a name="4769"/> 4769: 		repeat(
<a name="4770"/> 4770: 		  fun () -&gt;
<a name="4771"/> 4771: 			  Uniq = erlang:unique_integer([positive]),
<a name="4772"/> 4772: 			  Name = list_to_atom(TestCase ++ &quot;-&quot; ++
<a name="4773"/> 4773: 						  integer_to_list(Uniq)),
<a name="4774"/> 4774: 			  Tab = ets_new(Name, Flags),
<a name="4775"/> 4775:                           ForEachData(fun(Data) -&gt; ets:insert(Tab, Data) end),
<a name="4776"/> 4776: 			  case Fix of
<a name="4777"/> 4777: 			      false -&gt; ok;
<a name="4778"/> 4778: 			      true -&gt;
<a name="4779"/> 4779: 				  lists:foreach(fun (_) -&gt;
<a name="4780"/> 4780: 							vre_fix_tables(Tab)
<a name="4781"/> 4781: 						end,
<a name="4782"/> 4782: 						lists:seq(1,NoFix)),
<a name="4783"/> 4783:                                   KeyPos = ets:info(Tab,keypos),
<a name="4784"/> 4784:                                   ForEachData(fun(Data) -&gt;
<a name="4785"/> 4785: 						      ets:delete(Tab, element(KeyPos,Data))
<a name="4786"/> 4786:                                               end)
<a name="4787"/> 4787: 			  end
<a name="4788"/> 4788: 		  end,
<a name="4789"/> 4789: 		  NOTabs),
<a name="4790"/> 4790: 		Parent ! {KillMe, self()},
<a name="4791"/> 4791: 		receive after infinity -&gt; ok end
<a name="4792"/> 4792: 	end,
<a name="4793"/> 4793:     TPs = lists:map(fun (_) -&gt;
<a name="4794"/> 4794: 			    TP = my_spawn_link(PFun),
<a name="4795"/> 4795: 			    1 = erlang:trace(TP, true, [exiting]),
<a name="4796"/> 4796: 			    TP
<a name="4797"/> 4797: 		    end,
<a name="4798"/> 4798: 		    lists:seq(1, NOProcs)),
<a name="4799"/> 4799:     lists:foreach(fun (TP) -&gt;
<a name="4800"/> 4800: 			  receive {KillMe, TP} -&gt; ok end
<a name="4801"/> 4801: 		  end,
<a name="4802"/> 4802: 		  TPs),
<a name="4803"/> 4803:     LPs = start_loopers(erlang:system_info(schedulers),
<a name="4804"/> 4804: 			normal,
<a name="4805"/> 4805: 			fun (_) -&gt;
<a name="4806"/> 4806: 				erlang:yield()
<a name="4807"/> 4807: 			end,
<a name="4808"/> 4808: 			ok),
<a name="4809"/> 4809:     lists:foreach(fun (TP) -&gt;
<a name="4810"/> 4810: 			  unlink(TP),
<a name="4811"/> 4811: 			  exit(TP, bang)
<a name="4812"/> 4812: 		  end,
<a name="4813"/> 4813: 		  TPs),
<a name="4814"/> 4814:     lists:foreach(fun (TP) -&gt;
<a name="4815"/> 4815: 			  XScheds = count_exit_sched(TP),
<a name="4816"/> 4816: 			  io:format(&quot;~p XScheds=~p~n&quot;,
<a name="4817"/> 4817: 				    [TP, XScheds]),
<a name="4818"/> 4818: 			  true = XScheds &gt;= 3
<a name="4819"/> 4819: 		  end,
<a name="4820"/> 4820: 		  TPs),
<a name="4821"/> 4821:     stop_loopers(LPs),
<a name="verify_rescheduling_exit-last_expr"/><a name="4822"/> 4822:     ok.
<a name="4823"/> 4823: 
<a name="4824"/> 4824: 
<a name="4825"/> 4825: 
<a name="4826"/> 4826: <i>%% Make sure that slots for ets tables are cleared properly.</i>
<a name="table_leak-1"/><a name="4827"/> 4827: <b>table_leak</b>(Config) when is_list(Config) -&gt;
<a name="table_leak-last_expr"/><a name="4828"/> 4828: <b>    repeat_for_opts_all_non_stim_table_types</b>(fun(Opts) -&gt; table_leak_1(Opts,20000) end).
<a name="4829"/> 4829: 
<a name="table_leak_1-2"/><a name="4830"/> 4830: <b>table_leak_1</b>(_,0) -&gt; ok;
<a name="4831"/> 4831: <b>table_leak_1</b>(Opts,N) -&gt;
<a name="4832"/> 4832:     T = ets_new(fooflarf, Opts),
<a name="4833"/> 4833:     true = ets:delete(T),
<a name="table_leak_1-last_expr"/><a name="4834"/> 4834: <b>    table_leak_1</b>(Opts,N-1).
<a name="4835"/> 4835: 
<a name="4836"/> 4836: <i>%% Check proper return values for illegal delete operations.</i>
<a name="baddelete-1"/><a name="4837"/> 4837: <b>baddelete</b>(Config) when is_list(Config) -&gt;
<a name="4838"/> 4838:     EtsMem = etsmem(),
<a name="4839"/> 4839:     {'EXIT',{badarg,_}} = (catch ets:delete(foo)),
<a name="4840"/> 4840:     Tab = ets_new(foo,[]),
<a name="4841"/> 4841:     true = ets:delete(Tab),
<a name="4842"/> 4842:     {'EXIT',{badarg,_}} = (catch ets:delete(Tab)),
<a name="baddelete-last_expr"/><a name="4843"/> 4843: <b>    verify_etsmem</b>(EtsMem).
<a name="4844"/> 4844: 
<a name="4845"/> 4845: <i>%% Check that match_delete works. Also tests tab2list function.</i>
<a name="match_delete-1"/><a name="4846"/> 4846: <b>match_delete</b>(Config) when is_list(Config) -&gt;
<a name="4847"/> 4847:     EtsMem = etsmem(),
<a name="4848"/> 4848:     repeat_for_opts(fun match_delete_do/1,
<a name="4849"/> 4849:                     [write_concurrency,all_types]),
<a name="match_delete-last_expr"/><a name="4850"/> 4850: <b>    verify_etsmem</b>(EtsMem).
<a name="4851"/> 4851: 
<a name="match_delete_do-1"/><a name="4852"/> 4852: <b>match_delete_do</b>(Opts) -&gt;
<a name="4853"/> 4853:     EtsMem = etsmem(),
<a name="4854"/> 4854:     Tab = ets_new(kad,Opts),
<a name="4855"/> 4855:     fill_tab(Tab,foo),
<a name="4856"/> 4856:     ets:insert(Tab,{{c,key},bar}),
<a name="4857"/> 4857:     _ = ets:match_delete(Tab,{'_',foo}),
<a name="4858"/> 4858:     [{{c,key},bar}] = ets:tab2list(Tab),
<a name="4859"/> 4859:     _ = ets:match_delete(Tab,'_'),
<a name="4860"/> 4860:     [] = ets:tab2list(Tab),
<a name="4861"/> 4861:     true = ets:delete(Tab),
<a name="match_delete_do-last_expr"/><a name="4862"/> 4862: <b>    verify_etsmem</b>(EtsMem).
<a name="4863"/> 4863: 
<a name="4864"/> 4864: <i>%% OTP-3005: check match_delete with constant argument.</i>
<a name="match_delete3-1"/><a name="4865"/> 4865: <b>match_delete3</b>(Config) when is_list(Config) -&gt;
<a name="match_delete3-last_expr"/><a name="4866"/> 4866: <b>    repeat_for_opts</b>(fun match_delete3_do/1).
<a name="4867"/> 4867: 
<a name="match_delete3_do-1"/><a name="4868"/> 4868: <b>match_delete3_do</b>(Opts) -&gt;
<a name="4869"/> 4869:     EtsMem = etsmem(),
<a name="4870"/> 4870:     T = make_table(test,
<a name="4871"/> 4871: 		   [duplicate_bag | Opts],
<a name="4872"/> 4872: 		   [{aa,17},
<a name="4873"/> 4873: 		    {cA,1000},
<a name="4874"/> 4874: 		    {cA,17},
<a name="4875"/> 4875: 		    {cA,1000},
<a name="4876"/> 4876: 		    {aa,17}]),
<a name="4877"/> 4877:     %% 'aa' and 'cA' have the same hash value in the current
<a name="4878"/> 4878:     %% implementation. This causes the aa's to precede the cA's, to make
<a name="4879"/> 4879:     %% the test more interesting.
<a name="4880"/> 4880:     [{cA,1000},{cA,1000}] = ets:match_object(T, {'_', 1000}),
<a name="4881"/> 4881:     ets:match_delete(T, {cA,1000}),
<a name="4882"/> 4882:     [] = ets:match_object(T, {'_', 1000}),
<a name="4883"/> 4883:     ets:delete(T),
<a name="match_delete3_do-last_expr"/><a name="4884"/> 4884: <b>    verify_etsmem</b>(EtsMem).
<a name="4885"/> 4885: 
<a name="4886"/> 4886: 
<a name="4887"/> 4887: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="4888"/> 4888: 
<a name="4889"/> 4889: <i>%% Test ets:first/1 &amp; ets:next/2.</i>
<a name="firstnext-1"/><a name="4890"/> 4890: <b>firstnext</b>(Config) when is_list(Config) -&gt;
<a name="firstnext-last_expr"/><a name="4891"/> 4891: <b>    repeat_for_opts_all_set_table_types</b>(fun firstnext_do/1).
<a name="4892"/> 4892: 
<a name="firstnext_do-1"/><a name="4893"/> 4893: <b>firstnext_do</b>(Opts) -&gt;
<a name="4894"/> 4894:     EtsMem = etsmem(),
<a name="4895"/> 4895:     Tab = ets_new(foo,Opts),
<a name="4896"/> 4896:     [] = firstnext_collect(Tab,ets:first(Tab),[]),
<a name="4897"/> 4897:     fill_tab(Tab,foo),
<a name="4898"/> 4898:     Len = length(ets:tab2list(Tab)),
<a name="4899"/> 4899:     Len = length(firstnext_collect(Tab,ets:first(Tab),[])),
<a name="4900"/> 4900:     true = ets:delete(Tab),
<a name="firstnext_do-last_expr"/><a name="4901"/> 4901: <b>    verify_etsmem</b>(EtsMem).
<a name="4902"/> 4902: 
<a name="firstnext_collect-3"/><a name="4903"/> 4903: <b>firstnext_collect</b>(_Tab,'$end_of_table',List) -&gt;
<a name="4904"/> 4904:     List;
<a name="4905"/> 4905: <b>firstnext_collect</b>(Tab,Key,List) -&gt;
<a name="firstnext_collect-last_expr"/><a name="4906"/> 4906: <b>    firstnext_collect</b>(Tab,ets:next(Tab,Key),[Key|List]).
<a name="4907"/> 4907: 
<a name="4908"/> 4908: 
<a name="4909"/> 4909: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="4910"/> 4910: 
<a name="4911"/> 4911: <i>%% Tests ets:first/1 &amp; ets:next/2.</i>
<a name="firstnext_concurrent-1"/><a name="4912"/> 4912: <b>firstnext_concurrent</b>(Config) when is_list(Config) -&gt;
<a name="firstnext_concurrent-last_expr"/><a name="4913"/> 4913: <b>    lists:foreach</b>(
<a name="4914"/> 4914:       fun(TableType) -&gt; 
<a name="4915"/> 4915:               register(master, self()),
<a name="4916"/> 4916:               TableName = list_to_atom(atom_to_list(?MODULE) ++ atom_to_list(TableType)),
<a name="4917"/> 4917:               ets_init(TableName, 20, TableType),
<a name="4918"/> 4918:               [dynamic_go(TableName) || _ &lt;- lists:seq(1, 2)],
<a name="4919"/> 4919:               receive
<a name="4920"/> 4920:               after 5000 -&gt; ok
<a name="4921"/> 4921:               end,
<a name="4922"/> 4922:               unregister(master)
<a name="4923"/> 4923:       end, repeat_for_opts_atom2list(ord_set_types)).
<a name="4924"/> 4924: 
<a name="ets_init-3"/><a name="4925"/> 4925: <b>ets_init</b>(Tab, N, TableType) -&gt;
<a name="4926"/> 4926:     ets_new(Tab, [named_table,public,TableType]),
<a name="ets_init-last_expr"/><a name="4927"/> 4927: <b>    cycle</b>(Tab, lists:seq(1,N+1)).
<a name="4928"/> 4928: 
<a name="cycle-2"/><a name="4929"/> 4929: <b>cycle</b>(_Tab, [H|T]) when H &gt; length(T)-&gt; ok;
<a name="4930"/> 4930: <b>cycle</b>(Tab, L) -&gt;
<a name="4931"/> 4931:     ets:insert(Tab,list_to_tuple(L)),
<a name="cycle-last_expr"/><a name="4932"/> 4932: <b>    cycle</b>(Tab, tl(L)++[hd(L)]).
<a name="4933"/> 4933: 
<a name="dynamic_go-1"/><a name="dynamic_go-last_expr"/><a name="4934"/> 4934: <b>dynamic_go</b>(TableName) -&gt; my_spawn_link(fun() -&gt; dynamic_init(TableName) end).
<a name="4935"/> 4935: 
<a name="dynamic_init-1"/><a name="dynamic_init-last_expr"/><a name="4936"/> 4936: <b>dynamic_init</b>(TableName) -&gt; [dyn_lookup(TableName) || _ &lt;- lists:seq(1, 10)].
<a name="4937"/> 4937: 
<a name="dyn_lookup-1"/><a name="dyn_lookup-last_expr"/><a name="4938"/> 4938: <b>dyn_lookup</b>(T) -&gt; dyn_lookup(T, ets:first(T)).
<a name="4939"/> 4939: 
<a name="dyn_lookup-2"/><a name="4940"/> 4940: <b>dyn_lookup</b>(_T, '$end_of_table') -&gt; [];
<a name="4941"/> 4941: <b>dyn_lookup</b>(T, K) -&gt;
<a name="4942"/> 4942:     NextKey = ets:next(T,K),
<a name="dyn_lookup-last_expr"/><a name="4943"/> 4943: <b>    case ets:next</b>(T,K) of
<a name="4944"/> 4944: 	NextKey -&gt;
<a name="4945"/> 4945: 	    dyn_lookup(T, NextKey);
<a name="4946"/> 4946: 	NK -&gt;
<a name="4947"/> 4947: 	    io:fwrite(&quot;hmmm... ~p =/= ~p~n&quot;, [NextKey,NK]),
<a name="4948"/> 4948: 	    exit(failed)
<a name="4949"/> 4949:     end.
<a name="4950"/> 4950: 
<a name="4951"/> 4951: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="4952"/> 4952: 
<a name="slot-1"/><a name="4953"/> 4953: <b>slot</b>(Config) when is_list(Config) -&gt;
<a name="slot-last_expr"/><a name="4954"/> 4954: <b>    repeat_for_opts_all_set_table_types</b>(fun slot_do/1).
<a name="4955"/> 4955: 
<a name="slot_do-1"/><a name="4956"/> 4956: <b>slot_do</b>(Opts) -&gt;
<a name="4957"/> 4957:     EtsMem = etsmem(),
<a name="4958"/> 4958:     Tab = ets_new(foo,Opts),
<a name="4959"/> 4959:     fill_tab(Tab,foo),
<a name="4960"/> 4960:     Elts = ets:info(Tab,size),
<a name="4961"/> 4961:     Elts = slot_loop(Tab,0,0),
<a name="4962"/> 4962:     case ets:info(Tab, type) of
<a name="4963"/> 4963:         ordered_set -&gt;
<a name="4964"/> 4964:             '$end_of_table' = ets:slot(Tab,Elts);
<a name="4965"/> 4965:         _ -&gt; ok
<a name="4966"/> 4966:     end,
<a name="4967"/> 4967:     true = ets:delete(Tab),
<a name="slot_do-last_expr"/><a name="4968"/> 4968: <b>    verify_etsmem</b>(EtsMem).
<a name="4969"/> 4969: 
<a name="slot_loop-3"/><a name="4970"/> 4970: <b>slot_loop</b>(Tab,SlotNo,EltsSoFar) -&gt;
<a name="slot_loop-last_expr"/><a name="4971"/> 4971: <b>    case ets:slot</b>(Tab,SlotNo) of
<a name="4972"/> 4972: 	'$end_of_table' -&gt;
<a name="4973"/> 4973: 	    {'EXIT',{badarg,_}} =
<a name="4974"/> 4974: 		(catch ets:slot(Tab,SlotNo+1)),
<a name="4975"/> 4975: 	    EltsSoFar;
<a name="4976"/> 4976: 	Elts -&gt;
<a name="4977"/> 4977: 	    slot_loop(Tab,SlotNo+1,EltsSoFar+length(Elts))
<a name="4978"/> 4978:     end.
<a name="4979"/> 4979: 
<a name="4980"/> 4980: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="4981"/> 4981: 
<a name="hash_clash-1"/><a name="4982"/> 4982: <b>hash_clash</b>(Config) when is_list(Config) -&gt;
<a name="4983"/> 4983:     %% ensure that erlang:phash2 and ets:slot use different hash seed
<a name="4984"/> 4984:     Tab = ets:new(tab, [set]),
<a name="4985"/> 4985:     Buckets = erlang:element(1, ets:info(Tab, stats)),
<a name="4986"/> 4986:     Phash = erlang:phash2(&lt;&lt;&quot;123&quot;&gt;&gt;, Buckets),
<a name="4987"/> 4987:     true = ets:insert(Tab, {&lt;&lt;&quot;123&quot;&gt;&gt;, &quot;extra&quot;}),
<a name="hash_clash-last_expr"/><a name="4988"/> 4988: <b>    [] = ets:slot</b>(Tab, Phash).
<a name="4989"/> 4989: 
<a name="4990"/> 4990: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="4991"/> 4991: 
<a name="4992"/> 4992: 
<a name="match1-1"/><a name="4993"/> 4993: <b>match1</b>(Config) when is_list(Config) -&gt;
<a name="match1-last_expr"/><a name="4994"/> 4994: <b>    repeat_for_opts_all_set_table_types</b>(fun match1_do/1).
<a name="4995"/> 4995: 
<a name="match1_do-1"/><a name="4996"/> 4996: <b>match1_do</b>(Opts) -&gt;
<a name="4997"/> 4997:     EtsMem = etsmem(),
<a name="4998"/> 4998:     Tab = ets_new(foo,Opts),
<a name="4999"/> 4999:     fill_tab(Tab,foo),
<a name="5000"/> 5000:     [] = ets:match(Tab,{}),
<a name="5001"/> 5001:     ets:insert(Tab,{{one,4},4}),
<a name="5002"/> 5002:     ets:insert(Tab,{{one,5},5}),
<a name="5003"/> 5003:     ets:insert(Tab,{{two,4},4}),
<a name="5004"/> 5004:     ets:insert(Tab,{{two,5},6}),
<a name="5005"/> 5005:     case ets:match(Tab,{{one,'_'},'$0'}) of
<a name="5006"/> 5006: 	[[4],[5]] -&gt; ok;
<a name="5007"/> 5007: 	[[5],[4]] -&gt; ok
<a name="5008"/> 5008:     end,
<a name="5009"/> 5009:     case ets:match(Tab,{{two,'$1'},'$0'}) of
<a name="5010"/> 5010: 	[[4,4],[6,5]] -&gt; ok;
<a name="5011"/> 5011: 	[[6,5],[4,4]] -&gt; ok
<a name="5012"/> 5012:     end,
<a name="5013"/> 5013:     case ets:match(Tab,{{two,'$9'},'$4'}) of
<a name="5014"/> 5014: 	[[4,4],[6,5]] -&gt; ok;
<a name="5015"/> 5015: 	[[6,5],[4,4]] -&gt; ok
<a name="5016"/> 5016:     end,
<a name="5017"/> 5017:     case ets:match(Tab,{{two,'$9'},'$22'}) of
<a name="5018"/> 5018: 	[[4,4],[5,6]] -&gt; ok;
<a name="5019"/> 5019: 	[[5,6],[4,4]] -&gt; ok
<a name="5020"/> 5020:     end,
<a name="5021"/> 5021:     [[4]] = ets:match(Tab,{{two,'$0'},'$0'}),
<a name="5022"/> 5022:     Len = length(ets:match(Tab,'$0')),
<a name="5023"/> 5023:     Len = length(ets:match(Tab,'_')),
<a name="5024"/> 5024:     if Len &gt; 4 -&gt; ok end,
<a name="5025"/> 5025:     true = ets:delete(Tab),
<a name="match1_do-last_expr"/><a name="5026"/> 5026: <b>    verify_etsmem</b>(EtsMem).
<a name="5027"/> 5027: 
<a name="5028"/> 5028: <i>%% Test match with specified keypos bag table.</i>
<a name="match2-1"/><a name="5029"/> 5029: <b>match2</b>(Config) when is_list(Config) -&gt;
<a name="match2-last_expr"/><a name="5030"/> 5030: <b>    repeat_for_opts</b>(fun match2_do/1).
<a name="5031"/> 5031: 
<a name="match2_do-1"/><a name="5032"/> 5032: <b>match2_do</b>(Opts) -&gt;
<a name="5033"/> 5033:     EtsMem = etsmem(),
<a name="5034"/> 5034:     Tab = make_table(foobar,
<a name="5035"/> 5035: 		     [bag, named_table, {keypos, 2} | Opts],
<a name="5036"/> 5036: 		     [{value1, key1},
<a name="5037"/> 5037: 		      {value2_1, key2},
<a name="5038"/> 5038: 		      {value2_2, key2},
<a name="5039"/> 5039: 		      {value3_1, key3},
<a name="5040"/> 5040: 		      {value3_2, key3},
<a name="5041"/> 5041: 		      {value2_1, key2_wannabe}]),
<a name="5042"/> 5042:     case length(ets:match(Tab, '$1')) of
<a name="5043"/> 5043: 	6 -&gt; ok;
<a name="5044"/> 5044: 	_ -&gt; ct:fail(&quot;Length of matched list is wrong.&quot;)
<a name="5045"/> 5045:     end,
<a name="5046"/> 5046:     [[value3_1],[value3_2]] = ets:match(Tab, {'$1', key3}),
<a name="5047"/> 5047:     [[key1]] = ets:match(Tab, {value1, '$1'}),
<a name="5048"/> 5048:     [[key2_wannabe],[key2]] = ets:match(Tab, {value2_1, '$2'}),
<a name="5049"/> 5049:     [] = ets:match(Tab,{'$1',nosuchkey}),
<a name="5050"/> 5050:     [] = ets:match(Tab,{'$1',kgY2}), % same hash as key2
<a name="5051"/> 5051:     [] = ets:match(Tab,{nosuchvalue,'$1'}),
<a name="5052"/> 5052:     true = ets:delete(Tab),
<a name="match2_do-last_expr"/><a name="5053"/> 5053: <b>    verify_etsmem</b>(EtsMem).
<a name="5054"/> 5054: 
<a name="5055"/> 5055: <i>%% Some ets:match_object tests.</i>
<a name="match_object-1"/><a name="5056"/> 5056: <b>match_object</b>(Config) when is_list(Config) -&gt;
<a name="match_object-last_expr"/><a name="5057"/> 5057: <b>    repeat_for_opts_all_set_table_types</b>(fun match_object_do/1).
<a name="5058"/> 5058: 
<a name="match_object_do-1"/><a name="5059"/> 5059: <b>match_object_do</b>(Opts) -&gt;
<a name="5060"/> 5060:     EtsMem = etsmem(),
<a name="5061"/> 5061:     Tab = ets_new(foobar, Opts),
<a name="5062"/> 5062:     fill_tab(Tab, foo),
<a name="5063"/> 5063:     ets:insert(Tab,{{one,4},4}),
<a name="5064"/> 5064:     ets:insert(Tab,{{one,5},5}),
<a name="5065"/> 5065:     ets:insert(Tab,{{two,4},4}),
<a name="5066"/> 5066:     ets:insert(Tab,{{two,5},6}),
<a name="5067"/> 5067:     ets:insert(Tab, {#{camembert=&gt;cabécou},7}),
<a name="5068"/> 5068:     ets:insert(Tab, {#{&quot;hi&quot;=&gt;&quot;hello&quot;,&quot;wazzup&quot;=&gt;&quot;awesome&quot;,&quot;1337&quot;=&gt;&quot;42&quot;},8}),
<a name="5069"/> 5069:     ets:insert(Tab, {#{&quot;hi&quot;=&gt;&quot;hello&quot;,#{&quot;wazzup&quot;=&gt;3}=&gt;&quot;awesome&quot;,&quot;1337&quot;=&gt;&quot;42&quot;},9}),
<a name="5070"/> 5070:     ets:insert(Tab, {#{&quot;hi&quot;=&gt;&quot;hello&quot;,&quot;wazzup&quot;=&gt;#{&quot;awesome&quot;=&gt;3},&quot;1337&quot;=&gt;&quot;42&quot;},10}),
<a name="5071"/> 5071:     Is = lists:seq(1,100),
<a name="5072"/> 5072:     M1 = maps:from_list([{I,I}||I &lt;- Is]),
<a name="5073"/> 5073:     M2 = maps:from_list([{I,&quot;hi&quot;}||I &lt;- Is]),
<a name="5074"/> 5074:     ets:insert(Tab, {M1,11}),
<a name="5075"/> 5075:     ets:insert(Tab, {M2,12}),
<a name="5076"/> 5076: 
<a name="5077"/> 5077:     case ets:match_object(Tab, {{one, '_'}, '$0'}) of
<a name="5078"/> 5078: 	[{{one,5},5},{{one,4},4}] -&gt; ok;
<a name="5079"/> 5079: 	[{{one,4},4},{{one,5},5}] -&gt; ok;
<a name="5080"/> 5080: 	_ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5081"/> 5081:     end,
<a name="5082"/> 5082:     case ets:match_object(Tab, {{two, '$1'}, '$0'}) of
<a name="5083"/> 5083: 	[{{two,5},6},{{two,4},4}] -&gt; ok;
<a name="5084"/> 5084: 	[{{two,4},4},{{two,5},6}] -&gt; ok;
<a name="5085"/> 5085: 	_ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5086"/> 5086:     end,
<a name="5087"/> 5087:     case ets:match_object(Tab, {{two, '$9'}, '$4'}) of
<a name="5088"/> 5088: 	[{{two,5},6},{{two,4},4}] -&gt; ok;
<a name="5089"/> 5089: 	[{{two,4},4},{{two,5},6}] -&gt; ok;
<a name="5090"/> 5090: 	_ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5091"/> 5091:     end,
<a name="5092"/> 5092:     case ets:match_object(Tab, {{two, '$9'}, '$22'}) of
<a name="5093"/> 5093: 	[{{two,5},6},{{two,4},4}] -&gt; ok;
<a name="5094"/> 5094: 	[{{two,4},4},{{two,5},6}] -&gt; ok;
<a name="5095"/> 5095: 	_ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5096"/> 5096:     end,
<a name="5097"/> 5097: 
<a name="5098"/> 5098:     %% Check that maps are inspected for variables.
<a name="5099"/> 5099:     [{#{camembert:=cabécou},7}] = ets:match_object(Tab, {#{camembert=&gt;'_'},7}),
<a name="5100"/> 5100: 
<a name="5101"/> 5101:     [{#{&quot;hi&quot;:=&quot;hello&quot;,#{&quot;wazzup&quot;=&gt;3}:=&quot;awesome&quot;,&quot;1337&quot;:=&quot;42&quot;},9}] =
<a name="5102"/> 5102:         ets:match_object(Tab, {#{#{&quot;wazzup&quot;=&gt;3}=&gt;&quot;awesome&quot;,&quot;hi&quot;=&gt;&quot;hello&quot;,&quot;1337&quot;=&gt;&quot;42&quot;},9}),
<a name="5103"/> 5103:     [{#{&quot;hi&quot;:=&quot;hello&quot;,#{&quot;wazzup&quot;=&gt;3}:=&quot;awesome&quot;,&quot;1337&quot;:=&quot;42&quot;},9}] =
<a name="5104"/> 5104:         ets:match_object(Tab, {#{#{&quot;wazzup&quot;=&gt;3}=&gt;&quot;awesome&quot;,&quot;hi&quot;=&gt;&quot;hello&quot;,&quot;1337&quot;=&gt;'_'},'_'}),
<a name="5105"/> 5105:     [{#{&quot;hi&quot;:=&quot;hello&quot;,&quot;wazzup&quot;:=#{&quot;awesome&quot;:=3},&quot;1337&quot;:=&quot;42&quot;},10}] =
<a name="5106"/> 5106:         ets:match_object(Tab, {#{&quot;wazzup&quot;=&gt;'_',&quot;hi&quot;=&gt;'_',&quot;1337&quot;=&gt;'_'},10}),
<a name="5107"/> 5107: 
<a name="5108"/> 5108:     %% multiple patterns
<a name="5109"/> 5109:     Pat = {{#{#{&quot;wazzup&quot;=&gt;3}=&gt;&quot;awesome&quot;,&quot;hi&quot;=&gt;&quot;hello&quot;,&quot;1337&quot;=&gt;'_'},'$1'},[{is_integer,'$1'}],['$_']},
<a name="5110"/> 5110:     [{#{&quot;hi&quot;:=&quot;hello&quot;,#{&quot;wazzup&quot;=&gt;3}:=&quot;awesome&quot;,&quot;1337&quot;:=&quot;42&quot;},9}] =
<a name="5111"/> 5111:         ets:select(Tab, [Pat,Pat,Pat,Pat]),
<a name="5112"/> 5112:     case ets:match_object(Tab, {#{&quot;hi&quot;=&gt;&quot;hello&quot;,&quot;wazzup&quot;=&gt;'_',&quot;1337&quot;=&gt;&quot;42&quot;},'_'}) of
<a name="5113"/> 5113:         [{#{&quot;1337&quot; := &quot;42&quot;,&quot;hi&quot; := &quot;hello&quot;,&quot;wazzup&quot; := &quot;awesome&quot;},8},
<a name="5114"/> 5114:          {#{&quot;1337&quot; := &quot;42&quot;,&quot;hi&quot; := &quot;hello&quot;,&quot;wazzup&quot; := #{&quot;awesome&quot; := 3}},10}] -&gt; ok;
<a name="5115"/> 5115:         [{#{&quot;1337&quot; := &quot;42&quot;,&quot;hi&quot; := &quot;hello&quot;,&quot;wazzup&quot; := #{&quot;awesome&quot; := 3}},10},
<a name="5116"/> 5116:          {#{&quot;1337&quot; := &quot;42&quot;,&quot;hi&quot; := &quot;hello&quot;,&quot;wazzup&quot; := &quot;awesome&quot;},8}] -&gt; ok;
<a name="5117"/> 5117:         _ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5118"/> 5118:     end,
<a name="5119"/> 5119:     case ets:match_object(Tab, {#{&quot;hi&quot;=&gt;'_'},'_'}) of
<a name="5120"/> 5120:         [{#{&quot;1337&quot;:=&quot;42&quot;, &quot;hi&quot;:=&quot;hello&quot;},_},
<a name="5121"/> 5121:          {#{&quot;1337&quot;:=&quot;42&quot;, &quot;hi&quot;:=&quot;hello&quot;},_},
<a name="5122"/> 5122:          {#{&quot;1337&quot;:=&quot;42&quot;, &quot;hi&quot;:=&quot;hello&quot;},_}] -&gt; ok;
<a name="5123"/> 5123:         _ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5124"/> 5124:     end,
<a name="5125"/> 5125: 
<a name="5126"/> 5126:     %% match large maps
<a name="5127"/> 5127:     [{#{1:=1,2:=2,99:=99,100:=100},11}] = ets:match_object(Tab, {M1,11}),
<a name="5128"/> 5128:     [{#{1:=&quot;hi&quot;,2:=&quot;hi&quot;,99:=&quot;hi&quot;,100:=&quot;hi&quot;},12}] = ets:match_object(Tab, {M2,12}),
<a name="5129"/> 5129:     case ets:match_object(Tab, {#{1=&gt;'_',2=&gt;'_'},'_'}) of
<a name="5130"/> 5130:         %% only match a part of the map
<a name="5131"/> 5131:         [{#{1:=1,5:=5,99:=99,100:=100},11},{#{1:=&quot;hi&quot;,6:=&quot;hi&quot;,99:=&quot;hi&quot;},12}] -&gt; ok;
<a name="5132"/> 5132:         [{#{1:=&quot;hi&quot;,2:=&quot;hi&quot;,59:=&quot;hi&quot;},12},{#{1:=1,2:=2,39:=39,100:=100},11}] -&gt; ok;
<a name="5133"/> 5133:         _ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5134"/> 5134:     end,
<a name="5135"/> 5135:     case ets:match_object(Tab, {maps:from_list([{I,'_'}||I&lt;-Is]),'_'}) of
<a name="5136"/> 5136:         %% only match a part of the map
<a name="5137"/> 5137:         [{#{1:=1,5:=5,99:=99,100:=100},11},{#{1:=&quot;hi&quot;,6:=&quot;hi&quot;,99:=&quot;hi&quot;},12}] -&gt; ok;
<a name="5138"/> 5138:         [{#{1:=&quot;hi&quot;,2:=&quot;hi&quot;,59:=&quot;hi&quot;},12},{#{1:=1,2:=2,39:=39,100:=100},11}] -&gt; ok;
<a name="5139"/> 5139:         _ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5140"/> 5140:     end,
<a name="5141"/> 5141:     {'EXIT',{badarg,_}} = (catch ets:match_object(Tab, {#{'$1'=&gt;'_'},7})),
<a name="5142"/> 5142:     Mve = maps:from_list([{list_to_atom([$$|integer_to_list(I)]),'_'}||I&lt;-Is]),
<a name="5143"/> 5143:     {'EXIT',{badarg,_}} = (catch ets:match_object(Tab, {Mve,11})),
<a name="5144"/> 5144: 
<a name="5145"/> 5145:     %% Check that unsuccessful match returns an empty list.
<a name="5146"/> 5146:     [] = ets:match_object(Tab, {{three,'$0'}, '$92'}),
<a name="5147"/> 5147:     %% Check that '$0' equals '_'.
<a name="5148"/> 5148:     Len = length(ets:match_object(Tab, '$0')),
<a name="5149"/> 5149:     Len = length(ets:match_object(Tab, '_')),
<a name="5150"/> 5150:     if Len &gt; 4 -&gt; ok end,
<a name="5151"/> 5151:     true = ets:delete(Tab),
<a name="match_object_do-last_expr"/><a name="5152"/> 5152: <b>    verify_etsmem</b>(EtsMem).
<a name="5153"/> 5153: 
<a name="5154"/> 5154: <i>%% Tests that db_match_object does not generate a `badarg' when</i>
<a name="5155"/> 5155: <i>%% resuming a search with no previous matches.</i>
<a name="match_object2-1"/><a name="5156"/> 5156: <b>match_object2</b>(Config) when is_list(Config) -&gt;
<a name="match_object2-last_expr"/><a name="5157"/> 5157: <b>    repeat_for_opts_all_table_types</b>(fun match_object2_do/1).
<a name="5158"/> 5158: 
<a name="match_object2_do-1"/><a name="5159"/> 5159: <b>match_object2_do</b>(Opts) -&gt;
<a name="5160"/> 5160:     EtsMem = etsmem(),
<a name="5161"/> 5161:     KeyRange = 13005,
<a name="5162"/> 5162:     Tab = ets_new(foo, [{keypos, 2} | Opts], KeyRange),
<a name="5163"/> 5163:     fill_tab2(Tab, 0, KeyRange),     % match_db_object does 1000
<a name="5164"/> 5164: 						% elements per pass, might
<a name="5165"/> 5165: 						% change in the future.
<a name="5166"/> 5166:     [] = ets:match_object(Tab, {hej, '$1'}),
<a name="5167"/> 5167:     ets:delete(Tab),
<a name="match_object2_do-last_expr"/><a name="5168"/> 5168: <b>    verify_etsmem</b>(EtsMem).
<a name="5169"/> 5169: 
<a name="5170"/> 5170: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="5171"/> 5171: 
<a name="5172"/> 5172: 
<a name="5173"/> 5173: <i>%% OTP-3319. Test tab2list.</i>
<a name="tab2list-1"/><a name="5174"/> 5174: <b>tab2list</b>(Config) when is_list(Config) -&gt;
<a name="tab2list-last_expr"/><a name="5175"/> 5175: <b>    repeat_for_all_ord_set_table_types</b>(
<a name="5176"/> 5176:       fun(Opts) -&gt;
<a name="5177"/> 5177:               EtsMem = etsmem(),
<a name="5178"/> 5178:               Tab = make_table(foo,
<a name="5179"/> 5179:                                Opts,
<a name="5180"/> 5180:                                [{a,b}, {c,b}, {b,b}, {a,c}]),
<a name="5181"/> 5181:               [{a,c},{b,b},{c,b}] = ets:tab2list(Tab),
<a name="5182"/> 5182:               true = ets:delete(Tab),
<a name="5183"/> 5183:               verify_etsmem(EtsMem)
<a name="5184"/> 5184:       end).
<a name="5185"/> 5185: 
<a name="5186"/> 5186: <i>%% Simple general small test.  If this fails, ets is in really bad</i>
<a name="5187"/> 5187: <i>%% shape.</i>
<a name="misc1-1"/><a name="5188"/> 5188: <b>misc1</b>(Config) when is_list(Config) -&gt;
<a name="misc1-last_expr"/><a name="5189"/> 5189: <b>    repeat_for_opts_all_table_types</b>(fun misc1_do/1).
<a name="5190"/> 5190: 
<a name="misc1_do-1"/><a name="5191"/> 5191: <b>misc1_do</b>(Opts) -&gt;
<a name="5192"/> 5192:     EtsMem = etsmem(),
<a name="5193"/> 5193:     Tab = ets_new(foo,Opts),
<a name="5194"/> 5194:     true = lists:member(Tab,ets:all()),
<a name="5195"/> 5195:     ets:delete(Tab),
<a name="5196"/> 5196:     false = lists:member(Tab,ets:all()),
<a name="5197"/> 5197:     case catch ets:delete(Tab) of
<a name="5198"/> 5198: 	{'EXIT',_Reason} -&gt;
<a name="5199"/> 5199: 	    verify_etsmem(EtsMem);
<a name="5200"/> 5200: 	true -&gt;
<a name="5201"/> 5201: 	    ct:fail(&quot;Delete of nonexisting table returned `true'.&quot;)
<a name="5202"/> 5202:     end,
<a name="misc1_do-last_expr"/><a name="5203"/> 5203:     ok.
<a name="5204"/> 5204: 
<a name="5205"/> 5205: <i>%% Check the safe_fixtable function.</i>
<a name="safe_fixtable-1"/><a name="5206"/> 5206: <b>safe_fixtable</b>(Config) when is_list(Config) -&gt;
<a name="safe_fixtable-last_expr"/><a name="5207"/> 5207: <b>    repeat_for_opts_all_table_types</b>(fun safe_fixtable_do/1).
<a name="5208"/> 5208: 
<a name="safe_fixtable_do-1"/><a name="5209"/> 5209: <b>safe_fixtable_do</b>(Opts) -&gt;
<a name="5210"/> 5210:     EtsMem = etsmem(),
<a name="5211"/> 5211:     Tab = ets_new(foo, Opts),
<a name="5212"/> 5212:     fill_tab(Tab, foobar),
<a name="5213"/> 5213:     true = ets:safe_fixtable(Tab, true),
<a name="5214"/> 5214:     receive after 1 -&gt; ok end,
<a name="5215"/> 5215:     true = ets:safe_fixtable(Tab, false),
<a name="5216"/> 5216:     false = ets:info(Tab,safe_fixed_monotonic_time),
<a name="5217"/> 5217:     false = ets:info(Tab,safe_fixed),
<a name="5218"/> 5218:     SysBefore = erlang:timestamp(),
<a name="5219"/> 5219:     MonBefore = erlang:monotonic_time(),
<a name="5220"/> 5220:     true = ets:safe_fixtable(Tab, true),
<a name="5221"/> 5221:     MonAfter = erlang:monotonic_time(),
<a name="5222"/> 5222:     SysAfter = erlang:timestamp(),
<a name="5223"/> 5223:     Self = self(),
<a name="5224"/> 5224:     {FixMonTime,[{Self,1}]} = ets:info(Tab,safe_fixed_monotonic_time),
<a name="5225"/> 5225:     {FixSysTime,[{Self,1}]} = ets:info(Tab,safe_fixed),
<a name="5226"/> 5226:     true = is_integer(FixMonTime),
<a name="5227"/> 5227:     true = MonBefore =&lt; FixMonTime,
<a name="5228"/> 5228:     true = FixMonTime =&lt; MonAfter,
<a name="5229"/> 5229:     {FstMs,FstS,FstUs} = FixSysTime,
<a name="5230"/> 5230:     true = is_integer(FstMs),
<a name="5231"/> 5231:     true = is_integer(FstS),
<a name="5232"/> 5232:     true = is_integer(FstUs),
<a name="5233"/> 5233:     case erlang:system_info(time_warp_mode) of
<a name="5234"/> 5234: 	no_time_warp -&gt;
<a name="5235"/> 5235: 	    true = timer:now_diff(FixSysTime, SysBefore) &gt;= 0,
<a name="5236"/> 5236: 	    true = timer:now_diff(SysAfter, FixSysTime) &gt;= 0;
<a name="5237"/> 5237: 	_ -&gt;
<a name="5238"/> 5238: 	    %% ets:info(Tab,safe_fixed) not timewarp safe...
<a name="5239"/> 5239: 	    ignore
<a name="5240"/> 5240:     end,
<a name="5241"/> 5241:     %% Test that an unjustified 'unfix' is a no-op.
<a name="5242"/> 5242:     {Pid,MRef} = my_spawn_monitor(fun() -&gt; true = ets:safe_fixtable(Tab,false) end),
<a name="5243"/> 5243:     {'DOWN', MRef, process, Pid, normal} = receive M -&gt; M end,
<a name="5244"/> 5244:     true = ets:info(Tab,fixed),
<a name="5245"/> 5245:     {FixMonTime,[{Self,1}]} = ets:info(Tab,safe_fixed_monotonic_time),
<a name="5246"/> 5246:     {FixSysTime,[{Self,1}]} = ets:info(Tab,safe_fixed),
<a name="5247"/> 5247:     %% badarg's
<a name="5248"/> 5248:     {'EXIT', {badarg, _}} = (catch ets:safe_fixtable(Tab, foobar)),
<a name="5249"/> 5249:     true = ets:info(Tab,fixed),
<a name="5250"/> 5250:     true = ets:safe_fixtable(Tab, false),
<a name="5251"/> 5251:     false = ets:info(Tab,fixed),
<a name="5252"/> 5252:     {'EXIT', {badarg, _}} = (catch ets:safe_fixtable(Tab, foobar)),
<a name="5253"/> 5253:     false = ets:info(Tab,fixed),
<a name="5254"/> 5254:     ets:delete(Tab),
<a name="5255"/> 5255:     case catch ets:safe_fixtable(Tab, true) of
<a name="5256"/> 5256: 	{'EXIT', _Reason} -&gt;
<a name="5257"/> 5257: 	    verify_etsmem(EtsMem);
<a name="5258"/> 5258: 	_ -&gt;
<a name="5259"/> 5259: 	    ct:fail(&quot;Fixtable on nonexisting table returned `true'&quot;)
<a name="5260"/> 5260:     end,
<a name="safe_fixtable_do-last_expr"/><a name="5261"/> 5261:     ok.
<a name="5262"/> 5262: 
<a name="5263"/> 5263: <b>-define</b>(ets_info(Tab,Item,SlavePid), ets_info(Tab, Item, SlavePid, ?LINE)).
<a name="5264"/> 5264: 
<a name="5265"/> 5265: <i>%% Tests ets:info result for required tuples.</i>
<a name="info-1"/><a name="5266"/> 5266: <b>info</b>(Config) when is_list(Config) -&gt;
<a name="5267"/> 5267:     repeat_for_opts(fun info_do/1,
<a name="5268"/> 5268:                     [[void, set, bag, duplicate_bag, ordered_set],
<a name="5269"/> 5269:                      [void, private, protected, public],
<a name="5270"/> 5270:                      write_concurrency, read_concurrency, compressed]),
<a name="5271"/> 5271: 
<a name="5272"/> 5272:     undefined = ets:info(non_existing_table_xxyy),
<a name="5273"/> 5273:     undefined = ets:info(non_existing_table_xxyy,type),
<a name="5274"/> 5274:     undefined = ets:info(non_existing_table_xxyy,node),
<a name="5275"/> 5275:     undefined = ets:info(non_existing_table_xxyy,named_table),
<a name="5276"/> 5276:     undefined = ets:info(non_existing_table_xxyy,safe_fixed_monotonic_time),
<a name="5277"/> 5277:     undefined = ets:info(non_existing_table_xxyy,safe_fixed),
<a name="5278"/> 5278: 
<a name="5279"/> 5279:     {'EXIT',{badarg,_}} = (catch ets:info(42)),
<a name="5280"/> 5280:     {'EXIT',{badarg,_}} = (catch ets:info(42, type)),
<a name="5281"/> 5281:     {'EXIT',{badarg,_}} = (catch ets:info(make_ref())),
<a name="5282"/> 5282:     {'EXIT',{badarg,_}} = (catch ets:info(make_ref(), type)),
<a name="5283"/> 5283: 
<a name="5284"/> 5284:     case erlang:system_info(schedulers) of
<a name="5285"/> 5285:         1 -&gt; %% Fine grained locking is not activated when there is only one scheduler
<a name="5286"/> 5286:             lists:foreach(
<a name="5287"/> 5287:               fun(Type) -&gt;
<a name="5288"/> 5288:                       T1 = ets:new(t1, [public, Type, {write_concurrency, auto}]),
<a name="5289"/> 5289:                       false = ets:info(T1, write_concurrency),
<a name="5290"/> 5290:                       T2 = ets:new(t2, [public, Type, {write_concurrency, true}]),
<a name="5291"/> 5291:                       false = ets:info(T2, write_concurrency)
<a name="5292"/> 5292:               end,
<a name="5293"/> 5293:               [set, bag, duplicate_bag, ordered_set]),
<a name="5294"/> 5294:             T2 = ets:new(t2, [public, {write_concurrency, {debug_hash_fixed_number_of_locks, 2049}}]),
<a name="5295"/> 5295:             false = ets:info(T2, write_concurrency);
<a name="5296"/> 5296:         _ -&gt;
<a name="5297"/> 5297:             %% Test that one can set the synchronization granularity level for
<a name="5298"/> 5298:             %% tables of type set
<a name="5299"/> 5299:             T1 = ets:new(t1, [public, {write_concurrency, {debug_hash_fixed_number_of_locks, 1024}}]),
<a name="5300"/> 5300:             {debug_hash_fixed_number_of_locks, 1024} = ets:info(T1, write_concurrency),
<a name="5301"/> 5301:             T2 = ets:new(t2, [public, {write_concurrency, {debug_hash_fixed_number_of_locks, 2048}}]),
<a name="5302"/> 5302:             {debug_hash_fixed_number_of_locks, 2048} = ets:info(T2, write_concurrency),
<a name="5303"/> 5303:             T3 = ets:new(t3, [public, {write_concurrency, {debug_hash_fixed_number_of_locks, 1024}}, {write_concurrency, true}]),
<a name="5304"/> 5304:             true = ets:info(T3, write_concurrency),
<a name="5305"/> 5305:             T4 = ets:new(t4, [private, {write_concurrency, {debug_hash_fixed_number_of_locks, 1024}}]),
<a name="5306"/> 5306:             false = ets:info(T4, write_concurrency),
<a name="5307"/> 5307:             %% Test the auto option
<a name="5308"/> 5308:             lists:foreach(
<a name="5309"/> 5309:               fun(Type) -&gt;
<a name="5310"/> 5310:                       T5 = ets:new(t5, [public, Type, {write_concurrency, auto}]),
<a name="5311"/> 5311:                       auto = ets:info(T5, write_concurrency)
<a name="5312"/> 5312:               end,
<a name="5313"/> 5313:               [set, bag, duplicate_bag, ordered_set]),
<a name="5314"/> 5314:             T6 = ets:new(t6, [private, {write_concurrency, true}]),
<a name="5315"/> 5315:             false = ets:info(T6, write_concurrency),
<a name="5316"/> 5316:             T7 = ets:new(t7, [private, {write_concurrency, auto}]),
<a name="5317"/> 5317:             false = ets:info(T7, write_concurrency),
<a name="5318"/> 5318:             %% Test that the number of locks is rounded down to the nearest power of two
<a name="5319"/> 5319:             T8 = ets:new(t8, [public, {write_concurrency, {debug_hash_fixed_number_of_locks, 2049}}]),
<a name="5320"/> 5320:             {debug_hash_fixed_number_of_locks, 2048} = ets:info(T8, write_concurrency)
<a name="5321"/> 5321:     end,
<a name="info-last_expr"/><a name="5322"/> 5322:     ok.
<a name="5323"/> 5323: 
<a name="info_do-1"/><a name="5324"/> 5324: <b>info_do</b>(Opts) -&gt;
<a name="5325"/> 5325:     EtsMem = etsmem(),
<a name="5326"/> 5326:     TableType = lists:foldl(
<a name="5327"/> 5327:                   fun(Item, Curr) -&gt; 
<a name="5328"/> 5328:                           case Item of
<a name="5329"/> 5329:                               set -&gt; set;
<a name="5330"/> 5330:                               ordered_set -&gt; ordered_set;
<a name="5331"/> 5331:                               cat_ord_set -&gt; ordered_set;
<a name="5332"/> 5332:                               stim_cat_ord_set -&gt; ordered_set;
<a name="5333"/> 5333:                               bag -&gt; bag;
<a name="5334"/> 5334:                               duplicate_bag -&gt; duplicate_bag; 
<a name="5335"/> 5335:                               _ -&gt; Curr
<a name="5336"/> 5336:                           end
<a name="5337"/> 5337:                   end, set, Opts),
<a name="5338"/> 5338:     PublicOrCurr =
<a name="5339"/> 5339:         fun(Curr) -&gt;
<a name="5340"/> 5340:                 case lists:member({write_concurrency, false}, Opts) or
<a name="5341"/> 5341:                     lists:member(private, Opts) or
<a name="5342"/> 5342:                     lists:member(protected, Opts) of
<a name="5343"/> 5343:                     true -&gt; Curr;
<a name="5344"/> 5344:                     false -&gt; public
<a name="5345"/> 5345:                 end
<a name="5346"/> 5346:         end,
<a name="5347"/> 5347:     Protection = lists:foldl(
<a name="5348"/> 5348:                    fun(Item, Curr) -&gt;
<a name="5349"/> 5349:                            case Item of
<a name="5350"/> 5350:                                public -&gt; public;
<a name="5351"/> 5351:                                protected -&gt; protected;
<a name="5352"/> 5352:                                private -&gt; private;
<a name="5353"/> 5353:                                cat_ord_set -&gt; PublicOrCurr(Curr); %% Special items
<a name="5354"/> 5354:                                stim_cat_ord_set -&gt; PublicOrCurr(Curr);
<a name="5355"/> 5355:                                _ -&gt; Curr
<a name="5356"/> 5356:                            end
<a name="5357"/> 5357:                    end, protected, Opts),
<a name="5358"/> 5358:     MeMyselfI=self(),
<a name="5359"/> 5359:     ThisNode=node(),
<a name="5360"/> 5360:     Tab = ets_new(foobar, [{keypos, 2} | Opts]),
<a name="5361"/> 5361: 
<a name="5362"/> 5362:     %% Start slave to also do ets:info from a process not owning the table.
<a name="5363"/> 5363:     SlavePid = spawn_link(fun Slave() -&gt;
<a name="5364"/> 5364:                                   receive
<a name="5365"/> 5365:                                       {Master, Item} -&gt;
<a name="5366"/> 5366:                                           Master ! {self(), Item, ets:info(Tab, Item)}
<a name="5367"/> 5367:                                   end,
<a name="5368"/> 5368:                                   Slave()
<a name="5369"/> 5369:                           end),
<a name="5370"/> 5370: 
<a name="5371"/> 5371:     %% Note: ets:info/1 used to return a tuple, but from R11B onwards it
<a name="5372"/> 5372:     %% returns a list.
<a name="5373"/> 5373:     Res = ets:info(Tab),
<a name="5374"/> 5374:     {value, {memory, _Mem}} = lists:keysearch(memory, 1, Res),
<a name="5375"/> 5375:     {value, {owner, MeMyselfI}} = lists:keysearch(owner, 1, Res),
<a name="5376"/> 5376:     {value, {name, foobar}} = lists:keysearch(name, 1, Res),
<a name="5377"/> 5377:     {value, {size, 0}} = lists:keysearch(size, 1, Res),
<a name="5378"/> 5378:     {value, {node, ThisNode}} = lists:keysearch(node, 1, Res),
<a name="5379"/> 5379:     {value, {named_table, false}} = lists:keysearch(named_table, 1, Res),
<a name="5380"/> 5380:     {value, {type, TableType}} = lists:keysearch(type, 1, Res),
<a name="5381"/> 5381:     {value, {keypos, 2}} = lists:keysearch(keypos, 1, Res),
<a name="5382"/> 5382:     {value, {protection, Protection}} =
<a name="5383"/> 5383: 	lists:keysearch(protection, 1, Res),
<a name="5384"/> 5384:     {value, {id, Tab}} = lists:keysearch(id, 1, Res),
<a name="5385"/> 5385:     {value, {decentralized_counters, _DecentralizedCtrs}} =
<a name="5386"/> 5386:         lists:keysearch(decentralized_counters, 1, Res),
<a name="5387"/> 5387:     %% Test 'binary'
<a name="5388"/> 5388:     [] = ?ets_info(Tab, binary, SlavePid),
<a name="5389"/> 5389:     BinSz = 100,
<a name="5390"/> 5390:     RefcBin = list_to_binary(lists:seq(1,BinSz)),
<a name="5391"/> 5391:     ets:insert(Tab, {RefcBin,key}),
<a name="5392"/> 5392:     [{BinPtr,BinSz,2}] = ?ets_info(Tab,binary, SlavePid),
<a name="5393"/> 5393:     ets:insert(Tab, {RefcBin,key2}),
<a name="5394"/> 5394:     [{BinPtr,BinSz,3}, {BinPtr,BinSz,3}] = ?ets_info(Tab,binary,SlavePid),
<a name="5395"/> 5395:     ets:delete(Tab, key),
<a name="5396"/> 5396:     [{BinPtr,BinSz,2}] = ?ets_info(Tab,binary, SlavePid),
<a name="5397"/> 5397:     case TableType of
<a name="5398"/> 5398:         ordered_set -&gt;
<a name="5399"/> 5399:             ets:delete(Tab, key2);
<a name="5400"/> 5400:         _ -&gt;
<a name="5401"/> 5401:             ets:safe_fixtable(Tab, true),
<a name="5402"/> 5402:             ets:delete(Tab, key2),
<a name="5403"/> 5403:             [{BinPtr,BinSz,2}] = ?ets_info(Tab,binary, SlavePid),
<a name="5404"/> 5404:             ets:safe_fixtable(Tab, false)
<a name="5405"/> 5405:     end,
<a name="5406"/> 5406:     [] = ?ets_info(Tab,binary, SlavePid),
<a name="5407"/> 5407:     RefcBin = id(RefcBin), % keep alive
<a name="5408"/> 5408: 
<a name="5409"/> 5409:     unlink(SlavePid),
<a name="5410"/> 5410:     exit(SlavePid,kill),
<a name="5411"/> 5411:     true = ets:delete(Tab),
<a name="info_do-last_expr"/><a name="5412"/> 5412: <b>    verify_etsmem</b>(EtsMem).
<a name="5413"/> 5413: 
<a name="ets_info-4"/><a name="5414"/> 5414: <b>ets_info</b>(Tab, Item, SlavePid, _Line) -&gt;
<a name="5415"/> 5415:     R = ets:info(Tab, Item),
<a name="5416"/> 5416:     %%io:format(&quot;~p: ets:info(~p) -&gt; ~p\n&quot;, [_Line, Item, R]),
<a name="5417"/> 5417:     SlavePid ! {self(), Item},
<a name="5418"/> 5418:     {SlavePid, Item, R} = receive M -&gt; M end,
<a name="ets_info-last_expr"/><a name="5419"/> 5419:     R.
<a name="5420"/> 5420: 
<a name="5421"/> 5421: 
<a name="5422"/> 5422: 
<a name="info_binary_stress-1"/><a name="5423"/> 5423: <b>info_binary_stress</b>(_Config) -&gt;
<a name="info_binary_stress-last_expr"/><a name="5424"/> 5424: <b>    repeat_for_opts</b>(fun info_binary_stress_do/1,
<a name="5425"/> 5425:                     [[set,bag,duplicate_bag,ordered_set],
<a name="5426"/> 5426:                      compressed]).
<a name="5427"/> 5427: 
<a name="info_binary_stress_do-1"/><a name="5428"/> 5428: <b>info_binary_stress_do</b>(Opts) -&gt;
<a name="5429"/> 5429:     Tab = ets_new(info_binary_stress, [public, {write_concurrency,true} | Opts]),
<a name="5430"/> 5430: 
<a name="5431"/> 5431:     KeyRange = 1000,
<a name="5432"/> 5432:     ValueRange = 3,
<a name="5433"/> 5433:     RefcBin = list_to_binary(lists:seq(1,100)),
<a name="5434"/> 5434:     InitF = fun (_) -&gt; #{insert =&gt; 0, delete =&gt; 0, delete_object =&gt; 0}
<a name="5435"/> 5435:             end,
<a name="5436"/> 5436:     ExecF = fun (Counters) -&gt;
<a name="5437"/> 5437:                     Key = rand:uniform(KeyRange),
<a name="5438"/> 5438:                     Value = rand:uniform(ValueRange),
<a name="5439"/> 5439:                     Op = element(rand:uniform(4),{insert,insert,delete,delete_object}),
<a name="5440"/> 5440:                     case Op of
<a name="5441"/> 5441:                         insert -&gt;
<a name="5442"/> 5442:                             ets:insert(Tab, {Key,Value,RefcBin});
<a name="5443"/> 5443:                         delete -&gt;
<a name="5444"/> 5444:                             ets:delete(Tab, Key);
<a name="5445"/> 5445:                         delete_object -&gt;
<a name="5446"/> 5446:                             ets:delete_object(Tab, {Key,Value,RefcBin})
<a name="5447"/> 5447:                     end,
<a name="5448"/> 5448:                     Acc = incr_counter(Op, Counters),
<a name="5449"/> 5449: 
<a name="5450"/> 5450:                     receive stop -&gt;
<a name="5451"/> 5451:                                 [end_of_work | Acc]
<a name="5452"/> 5452:                     after 0 -&gt;
<a name="5453"/> 5453:                             Acc
<a name="5454"/> 5454:                     end
<a name="5455"/> 5455:             end,
<a name="5456"/> 5456:     FiniF = fun (Acc) -&gt; Acc end,
<a name="5457"/> 5457:     Pids = run_sched_workers(InitF, ExecF, FiniF, infinite),
<a name="5458"/> 5458:     timer:send_after(500, stop),
<a name="5459"/> 5459: 
<a name="5460"/> 5460:     Rounds = fun Loop(N, Fix) -&gt;
<a name="5461"/> 5461:                      ets:info(Tab, binary),
<a name="5462"/> 5462:                      ets:safe_fixtable(Tab, Fix),
<a name="5463"/> 5463:                      receive
<a name="5464"/> 5464:                          stop -&gt;
<a name="5465"/> 5465:                              ets:safe_fixtable(Tab, false),
<a name="5466"/> 5466:                              false = ets:info(Tab, fixed),
<a name="5467"/> 5467:                              N
<a name="5468"/> 5468:                      after 0 -&gt;
<a name="5469"/> 5469:                              Loop(N+1, not Fix)
<a name="5470"/> 5470:                      end
<a name="5471"/> 5471:              end (1, true),
<a name="5472"/> 5472:     [P ! stop || P &lt;- Pids],
<a name="5473"/> 5473:     Results = wait_pids(Pids),
<a name="5474"/> 5474:     Size = ets:info(Tab,size),
<a name="5475"/> 5475:     io:format(&quot;Ops = ~p\n&quot;, [maps_sum(Results)]),
<a name="5476"/> 5476:     io:format(&quot;Size = ~p\n&quot;, [Size]),
<a name="5477"/> 5477:     io:format(&quot;Stats = ~p\n&quot;, [ets:info(Tab,stats)]),
<a name="5478"/> 5478:     io:format(&quot;Rounds = ~p\n&quot;, [Rounds]),
<a name="5479"/> 5479:     Size = length(ets:info(Tab, binary)),
<a name="5480"/> 5480: 
<a name="5481"/> 5481:     ets:delete_all_objects(Tab),
<a name="5482"/> 5482:     [] = ets:info(Tab, binary),
<a name="5483"/> 5483:     true = ets:delete(Tab),
<a name="info_binary_stress_do-last_expr"/><a name="5484"/> 5484:     ok.
<a name="5485"/> 5485: 
<a name="5486"/> 5486: 
<a name="size_loop-4"/><a name="5487"/> 5487: <b>size_loop</b>(_T, 0, _, _) -&gt;
<a name="5488"/> 5488:     ok;
<a name="5489"/> 5489: <b>size_loop</b>(T, I, PrevSize, WhatToTest) -&gt;
<a name="5490"/> 5490:     Size = ets:info(T, WhatToTest),
<a name="5491"/> 5491:     case Size &lt; PrevSize of
<a name="5492"/> 5492:         true -&gt;
<a name="5493"/> 5493:             io:format(&quot;Bad ets:info/2 (got ~p expected &gt;=~p)&quot;,
<a name="5494"/> 5494:                       [Size, PrevSize]),
<a name="5495"/> 5495:             ct:fail(&quot;Bad ets:info/2)&quot;);
<a name="5496"/> 5496:         _ -&gt; ok
<a name="5497"/> 5497:     end,
<a name="size_loop-last_expr"/><a name="5498"/> 5498: <b>    size_loop</b>(T, I -1, Size, WhatToTest).
<a name="5499"/> 5499: 
<a name="add_loop-2"/><a name="5500"/> 5500: <b>add_loop</b>(_T, 0) -&gt;
<a name="5501"/> 5501:     ok;
<a name="5502"/> 5502: <b>add_loop</b>(T, I) -&gt;
<a name="5503"/> 5503:     ets:insert(T, {I}),
<a name="add_loop-last_expr"/><a name="5504"/> 5504: <b>    add_loop</b>(T, I -1).
<a name="5505"/> 5505: 
<a name="5506"/> 5506: 
<a name="test_table_counter_concurrency-2"/><a name="5507"/> 5507: <b>test_table_counter_concurrency</b>(WhatToTest, TableOptions) -&gt;
<a name="5508"/> 5508:     IntStatePrevOn =
<a name="5509"/> 5509:         erts_debug:set_internal_state(available_internal_state, true),
<a name="5510"/> 5510:     ItemsToAdd = 1000000,
<a name="5511"/> 5511:     SizeLoopSize = 1000,
<a name="5512"/> 5512:     T = ets:new(k, TableOptions),
<a name="5513"/> 5513:     case lists:member(ordered_set, TableOptions) of
<a name="5514"/> 5514:         true -&gt;
<a name="5515"/> 5515:             erts_debug:set_internal_state(ets_debug_random_split_join, {T, false});
<a name="5516"/> 5516:         false -&gt; ok
<a name="5517"/> 5517:     end,
<a name="5518"/> 5518:     0 = ets:info(T, size),
<a name="5519"/> 5519:     P = self(),
<a name="5520"/> 5520:     SpawnedSizeProcs =
<a name="5521"/> 5521:         [spawn_link(fun() -&gt;
<a name="5522"/> 5522:                             size_loop(T, SizeLoopSize, 0, WhatToTest),
<a name="5523"/> 5523:                             P ! done
<a name="5524"/> 5524:                     end)
<a name="5525"/> 5525:          || _ &lt;- lists:seq(1, 6)],
<a name="5526"/> 5526:     spawn_link(fun() -&gt;
<a name="5527"/> 5527:                        add_loop(T, ItemsToAdd),
<a name="5528"/> 5528:                        P ! done_add
<a name="5529"/> 5529:                end),
<a name="5530"/> 5530:     [receive
<a name="5531"/> 5531:          done -&gt; ok;
<a name="5532"/> 5532:          done_add -&gt; ok
<a name="5533"/> 5533:      end
<a name="5534"/> 5534:      || _ &lt;- [ok|SpawnedSizeProcs]],
<a name="5535"/> 5535:     case WhatToTest =:= size of
<a name="5536"/> 5536:         true -&gt;
<a name="5537"/> 5537:             ItemsToAdd = ets:info(T, size);
<a name="5538"/> 5538:         _ -&gt;
<a name="5539"/> 5539:             ok
<a name="5540"/> 5540:     end,
<a name="5541"/> 5541:     erts_debug:set_internal_state(available_internal_state, IntStatePrevOn),
<a name="test_table_counter_concurrency-last_expr"/><a name="5542"/> 5542:     ok.
<a name="5543"/> 5543: 
<a name="5544"/> 5544: <i>%% ERIERL-855: Calling info or whereis on a table being busy trapping (insert)</i>
<a name="5545"/> 5545: <i>%% could return 'undefined'.</i>
<a name="info_whereis_busy-1"/><a name="5546"/> 5546: <b>info_whereis_busy</b>(Config) when is_list(Config) -&gt;
<a name="5547"/> 5547:     TName = info_whereis_busy,
<a name="5548"/> 5548:     TName = ets:new(TName, [named_table, public]),
<a name="5549"/> 5549:     T = ets:whereis(TName),
<a name="5550"/> 5550:     NKeys = 100_000,
<a name="5551"/> 5551:     Tuples = [{K} || K &lt;- lists:seq(1,NKeys)],
<a name="5552"/> 5552:     _Inserter = spawn_link(fun() -&gt;
<a name="5553"/> 5553:                                    ets:insert(TName, Tuples)
<a name="5554"/> 5554:                            end),
<a name="5555"/> 5555:     repeat_while(fun() -&gt;
<a name="5556"/> 5556:                          Info = ets:info(TName),
<a name="5557"/> 5557:                          false = (Info =:= undefined),
<a name="5558"/> 5558:                          T = ets:whereis(TName),
<a name="5559"/> 5559:                          case lists:keyfind(size, 1, Info) of
<a name="5560"/> 5560:                              {size, NKeys} -&gt;
<a name="5561"/> 5561:                                  false;
<a name="5562"/> 5562:                              {size, _} -&gt;
<a name="5563"/> 5563:                                  true
<a name="5564"/> 5564:                          end
<a name="5565"/> 5565:                  end),
<a name="5566"/> 5566:     ets:delete(T),
<a name="info_whereis_busy-last_expr"/><a name="5567"/> 5567:     ok.
<a name="5568"/> 5568: 
<a name="5569"/> 5569: <i>%% Delete table during trapping ets:insert</i>
<a name="insert_trap_delete-1"/><a name="5570"/> 5570: <b>insert_trap_delete</b>(Config) when is_list(Config) -&gt;
<a name="5571"/> 5571:     repeat_for_opts(fun(Opts) -&gt;
<a name="5572"/> 5572:                             [insert_trap_delete_run1({Opts,InsertFunc,Mode})
<a name="5573"/> 5573:                              || InsertFunc &lt;- [insert,insert_new],
<a name="5574"/> 5574:                                 Mode &lt;- [exit, delete]]
<a name="5575"/> 5575:                     end,
<a name="5576"/> 5576:                     [all_non_stim_types, write_concurrency, compressed]),
<a name="insert_trap_delete-last_expr"/><a name="5577"/> 5577:     ok.
<a name="5578"/> 5578: 
<a name="insert_trap_delete_run1-1"/><a name="5579"/> 5579: <b>insert_trap_delete_run1</b>(Params) -&gt;
<a name="5580"/> 5580:     NKeys = 50_000 + rand:uniform(50_000),
<a name="5581"/> 5581:     %% First measure how many traps the insert op will do
<a name="5582"/> 5582:     Traps0 = insert_trap_delete_run3(unlimited, Params, NKeys),
<a name="5583"/> 5583:     %% Then do again and delete table at different moments
<a name="5584"/> 5584:     Decr = (Traps0 div 5) + 1,
<a name="insert_trap_delete_run1-last_expr"/><a name="5585"/> 5585: <b>    insert_trap_delete_run2</b>(Traps0-1, Decr, Params, NKeys).
<a name="5586"/> 5586: 
<a name="insert_trap_delete_run2-4"/><a name="5587"/> 5587: <b>insert_trap_delete_run2</b>(Traps, _Decr, Params, NKeys) when Traps =&lt; 1 -&gt;
<a name="5588"/> 5588:     insert_trap_delete_run3(1, Params, NKeys),
<a name="5589"/> 5589:     ok;
<a name="5590"/> 5590: <b>insert_trap_delete_run2</b>(Traps, Decr, Params, NKeys) -&gt;
<a name="5591"/> 5591:     insert_trap_delete_run3(Traps, Params, NKeys),
<a name="insert_trap_delete_run2-last_expr"/><a name="5592"/> 5592: <b>    insert_trap_delete_run2</b>(Traps - Decr, Decr, Params, NKeys).
<a name="5593"/> 5593: 
<a name="insert_trap_delete_run3-3"/><a name="5594"/> 5594: <b>insert_trap_delete_run3</b>(Traps, {Opts, InsertFunc, Mode}, NKeys) -&gt;
<a name="5595"/> 5595:     io:format(&quot;insert_trap_delete_run(~p, ~p, ~p) NKeys=~p\n&quot;,
<a name="5596"/> 5596:               [Traps, InsertFunc, Mode, NKeys]),
<a name="5597"/> 5597:     TabName = insert_trap_delete,
<a name="5598"/> 5598:     Tester = self(),
<a name="5599"/> 5599:     Tuples = [{K} || K &lt;- lists:seq(1,NKeys)],
<a name="5600"/> 5600: 
<a name="5601"/> 5601:     OwnerFun =
<a name="5602"/> 5602:         fun() -&gt;
<a name="5603"/> 5603:                 erlang:trace(Tester, true, [running]),
<a name="5604"/> 5604:                 ets_new(TabName, [named_table, public | Opts]),
<a name="5605"/> 5605:                 Tester ! {ets_new, ets:whereis(TabName)},
<a name="5606"/> 5606:                 io:format(&quot;Wait for ets:~p/2 to yield...\n&quot;, [InsertFunc]),
<a name="5607"/> 5607:                 GotTraps = repeat_while(
<a name="5608"/> 5608:                   fun(N) -&gt;
<a name="5609"/> 5609:                           case receive_any() of
<a name="5610"/> 5610:                               {trace, Tester, out, {ets,InsertFunc,2}} -&gt;
<a name="5611"/> 5611:                                   case N of
<a name="5612"/> 5612:                                       Traps -&gt; {false, Traps};
<a name="5613"/> 5613:                                       _ -&gt; {true, N+1}
<a name="5614"/> 5614:                                   end;
<a name="5615"/> 5615:                               &quot;Insert done&quot; -&gt;
<a name="5616"/> 5616:                                   io:format(&quot;Too late! Got ~p traps\n&quot;, [N]),
<a name="5617"/> 5617:                                   {false, N};
<a name="5618"/> 5618:                               _M -&gt;
<a name="5619"/> 5619:                                   %%io:format(&quot;[~p] Ignored msg: ~p\n&quot;, [N,_M]),
<a name="5620"/> 5620:                                   {true, N}
<a name="5621"/> 5621:                           end
<a name="5622"/> 5622:                   end,
<a name="5623"/> 5623:                   0),
<a name="5624"/> 5624:                 case Mode of
<a name="5625"/> 5625:                     delete -&gt;
<a name="5626"/> 5626:                         io:format(&quot;Delete table and then exit...\n&quot;,[]),
<a name="5627"/> 5627:                         ets:delete(TabName);
<a name="5628"/> 5628:                     exit -&gt;
<a name="5629"/> 5629:                         io:format(&quot;Exit and let table die...\n&quot;,[])
<a name="5630"/> 5630:                 end,
<a name="5631"/> 5631:                 Tester ! {traps, GotTraps}
<a name="5632"/> 5632:         end,
<a name="5633"/> 5633:     {Owner, Mon} = spawn_opt(OwnerFun, [link, monitor]),
<a name="5634"/> 5634: 
<a name="5635"/> 5635:     {ets_new, Tid} = receive_any(),
<a name="5636"/> 5636:     try ets:InsertFunc(TabName, Tuples) of
<a name="5637"/> 5637:         true -&gt;
<a name="5638"/> 5638:             try ets:lookup(Tid, NKeys) of
<a name="5639"/> 5639:                 [{NKeys}] -&gt; ok
<a name="5640"/> 5640:             catch
<a name="5641"/> 5641:                 error:badarg -&gt;
<a name="5642"/> 5642:                     %% Table must been deleted just after insert finished
<a name="5643"/> 5643:                     undefined = ets:info(Tid, id),
<a name="5644"/> 5644:                     undefined = ets:whereis(TabName)
<a name="5645"/> 5645:             end,
<a name="5646"/> 5646:             Owner ! &quot;Insert done&quot;
<a name="5647"/> 5647:     catch
<a name="5648"/> 5648:         error:badarg -&gt;
<a name="5649"/> 5649:             %% Insert failed, table must have been deleted
<a name="5650"/> 5650:             undefined = ets:info(Tid, id),
<a name="5651"/> 5651:             undefined = ets:whereis(TabName)
<a name="5652"/> 5652:     end,
<a name="5653"/> 5653:     {traps, GotTraps} = receive_any(),
<a name="5654"/> 5654:     {'DOWN', Mon, process, Owner, _} = receive_any(),
<a name="5655"/> 5655:     undefined = ets:whereis(TabName),
<a name="5656"/> 5656:     undefined = ets:info(Tid, id),
<a name="insert_trap_delete_run3-last_expr"/><a name="5657"/> 5657:     GotTraps.
<a name="5658"/> 5658: 
<a name="5659"/> 5659: <i>%% Rename table during trapping ets:insert</i>
<a name="insert_trap_rename-1"/><a name="5660"/> 5660: <b>insert_trap_rename</b>(Config) when is_list(Config) -&gt;
<a name="5661"/> 5661:     repeat_for_opts(fun(Opts) -&gt;
<a name="5662"/> 5662:                             [insert_trap_rename_run1(Opts, InsertFunc)
<a name="5663"/> 5663:                              || InsertFunc &lt;- [insert, insert_new]]
<a name="5664"/> 5664:                     end,
<a name="5665"/> 5665:                     [all_non_stim_types, write_concurrency, compressed]),
<a name="insert_trap_rename-last_expr"/><a name="5666"/> 5666:     ok.
<a name="5667"/> 5667: 
<a name="insert_trap_rename_run1-2"/><a name="5668"/> 5668: <b>insert_trap_rename_run1</b>(Opts, InsertFunc) -&gt;
<a name="5669"/> 5669:     NKeys = 50_000 + rand:uniform(50_000),
<a name="5670"/> 5670:     %% First measure how many traps the insert op will do
<a name="5671"/> 5671:     Traps0 = insert_trap_rename_run3(Opts, unlimited, InsertFunc, NKeys),
<a name="5672"/> 5672:     %% Then do again and rename table at different moments
<a name="5673"/> 5673:     Decr = (Traps0 div 5) + 1,
<a name="5674"/> 5674:     insert_trap_rename_run2(Opts, Traps0-1, Decr, InsertFunc, NKeys),
<a name="insert_trap_rename_run1-last_expr"/><a name="5675"/> 5675:     ok.
<a name="5676"/> 5676: 
<a name="insert_trap_rename_run2-5"/><a name="5677"/> 5677: <b>insert_trap_rename_run2</b>(Opts, Traps, _Decr, InsertFunc, NKeys) when Traps =&lt; 1 -&gt;
<a name="5678"/> 5678:     insert_trap_rename_run3(Opts, 1, InsertFunc, NKeys),
<a name="5679"/> 5679:     ok;
<a name="5680"/> 5680: <b>insert_trap_rename_run2</b>(Opts, Traps, Decr, InsertFunc, NKeys) -&gt;
<a name="5681"/> 5681:     insert_trap_rename_run3(Opts, Traps, InsertFunc, NKeys),
<a name="insert_trap_rename_run2-last_expr"/><a name="5682"/> 5682: <b>    insert_trap_rename_run2</b>(Opts, Traps - Decr, Decr, InsertFunc, NKeys).
<a name="5683"/> 5683: 
<a name="5684"/> 5684: 
<a name="insert_trap_rename_run3-4"/><a name="5685"/> 5685: <b>insert_trap_rename_run3</b>(Opts, Traps, InsertFunc, NKeys) -&gt;
<a name="5686"/> 5686:     io:format(&quot;insert_trap_rename_run(~p, ~p)\n&quot;, [Traps, InsertFunc]),
<a name="5687"/> 5687:     TabName = insert_trap_rename,
<a name="5688"/> 5688:     TabRenamed = insert_trap_rename_X,
<a name="5689"/> 5689:     Tester = self(),
<a name="5690"/> 5690:     Tuples = [{K} || K &lt;- lists:seq(1,NKeys)],
<a name="5691"/> 5691: 
<a name="5692"/> 5692:     OwnerFun =
<a name="5693"/> 5693:         fun() -&gt;
<a name="5694"/> 5694:                 erlang:trace(Tester, true, [running]),
<a name="5695"/> 5695:                 ets_new(TabName, [named_table, public | Opts]),
<a name="5696"/> 5696:                 Tester ! {ets_new, ets:whereis(TabName)},
<a name="5697"/> 5697:                 io:format(&quot;Wait for ets:~p/2 to yield...\n&quot;, [InsertFunc]),
<a name="5698"/> 5698:                 GotTraps = repeat_while(
<a name="5699"/> 5699:                   fun(N) -&gt;
<a name="5700"/> 5700:                           case receive_any() of
<a name="5701"/> 5701:                               {trace, Tester, out, {ets,InsertFunc,2}} -&gt;
<a name="5702"/> 5702:                                   case N of
<a name="5703"/> 5703:                                       Traps -&gt; {false, ok};
<a name="5704"/> 5704:                                       _ -&gt; {true, N+1}
<a name="5705"/> 5705:                                   end;
<a name="5706"/> 5706:                               &quot;Insert done&quot; -&gt;
<a name="5707"/> 5707:                                   io:format(&quot;Too late! Got ~p traps\n&quot;, [N]),
<a name="5708"/> 5708:                                   {false, N};
<a name="5709"/> 5709:                               _M -&gt;
<a name="5710"/> 5710:                                   %%io:format(&quot;[~p] Ignored msg: ~p\n&quot;, [N,_M]),
<a name="5711"/> 5711:                                   {true, N}
<a name="5712"/> 5712:                           end
<a name="5713"/> 5713:                   end,
<a name="5714"/> 5714:                   0),
<a name="5715"/> 5715:                 io:format(&quot;Rename table and wait...\n&quot;,[]),
<a name="5716"/> 5716:                 ets:rename(TabName, TabRenamed),
<a name="5717"/> 5717:                 ets:delete(TabRenamed, 42),
<a name="5718"/> 5718:                 Tester ! {renamed, GotTraps},
<a name="5719"/> 5719:                 receive die -&gt; ok end
<a name="5720"/> 5720:         end,
<a name="5721"/> 5721:     {Owner, Mon} = spawn_opt(OwnerFun, [link,monitor]),
<a name="5722"/> 5722: 
<a name="5723"/> 5723:     {ets_new, Tid} = receive_any(),
<a name="5724"/> 5724:     try ets:InsertFunc(TabName, Tuples) of
<a name="5725"/> 5725:         true -&gt;
<a name="5726"/> 5726:             io:format(&quot;ets:~p succeeded\n&quot;, [InsertFunc]),
<a name="5727"/> 5727:             true = ets:member(Tid, 1),
<a name="5728"/> 5728:             true = ets:member(Tid, NKeys)
<a name="5729"/> 5729:     catch
<a name="5730"/> 5730:         error:badarg -&gt;
<a name="5731"/> 5731:             io:format(&quot;ets:~p failed\n&quot;, [InsertFunc]),
<a name="5732"/> 5732:             false = ets:member(Tid, 1),
<a name="5733"/> 5733:             false = ets:member(Tid, NKeys)
<a name="5734"/> 5734:     end,
<a name="5735"/> 5735:     Owner ! &quot;Insert done&quot;,
<a name="5736"/> 5736:     {renamed, GotTraps} = receive_any(),
<a name="5737"/> 5737:     [] = ets:lookup(Tid, 42),
<a name="5738"/> 5738:     undefined = ets:whereis(TabName),
<a name="5739"/> 5739:     Tid = ets:whereis(TabRenamed),
<a name="5740"/> 5740:     Owner ! die,
<a name="5741"/> 5741:     {'DOWN', Mon, process, Owner, _} = receive_any(),
<a name="5742"/> 5742:     undefined = ets:whereis(TabName),
<a name="5743"/> 5743:     undefined = ets:whereis(TabRenamed),
<a name="insert_trap_rename_run3-last_expr"/><a name="5744"/> 5744:     GotTraps.
<a name="5745"/> 5745: 
<a name="5746"/> 5746: 
<a name="test_table_size_concurrency-1"/><a name="5747"/> 5747: <b>test_table_size_concurrency</b>(Config) when is_list(Config) -&gt;
<a name="test_table_size_concurrency-last_expr"/><a name="5748"/> 5748: <b>    case erlang:system_info</b>(schedulers) of
<a name="5749"/> 5749:         1 -&gt; {skip,&quot;Only valid on smp &gt; 1 systems&quot;};
<a name="5750"/> 5750:         _ -&gt;
<a name="5751"/> 5751:             lists:foreach(
<a name="5752"/> 5752:               fun(WriteConcurrencyOpt) -&gt;
<a name="5753"/> 5753:                       BaseOptions = [public, {write_concurrency, WriteConcurrencyOpt}],
<a name="5754"/> 5754:                       test_table_counter_concurrency(size, [set | BaseOptions]),
<a name="5755"/> 5755:                       test_table_counter_concurrency(size, [ordered_set | BaseOptions])
<a name="5756"/> 5756:               end,
<a name="5757"/> 5757:               [true, auto])
<a name="5758"/> 5758:     end.
<a name="5759"/> 5759: 
<a name="test_table_memory_concurrency-1"/><a name="5760"/> 5760: <b>test_table_memory_concurrency</b>(Config) when is_list(Config) -&gt;
<a name="test_table_memory_concurrency-last_expr"/><a name="5761"/> 5761: <b>    case erlang:system_info</b>(schedulers) of
<a name="5762"/> 5762:         1 -&gt; {skip,&quot;Only valid on smp &gt; 1 systems&quot;};
<a name="5763"/> 5763:         _ -&gt;
<a name="5764"/> 5764:             lists:foreach(
<a name="5765"/> 5765:               fun(WriteConcurrencyOpt) -&gt;
<a name="5766"/> 5766:                       BaseOptions = [public, {write_concurrency, WriteConcurrencyOpt}],
<a name="5767"/> 5767:                       test_table_counter_concurrency(memory, [set | BaseOptions]),
<a name="5768"/> 5768:                       test_table_counter_concurrency(memory, [ordered_set | BaseOptions])
<a name="5769"/> 5769:               end,
<a name="5770"/> 5770:               [true, auto])
<a name="5771"/> 5771:     end.
<a name="5772"/> 5772: 
<a name="5773"/> 5773: <i>%% Tests that calling the ets:delete operation on a table T with</i>
<a name="5774"/> 5774: <i>%% decentralized counters works while ets:info(T, size) operations are</i>
<a name="5775"/> 5775: <i>%% active</i>
<a name="test_delete_table_while_size_snapshot-1"/><a name="5776"/> 5776: <b>test_delete_table_while_size_snapshot</b>(Config) when is_list(Config) -&gt;
<a name="5777"/> 5777:     %% Run test case in a slave node as other test suites in stdlib
<a name="5778"/> 5778:     %% depend on that pids are ordered in creation order which is no
<a name="5779"/> 5779:     %% longer the case when many processes have been started before
<a name="5780"/> 5780:     {ok, Peer, Node} = ?CT_PEER(),
<a name="5781"/> 5781:     [ok = rpc:call(Node,
<a name="5782"/> 5782:                    ?MODULE,
<a name="5783"/> 5783:                    test_delete_table_while_size_snapshot_helper,
<a name="5784"/> 5784:                    [TableType])
<a name="5785"/> 5785:      || TableType &lt;- [set, ordered_set]],
<a name="5786"/> 5786:     peer:stop(Peer),
<a name="test_delete_table_while_size_snapshot-last_expr"/><a name="5787"/> 5787:     ok.
<a name="5788"/> 5788: 
<a name="test_delete_table_while_size_snapshot_helper-1"/><a name="5789"/> 5789: <b>test_delete_table_while_size_snapshot_helper</b>(TableType) -&gt;
<a name="5790"/> 5790:     TopParent = self(),
<a name="5791"/> 5791:     repeat_par(
<a name="5792"/> 5792:       fun() -&gt;
<a name="5793"/> 5793:               Table = ets:new(t, [public, TableType,
<a name="5794"/> 5794:                                   {decentralized_counters, true},
<a name="5795"/> 5795:                                   {write_concurrency, true}]),
<a name="5796"/> 5796:               Parent = self(),
<a name="5797"/> 5797:               NrOfSizeProcs = 100,
<a name="5798"/> 5798:               Pids = [ spawn(fun()-&gt; size_process(Table, Parent) end)
<a name="5799"/> 5799:                        || _ &lt;- lists:seq(1, NrOfSizeProcs)],
<a name="5800"/> 5800:               timer:sleep(1),
<a name="5801"/> 5801:               ets:delete(Table),
<a name="5802"/> 5802:               [receive
<a name="5803"/> 5803:                    table_gone -&gt;  ok;
<a name="5804"/> 5804:                    Problem -&gt; TopParent ! Problem
<a name="5805"/> 5805:                end || _ &lt;- Pids]
<a name="5806"/> 5806:       end,
<a name="5807"/> 5807:       100*erlang:system_info(schedulers_online)),
<a name="test_delete_table_while_size_snapshot_helper-last_expr"/><a name="5808"/> 5808:     receive
<a name="5809"/> 5809:         Problem -&gt; throw(Problem)
<a name="5810"/> 5810:     after 0 -&gt; ok
<a name="5811"/> 5811:     end.
<a name="5812"/> 5812: 
<a name="size_process-2"/><a name="5813"/> 5813: <b>size_process</b>(Table, Parent) -&gt;
<a name="size_process-last_expr"/><a name="5814"/> 5814: <b>    try ets:info</b>(Table, size) of
<a name="5815"/> 5815:         N when is_integer(N) -&gt;
<a name="5816"/> 5816:             size_process(Table, Parent);
<a name="5817"/> 5817:         undefined -&gt; Parent ! table_gone;
<a name="5818"/> 5818:         E -&gt; Parent ! {got_unexpected, E}
<a name="5819"/> 5819:     catch
<a name="5820"/> 5820:         E -&gt; Parent ! {got_unexpected_exception, E}
<a name="5821"/> 5821:     end.
<a name="5822"/> 5822: 
<a name="repeat_par-2"/><a name="5823"/> 5823: <b>repeat_par</b>(FunToRepeat, NrOfTimes) -&gt;
<a name="repeat_par-last_expr"/><a name="5824"/> 5824: <b>    repeat_par_help</b>(FunToRepeat, NrOfTimes, NrOfTimes).
<a name="5825"/> 5825: 
<a name="repeat_par_help-3"/><a name="5826"/> 5826: <b>repeat_par_help</b>(_FunToRepeat, 0, OrgNrOfTimes) -&gt;
<a name="5827"/> 5827:     repeat(fun()-&gt; receive done -&gt; ok end end, OrgNrOfTimes);
<a name="5828"/> 5828: <b>repeat_par_help</b>(FunToRepeat, NrOfTimes, OrgNrOfTimes) -&gt;
<a name="5829"/> 5829:     Parent = self(),
<a name="5830"/> 5830:     case NrOfTimes rem 5 of
<a name="5831"/> 5831:         0 -&gt; timer:sleep(1);
<a name="5832"/> 5832:         _ -&gt; ok
<a name="5833"/> 5833:     end,
<a name="5834"/> 5834:     spawn(fun()-&gt;
<a name="5835"/> 5835:                   FunToRepeat(),
<a name="5836"/> 5836:                   Parent ! done
<a name="5837"/> 5837:           end),
<a name="repeat_par_help-last_expr"/><a name="5838"/> 5838: <b>    repeat_par_help</b>(FunToRepeat, NrOfTimes-1, OrgNrOfTimes).
<a name="5839"/> 5839: 
<a name="test_decentralized_counters_setting-1"/><a name="5840"/> 5840: <b>test_decentralized_counters_setting</b>(Config) when is_list(Config) -&gt;
<a name="test_decentralized_counters_setting-last_expr"/><a name="5841"/> 5841: <b>    case erlang:system_info</b>(schedulers) of
<a name="5842"/> 5842:         1 -&gt; {skip,&quot;Only relevant when the number of shedulers &gt; 1&quot;};
<a name="5843"/> 5843:         _ -&gt; EtsMem = etsmem(),
<a name="5844"/> 5844:              do_test_decentralized_counters_setting(set),
<a name="5845"/> 5845:              do_test_decentralized_counters_setting(ordered_set),
<a name="5846"/> 5846:              do_test_decentralized_counters_default_setting(),
<a name="5847"/> 5847:              verify_etsmem(EtsMem)
<a name="5848"/> 5848:     end.
<a name="5849"/> 5849: 
<a name="do_test_decentralized_counters_setting-1"/><a name="5850"/> 5850: <b>do_test_decentralized_counters_setting</b>(TableType) -&gt;
<a name="5851"/> 5851:     wait_for_memory_deallocations(),
<a name="5852"/> 5852:     FlxCtrMemUsage = erts_debug:get_internal_state(flxctr_memory_usage),
<a name="5853"/> 5853:     FixOptsList =
<a name="5854"/> 5854:         fun(Opts) -&gt;
<a name="5855"/> 5855:                 case TableType of
<a name="5856"/> 5856:                     ordered_set -&gt;
<a name="5857"/> 5857:                         replace_dbg_hash_fixed_nr_of_locks(Opts);
<a name="5858"/> 5858:                     set -&gt;
<a name="5859"/> 5859:                         Opts
<a name="5860"/> 5860:                 end
<a name="5861"/> 5861:         end,
<a name="5862"/> 5862:     lists:foreach(
<a name="5863"/> 5863:       fun(OptList) -&gt;
<a name="5864"/> 5864:               T1 = ets:new(t1, FixOptsList([public, TableType] ++ OptList ++ [TableType])),
<a name="5865"/> 5865:               check_decentralized_counters(T1, false, FlxCtrMemUsage),
<a name="5866"/> 5866:               ets:delete(T1)
<a name="5867"/> 5867:       end,
<a name="5868"/> 5868:       [[{write_concurrency, false}]] ++
<a name="5869"/> 5869:           case TableType of
<a name="5870"/> 5870:               set -&gt;
<a name="5871"/> 5871:                   [[{write_concurrency, true}, {decentralized_counters, false}],
<a name="5872"/> 5872:                    [{write_concurrency, {debug_hash_fixed_number_of_locks, 1024}}, {write_concurrency, true}]];
<a name="5873"/> 5873:               ordered_set -&gt; []
<a name="5874"/> 5874:           end),
<a name="5875"/> 5875:     lists:foreach(
<a name="5876"/> 5876:       fun(OptList) -&gt;
<a name="5877"/> 5877:               T1 = ets:new(t1,
<a name="5878"/> 5878:                            FixOptsList([public,
<a name="5879"/> 5879:                                         TableType,
<a name="5880"/> 5880:                                         {write_concurrency, true}] ++ OptList ++ [TableType])),
<a name="5881"/> 5881:               check_decentralized_counters(T1, true, FlxCtrMemUsage),
<a name="5882"/> 5882:               ets:delete(T1),
<a name="5883"/> 5883:               wait_for_memory_deallocations(),
<a name="5884"/> 5884:               FlxCtrMemUsage = erts_debug:get_internal_state(flxctr_memory_usage)
<a name="5885"/> 5885:       end,
<a name="5886"/> 5886:       [[{decentralized_counters, true}],
<a name="5887"/> 5887:        [{write_concurrency, {debug_hash_fixed_number_of_locks, 1024}}],
<a name="5888"/> 5888:        [{write_concurrency, auto}]]),
<a name="do_test_decentralized_counters_setting-last_expr"/><a name="5889"/> 5889:     ok.
<a name="5890"/> 5890: 
<a name="do_test_decentralized_counters_default_setting-0"/><a name="5891"/> 5891: <b>do_test_decentralized_counters_default_setting</b>() -&gt;
<a name="5892"/> 5892:     wait_for_memory_deallocations(),
<a name="5893"/> 5893:     FlxCtrMemUsage = erts_debug:get_internal_state(flxctr_memory_usage),
<a name="5894"/> 5894:     Set = ets:new(t1, [public, {write_concurrency, true}]),
<a name="5895"/> 5895:     check_decentralized_counters(Set, false, FlxCtrMemUsage),
<a name="5896"/> 5896:     ets:delete(Set),
<a name="5897"/> 5897:     Set2 = ets:new(t1, [public, set, {write_concurrency, true}]),
<a name="5898"/> 5898:     check_decentralized_counters(Set2, false, FlxCtrMemUsage),
<a name="5899"/> 5899:     ets:delete(Set2),
<a name="5900"/> 5900:     OrdSet = ets:new(t1, [public, ordered_set, {write_concurrency, true}]),
<a name="5901"/> 5901:     check_decentralized_counters(OrdSet, true, FlxCtrMemUsage),
<a name="5902"/> 5902:     ets:delete(OrdSet),
<a name="do_test_decentralized_counters_default_setting-last_expr"/><a name="5903"/> 5903:     ok.
<a name="5904"/> 5904: 
<a name="check_decentralized_counters-3"/><a name="5905"/> 5905: <b>check_decentralized_counters</b>(T, ExpectedState, InitMemUsage) -&gt;
<a name="5906"/> 5906:     case {ExpectedState, erts_debug:get_internal_state(flxctr_memory_usage)} of
<a name="5907"/> 5907:         {false, notsup} -&gt; ok;
<a name="5908"/> 5908:         {false, X} -&gt; InitMemUsage = X;
<a name="5909"/> 5909:         {true, notsup} -&gt; ok;
<a name="5910"/> 5910:         {true, X} when X &gt; InitMemUsage -&gt; ok;
<a name="5911"/> 5911:         {true, _} -&gt; ct:fail(&quot;Decentralized counter not used.&quot;)
<a name="5912"/> 5912:     end,
<a name="check_decentralized_counters-last_expr"/><a name="5913"/> 5913: <b>    ExpectedState = ets:info</b>(T, decentralized_counters).
<a name="5914"/> 5914: 
<a name="5915"/> 5915: <i>%% Test various duplicate_bags stuff.</i>
<a name="dups-1"/><a name="5916"/> 5916: <b>dups</b>(Config) when is_list(Config) -&gt;
<a name="dups-last_expr"/><a name="5917"/> 5917: <b>    repeat_for_opts</b>(fun dups_do/1).
<a name="5918"/> 5918: 
<a name="dups_do-1"/><a name="5919"/> 5919: <b>dups_do</b>(Opts) -&gt;
<a name="5920"/> 5920:     EtsMem = etsmem(),
<a name="5921"/> 5921:     T = make_table(funky,
<a name="5922"/> 5922: 		   [duplicate_bag | Opts],
<a name="5923"/> 5923: 		   [{1, 2}, {1, 2}]),
<a name="5924"/> 5924:     2 = length(ets:tab2list(T)),
<a name="5925"/> 5925:     ets:delete(T, 1),
<a name="5926"/> 5926:     [] = ets:lookup(T, 1),
<a name="5927"/> 5927: 
<a name="5928"/> 5928:     ets:insert(T, {1, 2, 2}),
<a name="5929"/> 5929:     ets:insert(T, {1, 2, 4}),
<a name="5930"/> 5930:     ets:insert(T, {1, 2, 2}),
<a name="5931"/> 5931:     ets:insert(T, {1, 2, 2}),
<a name="5932"/> 5932:     ets:insert(T, {1, 2, 4}),
<a name="5933"/> 5933: 
<a name="5934"/> 5934:     5 = length(ets:tab2list(T)),
<a name="5935"/> 5935: 
<a name="5936"/> 5936:     5 = length(ets:match(T, {'$1', 2, '$2'})),
<a name="5937"/> 5937:     3 = length(ets:match(T, {'_', '$1', '$1'})),
<a name="5938"/> 5938:     ets:match_delete(T, {'_', '$1', '$1'}),
<a name="5939"/> 5939:     0 = length(ets:match(T, {'_', '$1', '$1'})),
<a name="5940"/> 5940:     ets:delete(T),
<a name="dups_do-last_expr"/><a name="5941"/> 5941: <b>    verify_etsmem</b>(EtsMem).
<a name="5942"/> 5942: 
<a name="5943"/> 5943: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="5944"/> 5944: 
<a name="5945"/> 5945: <i>%% Test the ets:tab2file function on an empty ets table.</i>
<a name="tab2file-1"/><a name="5946"/> 5946: <b>tab2file</b>(Config) when is_list(Config) -&gt;
<a name="5947"/> 5947:     FName = filename:join([proplists:get_value(priv_dir, Config),&quot;tab2file_case&quot;]),
<a name="5948"/> 5948:     tab2file_do(FName, [], set),
<a name="5949"/> 5949:     tab2file_do(FName, [], ordered_set),
<a name="5950"/> 5950:     tab2file_do(FName, [], cat_ord_set),
<a name="5951"/> 5951:     tab2file_do(FName, [], stim_cat_ord_set),
<a name="5952"/> 5952:     tab2file_do(FName, [{sync,true}], set),
<a name="5953"/> 5953:     tab2file_do(FName, [{sync,false}], set),
<a name="5954"/> 5954:     {'EXIT',{{badmatch,{error,_}},_}} = (catch tab2file_do(FName, [{sync,yes}], set)),
<a name="5955"/> 5955:     {'EXIT',{{badmatch,{error,_}},_}} = (catch tab2file_do(FName, [sync], set)),
<a name="tab2file-last_expr"/><a name="5956"/> 5956:     ok.
<a name="5957"/> 5957: 
<a name="tab2file_do-3"/><a name="5958"/> 5958: <b>tab2file_do</b>(FName, Opts, TableType) -&gt;
<a name="5959"/> 5959:     %% Write an empty ets table to a file, read back and check properties.
<a name="5960"/> 5960:     Tab = ets_new(ets_SUITE_foo_tab, [named_table, TableType, public,
<a name="5961"/> 5961: 				      {keypos, 2},
<a name="5962"/> 5962: 				      compressed,
<a name="5963"/> 5963: 				      {write_concurrency,true},
<a name="5964"/> 5964: 				      {read_concurrency,true}]),
<a name="5965"/> 5965:     ActualTableType =
<a name="5966"/> 5966:         case TableType of
<a name="5967"/> 5967:             cat_ord_set -&gt; ordered_set;
<a name="5968"/> 5968:             stim_cat_ord_set -&gt; ordered_set;
<a name="5969"/> 5969:             _ -&gt; TableType
<a name="5970"/> 5970:         end,
<a name="5971"/> 5971:     catch file:delete(FName),
<a name="5972"/> 5972:     Res = ets:tab2file(Tab, FName, Opts),
<a name="5973"/> 5973:     true = ets:delete(Tab),
<a name="5974"/> 5974:     ok = Res,
<a name="5975"/> 5975:     %%
<a name="5976"/> 5976:     EtsMem = etsmem(),
<a name="5977"/> 5977:     {ok, Tab2} = ets:file2tab(FName),
<a name="5978"/> 5978:     public = ets:info(Tab2, protection),
<a name="5979"/> 5979:     true = ets:info(Tab2, named_table),
<a name="5980"/> 5980:     2 = ets:info(Tab2, keypos),
<a name="5981"/> 5981:     ActualTableType = ets:info(Tab2, type),
<a name="5982"/> 5982:     true = ets:info(Tab2, compressed),
<a name="5983"/> 5983:     Smp = erlang:system_info(smp_support),
<a name="5984"/> 5984:     Smp = ets:info(Tab2, read_concurrency),
<a name="5985"/> 5985:     Smp = ets:info(Tab2, write_concurrency) orelse erlang:system_info(schedulers) == 1,
<a name="5986"/> 5986:     true = ets:delete(Tab2),
<a name="tab2file_do-last_expr"/><a name="5987"/> 5987: <b>    verify_etsmem</b>(EtsMem).
<a name="5988"/> 5988: 
<a name="5989"/> 5989: 
<a name="5990"/> 5990: <i>%% Check the ets:tab2file function on a filled set/bag type ets table.</i>
<a name="tab2file2-1"/><a name="5991"/> 5991: <b>tab2file2</b>(Config) when is_list(Config) -&gt;
<a name="tab2file2-last_expr"/><a name="5992"/> 5992: <b>    repeat_for_opts</b>(fun(Opts) -&gt;
<a name="5993"/> 5993:                             tab2file2_do(Opts, Config)
<a name="5994"/> 5994:                     end, [[stim_cat_ord_set,cat_ord_set,set,bag],compressed]).
<a name="5995"/> 5995: 
<a name="tab2file2_do-2"/><a name="5996"/> 5996: <b>tab2file2_do</b>(Opts, Config) -&gt;
<a name="5997"/> 5997:     EtsMem = etsmem(),
<a name="5998"/> 5998:     KeyRange = 10000,
<a name="5999"/> 5999:     Tab = ets_new(ets_SUITE_foo_tab, [named_table, private, {keypos, 2} | Opts],
<a name="6000"/> 6000:                   KeyRange),
<a name="6001"/> 6001:     FName = filename:join([proplists:get_value(priv_dir, Config),&quot;tab2file2_case&quot;]),
<a name="6002"/> 6002:     ok = fill_tab2(Tab, 0, KeyRange),   % Fill up the table (grucho mucho!)
<a name="6003"/> 6003:     Len = length(ets:tab2list(Tab)),
<a name="6004"/> 6004:     Mem = ets:info(Tab, memory),
<a name="6005"/> 6005:     Type = ets:info(Tab, type),
<a name="6006"/> 6006:     %%io:format(&quot;org tab: ~p\n&quot;,[ets:info(Tab)]),
<a name="6007"/> 6007:     ok = ets:tab2file(Tab, FName),
<a name="6008"/> 6008:     true = ets:delete(Tab),
<a name="6009"/> 6009: 
<a name="6010"/> 6010:     EtsMem4 = etsmem(),
<a name="6011"/> 6011: 
<a name="6012"/> 6012:     {ok, Tab2} = ets:file2tab(FName),
<a name="6013"/> 6013:     %%io:format(&quot;loaded tab: ~p\n&quot;,[ets:info(Tab2)]),
<a name="6014"/> 6014:     private = ets:info(Tab2, protection),
<a name="6015"/> 6015:     true = ets:info(Tab2, named_table),
<a name="6016"/> 6016:     2 = ets:info(Tab2, keypos),
<a name="6017"/> 6017:     Type = ets:info(Tab2, type),
<a name="6018"/> 6018:     Len = length(ets:tab2list(Tab2)),
<a name="6019"/> 6019:     Mem = ets:info(Tab2, memory),
<a name="6020"/> 6020:     true = ets:delete(Tab2),
<a name="6021"/> 6021:     io:format(&quot;Between = ~p\n&quot;, [EtsMem4]),
<a name="tab2file2_do-last_expr"/><a name="6022"/> 6022: <b>    verify_etsmem</b>(EtsMem).
<a name="6023"/> 6023: 
<a name="6024"/> 6024: <b>-define</b>(test_list, [8,5,4,1,58,125,255, 250, 245, 240, 235,
<a name="6025"/> 6025: 		    230, Num rem 255, 255, 125, 130, 135, 140, 145,
<a name="6026"/> 6026: 		    150, 134, 12, 54, Val rem 255, 12, 3, 6, 9, 126]).
<a name="6027"/> 6027: <b>-define</b>(big_test_list, [Num rem 256|lists:seq(1, 66)]).
<a name="6028"/> 6028: <b>-define</b>(test_integer, 2846287468+Num).
<a name="6029"/> 6029: <b>-define</b>(test_float, 187263.18236-Val).
<a name="6030"/> 6030: <b>-define</b>(test_atom, some_crazy_atom).
<a name="6031"/> 6031: <b>-define</b>(test_tuple, {just, 'Some', 'Tuple', 1, [list, item], Val+Num}).
<a name="6032"/> 6032: 
<a name="6033"/> 6033: <i>%% Insert different datatypes into a ets table.</i>
<a name="fill_tab2-3"/><a name="6034"/> 6034: <b>fill_tab2</b>(_Tab, _Val, 0) -&gt;
<a name="6035"/> 6035:     ok;
<a name="6036"/> 6036: <b>fill_tab2</b>(Tab, Val, Num) -&gt;
<a name="6037"/> 6037:     Item =
<a name="6038"/> 6038: 	case Num rem 10 of
<a name="6039"/> 6039: 	    0 -&gt; &quot;String&quot;;
<a name="6040"/> 6040: 	    1 -&gt; ?test_atom;
<a name="6041"/> 6041: 	    2 -&gt; ?test_tuple;
<a name="6042"/> 6042: 	    3 -&gt; ?test_integer;
<a name="6043"/> 6043: 	    4 -&gt; ?test_float;
<a name="6044"/> 6044: 	    5 -&gt; list_to_binary(?test_list); %Heap binary
<a name="6045"/> 6045: 	    6 -&gt; list_to_binary(?big_test_list); %Refc binary
<a name="6046"/> 6046: 	    7 -&gt; make_sub_binary(?test_list, Num); %Sub binary
<a name="6047"/> 6047: 	    8 -&gt; ?test_list;
<a name="6048"/> 6048: 	    9 -&gt; fun(X) -&gt; {Tab,Val,X*Num} end
<a name="6049"/> 6049: 	end,
<a name="6050"/> 6050:     true=ets:insert(Tab, {Item, Val}),
<a name="6051"/> 6051:     fill_tab2(Tab, Val+1, Num-1),
<a name="fill_tab2-last_expr"/><a name="6052"/> 6052:     ok.
<a name="6053"/> 6053: 
<a name="6054"/> 6054: <i>%% Test verification of tables with object count extended_info.</i>
<a name="tabfile_ext1-1"/><a name="6055"/> 6055: <b>tabfile_ext1</b>(Config) when is_list(Config) -&gt;
<a name="tabfile_ext1-last_expr"/><a name="6056"/> 6056: <b>    repeat_for_opts_all_set_table_types</b>(fun(Opts) -&gt; tabfile_ext1_do(Opts, Config) end).
<a name="6057"/> 6057: 
<a name="tabfile_ext1_do-2"/><a name="6058"/> 6058: <b>tabfile_ext1_do</b>(Opts,Config) -&gt;
<a name="6059"/> 6059:     FName = filename:join([proplists:get_value(priv_dir, Config),&quot;nisse.dat&quot;]),
<a name="6060"/> 6060:     FName2 = filename:join([proplists:get_value(priv_dir, Config),&quot;countflip.dat&quot;]),
<a name="6061"/> 6061:     KeyRange = 10,
<a name="6062"/> 6062:     L = lists:seq(1,KeyRange),
<a name="6063"/> 6063:     T = ets_new(x,Opts,KeyRange),
<a name="6064"/> 6064:     Name = make_ref(),
<a name="6065"/> 6065:     [ets:insert(T,{X,integer_to_list(X)}) || X &lt;- L],
<a name="6066"/> 6066:     ok = ets:tab2file(T,FName,[{extended_info,[object_count]}]),
<a name="6067"/> 6067:     true = lists:sort(ets:tab2list(T)) =:= 
<a name="6068"/> 6068: 	lists:sort(ets:tab2list(element(2,ets:file2tab(FName)))),
<a name="6069"/> 6069:     true = lists:sort(ets:tab2list(T)) =:= 
<a name="6070"/> 6070: 	lists:sort(ets:tab2list(
<a name="6071"/> 6071: 		     element(2,ets:file2tab(FName,[{verify,true}])))),
<a name="6072"/> 6072:     {ok,Name} = disk_log:open([{name,Name},{file,FName}]),
<a name="6073"/> 6073:     {_,[H0|T0]} = disk_log:chunk(Name,start),
<a name="6074"/> 6074:     disk_log:close(Name),
<a name="6075"/> 6075:     LH0=tuple_to_list(H0),
<a name="6076"/> 6076:     {value,{size,N}}=lists:keysearch(size,1,LH0),
<a name="6077"/> 6077:     NewLH0 = lists:keyreplace(size,1,LH0,{size,N-1}),
<a name="6078"/> 6078:     NewH0 = list_to_tuple(NewLH0),
<a name="6079"/> 6079:     NewT0=lists:keydelete(8,1,T0),
<a name="6080"/> 6080:     file:delete(FName2),
<a name="6081"/> 6081:     disk_log:open([{name,Name},{file,FName2},{mode,read_write}]),
<a name="6082"/> 6082:     disk_log:log_terms(Name,[NewH0|NewT0]),
<a name="6083"/> 6083:     disk_log:close(Name),
<a name="6084"/> 6084:     9 = length(ets:tab2list(element(2,ets:file2tab(FName2)))),
<a name="6085"/> 6085:     {error,invalid_object_count} = ets:file2tab(FName2,[{verify,true}]),
<a name="6086"/> 6086:     {ok, _} = ets:tabfile_info(FName2),
<a name="6087"/> 6087:     {ok, _} = ets:tabfile_info(FName),
<a name="6088"/> 6088:     file:delete(FName),
<a name="6089"/> 6089:     file:delete(FName2),
<a name="tabfile_ext1_do-last_expr"/><a name="6090"/> 6090:     ok.
<a name="6091"/> 6091: 
<a name="6092"/> 6092: 
<a name="6093"/> 6093: <i>%% Test verification of tables with md5sum extended_info.</i>
<a name="tabfile_ext2-1"/><a name="6094"/> 6094: <b>tabfile_ext2</b>(Config) when is_list(Config) -&gt;
<a name="tabfile_ext2-last_expr"/><a name="6095"/> 6095: <b>    repeat_for_opts_all_set_table_types</b>(fun(Opts) -&gt; tabfile_ext2_do(Opts,Config) end).
<a name="6096"/> 6096: 
<a name="tabfile_ext2_do-2"/><a name="6097"/> 6097: <b>tabfile_ext2_do</b>(Opts,Config) -&gt;
<a name="6098"/> 6098:     FName = filename:join([proplists:get_value(priv_dir, Config),&quot;olle.dat&quot;]),
<a name="6099"/> 6099:     FName2 = filename:join([proplists:get_value(priv_dir, Config),&quot;bitflip.dat&quot;]),
<a name="6100"/> 6100:     KeyRange = 10,
<a name="6101"/> 6101:     L = lists:seq(1, KeyRange),
<a name="6102"/> 6102:     T = ets_new(x, Opts, KeyRange),
<a name="6103"/> 6103:     Name = make_ref(),
<a name="6104"/> 6104:     [ets:insert(T,{X,integer_to_list(X)}) || X &lt;- L],
<a name="6105"/> 6105:     ok = ets:tab2file(T,FName,[{extended_info,[md5sum]}]),
<a name="6106"/> 6106:     true = lists:sort(ets:tab2list(T)) =:=
<a name="6107"/> 6107: 	lists:sort(ets:tab2list(element(2,ets:file2tab(FName)))),
<a name="6108"/> 6108:     true = lists:sort(ets:tab2list(T)) =:=
<a name="6109"/> 6109: 	lists:sort(ets:tab2list(
<a name="6110"/> 6110: 		     element(2,ets:file2tab(FName,[{verify,true}])))),
<a name="6111"/> 6111:     {ok, Name} = disk_log:open([{name,Name},{file,FName}]),
<a name="6112"/> 6112:     {_,[H1|T1]} = disk_log:chunk(Name,start),
<a name="6113"/> 6113:     disk_log:close(Name),
<a name="6114"/> 6114:     NewT1=lists:keyreplace(8,1,T1,{8,&quot;9&quot;}),
<a name="6115"/> 6115:     file:delete(FName2),
<a name="6116"/> 6116:     disk_log:open([{name,Name},{file,FName2},{mode,read_write}]),
<a name="6117"/> 6117:     disk_log:log_terms(Name,[H1|NewT1]),
<a name="6118"/> 6118:     disk_log:close(Name),
<a name="6119"/> 6119:     {value,{8,&quot;9&quot;}} = lists:keysearch(8,1,
<a name="6120"/> 6120: 				      ets:tab2list(
<a name="6121"/> 6121: 					element(2,ets:file2tab(FName2)))),
<a name="6122"/> 6122:     {error,checksum_error} = ets:file2tab(FName2,[{verify,true}]),
<a name="6123"/> 6123:     {value,{extended_info,[md5sum]}} =
<a name="6124"/> 6124: 	lists:keysearch(extended_info,1,element(2,ets:tabfile_info(FName2))),
<a name="6125"/> 6125:     {value,{extended_info,[md5sum]}} =
<a name="6126"/> 6126: 	lists:keysearch(extended_info,1,element(2,ets:tabfile_info(FName))),
<a name="6127"/> 6127:     file:delete(FName),
<a name="6128"/> 6128:     file:delete(FName2),
<a name="tabfile_ext2_do-last_expr"/><a name="6129"/> 6129:     ok.
<a name="6130"/> 6130: 
<a name="6131"/> 6131: <i>%% Test verification of (named) tables without extended info.</i>
<a name="tabfile_ext3-1"/><a name="6132"/> 6132: <b>tabfile_ext3</b>(Config) when is_list(Config) -&gt;
<a name="6133"/> 6133:     repeat_for_all_set_table_types(
<a name="6134"/> 6134:       fun(Opts) -&gt;
<a name="6135"/> 6135:               FName = filename:join([proplists:get_value(priv_dir, Config),&quot;namn.dat&quot;]),
<a name="6136"/> 6136:               FName2 = filename:join([proplists:get_value(priv_dir, Config),&quot;ncountflip.dat&quot;]),
<a name="6137"/> 6137:               L = lists:seq(1,10),
<a name="6138"/> 6138:               Name = make_ref(),
<a name="6139"/> 6139:               ?MODULE = ets_new(?MODULE,[named_table|Opts]),
<a name="6140"/> 6140:               [ets:insert(?MODULE,{X,integer_to_list(X)}) || X &lt;- L],
<a name="6141"/> 6141:               ets:tab2file(?MODULE,FName),
<a name="6142"/> 6142:               {error,cannot_create_table} = ets:file2tab(FName),
<a name="6143"/> 6143:               true = ets:delete(?MODULE),
<a name="6144"/> 6144:               {ok,?MODULE} = ets:file2tab(FName),
<a name="6145"/> 6145:               true = ets:delete(?MODULE),
<a name="6146"/> 6146:               disk_log:open([{name,Name},{file,FName}]),
<a name="6147"/> 6147:               {_,[H2|T2]} = disk_log:chunk(Name,start),
<a name="6148"/> 6148:               disk_log:close(Name),
<a name="6149"/> 6149:               NewT2=lists:keydelete(8,1,T2),
<a name="6150"/> 6150:               file:delete(FName2),
<a name="6151"/> 6151:               disk_log:open([{name,Name},{file,FName2},{mode,read_write}]),
<a name="6152"/> 6152:               disk_log:log_terms(Name,[H2|NewT2]),
<a name="6153"/> 6153:               disk_log:close(Name),
<a name="6154"/> 6154:               9 = length(ets:tab2list(element(2,ets:file2tab(FName2)))),
<a name="6155"/> 6155:               true = ets:delete(?MODULE),
<a name="6156"/> 6156:               {error,invalid_object_count} = ets:file2tab(FName2,[{verify,true}]),
<a name="6157"/> 6157:               {'EXIT',_} = (catch ets:delete(?MODULE)),
<a name="6158"/> 6158:               {ok,_} = ets:tabfile_info(FName2),
<a name="6159"/> 6159:               {ok,_} = ets:tabfile_info(FName),
<a name="6160"/> 6160:               file:delete(FName),
<a name="6161"/> 6161:               file:delete(FName2)
<a name="6162"/> 6162:       end),
<a name="tabfile_ext3-last_expr"/><a name="6163"/> 6163:     ok.
<a name="6164"/> 6164: 
<a name="6165"/> 6165: <i>%% Tests verification of large table with md5 sum.</i>
<a name="tabfile_ext4-1"/><a name="6166"/> 6166: <b>tabfile_ext4</b>(Config) when is_list(Config) -&gt;
<a name="6167"/> 6167:     repeat_for_all_set_table_types(
<a name="6168"/> 6168:       fun(Opts) -&gt;
<a name="6169"/> 6169:               FName = filename:join([proplists:get_value(priv_dir, Config),&quot;bauta.dat&quot;]),
<a name="6170"/> 6170:               LL = lists:seq(1,10000),
<a name="6171"/> 6171:               TL = ets_new(x,Opts),
<a name="6172"/> 6172:               Name2 = make_ref(),
<a name="6173"/> 6173:               [ets:insert(TL,{X,integer_to_list(X)}) || X &lt;- LL],
<a name="6174"/> 6174:               ok = ets:tab2file(TL,FName,[{extended_info,[md5sum]}]),
<a name="6175"/> 6175:               {ok, Name2} = disk_log:open([{name, Name2}, {file, FName},
<a name="6176"/> 6176:                                            {mode, read_only}]),
<a name="6177"/> 6177:               {C,[_|_]} = disk_log:chunk(Name2,start),
<a name="6178"/> 6178:               {_,[_|_]} = disk_log:chunk(Name2,C),
<a name="6179"/> 6179:               disk_log:close(Name2),
<a name="6180"/> 6180:               true = lists:sort(ets:tab2list(TL)) =:=
<a name="6181"/> 6181:                   lists:sort(ets:tab2list(element(2,ets:file2tab(FName)))),
<a name="6182"/> 6182:               Res = [begin
<a name="6183"/> 6183:                          {ok,FD} = file:open(FName,[binary,read,write]),
<a name="6184"/> 6184:                          {ok, Bin} = file:pread(FD,0,1000),
<a name="6185"/> 6185:                          &lt;&lt;B1:N/binary,Ch:8,B2/binary&gt;&gt; = Bin,
<a name="6186"/> 6186:                          Ch2 = (Ch + 1) rem 255,
<a name="6187"/> 6187:                          Bin2 = &lt;&lt;B1/binary,Ch2:8,B2/binary&gt;&gt;,
<a name="6188"/> 6188:                          ok = file:pwrite(FD,0,Bin2),
<a name="6189"/> 6189:                          ok = file:close(FD),
<a name="6190"/> 6190:                          X = case ets:file2tab(FName) of
<a name="6191"/> 6191:                                  {ok,TL2} -&gt;
<a name="6192"/> 6192:                                      true = lists:sort(ets:tab2list(TL)) =/=
<a name="6193"/> 6193:                                          lists:sort(ets:tab2list(TL2));
<a name="6194"/> 6194:                                  _ -&gt;
<a name="6195"/> 6195:                                      totally_broken
<a name="6196"/> 6196:                              end,
<a name="6197"/> 6197:                          {error,Y} = ets:file2tab(FName,[{verify,true}]),
<a name="6198"/> 6198:                          ets:tab2file(TL,FName,[{extended_info,[md5sum]}]),
<a name="6199"/> 6199:                          {X,Y}
<a name="6200"/> 6200:                      end || N &lt;- lists:seq(700,800)],
<a name="6201"/> 6201:               io:format(&quot;~p~n&quot;,[Res]),
<a name="6202"/> 6202:               file:delete(FName)
<a name="6203"/> 6203:       end),
<a name="tabfile_ext4-last_expr"/><a name="6204"/> 6204:     ok.
<a name="6205"/> 6205: 
<a name="6206"/> 6206: <i>%% Test that no disk_log is left open when file has been corrupted.</i>
<a name="badfile-1"/><a name="6207"/> 6207: <b>badfile</b>(Config) when is_list(Config) -&gt;
<a name="6208"/> 6208:     PrivDir = proplists:get_value(priv_dir,Config),
<a name="6209"/> 6209:     File = filename:join(PrivDir, &quot;badfile&quot;),
<a name="6210"/> 6210:     _ = file:delete(File),
<a name="6211"/> 6211:     T = ets:new(table, []),
<a name="6212"/> 6212:     true = ets:insert(T, [{a,1},{b,2}]),
<a name="6213"/> 6213:     ok = ets:tab2file(T, File, []),
<a name="6214"/> 6214:     true = ets:delete(T),
<a name="6215"/> 6215:     [H0 | Ts ] = get_all_terms(l, File),
<a name="6216"/> 6216:     H1 = tuple_to_list(H0),
<a name="6217"/> 6217:     H2 = [{K,V} || {K,V} &lt;- H1, K =/= protection],
<a name="6218"/> 6218:     H = list_to_tuple(H2),
<a name="6219"/> 6219:     ok = file:delete(File),
<a name="6220"/> 6220:     write_terms(l, File, [H | Ts]),
<a name="6221"/> 6221:     %% All mandatory keys are no longer members of the header
<a name="6222"/> 6222:     {error, badfile} = ets:file2tab(File),
<a name="6223"/> 6223:     {error, badfile} = ets:tabfile_info(File),
<a name="6224"/> 6224:     file:delete(File),
<a name="6225"/> 6225:     [] = disk_log:all(),
<a name="badfile-last_expr"/><a name="6226"/> 6226:     ok.
<a name="6227"/> 6227: 
<a name="get_all_terms-2"/><a name="6228"/> 6228: <b>get_all_terms</b>(Log, File) -&gt;
<a name="6229"/> 6229:     {ok, Log} = disk_log:open([{name,Log},
<a name="6230"/> 6230:                                {file, File},
<a name="6231"/> 6231:                                {mode, read_only}]),
<a name="6232"/> 6232:     Ts = get_all_terms(Log),
<a name="6233"/> 6233:     ok = disk_log:close(Log),
<a name="get_all_terms-last_expr"/><a name="6234"/> 6234:     Ts.
<a name="6235"/> 6235: 
<a name="get_all_terms-1"/><a name="6236"/> 6236: <b>get_all_terms</b>(Log) -&gt;
<a name="get_all_terms-last_expr"/><a name="6237"/> 6237: <b>    get_all_terms1</b>(Log, start, []).
<a name="6238"/> 6238: 
<a name="get_all_terms1-3"/><a name="6239"/> 6239: <b>get_all_terms1</b>(Log, Cont, Res) -&gt;
<a name="get_all_terms1-last_expr"/><a name="6240"/> 6240: <b>    case disk_log:chunk</b>(Log, Cont) of
<a name="6241"/> 6241: 	{error, _R} -&gt;
<a name="6242"/> 6242:             throw(fel);
<a name="6243"/> 6243: 	{Cont2, Terms} -&gt;
<a name="6244"/> 6244: 	    get_all_terms1(Log, Cont2, Res ++ Terms);
<a name="6245"/> 6245: 	eof -&gt;
<a name="6246"/> 6246: 	    Res
<a name="6247"/> 6247:     end.
<a name="6248"/> 6248: 
<a name="write_terms-3"/><a name="6249"/> 6249: <b>write_terms</b>(Log, File, Terms) -&gt;
<a name="6250"/> 6250:     {ok, Log} = disk_log:open([{name,Log},{file, File},{mode,read_write}]),
<a name="6251"/> 6251:     ok = disk_log:log(Log, Terms),
<a name="write_terms-last_expr"/><a name="6252"/> 6252: <b>    ok = disk_log:close</b>(Log).
<a name="6253"/> 6253: 
<a name="6254"/> 6254: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="6255"/> 6255: 
<a name="make_sub_binary-2"/><a name="6256"/> 6256: <b>make_sub_binary</b>(List, Num) when is_list(List) -&gt;
<a name="6257"/> 6257:     N = Num rem 23,
<a name="6258"/> 6258:     Bin = list_to_binary([lists:seq(0, N)|List]),
<a name="6259"/> 6259:     {_,B} = split_binary(Bin, N+1),
<a name="make_sub_binary-last_expr"/><a name="6260"/> 6260:     B.
<a name="6261"/> 6261: 
<a name="6262"/> 6262: 
<a name="6263"/> 6263: <i>%% Lookup stuff like crazy...</i>
<a name="6264"/> 6264: 
<a name="6265"/> 6265: <i>%% Perform multiple lookups for every key in a large table.</i>
<a name="heavy_lookup-1"/><a name="6266"/> 6266: <b>heavy_lookup</b>(Config) when is_list(Config) -&gt;
<a name="heavy_lookup-last_expr"/><a name="6267"/> 6267: <b>    repeat_for_opts_all_set_table_types</b>(fun heavy_lookup_do/1).
<a name="6268"/> 6268: 
<a name="heavy_lookup_do-1"/><a name="6269"/> 6269: <b>heavy_lookup_do</b>(Opts) -&gt;
<a name="6270"/> 6270:     EtsMem = etsmem(),
<a name="6271"/> 6271:     KeyRange = 7000,
<a name="6272"/> 6272:     Tab = ets_new(foobar_table, [{keypos, 2} | Opts], KeyRange),
<a name="6273"/> 6273:     ok = fill_tab2(Tab, 0, KeyRange),
<a name="6274"/> 6274:     _ = [do_lookup(Tab, KeyRange-1) || _ &lt;- lists:seq(1, 50)],
<a name="6275"/> 6275:     true = ets:delete(Tab),
<a name="heavy_lookup_do-last_expr"/><a name="6276"/> 6276: <b>    verify_etsmem</b>(EtsMem).
<a name="6277"/> 6277: 
<a name="do_lookup-2"/><a name="6278"/> 6278: <b>do_lookup</b>(_Tab, 0) -&gt; ok;
<a name="6279"/> 6279: <b>do_lookup</b>(Tab, N) -&gt;
<a name="do_lookup-last_expr"/><a name="6280"/> 6280: <b>    case ets:lookup</b>(Tab, N) of
<a name="6281"/> 6281: 	[] -&gt;
<a name="6282"/> 6282: 	    io:format(&quot;Set #~p was reported as empty. Not valid.&quot;,
<a name="6283"/> 6283: 		      [N]),
<a name="6284"/> 6284: 	    exit('Invalid lookup');
<a name="6285"/> 6285: 	_ -&gt;
<a name="6286"/> 6286: 	    do_lookup(Tab, N-1)
<a name="6287"/> 6287:     end.
<a name="6288"/> 6288: 
<a name="6289"/> 6289: <i>%% Perform multiple lookups for every element in a large table.</i>
<a name="heavy_lookup_element-1"/><a name="6290"/> 6290: <b>heavy_lookup_element</b>(Config) when is_list(Config) -&gt;
<a name="heavy_lookup_element-last_expr"/><a name="6291"/> 6291: <b>    repeat_for_opts_all_set_table_types</b>(fun heavy_lookup_element_do/1).
<a name="6292"/> 6292: 
<a name="heavy_lookup_element_do-1"/><a name="6293"/> 6293: <b>heavy_lookup_element_do</b>(Opts) -&gt;
<a name="6294"/> 6294:     EtsMem = etsmem(),
<a name="6295"/> 6295:     KeyRange = 7000,
<a name="6296"/> 6296:     Tab = ets_new(foobar_table, [{keypos, 2} | Opts], KeyRange),
<a name="6297"/> 6297:     ok = fill_tab2(Tab, 0, KeyRange),
<a name="6298"/> 6298:     %% lookup ALL elements 50 times
<a name="6299"/> 6299:     Laps = 50 div syrup_factor(),
<a name="6300"/> 6300:     _ = [do_lookup_element(Tab, KeyRange-1, 1) || _ &lt;- lists:seq(1, Laps)],
<a name="6301"/> 6301:     true = ets:delete(Tab),
<a name="heavy_lookup_element_do-last_expr"/><a name="6302"/> 6302: <b>    verify_etsmem</b>(EtsMem).
<a name="6303"/> 6303: 
<a name="do_lookup_element-3"/><a name="6304"/> 6304: <b>do_lookup_element</b>(_Tab, 0, _) -&gt; ok;
<a name="6305"/> 6305: <b>do_lookup_element</b>(Tab, N, M) -&gt;
<a name="do_lookup_element-last_expr"/><a name="6306"/> 6306: <b>    case catch ets:lookup_element</b>(Tab, N, M) of
<a name="6307"/> 6307: 	{'EXIT', {badarg, _}} -&gt;
<a name="6308"/> 6308: 	    case M of
<a name="6309"/> 6309: 		1 -&gt; ct:fail(&quot;Set #~p reported as empty. Not valid.&quot;,
<a name="6310"/> 6310: 			     [N]),
<a name="6311"/> 6311: 		     exit('Invalid lookup_element');
<a name="6312"/> 6312: 		_ -&gt; do_lookup_element(Tab, N-1, 1)
<a name="6313"/> 6313: 	    end;
<a name="6314"/> 6314: 	_ -&gt; do_lookup_element(Tab, N, M+1)
<a name="6315"/> 6315:     end.
<a name="6316"/> 6316: 
<a name="6317"/> 6317: 
<a name="heavy_concurrent-1"/><a name="6318"/> 6318: <b>heavy_concurrent</b>(Config) when is_list(Config) -&gt;
<a name="6319"/> 6319:     ct:timetrap({minutes,120}), %% valgrind needs a lot of time
<a name="heavy_concurrent-last_expr"/><a name="6320"/> 6320: <b>    repeat_for_opts_all_set_table_types</b>(fun do_heavy_concurrent/1).
<a name="6321"/> 6321: 
<a name="do_heavy_concurrent-1"/><a name="6322"/> 6322: <b>do_heavy_concurrent</b>(Opts) -&gt;
<a name="6323"/> 6323:     KeyRange = 10000,
<a name="6324"/> 6324:     Laps = 10000 div syrup_factor(),
<a name="6325"/> 6325:     EtsMem = etsmem(),
<a name="6326"/> 6326:     Tab = ets_new(blupp, [public, {keypos, 2} | Opts], KeyRange),
<a name="6327"/> 6327:     ok = fill_tab2(Tab, 0, KeyRange),
<a name="6328"/> 6328:     Procs = lists:map(
<a name="6329"/> 6329: 	      fun (N) -&gt;
<a name="6330"/> 6330: 		      my_spawn_link(
<a name="6331"/> 6331: 			fun () -&gt;
<a name="6332"/> 6332: 				do_heavy_concurrent_proc(Tab, Laps, N)
<a name="6333"/> 6333: 			end)
<a name="6334"/> 6334: 	      end,
<a name="6335"/> 6335: 	      lists:seq(1, 500)),
<a name="6336"/> 6336:     lists:foreach(fun (P) -&gt;
<a name="6337"/> 6337: 			  M = erlang:monitor(process, P),
<a name="6338"/> 6338: 			  receive
<a name="6339"/> 6339: 			      {'DOWN', M, process, P, _} -&gt;
<a name="6340"/> 6340: 				  ok
<a name="6341"/> 6341: 			  end
<a name="6342"/> 6342: 		  end,
<a name="6343"/> 6343: 		  Procs),
<a name="6344"/> 6344:     true = ets:delete(Tab),
<a name="do_heavy_concurrent-last_expr"/><a name="6345"/> 6345: <b>    verify_etsmem</b>(EtsMem).
<a name="6346"/> 6346: 
<a name="do_heavy_concurrent_proc-3"/><a name="6347"/> 6347: <b>do_heavy_concurrent_proc</b>(_Tab, 0, _Offs) -&gt;
<a name="6348"/> 6348:     done;
<a name="6349"/> 6349: <b>do_heavy_concurrent_proc</b>(Tab, N, Offs) when (N+Offs) rem 100 == 0 -&gt;
<a name="6350"/> 6350:     Data = {&quot;here&quot;, are, &quot;S O M E &quot;, data, &quot;toooooooooooooooooo&quot;, insert,
<a name="6351"/> 6351: 	    make_ref(), make_ref(), make_ref()},
<a name="6352"/> 6352:     true=ets:insert(Tab, {{self(),Data}, N}),
<a name="6353"/> 6353:     do_heavy_concurrent_proc(Tab, N-1, Offs);
<a name="6354"/> 6354: <b>do_heavy_concurrent_proc</b>(Tab, N, Offs) -&gt;
<a name="6355"/> 6355:     _ = ets:lookup(Tab, N),
<a name="do_heavy_concurrent_proc-last_expr"/><a name="6356"/> 6356: <b>    do_heavy_concurrent_proc</b>(Tab, N-1, Offs).
<a name="6357"/> 6357: 
<a name="6358"/> 6358: 
<a name="fold_empty-1"/><a name="6359"/> 6359: <b>fold_empty</b>(Config) when is_list(Config) -&gt;
<a name="6360"/> 6360:     repeat_for_opts_all_set_table_types(
<a name="6361"/> 6361:       fun(Opts) -&gt;
<a name="6362"/> 6362:               EtsMem = etsmem(),
<a name="6363"/> 6363:               Tab = make_table(a, Opts, []),
<a name="6364"/> 6364:               [] = ets:foldl(fun(_X) -&gt; exit(hej) end, [], Tab),
<a name="6365"/> 6365:               [] = ets:foldr(fun(_X) -&gt; exit(hej) end, [], Tab),
<a name="6366"/> 6366:               true = ets:delete(Tab),
<a name="6367"/> 6367:               verify_etsmem(EtsMem)
<a name="6368"/> 6368:       end),
<a name="fold_empty-last_expr"/><a name="6369"/> 6369:     ok.
<a name="6370"/> 6370: 
<a name="foldl-1"/><a name="6371"/> 6371: <b>foldl</b>(Config) when is_list(Config) -&gt;
<a name="6372"/> 6372:     repeat_for_opts_all_table_types(
<a name="6373"/> 6373:       fun(Opts) -&gt;
<a name="6374"/> 6374:               EtsMem = etsmem(),
<a name="6375"/> 6375:               L = [{a,1}, {c,3}, {b,2}],
<a name="6376"/> 6376:               LS = lists:sort(L),
<a name="6377"/> 6377:               Tab = make_table(a, Opts, L),
<a name="6378"/> 6378:               LS = lists:sort(ets:foldl(fun(E,A) -&gt; [E|A] end, [], Tab)),
<a name="6379"/> 6379:               true = ets:delete(Tab),
<a name="6380"/> 6380:               verify_etsmem(EtsMem)
<a name="6381"/> 6381:       end),
<a name="foldl-last_expr"/><a name="6382"/> 6382:     ok.
<a name="6383"/> 6383: 
<a name="foldr-1"/><a name="6384"/> 6384: <b>foldr</b>(Config) when is_list(Config) -&gt;
<a name="6385"/> 6385:     repeat_for_opts_all_table_types(
<a name="6386"/> 6386:       fun(Opts) -&gt;
<a name="6387"/> 6387:               EtsMem = etsmem(),
<a name="6388"/> 6388:               L = [{a,1}, {c,3}, {b,2}],
<a name="6389"/> 6389:               LS = lists:sort(L),
<a name="6390"/> 6390:               Tab = make_table(a, Opts, L),
<a name="6391"/> 6391:               LS = lists:sort(ets:foldr(fun(E,A) -&gt; [E|A] end, [], Tab)),
<a name="6392"/> 6392:               true = ets:delete(Tab),
<a name="6393"/> 6393:               verify_etsmem(EtsMem)
<a name="6394"/> 6394:       end),
<a name="foldr-last_expr"/><a name="6395"/> 6395:     ok.
<a name="6396"/> 6396: 
<a name="foldl_ordered-1"/><a name="6397"/> 6397: <b>foldl_ordered</b>(Config) when is_list(Config) -&gt;
<a name="6398"/> 6398:     repeat_for_opts_all_ord_set_table_types(
<a name="6399"/> 6399:       fun(Opts) -&gt;
<a name="6400"/> 6400:               EtsMem = etsmem(),
<a name="6401"/> 6401:               L = [{a,1}, {c,3}, {b,2}],
<a name="6402"/> 6402:               LS = lists:sort(L),
<a name="6403"/> 6403:               Tab = make_table(a, Opts, L),
<a name="6404"/> 6404:               LS = lists:reverse(ets:foldl(fun(E,A) -&gt; [E|A] end, [], Tab)),
<a name="6405"/> 6405:               true = ets:delete(Tab),
<a name="6406"/> 6406:               verify_etsmem(EtsMem)
<a name="6407"/> 6407:       end),
<a name="foldl_ordered-last_expr"/><a name="6408"/> 6408:     ok.
<a name="6409"/> 6409: 
<a name="foldr_ordered-1"/><a name="6410"/> 6410: <b>foldr_ordered</b>(Config) when is_list(Config) -&gt;
<a name="6411"/> 6411:     repeat_for_opts_all_ord_set_table_types(
<a name="6412"/> 6412:       fun(Opts) -&gt;
<a name="6413"/> 6413:               EtsMem = etsmem(),
<a name="6414"/> 6414:               L = [{a,1}, {c,3}, {b,2}],
<a name="6415"/> 6415:               LS = lists:sort(L),
<a name="6416"/> 6416:               Tab = make_table(a, Opts, L),
<a name="6417"/> 6417:               LS = ets:foldr(fun(E,A) -&gt; [E|A] end, [], Tab),
<a name="6418"/> 6418:               true = ets:delete(Tab),
<a name="6419"/> 6419:               verify_etsmem(EtsMem)
<a name="6420"/> 6420:       end),
<a name="foldr_ordered-last_expr"/><a name="6421"/> 6421:     ok.
<a name="6422"/> 6422: 
<a name="6423"/> 6423: <i>%% Test ets:member BIF.</i>
<a name="member-1"/><a name="6424"/> 6424: <b>member</b>(Config) when is_list(Config) -&gt;
<a name="member-last_expr"/><a name="6425"/> 6425: <b>    repeat_for_opts</b>(fun member_do/1, [write_concurrency, all_types]).
<a name="6426"/> 6426: 
<a name="member_do-1"/><a name="6427"/> 6427: <b>member_do</b>(Opts) -&gt;
<a name="6428"/> 6428:     EtsMem = etsmem(),
<a name="6429"/> 6429:     T = ets_new(xxx, Opts),
<a name="6430"/> 6430:     false = ets:member(T,hej),
<a name="6431"/> 6431:     E = fun(0,_F)-&gt;ok;
<a name="6432"/> 6432: 	   (N,F) -&gt;
<a name="6433"/> 6433: 		ets:insert(T,{N,N rem 10}),
<a name="6434"/> 6434: 		F(N-1,F)
<a name="6435"/> 6435: 	end,
<a name="6436"/> 6436:     E(10000,E),
<a name="6437"/> 6437:     false = ets:member(T,hej),
<a name="6438"/> 6438:     true = ets:member(T,1),
<a name="6439"/> 6439:     false = ets:member(T,20000),
<a name="6440"/> 6440:     ets:delete(T,5),
<a name="6441"/> 6441:     false = ets:member(T,5),
<a name="6442"/> 6442:     ets:safe_fixtable(T,true),
<a name="6443"/> 6443:     ets:delete(T,6),
<a name="6444"/> 6444:     false = ets:member(T,6),
<a name="6445"/> 6445:     ets:safe_fixtable(T,false),
<a name="6446"/> 6446:     false = ets:member(T,6),
<a name="6447"/> 6447:     ets:delete(T),
<a name="6448"/> 6448:     {'EXIT',{badarg,_}} = (catch ets:member(finnsinte, 23)),
<a name="6449"/> 6449:     {'EXIT',{badarg,_}} = (catch ets:member(T, 23)),
<a name="member_do-last_expr"/><a name="6450"/> 6450: <b>    verify_etsmem</b>(EtsMem).
<a name="6451"/> 6451: 
<a name="6452"/> 6452: 
<a name="build_table-3"/><a name="6453"/> 6453: <b>build_table</b>(L1,L2,Num) -&gt;
<a name="6454"/> 6454:     T = ets_new(xxx, [ordered_set]),
<a name="6455"/> 6455:     lists:foreach(
<a name="6456"/> 6456:       fun(X1) -&gt;
<a name="6457"/> 6457: 	      lists:foreach(
<a name="6458"/> 6458: 		fun(X2) -&gt;
<a name="6459"/> 6459: 			F = fun(FF,N) -&gt;
<a name="6460"/> 6460: 				    ets:insert(T,{{X1,X2,N}, X1, X2, N}),
<a name="6461"/> 6461: 				    case N of
<a name="6462"/> 6462: 					0 -&gt;
<a name="6463"/> 6463: 					    ok;
<a name="6464"/> 6464: 					_ -&gt;
<a name="6465"/> 6465: 					    FF(FF,N-1)
<a name="6466"/> 6466: 				    end
<a name="6467"/> 6467: 			    end,
<a name="6468"/> 6468: 			F(F,Num)
<a name="6469"/> 6469: 		end, L2)
<a name="6470"/> 6470:       end, L1),
<a name="build_table-last_expr"/><a name="6471"/> 6471:     T.
<a name="6472"/> 6472: 
<a name="build_table2-3"/><a name="6473"/> 6473: <b>build_table2</b>(L1,L2,Num) -&gt;
<a name="6474"/> 6474:     T = ets_new(xxx, [ordered_set]),
<a name="6475"/> 6475:     lists:foreach(
<a name="6476"/> 6476:       fun(X1) -&gt;
<a name="6477"/> 6477: 	      lists:foreach(
<a name="6478"/> 6478: 		fun(X2) -&gt;
<a name="6479"/> 6479: 			F = fun(FF,N) -&gt;
<a name="6480"/> 6480: 				    ets:insert(T,{{N,X1,X2}, N, X1, X2}),
<a name="6481"/> 6481: 				    case N of
<a name="6482"/> 6482: 					0 -&gt;
<a name="6483"/> 6483: 					    ok;
<a name="6484"/> 6484: 					_ -&gt;
<a name="6485"/> 6485: 					    FF(FF,N-1)
<a name="6486"/> 6486: 				    end
<a name="6487"/> 6487: 			    end,
<a name="6488"/> 6488: 			F(F,Num)
<a name="6489"/> 6489: 		end, L2)
<a name="6490"/> 6490:       end, L1),
<a name="build_table2-last_expr"/><a name="6491"/> 6491:     T.
<a name="6492"/> 6492: 
<a name="time_match_object-3"/><a name="6493"/> 6493: <b>time_match_object</b>(Tab,Match, Res) -&gt;
<a name="6494"/> 6494:     T1 = erlang:monotonic_time(microsecond),
<a name="6495"/> 6495:     Res = ets:match_object(Tab,Match),
<a name="6496"/> 6496:     T2 = erlang:monotonic_time(microsecond),
<a name="time_match_object-last_expr"/><a name="6497"/> 6497:     T2 - T1.
<a name="6498"/> 6498: 
<a name="time_match-2"/><a name="6499"/> 6499: <b>time_match</b>(Tab,Match) -&gt;
<a name="6500"/> 6500:     T1 = erlang:monotonic_time(microsecond),
<a name="6501"/> 6501:     ets:match(Tab,Match),
<a name="6502"/> 6502:     T2 = erlang:monotonic_time(microsecond),
<a name="time_match-last_expr"/><a name="6503"/> 6503:     T2 - T1.
<a name="6504"/> 6504: 
<a name="seventyfive_percent_success-4"/><a name="6505"/> 6505: <b>seventyfive_percent_success</b>(_,S,Fa,0) -&gt;
<a name="6506"/> 6506:     true = (S &gt; ((S + Fa) * 0.75));
<a name="6507"/> 6507: 
<a name="6508"/> 6508: <b>seventyfive_percent_success</b>(F, S, Fa, N) when is_function(F, 0) -&gt;
<a name="seventyfive_percent_success-last_expr"/><a name="6509"/> 6509: <b>    try F</b>() of
<a name="6510"/> 6510:         _ -&gt;
<a name="6511"/> 6511: 	    seventyfive_percent_success(F, S+1, Fa, N-1)
<a name="6512"/> 6512:     catch error:_ -&gt;
<a name="6513"/> 6513: 	    seventyfive_percent_success(F, S, Fa+1, N-1)
<a name="6514"/> 6514:     end.
<a name="6515"/> 6515: 
<a name="fifty_percent_success-4"/><a name="6516"/> 6516: <b>fifty_percent_success</b>(_,S,Fa,0) -&gt;
<a name="6517"/> 6517:     true = (S &gt; ((S + Fa) * 0.5));
<a name="6518"/> 6518: 
<a name="6519"/> 6519: <b>fifty_percent_success</b>(F, S, Fa, N) when is_function(F, 0) -&gt;
<a name="fifty_percent_success-last_expr"/><a name="6520"/> 6520: <b>    try F</b>() of
<a name="6521"/> 6521:         _ -&gt;
<a name="6522"/> 6522: 	    fifty_percent_success(F, S+1, Fa, N-1)
<a name="6523"/> 6523:     catch
<a name="6524"/> 6524:         error:_ -&gt;
<a name="6525"/> 6525: 	    fifty_percent_success(F, S, Fa+1, N-1)
<a name="6526"/> 6526:     end.
<a name="6527"/> 6527: 
<a name="create_random_string-1"/><a name="6528"/> 6528: <b>create_random_string</b>(0) -&gt;
<a name="6529"/> 6529:     [];
<a name="6530"/> 6530: 
<a name="6531"/> 6531: <b>create_random_string</b>(OfLength) -&gt;
<a name="6532"/> 6532:     C = case rand:uniform(2) of
<a name="6533"/> 6533: 	    1 -&gt;
<a name="6534"/> 6534: 		(rand:uniform($Z - $A + 1) - 1) + $A;
<a name="6535"/> 6535: 	    _ -&gt;
<a name="6536"/> 6536: 		(rand:uniform($z - $a + 1) - 1) + $a
<a name="6537"/> 6537: 	end,
<a name="create_random_string-last_expr"/><a name="6538"/> 6538: <b>    [C | create_random_string</b>(OfLength - 1)].
<a name="6539"/> 6539: 
<a name="6540"/> 6540: 
<a name="create_random_tuple-1"/><a name="6541"/> 6541: <b>create_random_tuple</b>(OfLength) -&gt;
<a name="create_random_tuple-last_expr"/><a name="6542"/> 6542: <b>    list_to_tuple</b>(lists:map(fun(X) -&gt;
<a name="6543"/> 6543: 				    list_to_atom([X])
<a name="6544"/> 6544: 			    end,create_random_string(OfLength))).
<a name="6545"/> 6545: 
<a name="create_partly_bound_tuple-1"/><a name="6546"/> 6546: <b>create_partly_bound_tuple</b>(OfLength) -&gt;
<a name="create_partly_bound_tuple-last_expr"/><a name="6547"/> 6547: <b>    case rand:uniform</b>(2) of
<a name="6548"/> 6548: 	1 -&gt;
<a name="6549"/> 6549: 	    create_partly_bound_tuple1(OfLength);
<a name="6550"/> 6550: 	_ -&gt;
<a name="6551"/> 6551: 	    create_partly_bound_tuple3(OfLength)
<a name="6552"/> 6552:     end.
<a name="6553"/> 6553: 
<a name="create_partly_bound_tuple1-1"/><a name="6554"/> 6554: <b>create_partly_bound_tuple1</b>(OfLength) -&gt;
<a name="6555"/> 6555:     T0 = create_random_tuple(OfLength),
<a name="6556"/> 6556:     I = rand:uniform(OfLength),
<a name="create_partly_bound_tuple1-last_expr"/><a name="6557"/> 6557: <b>    setelement</b>(I,T0,'$1').
<a name="6558"/> 6558: 
<a name="6559"/> 6559: 
<a name="set_n_random_elements-4"/><a name="6560"/> 6560: <b>set_n_random_elements</b>(T0,0,_,_) -&gt;
<a name="6561"/> 6561:     T0;
<a name="6562"/> 6562: <b>set_n_random_elements</b>(T0,N,OfLength,GenFun) -&gt;
<a name="6563"/> 6563:     I = rand:uniform(OfLength),
<a name="6564"/> 6564:     What = GenFun(I),
<a name="set_n_random_elements-last_expr"/><a name="6565"/> 6565: <b>    case element</b>(I,T0) of
<a name="6566"/> 6566: 	What -&gt;
<a name="6567"/> 6567: 	    set_n_random_elements(T0,N,OfLength,GenFun);
<a name="6568"/> 6568: 	_Else -&gt;
<a name="6569"/> 6569: 	    set_n_random_elements(setelement(I,T0,What),
<a name="6570"/> 6570: 				  N-1,OfLength,GenFun)
<a name="6571"/> 6571:     end.
<a name="6572"/> 6572: 
<a name="make_dollar_atom-1"/><a name="6573"/> 6573: <b>make_dollar_atom</b>(I) -&gt;
<a name="make_dollar_atom-last_expr"/><a name="6574"/> 6574: <b>    list_to_atom</b>([$$] ++ integer_to_list(I)).
<a name="create_partly_bound_tuple2-1"/><a name="6575"/> 6575: <b>create_partly_bound_tuple2</b>(OfLength) -&gt;
<a name="6576"/> 6576:     T0 = create_random_tuple(OfLength),
<a name="6577"/> 6577:     I = rand:uniform(OfLength - 1),
<a name="create_partly_bound_tuple2-last_expr"/><a name="6578"/> 6578: <b>    set_n_random_elements</b>(T0,I,OfLength,fun make_dollar_atom/1).
<a name="6579"/> 6579: 
<a name="create_partly_bound_tuple3-1"/><a name="6580"/> 6580: <b>create_partly_bound_tuple3</b>(OfLength) -&gt;
<a name="6581"/> 6581:     T0 = create_random_tuple(OfLength),
<a name="6582"/> 6582:     I = rand:uniform(OfLength - 1),
<a name="create_partly_bound_tuple3-last_expr"/><a name="6583"/> 6583: <b>    set_n_random_elements</b>(T0,I,OfLength,fun(_) -&gt; '_' end).
<a name="6584"/> 6584: 
<a name="do_n_times-2"/><a name="6585"/> 6585: <b>do_n_times</b>(_,0) -&gt;
<a name="6586"/> 6586:     ok;
<a name="6587"/> 6587: <b>do_n_times</b>(Fun,N) -&gt;
<a name="6588"/> 6588:     Fun(),
<a name="6589"/> 6589:     case N rem 1000 of
<a name="6590"/> 6590: 	0 -&gt;
<a name="6591"/> 6591: 	    io:format(&quot;.&quot;);
<a name="6592"/> 6592: 	_ -&gt;
<a name="6593"/> 6593: 	    ok
<a name="6594"/> 6594:     end,
<a name="do_n_times-last_expr"/><a name="6595"/> 6595: <b>    do_n_times</b>(Fun,N-1).
<a name="6596"/> 6596: 
<a name="make_table-3"/><a name="6597"/> 6597: <b>make_table</b>(Name, Options, Elements) -&gt;
<a name="6598"/> 6598:     T = ets_new(Name, Options),
<a name="6599"/> 6599:     lists:foreach(fun(E) -&gt; ets:insert(T, E) end, Elements),
<a name="make_table-last_expr"/><a name="6600"/> 6600:     T.
<a name="6601"/> 6601: 
<a name="filltabint-2"/><a name="6602"/> 6602: <b>filltabint</b>(Tab,0) -&gt;
<a name="6603"/> 6603:     Tab;
<a name="6604"/> 6604: <b>filltabint</b>(Tab,N) -&gt;
<a name="6605"/> 6605:     ets:insert(Tab,{N,integer_to_list(N)}),
<a name="filltabint-last_expr"/><a name="6606"/> 6606: <b>    filltabint</b>(Tab,N-1).
<a name="6607"/> 6607: 
<a name="filltabint2-2"/><a name="6608"/> 6608: <b>filltabint2</b>(Tab,0) -&gt;
<a name="6609"/> 6609:     Tab;
<a name="6610"/> 6610: <b>filltabint2</b>(Tab,N) -&gt;
<a name="6611"/> 6611:     ets:insert(Tab,{N + N rem 2,integer_to_list(N)}),
<a name="filltabint2-last_expr"/><a name="6612"/> 6612: <b>    filltabint2</b>(Tab,N-1).
<a name="filltabint3-2"/><a name="6613"/> 6613: <b>filltabint3</b>(Tab,0) -&gt;
<a name="6614"/> 6614:     Tab;
<a name="6615"/> 6615: <b>filltabint3</b>(Tab,N) -&gt;
<a name="6616"/> 6616:     ets:insert(Tab,{N + N rem 2,integer_to_list(N + N rem 2)}),
<a name="filltabint3-last_expr"/><a name="6617"/> 6617: <b>    filltabint3</b>(Tab,N-1).
<a name="xfilltabint-2"/><a name="6618"/> 6618: <b>xfilltabint</b>(Tab,N) -&gt;
<a name="xfilltabint-last_expr"/><a name="6619"/> 6619: <b>    case ets:info</b>(Tab,type) of
<a name="6620"/> 6620: 	bag -&gt;
<a name="6621"/> 6621: 	    filltabint2(Tab,N);
<a name="6622"/> 6622: 	duplicate_bag -&gt;
<a name="6623"/> 6623: 	    ets:select_delete(Tab,[{'_',[],[true]}]),
<a name="6624"/> 6624: 	    filltabint3(Tab,N);
<a name="6625"/> 6625: 	_ -&gt;
<a name="6626"/> 6626: 	    filltabint(Tab,N)
<a name="6627"/> 6627:     end.
<a name="6628"/> 6628: 
<a name="filltabintup-2"/><a name="6629"/> 6629: <b>filltabintup</b>(Tab,0) -&gt;
<a name="6630"/> 6630:     Tab;
<a name="6631"/> 6631: <b>filltabintup</b>(Tab,N) -&gt;
<a name="6632"/> 6632:     ets:insert(Tab,{{N,integer_to_list(N)},integer_to_list(N)}),
<a name="filltabintup-last_expr"/><a name="6633"/> 6633: <b>    filltabintup</b>(Tab,N-1).
<a name="6634"/> 6634: 
<a name="filltabintup2-2"/><a name="6635"/> 6635: <b>filltabintup2</b>(Tab,0) -&gt;
<a name="6636"/> 6636:     Tab;
<a name="6637"/> 6637: <b>filltabintup2</b>(Tab,N) -&gt;
<a name="6638"/> 6638:     ets:insert(Tab,{{N + N rem 2,integer_to_list(N)},integer_to_list(N)}),
<a name="filltabintup2-last_expr"/><a name="6639"/> 6639: <b>    filltabintup2</b>(Tab,N-1).
<a name="filltabintup3-2"/><a name="6640"/> 6640: <b>filltabintup3</b>(Tab,0) -&gt;
<a name="6641"/> 6641:     Tab;
<a name="6642"/> 6642: <b>filltabintup3</b>(Tab,N) -&gt;
<a name="6643"/> 6643:     ets:insert(Tab,{{N + N rem 2,integer_to_list(N + N rem 2)},integer_to_list(N + N rem 2)}),
<a name="filltabintup3-last_expr"/><a name="6644"/> 6644: <b>    filltabintup3</b>(Tab,N-1).
<a name="6645"/> 6645: 
<a name="filltabstr-2"/><a name="6646"/> 6646: <b>filltabstr</b>(Tab,N) -&gt;
<a name="filltabstr-last_expr"/><a name="6647"/> 6647: <b>    filltabstr</b>(Tab,0,N).
<a name="filltabstr-3"/><a name="6648"/> 6648: <b>filltabstr</b>(Tab,N,N) -&gt;
<a name="6649"/> 6649:     Tab;
<a name="6650"/> 6650: <b>filltabstr</b>(Tab,Floor,N) when N &gt; Floor -&gt;
<a name="6651"/> 6651:     ets:insert(Tab,{integer_to_list(N),N}),
<a name="filltabstr-last_expr"/><a name="6652"/> 6652: <b>    filltabstr</b>(Tab,Floor,N-1).
<a name="6653"/> 6653: 
<a name="filltabstr2-2"/><a name="6654"/> 6654: <b>filltabstr2</b>(Tab,0) -&gt;
<a name="6655"/> 6655:     Tab;
<a name="6656"/> 6656: <b>filltabstr2</b>(Tab,N) -&gt;
<a name="6657"/> 6657:     ets:insert(Tab,{integer_to_list(N),N}),
<a name="6658"/> 6658:     ets:insert(Tab,{integer_to_list(N),N+1}),
<a name="filltabstr2-last_expr"/><a name="6659"/> 6659: <b>    filltabstr2</b>(Tab,N-1).
<a name="filltabstr3-2"/><a name="6660"/> 6660: <b>filltabstr3</b>(Tab,0) -&gt;
<a name="6661"/> 6661:     Tab;
<a name="6662"/> 6662: <b>filltabstr3</b>(Tab,N) -&gt;
<a name="6663"/> 6663:     ets:insert(Tab,{integer_to_list(N),N}),
<a name="6664"/> 6664:     ets:insert(Tab,{integer_to_list(N),N}),
<a name="filltabstr3-last_expr"/><a name="6665"/> 6665: <b>    filltabstr3</b>(Tab,N-1).
<a name="xfilltabstr-2"/><a name="6666"/> 6666: <b>xfilltabstr</b>(Tab,N) -&gt;
<a name="xfilltabstr-last_expr"/><a name="6667"/> 6667: <b>    case ets:info</b>(Tab,type) of
<a name="6668"/> 6668: 	bag -&gt;
<a name="6669"/> 6669: 	    filltabstr2(Tab,N);
<a name="6670"/> 6670: 	duplicate_bag -&gt;
<a name="6671"/> 6671: 	    ets:select_delete(Tab,[{'_',[],[true]}]),
<a name="6672"/> 6672: 	    filltabstr3(Tab,N);
<a name="6673"/> 6673: 	_ -&gt;
<a name="6674"/> 6674: 	    filltabstr(Tab,N)
<a name="6675"/> 6675:     end.
<a name="6676"/> 6676: 
<a name="fill_sets_int-1"/><a name="6677"/> 6677: <b>fill_sets_int</b>(N) -&gt;
<a name="fill_sets_int-last_expr"/><a name="6678"/> 6678: <b>    fill_sets_int</b>(N,[]).
<a name="fill_sets_int-2"/><a name="6679"/> 6679: <b>fill_sets_int</b>(N,Opts) -&gt;
<a name="6680"/> 6680:     Tab1 = ets_new(xxx,
<a name="6681"/> 6681:                    replace_dbg_hash_fixed_nr_of_locks([ordered_set|Opts])),
<a name="6682"/> 6682:     filltabint(Tab1,N),
<a name="6683"/> 6683:     Tab2 = ets_new(xxx, [set|Opts]),
<a name="6684"/> 6684:     filltabint(Tab2,N),
<a name="6685"/> 6685:     Tab3 = ets_new(xxx, [bag|Opts]),
<a name="6686"/> 6686:     filltabint2(Tab3,N),
<a name="6687"/> 6687:     Tab4 = ets_new(xxx, [duplicate_bag|Opts]),
<a name="6688"/> 6688:     filltabint3(Tab4,N),
<a name="fill_sets_int-last_expr"/><a name="6689"/> 6689:     [Tab1,Tab2,Tab3,Tab4].
<a name="6690"/> 6690: 
<a name="fill_sets_intup-2"/><a name="6691"/> 6691: <b>fill_sets_intup</b>(N,Opts) -&gt;
<a name="6692"/> 6692:     Tab1 = ets_new(xxx,
<a name="6693"/> 6693:                    replace_dbg_hash_fixed_nr_of_locks([ordered_set|Opts])),
<a name="6694"/> 6694:     filltabintup(Tab1,N),
<a name="6695"/> 6695:     Tab2 = ets_new(xxx, [set|Opts]),
<a name="6696"/> 6696:     filltabintup(Tab2,N),
<a name="6697"/> 6697:     Tab3 = ets_new(xxx, [bag|Opts]),
<a name="6698"/> 6698:     filltabintup2(Tab3,N),
<a name="6699"/> 6699:     Tab4 = ets_new(xxx, [duplicate_bag|Opts]),
<a name="6700"/> 6700:     filltabintup3(Tab4,N),
<a name="fill_sets_intup-last_expr"/><a name="6701"/> 6701:     [Tab1,Tab2,Tab3,Tab4].
<a name="6702"/> 6702: 
<a name="check_fun-3"/><a name="6703"/> 6703: <b>check_fun</b>(_Tab,_Fun,'$end_of_table') -&gt;
<a name="6704"/> 6704:     ok;
<a name="6705"/> 6705: <b>check_fun</b>(Tab,Fun,Item) -&gt;
<a name="6706"/> 6706:     lists:foreach(fun(Obj) -&gt;
<a name="6707"/> 6707: 			  true = Fun(Obj)
<a name="6708"/> 6708: 		  end,
<a name="6709"/> 6709: 		  ets:lookup(Tab,Item)),
<a name="check_fun-last_expr"/><a name="6710"/> 6710: <b>    check_fun</b>(Tab,Fun,ets:next(Tab,Item)).
<a name="6711"/> 6711: 
<a name="check-3"/><a name="6712"/> 6712: <b>check</b>(Tab,Fun,N) -&gt;
<a name="6713"/> 6713:     N = ets:info(Tab, size),
<a name="check-last_expr"/><a name="6714"/> 6714: <b>    check_fun</b>(Tab,Fun,ets:first(Tab)).
<a name="6715"/> 6715: 
<a name="6716"/> 6716: 
<a name="6717"/> 6717: 
<a name="del_one_by_one_set-3"/><a name="6718"/> 6718: <b>del_one_by_one_set</b>(T,N,N) -&gt;
<a name="6719"/> 6719:     0 = ets:info(T,size),
<a name="6720"/> 6720:     ok;
<a name="6721"/> 6721: <b>del_one_by_one_set</b>(T,From,To) -&gt;
<a name="6722"/> 6722:     N = ets:info(T,size),
<a name="6723"/> 6723:     ets:delete_object(T,{From, integer_to_list(From)}),
<a name="6724"/> 6724:     N = (ets:info(T,size) + 1),
<a name="6725"/> 6725:     Next = if
<a name="6726"/> 6726: 	       From &lt; To -&gt;
<a name="6727"/> 6727: 		   From + 1;
<a name="6728"/> 6728: 	       true -&gt;
<a name="6729"/> 6729: 		   From - 1
<a name="6730"/> 6730: 	   end,
<a name="del_one_by_one_set-last_expr"/><a name="6731"/> 6731: <b>    del_one_by_one_set</b>(T,Next,To).
<a name="6732"/> 6732: 
<a name="del_one_by_one_bag-3"/><a name="6733"/> 6733: <b>del_one_by_one_bag</b>(T,N,N) -&gt;
<a name="6734"/> 6734:     0 = ets:info(T,size),
<a name="6735"/> 6735:     ok;
<a name="6736"/> 6736: <b>del_one_by_one_bag</b>(T,From,To) -&gt;
<a name="6737"/> 6737:     N = ets:info(T,size),
<a name="6738"/> 6738:     ets:delete_object(T,{From + From rem 2, integer_to_list(From)}),
<a name="6739"/> 6739:     N = (ets:info(T,size) + 1),
<a name="6740"/> 6740:     Next = if
<a name="6741"/> 6741: 	       From &lt; To -&gt;
<a name="6742"/> 6742: 		   From + 1;
<a name="6743"/> 6743: 	       true -&gt;
<a name="6744"/> 6744: 		   From - 1
<a name="6745"/> 6745: 	   end,
<a name="del_one_by_one_bag-last_expr"/><a name="6746"/> 6746: <b>    del_one_by_one_bag</b>(T,Next,To).
<a name="6747"/> 6747: 
<a name="6748"/> 6748: 
<a name="del_one_by_one_dbag_1-3"/><a name="6749"/> 6749: <b>del_one_by_one_dbag_1</b>(T,N,N) -&gt;
<a name="6750"/> 6750:     0 = ets:info(T,size),
<a name="6751"/> 6751:     ok;
<a name="6752"/> 6752: <b>del_one_by_one_dbag_1</b>(T,From,To) -&gt;
<a name="6753"/> 6753:     N = ets:info(T,size),
<a name="6754"/> 6754:     ets:delete_object(T,{From, integer_to_list(From)}),
<a name="6755"/> 6755:     case From rem 2 of
<a name="6756"/> 6756: 	0 -&gt;
<a name="6757"/> 6757: 	    N = (ets:info(T,size) + 2);
<a name="6758"/> 6758: 	1 -&gt;
<a name="6759"/> 6759: 	    N = ets:info(T,size)
<a name="6760"/> 6760:     end,
<a name="6761"/> 6761:     Next = if
<a name="6762"/> 6762: 	       From &lt; To -&gt;
<a name="6763"/> 6763: 		   From + 1;
<a name="6764"/> 6764: 	       true -&gt;
<a name="6765"/> 6765: 		   From - 1
<a name="6766"/> 6766: 	   end,
<a name="del_one_by_one_dbag_1-last_expr"/><a name="6767"/> 6767: <b>    del_one_by_one_dbag_1</b>(T,Next,To).
<a name="6768"/> 6768: 
<a name="del_one_by_one_dbag_2-3"/><a name="6769"/> 6769: <b>del_one_by_one_dbag_2</b>(T,N,N) -&gt;
<a name="6770"/> 6770:     0 = ets:info(T,size),
<a name="6771"/> 6771:     ok;
<a name="6772"/> 6772: <b>del_one_by_one_dbag_2</b>(T,From,To) -&gt;
<a name="6773"/> 6773:     N = ets:info(T,size),
<a name="6774"/> 6774:     ets:delete_object(T,{From, integer_to_list(From)}),
<a name="6775"/> 6775:     case From rem 2 of
<a name="6776"/> 6776: 	0 -&gt;
<a name="6777"/> 6777: 	    N = (ets:info(T,size) + 3);
<a name="6778"/> 6778: 	1 -&gt;
<a name="6779"/> 6779: 	    N = (ets:info(T,size) + 1)
<a name="6780"/> 6780:     end,
<a name="6781"/> 6781:     Next = if
<a name="6782"/> 6782: 	       From &lt; To -&gt;
<a name="6783"/> 6783: 		   From + 1;
<a name="6784"/> 6784: 	       true -&gt;
<a name="6785"/> 6785: 		   From - 1
<a name="6786"/> 6786: 	   end,
<a name="del_one_by_one_dbag_2-last_expr"/><a name="6787"/> 6787: <b>    del_one_by_one_dbag_2</b>(T,Next,To).
<a name="6788"/> 6788: 
<a name="del_one_by_one_dbag_3-3"/><a name="6789"/> 6789: <b>del_one_by_one_dbag_3</b>(T,N,N) -&gt;
<a name="6790"/> 6790:     0 = ets:info(T,size),
<a name="6791"/> 6791:     ok;
<a name="6792"/> 6792: <b>del_one_by_one_dbag_3</b>(T,From,To) -&gt;
<a name="6793"/> 6793:     N = ets:info(T,size),
<a name="6794"/> 6794:     Obj = {From + From rem 2, integer_to_list(From)},
<a name="6795"/> 6795:     ets:delete_object(T,Obj),
<a name="6796"/> 6796:     case From rem 2 of
<a name="6797"/> 6797: 	0 -&gt;
<a name="6798"/> 6798: 	    N = (ets:info(T,size) + 2);
<a name="6799"/> 6799: 	1 -&gt;
<a name="6800"/> 6800: 	    N = (ets:info(T,size) + 1),
<a name="6801"/> 6801: 	    Obj2 = {From, integer_to_list(From)},
<a name="6802"/> 6802: 	    ets:delete_object(T,Obj2),
<a name="6803"/> 6803: 	    N = (ets:info(T,size) + 2)
<a name="6804"/> 6804:     end,
<a name="6805"/> 6805:     Next = if
<a name="6806"/> 6806: 	       From &lt; To -&gt;
<a name="6807"/> 6807: 		   From + 1;
<a name="6808"/> 6808: 	       true -&gt;
<a name="6809"/> 6809: 		   From - 1
<a name="6810"/> 6810: 	   end,
<a name="del_one_by_one_dbag_3-last_expr"/><a name="6811"/> 6811: <b>    del_one_by_one_dbag_3</b>(T,Next,To).
<a name="6812"/> 6812: 
<a name="6813"/> 6813: 
<a name="successive_delete-4"/><a name="6814"/> 6814: <b>successive_delete</b>(Table,From,To,Type) -&gt;
<a name="successive_delete-last_expr"/><a name="6815"/> 6815: <b>    successive_delete</b>(Table,From,To,Type,ets:info(Table,type)).
<a name="6816"/> 6816: 
<a name="successive_delete-5"/><a name="6817"/> 6817: <b>successive_delete</b>(_Table,N,N,_,_) -&gt;
<a name="6818"/> 6818:     ok;
<a name="6819"/> 6819: <b>successive_delete</b>(Table,From,To,Type,TType) -&gt;
<a name="6820"/> 6820:     MS = case Type of
<a name="6821"/> 6821: 	     bound -&gt;
<a name="6822"/> 6822: 		 [{{From,'_'},[],[true]}];
<a name="6823"/> 6823: 	     unbound -&gt;
<a name="6824"/> 6824: 		 [{{'$1','_'},[],[{'==', '$1', From}]}]
<a name="6825"/> 6825: 	 end,
<a name="6826"/> 6826:     case TType of
<a name="6827"/> 6827: 	X when X == bag; X == duplicate_bag -&gt;
<a name="6828"/> 6828: 	    %%erlang:display(From),
<a name="6829"/> 6829: 	    case From rem 2 of
<a name="6830"/> 6830: 		0 -&gt;
<a name="6831"/> 6831: 		    2 = ets:select_delete(Table,MS);
<a name="6832"/> 6832: 		_ -&gt;
<a name="6833"/> 6833: 		    0 = ets:select_delete(Table,MS)
<a name="6834"/> 6834: 	    end;
<a name="6835"/> 6835: 	_ -&gt;
<a name="6836"/> 6836: 	    1 = ets:select_delete(Table,MS)
<a name="6837"/> 6837:     end,
<a name="6838"/> 6838:     Next = if
<a name="6839"/> 6839: 	       From &lt; To -&gt;
<a name="6840"/> 6840: 		   From + 1;
<a name="6841"/> 6841: 	       true -&gt;
<a name="6842"/> 6842: 		   From - 1
<a name="6843"/> 6843: 	   end,
<a name="successive_delete-last_expr"/><a name="6844"/> 6844: <b>    successive_delete</b>(Table, Next, To, Type,TType).
<a name="6845"/> 6845: 
<a name="gen_dets_filename-2"/><a name="6846"/> 6846: <b>gen_dets_filename</b>(Config,N) -&gt;
<a name="gen_dets_filename-last_expr"/><a name="6847"/> 6847: <b>    filename:join</b>(proplists:get_value(priv_dir,Config),
<a name="6848"/> 6848: 		  &quot;testdets_&quot; ++ integer_to_list(N) ++ &quot;.dets&quot;).
<a name="6849"/> 6849: 
<a name="otp_6842_select_1000-1"/><a name="6850"/> 6850: <b>otp_6842_select_1000</b>(Config) when is_list(Config) -&gt;
<a name="6851"/> 6851:     repeat_for_opts_all_ord_set_table_types(
<a name="6852"/> 6852:       fun(Opts) -&gt;
<a name="6853"/> 6853:               KeyRange = 10000,
<a name="6854"/> 6854:               Tab = ets_new(xxx, Opts, KeyRange),
<a name="6855"/> 6855:               [ets:insert(Tab,{X,X}) || X &lt;- lists:seq(1,KeyRange)],
<a name="6856"/> 6856:               AllTrue = lists:duplicate(10,true),
<a name="6857"/> 6857:               AllTrue =
<a name="6858"/> 6858:                   [ length(
<a name="6859"/> 6859:                       element(1,
<a name="6860"/> 6860:                               ets:select(Tab,[{'_',[],['$_']}],X*1000))) =:=
<a name="6861"/> 6861:                         X*1000 || X &lt;- lists:seq(1,10) ],
<a name="6862"/> 6862:               Sequences = [[1000,1000,1000,1000,1000,1000,1000,1000,1000,1000],
<a name="6863"/> 6863:                            [2000,2000,2000,2000,2000],
<a name="6864"/> 6864:                            [3000,3000,3000,1000],
<a name="6865"/> 6865:                            [4000,4000,2000],
<a name="6866"/> 6866:                            [5000,5000],
<a name="6867"/> 6867:                            [6000,4000],
<a name="6868"/> 6868:                            [7000,3000],
<a name="6869"/> 6869:                            [8000,2000],
<a name="6870"/> 6870:                            [9000,1000],
<a name="6871"/> 6871:                            [10000]],
<a name="6872"/> 6872:               AllTrue = [ check_seq(Tab, ets:select(Tab,[{'_',[],['$_']}],hd(L)),L) ||
<a name="6873"/> 6873:                             L &lt;- Sequences ],
<a name="6874"/> 6874:               ets:delete(Tab)
<a name="6875"/> 6875:       end),
<a name="otp_6842_select_1000-last_expr"/><a name="6876"/> 6876:     ok.
<a name="6877"/> 6877: 
<a name="check_seq-3"/><a name="6878"/> 6878: <b>check_seq</b>(_,'$end_of_table',[]) -&gt;
<a name="6879"/> 6879:     true;
<a name="6880"/> 6880: <b>check_seq</b>(Tab,{L,C},[H|T]) when length(L) =:= H -&gt;
<a name="6881"/> 6881:     check_seq(Tab, ets:select(C),T);
<a name="6882"/> 6882: <b>check_seq</b>(A,B,C) -&gt;
<a name="6883"/> 6883:     erlang:display({A,B,C}),
<a name="check_seq-last_expr"/><a name="6884"/> 6884:     false.
<a name="6885"/> 6885: 
<a name="otp_6338-1"/><a name="6886"/> 6886: <b>otp_6338</b>(Config) when is_list(Config) -&gt;
<a name="6887"/> 6887:     repeat_for_opts_all_ord_set_table_types(
<a name="6888"/> 6888:       fun(Opts) -&gt;
<a name="6889"/> 6889:               L = binary_to_term(&lt;&lt;131,108,0,0,0,2,104,2,108,0,0,0,2,103,100,0,19,112,112,
<a name="6890"/> 6890:                                    98,49,95,98,115,49,50,64,98,108,97,100,101,95,48,95,53,
<a name="6891"/> 6891:                                    0,0,33,50,0,0,0,4,1,98,0,0,23,226,106,100,0,4,101,120,
<a name="6892"/> 6892:                                    105,116,104,2,108,0,0,0,2,104,2,100,0,3,115,98,109,100,
<a name="6893"/> 6893:                                    0,19,112,112,98,50,95,98,115,49,50,64,98,108,97,100,
<a name="6894"/> 6894:                                    101,95,48,95,56,98,0,0,18,231,106,100,0,4,114,101,99,
<a name="6895"/> 6895:                                    118,106&gt;&gt;),
<a name="6896"/> 6896:               T = ets_new(xxx,Opts),
<a name="6897"/> 6897:               lists:foreach(fun(X) -&gt; ets:insert(T,X) end,L),
<a name="6898"/> 6898:               [[4839,recv]] = ets:match(T,{[{sbm,ppb2_bs12@blade_0_8},'$1'],'$2'}),
<a name="6899"/> 6899:               ets:delete(T)
<a name="6900"/> 6900:       end),
<a name="otp_6338-last_expr"/><a name="6901"/> 6901:     ok.
<a name="6902"/> 6902: 
<a name="6903"/> 6903: <i>%% OTP-15660: Verify select not doing excessive trapping</i>
<a name="6904"/> 6904: <i>%%            when process have mbuf heap fragments.</i>
<a name="select_mbuf_trapping-1"/><a name="6905"/> 6905: <b>select_mbuf_trapping</b>(Config) when is_list(Config) -&gt;
<a name="6906"/> 6906:     select_mbuf_trapping_do(set),
<a name="select_mbuf_trapping-last_expr"/><a name="6907"/> 6907: <b>    select_mbuf_trapping_do</b>(ordered_set).
<a name="6908"/> 6908: 
<a name="select_mbuf_trapping_do-1"/><a name="6909"/> 6909: <b>select_mbuf_trapping_do</b>(Type) -&gt;
<a name="6910"/> 6910:     T = ets:new(xxx, [Type]),
<a name="6911"/> 6911:     NKeys = 50,
<a name="6912"/> 6912:     [ets:insert(T, {K, value}) || K &lt;- lists:seq(1,NKeys)],
<a name="6913"/> 6913: 
<a name="6914"/> 6914:     {priority, Prio} = process_info(self(), priority),
<a name="6915"/> 6915:     Tracee = self(),
<a name="6916"/> 6916:     [SchedTracer]
<a name="6917"/> 6917: 	= start_loopers(1, Prio,
<a name="6918"/> 6918: 			fun (SC) -&gt;
<a name="6919"/> 6919: 				receive
<a name="6920"/> 6920: 				    {trace, Tracee, out, _} -&gt;
<a name="6921"/> 6921: 					SC+1;
<a name="6922"/> 6922: 				    done -&gt;
<a name="6923"/> 6923: 					Tracee ! {schedule_count, SC},
<a name="6924"/> 6924:                                         exit(normal)
<a name="6925"/> 6925: 				end
<a name="6926"/> 6926: 			end,
<a name="6927"/> 6927: 			0),
<a name="6928"/> 6928: 
<a name="6929"/> 6929:     erlang:garbage_collect(),
<a name="6930"/> 6930:     1 = erlang:trace(self(), true, [running,{tracer,SchedTracer}]),
<a name="6931"/> 6931: 
<a name="6932"/> 6932:     %% Artificially create an mbuf heap fragment
<a name="6933"/> 6933:     MbufTerm = &quot;Frag me up&quot;,
<a name="6934"/> 6934:     MbufTerm = erts_debug:set_internal_state(mbuf, MbufTerm),
<a name="6935"/> 6935: 
<a name="6936"/> 6936:     Keys = ets:select(T, [{{'$1', value}, [], ['$1']}]),
<a name="6937"/> 6937:     NKeys = length(Keys),
<a name="6938"/> 6938: 
<a name="6939"/> 6939:     1 = erlang:trace(self(), false, [running]),
<a name="6940"/> 6940:     Ref = erlang:trace_delivered(Tracee),
<a name="6941"/> 6941:     receive
<a name="6942"/> 6942:         {trace_delivered, Tracee, Ref} -&gt;
<a name="6943"/> 6943:             SchedTracer ! done
<a name="6944"/> 6944:     end,
<a name="6945"/> 6945:     receive
<a name="6946"/> 6946: 	{schedule_count, N} -&gt;
<a name="6947"/> 6947: 	    io:format(&quot;~p context switches: ~p&quot;, [Type,N]),
<a name="6948"/> 6948: 	    if
<a name="6949"/> 6949: 		N &lt; 3 -&gt; ok;
<a name="6950"/> 6950: 		true -&gt; ct:fail(failed)
<a name="6951"/> 6951: 	    end
<a name="6952"/> 6952:     end,
<a name="6953"/> 6953:     true = ets:delete(T),
<a name="select_mbuf_trapping_do-last_expr"/><a name="6954"/> 6954:     ok.
<a name="6955"/> 6955: 
<a name="6956"/> 6956: 
<a name="6957"/> 6957: 
<a name="6958"/> 6958: <i>%% Elements could come in the wrong order in a bag if a rehash occurred.</i>
<a name="otp_5340-1"/><a name="6959"/> 6959: <b>otp_5340</b>(Config) when is_list(Config) -&gt;
<a name="otp_5340-last_expr"/><a name="6960"/> 6960: <b>    repeat_for_opts</b>(fun otp_5340_do/1).
<a name="6961"/> 6961: 
<a name="otp_5340_do-1"/><a name="6962"/> 6962: <b>otp_5340_do</b>(Opts) -&gt;
<a name="6963"/> 6963:     N = 3000,
<a name="6964"/> 6964:     T = ets_new(otp_5340, [bag,public | Opts]),
<a name="6965"/> 6965:     Ids = [1,2,3,4,5],
<a name="6966"/> 6966:     [w(T, N, Id) || Id &lt;- Ids],
<a name="6967"/> 6967:     verify(T, Ids),
<a name="otp_5340_do-last_expr"/><a name="6968"/> 6968: <b>    ets:delete</b>(T).
<a name="6969"/> 6969: 
<a name="w-3"/><a name="6970"/> 6970: <b>w</b>(_,0, _) -&gt; ok;
<a name="6971"/> 6971: <b>w</b>(T,N, Id) -&gt;
<a name="6972"/> 6972:     ets:insert(T, {N, Id}),
<a name="w-last_expr"/><a name="6973"/> 6973: <b>    w</b>(T,N-1,Id).
<a name="6974"/> 6974: 
<a name="verify-2"/><a name="6975"/> 6975: <b>verify</b>(T, Ids) -&gt;
<a name="6976"/> 6976:     List = my_tab_to_list(T),
<a name="6977"/> 6977:     Errors = lists:filter(fun(Bucket) -&gt;
<a name="6978"/> 6978: 				  verify2(Bucket, Ids)
<a name="6979"/> 6979: 			  end, List),
<a name="verify-last_expr"/><a name="6980"/> 6980:     case Errors of
<a name="6981"/> 6981: 	[] -&gt;
<a name="6982"/> 6982: 	    ok;
<a name="6983"/> 6983: 	_ -&gt;
<a name="6984"/> 6984: 	    io:format(&quot;Failed:\n~p\n&quot;, [Errors]),
<a name="6985"/> 6985: 	    ct:fail(failed)
<a name="6986"/> 6986:     end.
<a name="6987"/> 6987: 
<a name="verify2-2"/><a name="6988"/> 6988: <b>verify2</b>([{_N,Id}|RL], [Id|R]) -&gt;
<a name="6989"/> 6989:     verify2(RL,R);
<a name="6990"/> 6990: <b>verify2</b>([],[]) -&gt; false;
<a name="6991"/> 6991: <b>verify2</b>(_Err, _) -&gt;
<a name="verify2-last_expr"/><a name="6992"/> 6992:     true.
<a name="6993"/> 6993: 
<a name="6994"/> 6994: <i>%% delete_object followed by delete on fixed bag failed to delete objects.</i>
<a name="otp_7665-1"/><a name="6995"/> 6995: <b>otp_7665</b>(Config) when is_list(Config) -&gt;
<a name="otp_7665-last_expr"/><a name="6996"/> 6996: <b>    repeat_for_opts</b>(fun otp_7665_do/1).
<a name="6997"/> 6997: 
<a name="otp_7665_do-1"/><a name="6998"/> 6998: <b>otp_7665_do</b>(Opts) -&gt;
<a name="6999"/> 6999:     Tab = ets_new(otp_7665,[bag | Opts]),
<a name="7000"/> 7000:     Min = 0,
<a name="7001"/> 7001:     Max = 10,
<a name="7002"/> 7002:     lists:foreach(fun(N)-&gt; otp_7665_act(Tab,Min,Max,N) end,
<a name="7003"/> 7003: 		  lists:seq(Min,Max)),
<a name="otp_7665_do-last_expr"/><a name="7004"/> 7004: <b>    true = ets:delete</b>(Tab).
<a name="7005"/> 7005: 
<a name="otp_7665_act-4"/><a name="7006"/> 7006: <b>otp_7665_act</b>(Tab,Min,Max,DelNr) -&gt;
<a name="7007"/> 7007:     List1 = [{key,N} || N &lt;- lists:seq(Min,Max)],
<a name="7008"/> 7008:     true = ets:insert(Tab, List1),
<a name="7009"/> 7009:     true = ets:safe_fixtable(Tab, true),
<a name="7010"/> 7010:     true = ets:delete_object(Tab, {key,DelNr}),
<a name="7011"/> 7011:     List2 = lists:sort(lists:delete({key,DelNr}, List1)),
<a name="7012"/> 7012: 
<a name="7013"/> 7013:     %% Now verify that we find all remaining objects
<a name="7014"/> 7014:     List2 = lists:sort(ets:lookup(Tab,key)),
<a name="7015"/> 7015:     EList2 = lists:sort(lists:map(fun({key,N})-&gt; N end,
<a name="7016"/> 7016:                                   List2)),
<a name="7017"/> 7017:     EList2 = lists:sort(ets:lookup_element(Tab,key,2)),
<a name="7018"/> 7018:     true = ets:delete(Tab, key),
<a name="7019"/> 7019:     [] = ets:lookup(Tab, key),
<a name="7020"/> 7020:     true = ets:safe_fixtable(Tab, false),
<a name="otp_7665_act-last_expr"/><a name="7021"/> 7021:     ok.
<a name="7022"/> 7022: 
<a name="7023"/> 7023: <i>%% Whitebox testing of meta name table hashing.</i>
<a name="meta_wb-1"/><a name="7024"/> 7024: <b>meta_wb</b>(Config) when is_list(Config) -&gt;
<a name="7025"/> 7025:     EtsMem = etsmem(),
<a name="7026"/> 7026:     repeat_for_opts_all_non_stim_table_types(fun meta_wb_do/1),
<a name="meta_wb-last_expr"/><a name="7027"/> 7027: <b>    verify_etsmem</b>(EtsMem).
<a name="7028"/> 7028: 
<a name="7029"/> 7029: 
<a name="meta_wb_do-1"/><a name="7030"/> 7030: <b>meta_wb_do</b>(Opts) -&gt;
<a name="7031"/> 7031:     %% Do random new/delete/rename of colliding named tables
<a name="7032"/> 7032:     Names0 = [pioneer | colliding_names(pioneer)],
<a name="7033"/> 7033: 
<a name="7034"/> 7034:     %% Remove any names that happen to exist as tables already
<a name="7035"/> 7035:     Names = lists:filter(fun(Name) -&gt; ets:info(Name) == undefined end,
<a name="7036"/> 7036:                          Names0),
<a name="7037"/> 7037:     Len = length(Names),
<a name="7038"/> 7038:     OpFuns = {fun meta_wb_new/4, fun meta_wb_delete/4, fun meta_wb_rename/4},
<a name="7039"/> 7039: 
<a name="7040"/> 7040:     true = (Len &gt;= 3),
<a name="7041"/> 7041: 
<a name="7042"/> 7042:     io:format(&quot;Colliding names = ~p\n&quot;,[Names]),
<a name="7043"/> 7043:     F = fun(0,_,_) -&gt; ok;
<a name="7044"/> 7044: 	   (N,Tabs,Me) -&gt;
<a name="7045"/> 7045: 		Name1 = lists:nth(rand:uniform(Len), Names),
<a name="7046"/> 7046: 		Name2 = lists:nth(rand:uniform(Len), Names),
<a name="7047"/> 7047: 		Op = element(rand:uniform(3),OpFuns),
<a name="7048"/> 7048: 		NTabs = Op(Name1, Name2, Tabs, Opts),
<a name="7049"/> 7049: 		Me(N-1, NTabs, Me)
<a name="7050"/> 7050: 	end,
<a name="7051"/> 7051:     F(Len*100, [], F),
<a name="7052"/> 7052: 
<a name="7053"/> 7053:     %% cleanup
<a name="meta_wb_do-last_expr"/><a name="7054"/> 7054: <b>    lists:foreach</b>(fun(Name)-&gt;catch ets:delete(Name) end,
<a name="7055"/> 7055: 		  Names).
<a name="7056"/> 7056: 
<a name="meta_wb_new-4"/><a name="7057"/> 7057: <b>meta_wb_new</b>(Name, _, Tabs, Opts) -&gt;
<a name="meta_wb_new-last_expr"/><a name="7058"/> 7058: <b>    case </b>(catch ets_new(Name,[named_table|Opts])) of
<a name="7059"/> 7059: 	Name -&gt;
<a name="7060"/> 7060: 	    false = lists:member(Name, Tabs),
<a name="7061"/> 7061: 	    [Name | Tabs];
<a name="7062"/> 7062: 	{'EXIT',{badarg,_}} -&gt;
<a name="7063"/> 7063: 	    true = lists:member(Name, Tabs),
<a name="7064"/> 7064: 	    Tabs
<a name="7065"/> 7065:     end.
<a name="meta_wb_delete-4"/><a name="7066"/> 7066: <b>meta_wb_delete</b>(Name, _, Tabs, _) -&gt;
<a name="meta_wb_delete-last_expr"/><a name="7067"/> 7067: <b>    case </b>(catch ets:delete(Name)) of
<a name="7068"/> 7068: 	true -&gt;
<a name="7069"/> 7069: 	    true = lists:member(Name, Tabs),
<a name="7070"/> 7070: 	    lists:delete(Name, Tabs);
<a name="7071"/> 7071: 	{'EXIT',{badarg,_}} -&gt;
<a name="7072"/> 7072: 	    false = lists:member(Name, Tabs),
<a name="7073"/> 7073: 	    Tabs
<a name="7074"/> 7074:     end.
<a name="meta_wb_rename-4"/><a name="7075"/> 7075: <b>meta_wb_rename</b>(Old, New, Tabs, _) -&gt;
<a name="meta_wb_rename-last_expr"/><a name="7076"/> 7076: <b>    case </b>(catch ets:rename(Old,New)) of
<a name="7077"/> 7077: 	New -&gt;
<a name="7078"/> 7078: 	    true = lists:member(Old, Tabs)
<a name="7079"/> 7079: 		andalso not lists:member(New, Tabs),
<a name="7080"/> 7080: 	    [New | lists:delete(Old, Tabs)];
<a name="7081"/> 7081: 	{'EXIT',{badarg,_}} -&gt;
<a name="7082"/> 7082: 	    true = not lists:member(Old, Tabs)
<a name="7083"/> 7083: 		orelse lists:member(New,Tabs),
<a name="7084"/> 7084: 	    Tabs
<a name="7085"/> 7085:     end.
<a name="7086"/> 7086: 
<a name="7087"/> 7087: 
<a name="colliding_names-1"/><a name="7088"/> 7088: <b>colliding_names</b>(Name) -&gt;
<a name="colliding_names-last_expr"/><a name="7089"/> 7089: <b>    erts_debug:set_internal_state</b>(colliding_names, {Name,5}).
<a name="7090"/> 7090: 
<a name="7091"/> 7091: 
<a name="7092"/> 7092: <i>%% OTP_6913: Grow and shrink.</i>
<a name="7093"/> 7093: 
<a name="grow_shrink-1"/><a name="7094"/> 7094: <b>grow_shrink</b>(Config) when is_list(Config) -&gt;
<a name="grow_shrink-last_expr"/><a name="7095"/> 7095: <b>    repeat_for_all_set_table_types</b>(
<a name="7096"/> 7096:       fun(Opts) -&gt;
<a name="7097"/> 7097:               EtsMem = etsmem(),
<a name="7098"/> 7098:               
<a name="7099"/> 7099:               Set = ets_new(a, Opts, 5000),
<a name="7100"/> 7100:               grow_shrink_0(0, 3071, 3000, 5000, Set),
<a name="7101"/> 7101:               ets:delete(Set),
<a name="7102"/> 7102:               
<a name="7103"/> 7103:               verify_etsmem(EtsMem)
<a name="7104"/> 7104:       end).
<a name="7105"/> 7105: 
<a name="grow_shrink_0-5"/><a name="7106"/> 7106: <b>grow_shrink_0</b>(N, _, _, Max, _) when N &gt;= Max -&gt;
<a name="7107"/> 7107:     ok;
<a name="7108"/> 7108: <b>grow_shrink_0</b>(N0, GrowN, ShrinkN, Max, T) -&gt;
<a name="7109"/> 7109:     N1 = grow_shrink_1(N0, GrowN, ShrinkN, T),
<a name="grow_shrink_0-last_expr"/><a name="7110"/> 7110: <b>    grow_shrink_0</b>(N1, GrowN, ShrinkN, Max, T).
<a name="7111"/> 7111: 
<a name="grow_shrink_1-4"/><a name="7112"/> 7112: <b>grow_shrink_1</b>(N0, GrowN, ShrinkN, T) -&gt;
<a name="7113"/> 7113:     N1 = grow_shrink_2(N0+1, N0 + GrowN, T),
<a name="grow_shrink_1-last_expr"/><a name="7114"/> 7114: <b>    grow_shrink_3</b>(N1, N1 - ShrinkN, T).
<a name="7115"/> 7115: 
<a name="grow_shrink_2-3"/><a name="7116"/> 7116: <b>grow_shrink_2</b>(N, GrowTo, _) when N &gt; GrowTo -&gt;
<a name="7117"/> 7117:     GrowTo;
<a name="7118"/> 7118: <b>grow_shrink_2</b>(N, GrowTo, T) -&gt;
<a name="7119"/> 7119:     true = ets:insert(T, {N,a}),
<a name="grow_shrink_2-last_expr"/><a name="7120"/> 7120: <b>    grow_shrink_2</b>(N+1, GrowTo, T).
<a name="7121"/> 7121: 
<a name="grow_shrink_3-3"/><a name="7122"/> 7122: <b>grow_shrink_3</b>(N, ShrinkTo, _) when N =&lt; ShrinkTo -&gt;
<a name="7123"/> 7123:     ShrinkTo;
<a name="7124"/> 7124: <b>grow_shrink_3</b>(N, ShrinkTo, T) -&gt;
<a name="7125"/> 7125:     true = ets:delete(T, N),
<a name="grow_shrink_3-last_expr"/><a name="7126"/> 7126: <b>    grow_shrink_3</b>(N-1, ShrinkTo, T).
<a name="7127"/> 7127: 
<a name="7128"/> 7128: <i>%% Grow a hash table that still contains pseudo-deleted objects.</i>
<a name="grow_pseudo_deleted-1"/><a name="7129"/> 7129: <b>grow_pseudo_deleted</b>(Config) when is_list(Config) -&gt;
<a name="grow_pseudo_deleted-last_expr"/><a name="7130"/> 7130: <b>    only_if_smp</b>(fun() -&gt; grow_pseudo_deleted_do() end).
<a name="7131"/> 7131: 
<a name="grow_pseudo_deleted_do-0"/><a name="7132"/> 7132: <b>grow_pseudo_deleted_do</b>() -&gt;
<a name="grow_pseudo_deleted_do-last_expr"/><a name="7133"/> 7133: <b>    lists:foreach</b>(fun(Type) -&gt; grow_pseudo_deleted_do(Type) end,
<a name="7134"/> 7134: 		  [set,bag,duplicate_bag]).
<a name="7135"/> 7135: 
<a name="grow_pseudo_deleted_do-1"/><a name="7136"/> 7136: <b>grow_pseudo_deleted_do</b>(Type) -&gt;
<a name="7137"/> 7137:     process_flag(scheduler,1),
<a name="7138"/> 7138:     Self = self(),
<a name="7139"/> 7139:     T = ets_new(kalle,[Type,public,{write_concurrency,true}]),
<a name="7140"/> 7140:     Mod = 7, Mult = 10000,
<a name="7141"/> 7141:     filltabint(T,Mod*Mult),
<a name="7142"/> 7142:     true = ets:safe_fixtable(T,true),
<a name="7143"/> 7143:     Mult = ets:select_delete(T,
<a name="7144"/> 7144: 			     [{{'$1', '_'},
<a name="7145"/> 7145: 			       [{'=:=', {'rem', '$1', Mod}, 0}],
<a name="7146"/> 7146: 			       [true]}]),
<a name="7147"/> 7147:     Left = Mult*(Mod-1),
<a name="7148"/> 7148:     Left = ets:info(T,size),
<a name="7149"/> 7149:     Mult = get_kept_objects(T),
<a name="7150"/> 7150:     filltabstr(T,Mult),
<a name="7151"/> 7151:     my_spawn_opt(
<a name="7152"/> 7152:       fun() -&gt;
<a name="7153"/> 7153: 	      true = ets:info(T,fixed),
<a name="7154"/> 7154: 	      Self ! start,
<a name="7155"/> 7155: 	      io:put_chars(&quot;Starting to filltabstr...\n&quot;),
<a name="7156"/> 7156: 	      do_tc(fun() -&gt;
<a name="7157"/> 7157: 			    filltabstr(T, Mult, Mult+10000)
<a name="7158"/> 7158: 		    end,
<a name="7159"/> 7159: 		    fun(Elapsed) -&gt;
<a name="7160"/> 7160: 			    io:format(&quot;Done with filltabstr in ~p ms\n&quot;,
<a name="7161"/> 7161: 				      [Elapsed])
<a name="7162"/> 7162: 		    end),
<a name="7163"/> 7163: 	      Self ! done
<a name="7164"/> 7164:       end, [link, {scheduler,2}]),
<a name="7165"/> 7165:     start = receive_any(),
<a name="7166"/> 7166:     io:format(&quot;Unfixing table... nitems=~p\n&quot;, [ets:info(T, size)]),
<a name="7167"/> 7167:     do_tc(fun() -&gt;
<a name="7168"/> 7168: 		  true = ets:safe_fixtable(T, false)
<a name="7169"/> 7169: 	  end,
<a name="7170"/> 7170: 	  fun(Elapsed) -&gt;
<a name="7171"/> 7171: 		  io:format(&quot;Unfix table done in ~p ms. nitems=~p\n&quot;,
<a name="7172"/> 7172: 			    [Elapsed,ets:info(T, size)])
<a name="7173"/> 7173: 	  end),
<a name="7174"/> 7174:     false = ets:info(T,fixed),
<a name="7175"/> 7175:     0 = get_kept_objects(T),
<a name="7176"/> 7176:     done = receive_any(),
<a name="7177"/> 7177:     %%verify_table_load(T), % may fail if concurrency is poor (genny)
<a name="7178"/> 7178:     ets:delete(T),
<a name="grow_pseudo_deleted_do-last_expr"/><a name="7179"/> 7179: <b>    process_flag</b>(scheduler,0).
<a name="7180"/> 7180: 
<a name="7181"/> 7181: <i>%% Shrink a hash table that still contains pseudo-deleted objects.</i>
<a name="shrink_pseudo_deleted-1"/><a name="7182"/> 7182: <b>shrink_pseudo_deleted</b>(Config) when is_list(Config) -&gt;
<a name="shrink_pseudo_deleted-last_expr"/><a name="7183"/> 7183: <b>    only_if_smp</b>(fun()-&gt;shrink_pseudo_deleted_do() end).
<a name="7184"/> 7184: 
<a name="shrink_pseudo_deleted_do-0"/><a name="7185"/> 7185: <b>shrink_pseudo_deleted_do</b>() -&gt;
<a name="shrink_pseudo_deleted_do-last_expr"/><a name="7186"/> 7186: <b>    lists:foreach</b>(fun(Type) -&gt; shrink_pseudo_deleted_do(Type) end,
<a name="7187"/> 7187: 		  [set,bag,duplicate_bag]).
<a name="7188"/> 7188: 
<a name="shrink_pseudo_deleted_do-1"/><a name="7189"/> 7189: <b>shrink_pseudo_deleted_do</b>(Type) -&gt;
<a name="7190"/> 7190:     process_flag(scheduler,1),
<a name="7191"/> 7191:     Self = self(),
<a name="7192"/> 7192:     T = ets_new(kalle,[Type,public,{write_concurrency,true}]),
<a name="7193"/> 7193:     Half = 10000,
<a name="7194"/> 7194:     filltabint(T,Half*2),
<a name="7195"/> 7195:     true = ets:safe_fixtable(T,true),
<a name="7196"/> 7196:     Half = ets:select_delete(T,
<a name="7197"/> 7197: 			     [{{'$1', '_'},
<a name="7198"/> 7198: 			       [{'&gt;', '$1', Half}],
<a name="7199"/> 7199: 			       [true]}]),
<a name="7200"/> 7200:     Half = ets:info(T,size),
<a name="7201"/> 7201:     Half = get_kept_objects(T),
<a name="7202"/> 7202:     my_spawn_opt(
<a name="7203"/> 7203:       fun()-&gt; true = ets:info(T,fixed),
<a name="7204"/> 7204: 	      Self ! start,
<a name="7205"/> 7205: 	      io:put_chars(&quot;Starting to delete... ~p\n&quot;),
<a name="7206"/> 7206: 	      do_tc(fun() -&gt;
<a name="7207"/> 7207: 			    del_one_by_one_set(T, 1, Half+1)
<a name="7208"/> 7208: 		    end,
<a name="7209"/> 7209: 		    fun(Elapsed) -&gt;
<a name="7210"/> 7210: 			    io:format(&quot;Done with delete in ~p ms.\n&quot;,
<a name="7211"/> 7211: 				      [Elapsed])
<a name="7212"/> 7212: 		    end),
<a name="7213"/> 7213: 	      Self ! done
<a name="7214"/> 7214:       end, [link, {scheduler,2}]),
<a name="7215"/> 7215:     start = receive_any(),
<a name="7216"/> 7216:     io:format(&quot;Unfixing table... nitems=~p\n&quot;, [ets:info(T, size)]),
<a name="7217"/> 7217:     do_tc(fun() -&gt;
<a name="7218"/> 7218: 		  true = ets:safe_fixtable(T, false)
<a name="7219"/> 7219: 	  end,
<a name="7220"/> 7220: 	  fun(Elapsed) -&gt;
<a name="7221"/> 7221: 		  io:format(&quot;Unfix table done in ~p ms. nitems=~p\n&quot;,
<a name="7222"/> 7222: 			    [Elapsed,ets:info(T, size)])
<a name="7223"/> 7223: 	  end),
<a name="7224"/> 7224:     false = ets:info(T,fixed),
<a name="7225"/> 7225:     0 = get_kept_objects(T),
<a name="7226"/> 7226:     done = receive_any(),
<a name="7227"/> 7227:     %%verify_table_load(T), % may fail if concurrency is poor (genny)
<a name="7228"/> 7228:     ets:delete(T),
<a name="shrink_pseudo_deleted_do-last_expr"/><a name="7229"/> 7229: <b>    process_flag</b>(scheduler,0).
<a name="7230"/> 7230: 
<a name="7231"/> 7231: 
<a name="7232"/> 7232: 
<a name="meta_lookup_unnamed_read-1"/><a name="7233"/> 7233: <b>meta_lookup_unnamed_read</b>(Config) when is_list(Config) -&gt;
<a name="7234"/> 7234:     InitF = fun(_) -&gt; Tab = ets_new(unnamed,[]),
<a name="7235"/> 7235: 		      true = ets:insert(Tab,{key,data}),
<a name="7236"/> 7236: 		      Tab
<a name="7237"/> 7237: 	    end,
<a name="7238"/> 7238:     ExecF = fun(Tab) -&gt; [{key,data}] = ets:lookup(Tab,key),
<a name="7239"/> 7239: 			Tab
<a name="7240"/> 7240: 	    end,
<a name="7241"/> 7241:     FiniF = fun(Tab) -&gt; true = ets:delete(Tab)
<a name="7242"/> 7242: 	    end,
<a name="meta_lookup_unnamed_read-last_expr"/><a name="7243"/> 7243: <b>    run_smp_workers</b>(InitF,ExecF,FiniF,10000).
<a name="7244"/> 7244: 
<a name="meta_lookup_unnamed_write-1"/><a name="7245"/> 7245: <b>meta_lookup_unnamed_write</b>(Config) when is_list(Config) -&gt;
<a name="7246"/> 7246:     InitF = fun(_) -&gt; Tab = ets_new(unnamed,[]),
<a name="7247"/> 7247: 		      {Tab,0}
<a name="7248"/> 7248: 	    end,
<a name="7249"/> 7249:     ExecF = fun({Tab,N}) -&gt; true = ets:insert(Tab,{key,N}),
<a name="7250"/> 7250: 			    {Tab,N+1}
<a name="7251"/> 7251: 	    end,
<a name="7252"/> 7252:     FiniF = fun({Tab,_}) -&gt; true = ets:delete(Tab)
<a name="7253"/> 7253: 	    end,
<a name="meta_lookup_unnamed_write-last_expr"/><a name="7254"/> 7254: <b>    run_smp_workers</b>(InitF,ExecF,FiniF,10000).
<a name="7255"/> 7255: 
<a name="meta_lookup_named_read-1"/><a name="7256"/> 7256: <b>meta_lookup_named_read</b>(Config) when is_list(Config) -&gt;
<a name="7257"/> 7257:     InitF = fun([ProcN|_]) -&gt; Name = list_to_atom(integer_to_list(ProcN)),
<a name="7258"/> 7258: 			      Tab = ets_new(Name,[named_table]),
<a name="7259"/> 7259: 			      true = ets:insert(Tab,{key,data}),
<a name="7260"/> 7260: 			      Tab
<a name="7261"/> 7261: 	    end,
<a name="7262"/> 7262:     ExecF = fun(Tab) -&gt; [{key,data}] = ets:lookup(Tab,key),
<a name="7263"/> 7263: 			Tab
<a name="7264"/> 7264: 	    end,
<a name="7265"/> 7265:     FiniF = fun(Tab) -&gt; true = ets:delete(Tab)
<a name="7266"/> 7266: 	    end,
<a name="meta_lookup_named_read-last_expr"/><a name="7267"/> 7267: <b>    run_smp_workers</b>(InitF,ExecF,FiniF,10000).
<a name="7268"/> 7268: 
<a name="meta_lookup_named_write-1"/><a name="7269"/> 7269: <b>meta_lookup_named_write</b>(Config) when is_list(Config) -&gt;
<a name="7270"/> 7270:     InitF = fun([ProcN|_]) -&gt; Name = list_to_atom(integer_to_list(ProcN)),
<a name="7271"/> 7271: 			      Tab = ets_new(Name,[named_table]),
<a name="7272"/> 7272: 			      {Tab,0}
<a name="7273"/> 7273: 	    end,
<a name="7274"/> 7274:     ExecF = fun({Tab,N}) -&gt; true = ets:insert(Tab,{key,N}),
<a name="7275"/> 7275: 			    {Tab,N+1}
<a name="7276"/> 7276: 	    end,
<a name="7277"/> 7277:     FiniF = fun({Tab,_}) -&gt; true = ets:delete(Tab)
<a name="7278"/> 7278: 	    end,
<a name="meta_lookup_named_write-last_expr"/><a name="7279"/> 7279: <b>    run_smp_workers</b>(InitF,ExecF,FiniF,10000).
<a name="7280"/> 7280: 
<a name="meta_newdel_unnamed-1"/><a name="7281"/> 7281: <b>meta_newdel_unnamed</b>(Config) when is_list(Config) -&gt;
<a name="7282"/> 7282:     InitF = fun(_) -&gt; ok end,
<a name="7283"/> 7283:     ExecF = fun(_) -&gt; Tab = ets_new(unnamed,[]),
<a name="7284"/> 7284: 		      true = ets:delete(Tab)
<a name="7285"/> 7285: 	    end,
<a name="7286"/> 7286:     FiniF = fun(_) -&gt; ok end,
<a name="meta_newdel_unnamed-last_expr"/><a name="7287"/> 7287: <b>    run_smp_workers</b>(InitF,ExecF,FiniF,10000).
<a name="7288"/> 7288: 
<a name="meta_newdel_named-1"/><a name="7289"/> 7289: <b>meta_newdel_named</b>(Config) when is_list(Config) -&gt;
<a name="7290"/> 7290:     InitF = fun([ProcN|_]) -&gt; list_to_atom(integer_to_list(ProcN))
<a name="7291"/> 7291: 	    end,
<a name="7292"/> 7292:     ExecF = fun(Name) -&gt; Name = ets_new(Name,[named_table]),
<a name="7293"/> 7293: 			 true = ets:delete(Name),
<a name="7294"/> 7294: 			 Name
<a name="7295"/> 7295: 	    end,
<a name="7296"/> 7296:     FiniF = fun(_) -&gt; ok end,
<a name="meta_newdel_named-last_expr"/><a name="7297"/> 7297: <b>    run_smp_workers</b>(InitF,ExecF,FiniF,10000).
<a name="7298"/> 7298: 
<a name="7299"/> 7299: <i>%% Concurrent insert's on same table.</i>
<a name="smp_insert-1"/><a name="7300"/> 7300: <b>smp_insert</b>(Config) when is_list(Config) -&gt;
<a name="smp_insert-last_expr"/><a name="7301"/> 7301: <b>    repeat_for_opts</b>(fun smp_insert_do/1,
<a name="7302"/> 7302:                     [[set,ordered_set,stim_cat_ord_set]]).
<a name="7303"/> 7303: 
<a name="smp_insert_do-1"/><a name="7304"/> 7304: <b>smp_insert_do</b>(Opts) -&gt;
<a name="7305"/> 7305:     KeyRange = 10000,
<a name="7306"/> 7306:     ets_new(smp_insert,[named_table,public,{write_concurrency,true}|Opts],
<a name="7307"/> 7307:             KeyRange),
<a name="7308"/> 7308:     InitF = fun(_) -&gt; ok end,
<a name="7309"/> 7309:     ExecF = fun(_) -&gt; true = ets:insert(smp_insert,{rand:uniform(KeyRange)})
<a name="7310"/> 7310:             end,
<a name="7311"/> 7311:     FiniF = fun(_) -&gt; ok end,
<a name="7312"/> 7312:     run_smp_workers(InitF,ExecF,FiniF,100000),
<a name="7313"/> 7313:     verify_table_load(smp_insert),
<a name="smp_insert_do-last_expr"/><a name="7314"/> 7314: <b>    ets:delete</b>(smp_insert).
<a name="7315"/> 7315: 
<a name="7316"/> 7316: <i>%% Concurrent deletes on same fixated table.</i>
<a name="smp_fixed_delete-1"/><a name="7317"/> 7317: <b>smp_fixed_delete</b>(Config) when is_list(Config) -&gt;
<a name="smp_fixed_delete-last_expr"/><a name="7318"/> 7318: <b>    only_if_smp</b>(fun() -&gt; smp_fixed_delete_do() end).
<a name="7319"/> 7319: 
<a name="smp_fixed_delete_do-0"/><a name="7320"/> 7320: <b>smp_fixed_delete_do</b>() -&gt;
<a name="7321"/> 7321:     T = ets_new(foo,[public,{write_concurrency,true}]),
<a name="7322"/> 7322:     %%Mem = ets:info(T,memory),
<a name="7323"/> 7323:     NumOfObjs = 100000,
<a name="7324"/> 7324:     filltabint(T,NumOfObjs),
<a name="7325"/> 7325:     ets:safe_fixtable(T,true),
<a name="7326"/> 7326:     Buckets = num_of_buckets(T),
<a name="7327"/> 7327:     InitF = fun([ProcN,NumOfProcs|_]) -&gt; {ProcN,NumOfProcs} end,
<a name="7328"/> 7328:     ExecF = fun({Key,_}) when Key &gt; NumOfObjs -&gt;
<a name="7329"/> 7329:                     [end_of_work];
<a name="7330"/> 7330:                ({Key,Increment}) -&gt;
<a name="7331"/> 7331:                     true = ets:delete(T,Key),
<a name="7332"/> 7332:                     {Key+Increment,Increment}
<a name="7333"/> 7333:             end,
<a name="7334"/> 7334:     FiniF = fun(_) -&gt; ok end,
<a name="7335"/> 7335:     run_sched_workers(InitF,ExecF,FiniF,NumOfObjs),
<a name="7336"/> 7336:     0 = ets:info(T,size),
<a name="7337"/> 7337:     true = ets:info(T,fixed),
<a name="7338"/> 7338:     Buckets = num_of_buckets(T),
<a name="7339"/> 7339:     case ets:info(T,type) of
<a name="7340"/> 7340:         set -&gt; NumOfObjs = get_kept_objects(T);
<a name="7341"/> 7341:         _ -&gt; ok
<a name="7342"/> 7342:     end,
<a name="7343"/> 7343:     ets:safe_fixtable(T,false),
<a name="7344"/> 7344:     %% Will fail as unfix does not shrink the table:
<a name="7345"/> 7345:     %%Mem = ets:info(T,memory),
<a name="7346"/> 7346:     %%verify_table_load(T),
<a name="smp_fixed_delete_do-last_expr"/><a name="7347"/> 7347: <b>    ets:delete</b>(T).
<a name="7348"/> 7348: 
<a name="7349"/> 7349: <i>%% ERL-720</i>
<a name="7350"/> 7350: <i>%% Provoke race between ets:delete and table unfix (by select_count)</i>
<a name="7351"/> 7351: <i>%% that caused ets_misc memory counter to indicate false leak.</i>
<a name="delete_unfix_race-1"/><a name="7352"/> 7352: <b>delete_unfix_race</b>(Config) when is_list(Config) -&gt;
<a name="7353"/> 7353:     EtsMem = etsmem(),
<a name="7354"/> 7354:     Table = ets:new(t,[set,public,{write_concurrency,true}]),
<a name="7355"/> 7355:     InsertOp =
<a name="7356"/> 7356:         fun() -&gt;
<a name="7357"/> 7357:                 receive stop -&gt;
<a name="7358"/> 7358:                         false
<a name="7359"/> 7359:                 after 0 -&gt;
<a name="7360"/> 7360:                         ets:insert(Table, {rand:uniform(10)}),
<a name="7361"/> 7361:                         true
<a name="7362"/> 7362:                 end
<a name="7363"/> 7363:         end,
<a name="7364"/> 7364:     DeleteOp =
<a name="7365"/> 7365:         fun() -&gt;
<a name="7366"/> 7366:                 receive stop -&gt;
<a name="7367"/> 7367:                         false
<a name="7368"/> 7368:                 after 0 -&gt;
<a name="7369"/> 7369:                         ets:delete(Table, rand:uniform(10)),
<a name="7370"/> 7370:                         true
<a name="7371"/> 7371:                 end
<a name="7372"/> 7372:         end,
<a name="7373"/> 7373:     SelectOp =
<a name="7374"/> 7374:         fun() -&gt;
<a name="7375"/> 7375:                 ets:select_count(Table, ets:fun2ms(fun(X) -&gt; true end))
<a name="7376"/> 7376:         end,
<a name="7377"/> 7377:     Main = self(),
<a name="7378"/> 7378:     Ins = spawn(fun()-&gt; repeat_while(InsertOp), Main ! self() end),
<a name="7379"/> 7379:     Del = spawn(fun()-&gt; repeat_while(DeleteOp), Main ! self() end),
<a name="7380"/> 7380:     spawn(fun()-&gt;
<a name="7381"/> 7381:                   repeat(SelectOp, 10000),
<a name="7382"/> 7382:                   Del ! stop,
<a name="7383"/> 7383:                   Ins ! stop
<a name="7384"/> 7384:           end),
<a name="7385"/> 7385:     [receive Pid -&gt; ok end || Pid &lt;- [Ins,Del]],
<a name="7386"/> 7386:     ets:delete(Table),
<a name="delete_unfix_race-last_expr"/><a name="7387"/> 7387: <b>    verify_etsmem</b>(EtsMem).
<a name="7388"/> 7388: 
<a name="num_of_buckets-1"/><a name="7389"/> 7389: <b>num_of_buckets</b>(T) -&gt;
<a name="num_of_buckets-last_expr"/><a name="7390"/> 7390: <b>    case ets:info</b>(T,type) of
<a name="7391"/> 7391:         set -&gt; element(1,ets:info(T,stats));
<a name="7392"/> 7392:         bag -&gt; element(1,ets:info(T,stats));
<a name="7393"/> 7393:         duplicate_bag -&gt; element(1,ets:info(T,stats));
<a name="7394"/> 7394:         _ -&gt; ok
<a name="7395"/> 7395:     end.
<a name="7396"/> 7396: 
<a name="7397"/> 7397: <i>%% Fixate hash table while other process is busy doing unfix.</i>
<a name="smp_unfix_fix-1"/><a name="7398"/> 7398: <b>smp_unfix_fix</b>(Config) when is_list(Config) -&gt;
<a name="smp_unfix_fix-last_expr"/><a name="7399"/> 7399: <b>    only_if_smp</b>(fun()-&gt; smp_unfix_fix_do() end).
<a name="7400"/> 7400: 
<a name="smp_unfix_fix_do-0"/><a name="7401"/> 7401: <b>smp_unfix_fix_do</b>() -&gt;
<a name="7402"/> 7402:     process_flag(scheduler,1),
<a name="7403"/> 7403:     Parent = self(),
<a name="7404"/> 7404:     T = ets_new(foo,[public,{write_concurrency,true}]),
<a name="7405"/> 7405:     %%Mem = ets:info(T,memory),
<a name="7406"/> 7406:     NumOfObjs = 100000,
<a name="7407"/> 7407:     Deleted = 50000,
<a name="7408"/> 7408:     filltabint(T,NumOfObjs),
<a name="7409"/> 7409:     ets:safe_fixtable(T,true),
<a name="7410"/> 7410:     Buckets = num_of_buckets(T),
<a name="7411"/> 7411:     Deleted = ets:select_delete(T,[{{'$1', '_'},
<a name="7412"/> 7412: 				    [{'=&lt;','$1', Deleted}],
<a name="7413"/> 7413: 				    [true]}]),
<a name="7414"/> 7414:     Buckets = num_of_buckets(T),
<a name="7415"/> 7415:     Left = NumOfObjs - Deleted,
<a name="7416"/> 7416:     Left = ets:info(T,size),
<a name="7417"/> 7417:     true = ets:info(T,fixed),
<a name="7418"/> 7418:     Deleted = get_kept_objects(T),
<a name="7419"/> 7419: 
<a name="7420"/> 7420:     {Child, Mref} =
<a name="7421"/> 7421: 	my_spawn_opt(
<a name="7422"/> 7422: 	  fun()-&gt;
<a name="7423"/> 7423: 		  true = ets:info(T,fixed),
<a name="7424"/> 7424: 		  Parent ! start,
<a name="7425"/> 7425: 		  io:format(&quot;Child waiting for table to be unfixed... mem=~p\n&quot;,
<a name="7426"/> 7426: 			    [ets:info(T, memory)]),
<a name="7427"/> 7427: 		  do_tc(fun() -&gt;
<a name="7428"/> 7428: 				repeat_while(fun()-&gt; ets:info(T, fixed) end)
<a name="7429"/> 7429: 			end,
<a name="7430"/> 7430: 			fun(Elapsed) -&gt;
<a name="7431"/> 7431: 				io:format(&quot;Table unfixed in ~p ms.&quot;
<a name="7432"/> 7432: 					  &quot; Child Fixating! mem=~p\n&quot;,
<a name="7433"/> 7433: 					  [Elapsed,ets:info(T,memory)])
<a name="7434"/> 7434: 			end),
<a name="7435"/> 7435: 		  true = ets:safe_fixtable(T,true),
<a name="7436"/> 7436: 		  repeat_while(fun(Key) when Key =&lt; NumOfObjs -&gt;
<a name="7437"/> 7437: 				       ets:delete(T,Key), {true,Key+1};
<a name="7438"/> 7438: 				  (Key) -&gt; {false,Key}
<a name="7439"/> 7439: 			       end,
<a name="7440"/> 7440: 			       Deleted),
<a name="7441"/> 7441: 		  0 = ets:info(T,size),
<a name="7442"/> 7442: 		  true = get_kept_objects(T) &gt;= Left,
<a name="7443"/> 7443: 		  done = receive_any()
<a name="7444"/> 7444: 	  end,
<a name="7445"/> 7445: 	  [link, monitor, {scheduler,2}]),
<a name="7446"/> 7446: 
<a name="7447"/> 7447:     start = receive_any(),
<a name="7448"/> 7448:     true = ets:info(T,fixed),
<a name="7449"/> 7449:     io:put_chars(&quot;Parent starting to unfix... ~p\n&quot;),
<a name="7450"/> 7450:     do_tc(fun() -&gt;
<a name="7451"/> 7451: 		  ets:safe_fixtable(T, false)
<a name="7452"/> 7452: 	  end,
<a name="7453"/> 7453: 	  fun(Elapsed) -&gt;
<a name="7454"/> 7454: 		  io:format(&quot;Parent done with unfix in ~p ms.\n&quot;,
<a name="7455"/> 7455: 			    [Elapsed])
<a name="7456"/> 7456: 	  end),
<a name="7457"/> 7457:     Child ! done,
<a name="7458"/> 7458:     {'DOWN', Mref, process, Child, normal} = receive_any(),
<a name="7459"/> 7459:     false = ets:info(T,fixed),
<a name="7460"/> 7460:     0 = get_kept_objects(T),
<a name="7461"/> 7461:     %%verify_table_load(T),
<a name="7462"/> 7462:     ets:delete(T),
<a name="smp_unfix_fix_do-last_expr"/><a name="7463"/> 7463: <b>    process_flag</b>(scheduler,0).
<a name="7464"/> 7464: 
<a name="7465"/> 7465: <i>%% Unsafe unfix was done by trapping select/match.</i>
<a name="otp_8166-1"/><a name="7466"/> 7466: <b>otp_8166</b>(Config) when is_list(Config) -&gt;
<a name="otp_8166-last_expr"/><a name="7467"/> 7467: <b>    only_if_smp</b>(3, fun()-&gt; otp_8166_do(false),
<a name="7468"/> 7468: 			   otp_8166_do(true)
<a name="7469"/> 7469: 		   end).
<a name="7470"/> 7470: 
<a name="otp_8166_do-1"/><a name="7471"/> 7471: <b>otp_8166_do</b>(WC) -&gt;
<a name="7472"/> 7472:     %% Bug scenario: One process segv while reading the table because another
<a name="7473"/> 7473:     %% process is doing unfix without write-lock at the end of a trapping match_object.
<a name="7474"/> 7474:     process_flag(scheduler,1),
<a name="7475"/> 7475:     T = ets_new(foo,[public, {write_concurrency,WC}]),
<a name="7476"/> 7476:     NumOfObjs = 3000,  %% Need more than 1000 live objects for match_object to trap one time
<a name="7477"/> 7477:     Deleted = NumOfObjs div 2,
<a name="7478"/> 7478:     filltabint(T,NumOfObjs),
<a name="7479"/> 7479:     {ReaderPid, ReaderMref} = my_spawn_opt(fun()-&gt; otp_8166_reader(T,NumOfObjs) end,
<a name="7480"/> 7480:                                            [link, monitor, {scheduler,2}]),
<a name="7481"/> 7481:     {ZombieCrPid, ZombieCrMref} = my_spawn_opt(fun()-&gt; otp_8166_zombie_creator(T,Deleted) end,
<a name="7482"/> 7482:                                                [link, monitor, {scheduler,3}]),
<a name="7483"/> 7483: 
<a name="7484"/> 7484:     repeat(fun() -&gt; ZombieCrPid ! {loop, self()},
<a name="7485"/> 7485: 		    zombies_created = receive_any(),
<a name="7486"/> 7486: 		    otp_8166_trapper(T, 10, ZombieCrPid)
<a name="7487"/> 7487: 	   end, 100),
<a name="7488"/> 7488: 
<a name="7489"/> 7489:     ReaderPid ! quit,
<a name="7490"/> 7490:     {'DOWN', ReaderMref, process, ReaderPid, normal} = receive_any(),
<a name="7491"/> 7491:     ZombieCrPid ! quit,
<a name="7492"/> 7492:     {'DOWN', ZombieCrMref, process, ZombieCrPid, normal} = receive_any(),
<a name="7493"/> 7493:     false = ets:info(T,fixed),
<a name="7494"/> 7494:     0 = get_kept_objects(T),
<a name="7495"/> 7495:     %%verify_table_load(T),
<a name="7496"/> 7496:     ets:delete(T),
<a name="otp_8166_do-last_expr"/><a name="7497"/> 7497: <b>    process_flag</b>(scheduler,0).
<a name="7498"/> 7498: 
<a name="7499"/> 7499: <i>%% Keep reading the table</i>
<a name="otp_8166_reader-2"/><a name="7500"/> 7500: <b>otp_8166_reader</b>(T, NumOfObjs) -&gt;
<a name="otp_8166_reader-last_expr"/><a name="7501"/> 7501: <b>    repeat_while</b>(fun(0) -&gt;
<a name="7502"/> 7502: 			 receive quit -&gt; {false,done}
<a name="7503"/> 7503: 			 after 0 -&gt; {true,NumOfObjs}
<a name="7504"/> 7504: 			 end;
<a name="7505"/> 7505: 		    (Key) -&gt;
<a name="7506"/> 7506: 			 ets:lookup(T,Key),
<a name="7507"/> 7507: 			 {true, Key-1}
<a name="7508"/> 7508: 		 end,
<a name="7509"/> 7509: 		 NumOfObjs).
<a name="7510"/> 7510: 
<a name="7511"/> 7511: <i>%% Do a match_object that will trap and thereby fixate and then unfixate the table</i>
<a name="otp_8166_trapper-3"/><a name="7512"/> 7512: <b>otp_8166_trapper</b>(T, Try, ZombieCrPid) -&gt;
<a name="7513"/> 7513:     [] = ets:match_object(T,{'_',&quot;Pink Unicorn&quot;}),
<a name="otp_8166_trapper-last_expr"/><a name="7514"/> 7514: <b>    case {ets:info</b>(T,fixed),Try} of
<a name="7515"/> 7515: 	{true,1} -&gt;
<a name="7516"/> 7516: 	    io:format(&quot;failed to provoke unsafe unfix, give up...\n&quot;,[]),
<a name="7517"/> 7517: 	    ZombieCrPid ! unfix;
<a name="7518"/> 7518: 	{true,_} -&gt;
<a name="7519"/> 7519: 	    io:format(&quot;trapper too fast, trying again...\n&quot;,[]),
<a name="7520"/> 7520: 	    otp_8166_trapper(T, Try-1, ZombieCrPid);
<a name="7521"/> 7521: 	{false,_} -&gt; done
<a name="7522"/> 7522:     end.
<a name="7523"/> 7523: 
<a name="7524"/> 7524: 
<a name="7525"/> 7525: <i>%% Fixate table and create some pseudo-deleted objects (zombies)</i>
<a name="7526"/> 7526: <i>%% Then wait for trapper to fixate before unfixing, as we want the trappers'</i>
<a name="7527"/> 7527: <i>%% unfix to be the one that purges the zombies.</i>
<a name="otp_8166_zombie_creator-2"/><a name="7528"/> 7528: <b>otp_8166_zombie_creator</b>(T,Deleted) -&gt;
<a name="otp_8166_zombie_creator-last_expr"/><a name="7529"/> 7529: <b>    case receive_any</b>() of
<a name="7530"/> 7530: 	quit -&gt; done;
<a name="7531"/> 7531: 
<a name="7532"/> 7532: 	{loop,Pid} -&gt;
<a name="7533"/> 7533: 	    filltabint(T,Deleted),
<a name="7534"/> 7534: 	    ets:safe_fixtable(T,true),
<a name="7535"/> 7535: 	    Deleted = ets:select_delete(T,[{{'$1', '_'},
<a name="7536"/> 7536: 					    [{'=&lt;','$1', Deleted}],
<a name="7537"/> 7537: 					    [true]}]),
<a name="7538"/> 7538: 	    Pid ! zombies_created,
<a name="7539"/> 7539: 	    repeat_while(fun() -&gt; case ets:info(T,safe_fixed_monotonic_time) of
<a name="7540"/> 7540: 				      {_,[_P1,_P2]} -&gt;
<a name="7541"/> 7541: 					  false;
<a name="7542"/> 7542: 				      _ -&gt;
<a name="7543"/> 7543: 					  receive unfix -&gt; false
<a name="7544"/> 7544: 					  after 0 -&gt; true
<a name="7545"/> 7545: 					  end
<a name="7546"/> 7546: 				  end
<a name="7547"/> 7547: 			 end),
<a name="7548"/> 7548: 	    ets:safe_fixtable(T,false),
<a name="7549"/> 7549: 	    otp_8166_zombie_creator(T,Deleted);
<a name="7550"/> 7550: 
<a name="7551"/> 7551: 	unfix -&gt;
<a name="7552"/> 7552: 	    io:format(&quot;ignore unfix in outer loop?\n&quot;,[]),
<a name="7553"/> 7553: 	    otp_8166_zombie_creator(T,Deleted)
<a name="7554"/> 7554:     end.
<a name="7555"/> 7555: 
<a name="7556"/> 7556: 
<a name="7557"/> 7557: 
<a name="7558"/> 7558: 
<a name="verify_table_load-1"/><a name="7559"/> 7559: <b>verify_table_load</b>(T) -&gt;
<a name="verify_table_load-last_expr"/><a name="7560"/> 7560: <b>    case ets:info</b>(T,type) of
<a name="7561"/> 7561:         ordered_set -&gt; ok;
<a name="7562"/> 7562:         _ -&gt;
<a name="7563"/> 7563:             Stats = ets:info(T,stats),
<a name="7564"/> 7564:             {Buckets,AvgLen,StdDev,ExpSD,_MinLen,_MaxLen,_,_} = Stats,
<a name="7565"/> 7565:             ok = if
<a name="7566"/> 7566:                      AvgLen &gt; 1.2 -&gt;
<a name="7567"/> 7567:                          io:format(&quot;Table overloaded: Stats=~p\n~p\n&quot;,
<a name="7568"/> 7568:                                    [Stats, ets:info(T)]),
<a name="7569"/> 7569:                          false;
<a name="7570"/> 7570: 
<a name="7571"/> 7571:                      Buckets&gt;256, AvgLen &lt; 0.47 -&gt;
<a name="7572"/> 7572:                          io:format(&quot;Table underloaded: Stats=~p\n~p\n&quot;,
<a name="7573"/> 7573:                                    [Stats, ets:info(T)]),
<a name="7574"/> 7574:                          false;
<a name="7575"/> 7575: 
<a name="7576"/> 7576:                      StdDev &gt; ExpSD*2 -&gt;
<a name="7577"/> 7577:                          io:format(&quot;Too large standard deviation (poor hashing?),&quot;
<a name="7578"/> 7578:                                    &quot; stats=~p\n~p\n&quot;,[Stats, ets:info(T)]),
<a name="7579"/> 7579:                          false;
<a name="7580"/> 7580: 
<a name="7581"/> 7581:                      true -&gt;
<a name="7582"/> 7582:                          io:format(&quot;Stats = ~p\n~p\n&quot;,[Stats, ets:info(T)]),
<a name="7583"/> 7583:                          ok
<a name="7584"/> 7584:                  end
<a name="7585"/> 7585:     end.
<a name="7586"/> 7586: 
<a name="7587"/> 7587: 
<a name="7588"/> 7588: <i>%% ets:select on a tree with NIL key object.</i>
<a name="otp_8732-1"/><a name="7589"/> 7589: <b>otp_8732</b>(Config) when is_list(Config) -&gt;
<a name="7590"/> 7590:     repeat_for_all_ord_set_table_types(
<a name="7591"/> 7591:       fun(Opts) -&gt;
<a name="7592"/> 7592:               KeyRange = 999,
<a name="7593"/> 7593:               KeyFun = fun(K) -&gt; integer_to_list(K) end,
<a name="7594"/> 7594:               Tab = ets_new(noname,Opts, KeyRange, KeyFun),
<a name="7595"/> 7595:               filltabstr(Tab, KeyRange),
<a name="7596"/> 7596:               ets:insert(Tab,{[],&quot;nasty NIL object&quot;}),
<a name="7597"/> 7597:               [] = ets:match(Tab,{'_',nomatch}) %% Will hang if bug not fixed
<a name="7598"/> 7598:       end),
<a name="otp_8732-last_expr"/><a name="7599"/> 7599:     ok.
<a name="7600"/> 7600: 
<a name="7601"/> 7601: 
<a name="7602"/> 7602: <i>%% Run concurrent select_delete (and inserts) on same table.</i>
<a name="smp_select_delete-1"/><a name="7603"/> 7603: <b>smp_select_delete</b>(Config) when is_list(Config) -&gt;
<a name="smp_select_delete-last_expr"/><a name="7604"/> 7604: <b>    repeat_for_opts</b>(fun smp_select_delete_do/1,
<a name="7605"/> 7605:                     [[set,ordered_set,stim_cat_ord_set],
<a name="7606"/> 7606:                      read_concurrency, compressed]).
<a name="7607"/> 7607: 
<a name="smp_select_delete_do-1"/><a name="7608"/> 7608: <b>smp_select_delete_do</b>(Opts) -&gt;
<a name="7609"/> 7609:     KeyRange = 10000,
<a name="7610"/> 7610:     begin % indentation
<a name="7611"/> 7611:               T = ets_new(smp_select_delete,[named_table,public,{write_concurrency,true}|Opts],
<a name="7612"/> 7612:                           KeyRange),
<a name="7613"/> 7613:               Mod = 17,
<a name="7614"/> 7614:               Zeros = erlang:make_tuple(Mod,0),
<a name="7615"/> 7615:               InitF = fun(_) -&gt; Zeros end,
<a name="7616"/> 7616:               ExecF = fun(Diffs0) -&gt;
<a name="7617"/> 7617:                               case rand:uniform(20) of
<a name="7618"/> 7618:                                   1 -&gt;
<a name="7619"/> 7619:                                       Mod = 17,
<a name="7620"/> 7620:                                       Eq = rand:uniform(Mod) - 1,
<a name="7621"/> 7621:                                       Deleted = ets:select_delete(T,
<a name="7622"/> 7622:                                                                   [{{'_', '$1'},
<a name="7623"/> 7623:                                                                     [{'=:=', {'rem', '$1', Mod}, Eq}],
<a name="7624"/> 7624:                                                                     [true]}]),
<a name="7625"/> 7625:                                       Diffs1 = setelement(Eq+1, Diffs0,
<a name="7626"/> 7626:                                                           element(Eq+1,Diffs0) - Deleted),
<a name="7627"/> 7627:                                       Diffs1;
<a name="7628"/> 7628:                                   _ -&gt;
<a name="7629"/> 7629:                                       Key = rand:uniform(KeyRange),
<a name="7630"/> 7630:                                       Eq = Key rem Mod,
<a name="7631"/> 7631:                                       case ets:insert_new(T,{Key,Key}) of
<a name="7632"/> 7632:                                           true -&gt;
<a name="7633"/> 7633:                                               Diffs1 = setelement(Eq+1, Diffs0,
<a name="7634"/> 7634:                                                                   element(Eq+1,Diffs0)+1),
<a name="7635"/> 7635:                                               Diffs1;
<a name="7636"/> 7636:                                           false -&gt; Diffs0
<a name="7637"/> 7637:                                       end
<a name="7638"/> 7638:                               end
<a name="7639"/> 7639:                       end,
<a name="7640"/> 7640:               FiniF = fun(Result) -&gt; Result end,
<a name="7641"/> 7641:               Results = run_sched_workers(InitF,ExecF,FiniF,20000),
<a name="7642"/> 7642:               TotCnts = lists:foldl(fun(Diffs, Sum) -&gt; add_lists(Sum,tuple_to_list(Diffs)) end,
<a name="7643"/> 7643:                                     lists:duplicate(Mod, 0), Results),
<a name="7644"/> 7644:               io:format(&quot;TotCnts = ~p\n&quot;,[TotCnts]),
<a name="7645"/> 7645:               LeftInTab = lists:foldl(fun(N,Sum) -&gt; Sum+N end,
<a name="7646"/> 7646:                                       0, TotCnts),
<a name="7647"/> 7647:               io:format(&quot;LeftInTab = ~p\n&quot;,[LeftInTab]),
<a name="7648"/> 7648:               LeftInTab = ets:info(T,size),
<a name="7649"/> 7649:               lists:foldl(fun(Cnt,Eq) -&gt;
<a name="7650"/> 7650:                                   WasCnt = ets:select_count(T,
<a name="7651"/> 7651:                                                             [{{'_', '$1'},
<a name="7652"/> 7652:                                                               [{'=:=', {'rem', '$1', Mod}, Eq}],
<a name="7653"/> 7653:                                                               [true]}]),
<a name="7654"/> 7654:                                   io:format(&quot;~p: ~p =?= ~p\n&quot;,[Eq,Cnt,WasCnt]),
<a name="7655"/> 7655:                                   Cnt = WasCnt,
<a name="7656"/> 7656:                                   Eq+1
<a name="7657"/> 7657:                           end,
<a name="7658"/> 7658:                           0, TotCnts),
<a name="7659"/> 7659:               %% May fail as select_delete does not shrink table (enough)
<a name="7660"/> 7660:               %%verify_table_load(T),
<a name="7661"/> 7661:               LeftInTab = ets:select_delete(T, [{{'$1','$1'}, [], [true]}]),
<a name="7662"/> 7662:               0 = ets:info(T,size),
<a name="7663"/> 7663:               false = ets:info(T,fixed),
<a name="7664"/> 7664:               ets:delete(T)
<a name="7665"/> 7665:     end, % indentation
<a name="smp_select_delete_do-last_expr"/><a name="7666"/> 7666:     ok.
<a name="7667"/> 7667: 
<a name="smp_select_replace-1"/><a name="7668"/> 7668: <b>smp_select_replace</b>(Config) when is_list(Config) -&gt;
<a name="smp_select_replace-last_expr"/><a name="7669"/> 7669: <b>    repeat_for_opts</b>(fun smp_select_replace_do/1,
<a name="7670"/> 7670:                     [[set,ordered_set,stim_cat_ord_set,duplicate_bag],
<a name="7671"/> 7671:                      compressed]).
<a name="7672"/> 7672: 
<a name="smp_select_replace_do-1"/><a name="7673"/> 7673: <b>smp_select_replace_do</b>(Opts) -&gt;
<a name="7674"/> 7674:     KeyRange = 20,
<a name="7675"/> 7675:     T = ets_new(smp_select_replace,
<a name="7676"/> 7676:                 [public, {write_concurrency, true} | Opts],
<a name="7677"/> 7677:                 KeyRange),
<a name="7678"/> 7678:     InitF = fun (_) -&gt; 0 end,
<a name="7679"/> 7679:     ExecF = fun (Cnt0) -&gt;
<a name="7680"/> 7680:                     CounterId = rand:uniform(KeyRange),
<a name="7681"/> 7681:                     Match = [{{'$1', '$2'},
<a name="7682"/> 7682:                               [{'=:=', '$1', CounterId}],
<a name="7683"/> 7683:                               [{{'$1', {'+', '$2', 1}}}]}],
<a name="7684"/> 7684:                     Cnt1 = case ets:select_replace(T, Match) of
<a name="7685"/> 7685:                                1 -&gt; Cnt0+1;
<a name="7686"/> 7686:                                0 -&gt;
<a name="7687"/> 7687:                                    ets:insert_new(T, {CounterId, 0}),
<a name="7688"/> 7688:                                    Cnt0
<a name="7689"/> 7689:                            end,
<a name="7690"/> 7690:                     receive stop -&gt;
<a name="7691"/> 7691:                             [end_of_work | Cnt1]
<a name="7692"/> 7692:                     after 0 -&gt;
<a name="7693"/> 7693:                             Cnt1
<a name="7694"/> 7694:                     end
<a name="7695"/> 7695:             end,
<a name="7696"/> 7696:     FiniF = fun (Cnt) -&gt; Cnt end,
<a name="7697"/> 7697:     Pids = run_sched_workers(InitF, ExecF, FiniF, infinite),
<a name="7698"/> 7698:     receive after 3*1000 -&gt; ok end,
<a name="7699"/> 7699:     [P ! stop || P &lt;- Pids],
<a name="7700"/> 7700:     Results = wait_pids(Pids),
<a name="7701"/> 7701:     FinalCounts = ets:select(T, [{{'_', '$1'}, [], ['$1']}]),
<a name="7702"/> 7702:     Total = lists:sum(FinalCounts),
<a name="7703"/> 7703:     Total = lists:sum(Results),
<a name="7704"/> 7704:     KeyRange = ets:select_delete(T, [{{'_', '_'}, [], [true]}]),
<a name="7705"/> 7705:     0 = ets:info(T, size),
<a name="7706"/> 7706:     true = ets:delete(T),
<a name="smp_select_replace_do-last_expr"/><a name="7707"/> 7707:     ok.
<a name="7708"/> 7708: 
<a name="7709"/> 7709: <i>%% Iterate ordered_set with write_concurrency</i>
<a name="7710"/> 7710: <i>%% and make sure we hit all &quot;stable&quot; long lived keys</i>
<a name="7711"/> 7711: <i>%% while &quot;volatile&quot; objects are randomly inserted and deleted.</i>
<a name="smp_ordered_iteration-1"/><a name="7712"/> 7712: <b>smp_ordered_iteration</b>(Config) when is_list(Config) -&gt;
<a name="smp_ordered_iteration-last_expr"/><a name="7713"/> 7713: <b>    repeat_for_opts</b>(fun smp_ordered_iteration_do/1,
<a name="7714"/> 7714:                     [[cat_ord_set,stim_cat_ord_set]]).
<a name="7715"/> 7715: 
<a name="7716"/> 7716: 
<a name="smp_ordered_iteration_do-1"/><a name="7717"/> 7717: <b>smp_ordered_iteration_do</b>(Opts) -&gt;
<a name="7718"/> 7718:     KeyRange = 1000,
<a name="7719"/> 7719:     OffHeap = erts_test_utils:mk_ext_pid({a@b,1}, 4711, 1),
<a name="7720"/> 7720:     KeyFun = fun(K, Type) -&gt;
<a name="7721"/> 7721:                      {K div 10, K rem 10, Type, OffHeap}
<a name="7722"/> 7722:              end,
<a name="7723"/> 7723:     StimKeyFun = fun(K) -&gt;
<a name="7724"/> 7724:                          KeyFun(K, element(rand:uniform(3),
<a name="7725"/> 7725:                                            {stable, other, volatile}))
<a name="7726"/> 7726:                  end,
<a name="7727"/> 7727:     T = ets_new(smp_ordered_iteration, [public, {write_concurrency,true} | Opts],
<a name="7728"/> 7728:                 KeyRange, StimKeyFun),
<a name="7729"/> 7729:     NStable = KeyRange div 4,
<a name="7730"/> 7730:     prefill_table(T, KeyRange, NStable, fun(K) -&gt; {KeyFun(K, stable), 0} end),
<a name="7731"/> 7731:     NStable = ets:info(T, size),
<a name="7732"/> 7732:     NVolatile = KeyRange div 2,
<a name="7733"/> 7733:     prefill_table(T, KeyRange, NVolatile, fun(K) -&gt; {KeyFun(K, volatile), 0} end),
<a name="7734"/> 7734: 
<a name="7735"/> 7735:     InitF = fun (_) -&gt; #{insert =&gt; 0, delete =&gt; 0,
<a name="7736"/> 7736:                          select_delete_bk =&gt; 0, select_delete_pbk =&gt; 0,
<a name="7737"/> 7737:                          select_replace_bk =&gt; 0, select_replace_pbk =&gt; 0}
<a name="7738"/> 7738:             end,
<a name="7739"/> 7739:     ExecF = fun (Counters) -&gt;
<a name="7740"/> 7740:                     K = rand:uniform(KeyRange),
<a name="7741"/> 7741:                     Key = KeyFun(K, volatile),
<a name="7742"/> 7742:                     Acc = case rand:uniform(22) of
<a name="7743"/> 7743:                               R when R =&lt; 10 -&gt;
<a name="7744"/> 7744:                                   ets:insert(T, {Key}),
<a name="7745"/> 7745:                                   incr_counter(insert, Counters);
<a name="7746"/> 7746:                               R when R =&lt; 15 -&gt;
<a name="7747"/> 7747:                                   ets:delete(T, Key),
<a name="7748"/> 7748:                                   incr_counter(delete, Counters);
<a name="7749"/> 7749:                               R when R =&lt; 19 -&gt;
<a name="7750"/> 7750:                                   %% Delete bound key
<a name="7751"/> 7751:                                   ets:select_delete(T, [{{Key, '_'}, [], [true]}]),
<a name="7752"/> 7752:                                   incr_counter(select_delete_bk, Counters);
<a name="7753"/> 7753:                               R when R =&lt; 20 -&gt;
<a name="7754"/> 7754:                                   %% Delete partially bound key
<a name="7755"/> 7755:                                   ets:select_delete(T, [{{{K div 10, '_', volatile, '_'}, '_'}, [], [true]}]),
<a name="7756"/> 7756:                                   incr_counter(select_delete_pbk, Counters);
<a name="7757"/> 7757:                               R when R =&lt; 21 -&gt;
<a name="7758"/> 7758:                                   %% Replace bound key
<a name="7759"/> 7759:                                   ets:select_replace(T, [{{Key, '$1'}, [],
<a name="7760"/> 7760:                                                           [{{{const,Key}, {'+','$1',1}}}]}]),
<a name="7761"/> 7761:                                   incr_counter(select_replace_bk, Counters);
<a name="7762"/> 7762:                               _ -&gt;
<a name="7763"/> 7763:                                   %% Replace partially bound key
<a name="7764"/> 7764:                                   ets:select_replace(T, [{{{K div 10, '_', volatile, '_'}, '$1'}, [],
<a name="7765"/> 7765:                                                           [{{{element,1,'$_'}, {'+','$1',1}}}]}]),
<a name="7766"/> 7766:                                   incr_counter(select_replace_pbk, Counters)
<a name="7767"/> 7767:                     end,
<a name="7768"/> 7768:                     receive stop -&gt;
<a name="7769"/> 7769:                             [end_of_work | Acc]
<a name="7770"/> 7770:                     after 0 -&gt;
<a name="7771"/> 7771:                             Acc
<a name="7772"/> 7772:                     end
<a name="7773"/> 7773:             end,
<a name="7774"/> 7774:     FiniF = fun (Acc) -&gt; Acc end,
<a name="7775"/> 7775:     Pids = run_sched_workers(InitF, ExecF, FiniF, infinite),
<a name="7776"/> 7776:     timer:send_after(1000, stop),
<a name="7777"/> 7777: 
<a name="7778"/> 7778:     Log2ChunkMax = math:log2(NStable*2),
<a name="7779"/> 7779:     Rounds = fun Loop(N) -&gt;
<a name="7780"/> 7780:                      MS = [{{{'_', '_', stable, '_'}, '_'}, [], [true]}],
<a name="7781"/> 7781:                      NStable = ets:select_count(T, MS),
<a name="7782"/> 7782:                      NStable = count_stable(T, next, ets:first(T), 0),
<a name="7783"/> 7783:                      NStable = count_stable(T, prev, ets:last(T), 0),
<a name="7784"/> 7784:                      NStable = length(ets:select(T, MS)),
<a name="7785"/> 7785:                      NStable = length(ets:select_reverse(T, MS)),
<a name="7786"/> 7786:                      Chunk = round(math:pow(2, rand:uniform()*Log2ChunkMax)),
<a name="7787"/> 7787:                      NStable = ets_select_chunks_count(T, MS, Chunk),
<a name="7788"/> 7788:                      receive stop -&gt; N
<a name="7789"/> 7789:                      after 0 -&gt; Loop(N+1)
<a name="7790"/> 7790:                      end
<a name="7791"/> 7791:              end (1),
<a name="7792"/> 7792:     [P ! stop || P &lt;- Pids],
<a name="7793"/> 7793:     Results = wait_pids(Pids),
<a name="7794"/> 7794:     io:format(&quot;Ops = ~p\n&quot;, [maps_sum(Results)]),
<a name="7795"/> 7795:     io:format(&quot;Diff = ~p\n&quot;, [ets:info(T,size) - NStable - NVolatile]),
<a name="7796"/> 7796:     io:format(&quot;Stats = ~p\n&quot;, [ets:info(T,stats)]),
<a name="7797"/> 7797:     io:format(&quot;Rounds = ~p\n&quot;, [Rounds]),
<a name="7798"/> 7798:     true = ets:delete(T),
<a name="7799"/> 7799: 
<a name="7800"/> 7800:     %% Verify no leakage of offheap key data
<a name="7801"/> 7801:     ok = erts_test_utils:check_node_dist(),
<a name="smp_ordered_iteration_do-last_expr"/><a name="7802"/> 7802:     ok.
<a name="7803"/> 7803: 
<a name="incr_counter-2"/><a name="7804"/> 7804: <b>incr_counter</b>(Name, Counters) -&gt;
<a name="incr_counter-last_expr"/><a name="7805"/> 7805: <b>    Counters#{Name =&gt; maps:get</b>(Name, Counters, 0) + 1}.
<a name="7806"/> 7806: 
<a name="count_stable-4"/><a name="7807"/> 7807: <b>count_stable</b>(T, Next, {_, _, stable, _}=Key, N) -&gt;
<a name="7808"/> 7808:     count_stable(T, Next, ets:Next(T, Key), N+1);
<a name="7809"/> 7809: <b>count_stable</b>(T, Next, {_, _, volatile, _}=Key, N) -&gt;
<a name="7810"/> 7810:     count_stable(T, Next, ets:Next(T, Key), N);
<a name="7811"/> 7811: <b>count_stable</b>(_, _, '$end_of_table', N) -&gt;
<a name="count_stable-last_expr"/><a name="7812"/> 7812:     N.
<a name="7813"/> 7813: 
<a name="ets_select_chunks_count-3"/><a name="7814"/> 7814: <b>ets_select_chunks_count</b>(T, MS, Chunk) -&gt;
<a name="ets_select_chunks_count-last_expr"/><a name="7815"/> 7815: <b>    ets_select_chunks_count</b>(ets:select(T, MS, Chunk), 0).
<a name="7816"/> 7816: 
<a name="ets_select_chunks_count-2"/><a name="7817"/> 7817: <b>ets_select_chunks_count</b>('$end_of_table', N) -&gt;
<a name="7818"/> 7818:     N;
<a name="7819"/> 7819: <b>ets_select_chunks_count</b>({List, Continuation}, N) -&gt;
<a name="ets_select_chunks_count-last_expr"/><a name="7820"/> 7820: <b>    ets_select_chunks_count</b>(ets:select(Continuation),
<a name="7821"/> 7821:                            length(List) + N).
<a name="7822"/> 7822: 
<a name="maps_sum-1"/><a name="7823"/> 7823: <b>maps_sum</b>([Ma | Tail]) when is_map(Ma) -&gt;
<a name="7824"/> 7824:     maps_sum([lists:sort(maps:to_list(Ma)) | Tail]);
<a name="7825"/> 7825: <b>maps_sum</b>([La, Mb | Tail]) -&gt;
<a name="7826"/> 7826:     Lab = lists:zipwith(fun({K,Va}, {K,Vb}) -&gt; {K,Va+Vb} end,
<a name="7827"/> 7827:                         La,
<a name="7828"/> 7828:                         lists:sort(maps:to_list(Mb))),
<a name="7829"/> 7829:     maps_sum([Lab | Tail]);
<a name="7830"/> 7830: <b>maps_sum</b>([L]) -&gt;
<a name="maps_sum-last_expr"/><a name="7831"/> 7831:     L.
<a name="7832"/> 7832: 
<a name="7833"/> 7833: 
<a name="7834"/> 7834: 
<a name="7835"/> 7835: 
<a name="7836"/> 7836: <i>%% Test different types.</i>
<a name="types-1"/><a name="7837"/> 7837: <b>types</b>(Config) when is_list(Config) -&gt;
<a name="7838"/> 7838:     init_externals(),
<a name="types-last_expr"/><a name="7839"/> 7839: <b>    repeat_for_opts</b>(fun types_do/1, [repeat_for_opts_atom2list(set_types),
<a name="7840"/> 7840:                                      compressed]).
<a name="7841"/> 7841: 
<a name="types_do-1"/><a name="7842"/> 7842: <b>types_do</b>(Opts) -&gt;
<a name="7843"/> 7843:     EtsMem = etsmem(),
<a name="7844"/> 7844:     T = ets_new(xxx,Opts),
<a name="7845"/> 7845:     Fun = fun(Term) -&gt;
<a name="7846"/> 7846: 		  ets:insert(T,{Term}),
<a name="7847"/> 7847: 		  [{Term}] = ets:lookup(T,Term),
<a name="7848"/> 7848: 		  ets:insert(T,{Term,xxx}),
<a name="7849"/> 7849: 		  [{Term,xxx}] = ets:lookup(T,Term),
<a name="7850"/> 7850: 		  ets:insert(T,{Term,&quot;xxx&quot;}),
<a name="7851"/> 7851: 		  [{Term,&quot;xxx&quot;}] = ets:lookup(T,Term),
<a name="7852"/> 7852: 		  ets:insert(T,{xxx,Term}),
<a name="7853"/> 7853: 		  [{xxx,Term}] = ets:lookup(T,xxx),
<a name="7854"/> 7854: 		  ets:insert(T,{&quot;xxx&quot;,Term}),
<a name="7855"/> 7855: 		  [{&quot;xxx&quot;,Term}] = ets:lookup(T,&quot;xxx&quot;),
<a name="7856"/> 7856: 		  ets:delete_all_objects(T),
<a name="7857"/> 7857: 		  0 = ets:info(T,size)
<a name="7858"/> 7858:           end,
<a name="7859"/> 7859:     test_terms(Fun, strict),
<a name="7860"/> 7860:     ets:delete(T),
<a name="types_do-last_expr"/><a name="7861"/> 7861: <b>    verify_etsmem</b>(EtsMem).
<a name="7862"/> 7862: 
<a name="7863"/> 7863: 
<a name="7864"/> 7864: <i>%% OTP-9932: Memory overwrite when inserting large integers in compressed bag.</i>
<a name="7865"/> 7865: <i>%% Will crash with segv on 64-bit opt if not fixed.</i>
<a name="otp_9932-1"/><a name="7866"/> 7866: <b>otp_9932</b>(Config) when is_list(Config) -&gt;
<a name="7867"/> 7867:     T = ets_new(xxx, [bag, compressed]),
<a name="7868"/> 7868:     Fun = fun(N) -&gt;
<a name="7869"/> 7869: 		  Key = {1316110174588445 bsl N,1316110174588583 bsl N},
<a name="7870"/> 7870: 		  S = {Key, Key},
<a name="7871"/> 7871: 		  true = ets:insert(T, S),
<a name="7872"/> 7872: 		  [S] = ets:lookup(T, Key),
<a name="7873"/> 7873: 		  true = ets:insert(T, S),
<a name="7874"/> 7874: 		  [S] = ets:lookup(T, Key)
<a name="7875"/> 7875: 	  end,
<a name="7876"/> 7876:     lists:foreach(Fun, lists:seq(0, 16)),
<a name="otp_9932-last_expr"/><a name="7877"/> 7877: <b>    ets:delete</b>(T).
<a name="7878"/> 7878: 
<a name="7879"/> 7879: 
<a name="7880"/> 7880: <i>%% vm-deadlock caused by race between ets:delete and others on</i>
<a name="7881"/> 7881: <i>%% write_concurrency table.</i>
<a name="otp_9423-1"/><a name="7882"/> 7882: <b>otp_9423</b>(Config) when is_list(Config) -&gt;
<a name="otp_9423-last_expr"/><a name="7883"/> 7883: <b>    repeat_for_all_non_stim_set_table_types</b>(
<a name="7884"/> 7884:       fun(Opts) -&gt;
<a name="7885"/> 7885:               InitF = fun(_) -&gt; {0,0} end,
<a name="7886"/> 7886:               ExecF = fun({S,F}) -&gt;
<a name="7887"/> 7887:                               receive
<a name="7888"/> 7888:                                   stop -&gt;
<a name="7889"/> 7889:                                       io:format(&quot;~p got stop\n&quot;, [self()]),
<a name="7890"/> 7890:                                       [end_of_work | {&quot;Succeded=&quot;,S,&quot;Failed=&quot;,F}]
<a name="7891"/> 7891:                               after 0 -&gt;
<a name="7892"/> 7892:                                       %%io:format(&quot;~p (~p) doing lookup\n&quot;, [self(), {S,F}]),
<a name="7893"/> 7893:                                       try ets:lookup(otp_9423, key) of
<a name="7894"/> 7894:                                           [] -&gt; {S+1,F}
<a name="7895"/> 7895:                                       catch
<a name="7896"/> 7896:                                           error:badarg -&gt; {S,F+1}
<a name="7897"/> 7897:                                       end
<a name="7898"/> 7898:                               end
<a name="7899"/> 7899:                       end,
<a name="7900"/> 7900:               FiniF = fun(R) -&gt; R end,
<a name="7901"/> 7901:               case run_smp_workers(InitF, ExecF, FiniF, infinite, 1) of
<a name="7902"/> 7902:                   Pids when is_list(Pids) -&gt;
<a name="7903"/> 7903:                       %%[P ! start || P &lt;- Pids],
<a name="7904"/> 7904:                       repeat(fun() -&gt; ets_new(otp_9423, [named_table, public, 
<a name="7905"/> 7905:                                                          {write_concurrency,true}|Opts]),
<a name="7906"/> 7906:                                       ets:delete(otp_9423)
<a name="7907"/> 7907:                              end, 10000),
<a name="7908"/> 7908:                       [P ! stop || P &lt;- Pids],
<a name="7909"/> 7909:                       wait_pids(Pids),
<a name="7910"/> 7910:                       ok;
<a name="7911"/> 7911: 
<a name="7912"/> 7912:                   Skipped -&gt; Skipped
<a name="7913"/> 7913:               end
<a name="7914"/> 7914:       end).
<a name="7915"/> 7915: 
<a name="7916"/> 7916: 
<a name="7917"/> 7917: 
<a name="7918"/> 7918: <i>%% Corrupted binary in compressed table</i>
<a name="otp_10182-1"/><a name="7919"/> 7919: <b>otp_10182</b>(Config) when is_list(Config) -&gt;
<a name="otp_10182-last_expr"/><a name="7920"/> 7920: <b>    repeat_for_opts_all_table_types</b>(
<a name="7921"/> 7921:       fun(Opts) -&gt; 
<a name="7922"/> 7922:               Bin = &lt;&lt;&quot;aHR0cDovL2hvb3RzdWl0ZS5jb20vYy9wcm8tYWRyb2xsLWFi&quot;&gt;&gt;,
<a name="7923"/> 7923:               Key = {test, Bin},
<a name="7924"/> 7924:               Value = base64:decode(Bin),
<a name="7925"/> 7925:               In = {Key,Value},
<a name="7926"/> 7926:               Db = ets_new(undefined, Opts),
<a name="7927"/> 7927:               ets:insert(Db, In),
<a name="7928"/> 7928:               [Out] = ets:lookup(Db, Key),
<a name="7929"/> 7929:               io:format(&quot;In :  ~p\nOut: ~p\n&quot;, [In,Out]),
<a name="7930"/> 7930:               ets:delete(Db),
<a name="7931"/> 7931:               In = Out
<a name="7932"/> 7932:       end).
<a name="7933"/> 7933: 
<a name="7934"/> 7934: <i>%% Verify magic refs in compressed table are reference counted correctly</i>
<a name="compress_magic_ref-1"/><a name="7935"/> 7935: <b>compress_magic_ref</b>(Config) when is_list(Config)-&gt;
<a name="7936"/> 7936:     F = fun(Opts) -&gt;
<a name="7937"/> 7937:                 T = ets:new(banana, Opts),
<a name="7938"/> 7938:                 ets:insert(T, {key, atomics:new(2, [])}),
<a name="7939"/> 7939:                 erlang:garbage_collect(),  % make really sure no ref on heap
<a name="7940"/> 7940:                 [{_, Ref}] = ets:lookup(T, key),
<a name="7941"/> 7941:                 #{size := 2} = atomics:info(Ref), % Still alive!
<a name="7942"/> 7942: 
<a name="7943"/> 7943:                 %% Now test ets:delete will deallocate if last ref
<a name="7944"/> 7944:                 WeakRef = term_to_binary(Ref),
<a name="7945"/> 7945:                 erlang:garbage_collect(),  % make sure no Ref on heap
<a name="7946"/> 7946:                 ets:delete(T, key),
<a name="7947"/> 7947:                 StaleRef = binary_to_term(WeakRef),
<a name="7948"/> 7948:                 badarg = try atomics:info(StaleRef)
<a name="7949"/> 7949:                          catch error:badarg -&gt; badarg end,
<a name="7950"/> 7950:                 ets:delete(T),
<a name="7951"/> 7951:                 ok
<a name="7952"/> 7952:           end,
<a name="7953"/> 7953:     repeat_for_opts(F, [[set, ordered_set], compressed]),
<a name="compress_magic_ref-last_expr"/><a name="7954"/> 7954:     ok.
<a name="7955"/> 7955: 
<a name="7956"/> 7956: <i>%% Test that ets:all include/exclude tables that we know are created/deleted</i>
<a name="ets_all-1"/><a name="7957"/> 7957: <b>ets_all</b>(Config) when is_list(Config) -&gt;
<a name="7958"/> 7958:     Pids = [spawn_link(fun() -&gt; ets_all_run() end) || _ &lt;- [1,2]],
<a name="7959"/> 7959:     receive after 3*1000 -&gt; ok end,
<a name="7960"/> 7960:     [begin unlink(P), exit(P,kill) end || P &lt;- Pids],
<a name="ets_all-last_expr"/><a name="7961"/> 7961:     ok.
<a name="7962"/> 7962: 
<a name="ets_all_run-0"/><a name="7963"/> 7963: <b>ets_all_run</b>() -&gt;
<a name="7964"/> 7964:     Table = ets:new(undefined, []),
<a name="7965"/> 7965:     true = lists:member(Table, ets:all()),
<a name="7966"/> 7966:     ets:delete(Table),
<a name="7967"/> 7967:     false = lists:member(Table, ets:all()),
<a name="ets_all_run-last_expr"/><a name="7968"/> 7968: <b>    ets_all_run</b>().
<a name="7969"/> 7969: 
<a name="create_tables-1"/><a name="7970"/> 7970: <b>create_tables</b>(N) -&gt;
<a name="create_tables-last_expr"/><a name="7971"/> 7971: <b>    create_tables</b>(N, []).
<a name="7972"/> 7972: 
<a name="create_tables-2"/><a name="7973"/> 7973: <b>create_tables</b>(0, Ts) -&gt;
<a name="7974"/> 7974:     Ts;
<a name="7975"/> 7975: <b>create_tables</b>(N, Ts) -&gt;
<a name="create_tables-last_expr"/><a name="7976"/> 7976: <b>    create_tables</b>(N-1, [ets:new(tjo, [])|Ts]).
<a name="7977"/> 7977: 
<a name="massive_ets_all-1"/><a name="7978"/> 7978: <b>massive_ets_all</b>(Config) when is_list(Config) -&gt;
<a name="7979"/> 7979:     Me = self(),
<a name="7980"/> 7980:     InitTables = lists:sort(ets:all()),
<a name="7981"/> 7981:     io:format(&quot;InitTables=~p~n&quot;, [InitTables]),
<a name="7982"/> 7982:     PMs0 = lists:map(fun (Sid) -&gt;
<a name="7983"/> 7983:                              my_spawn_opt(fun () -&gt;
<a name="7984"/> 7984:                                                   Ts = create_tables(250),
<a name="7985"/> 7985:                                                   Me ! {self(), up, Ts},
<a name="7986"/> 7986:                                                   receive {Me, die} -&gt; ok end
<a name="7987"/> 7987:                                           end,
<a name="7988"/> 7988:                                           [link, monitor, {scheduler, Sid}])
<a name="7989"/> 7989:                      end,
<a name="7990"/> 7990:                      lists:seq(1, erlang:system_info(schedulers_online))),
<a name="7991"/> 7991:     AllRes = lists:sort(lists:foldl(fun ({P, _M}, Ts) -&gt;
<a name="7992"/> 7992:                                             receive
<a name="7993"/> 7993:                                                 {P, up, PTs} -&gt;
<a name="7994"/> 7994:                                                     PTs ++ Ts
<a name="7995"/> 7995:                                             end
<a name="7996"/> 7996:                                     end,
<a name="7997"/> 7997:                                     InitTables,
<a name="7998"/> 7998:                                     PMs0)),
<a name="7999"/> 7999:     AllRes = lists:sort(ets:all()),
<a name="8000"/> 8000:     PMs1 = lists:map(fun (_) -&gt;
<a name="8001"/> 8001:                              my_spawn_opt(fun () -&gt;
<a name="8002"/> 8002:                                                   AllRes = lists:sort(ets:all())
<a name="8003"/> 8003:                                           end,
<a name="8004"/> 8004:                                           [link, monitor])
<a name="8005"/> 8005:                      end, lists:seq(1, 50)),
<a name="8006"/> 8006:     lists:foreach(fun ({P, M}) -&gt;
<a name="8007"/> 8007:                           receive
<a name="8008"/> 8008:                               {'DOWN', M, process, P, _} -&gt;
<a name="8009"/> 8009:                                   ok
<a name="8010"/> 8010:                           end
<a name="8011"/> 8011:                   end, PMs1),
<a name="8012"/> 8012:     PMs2 = lists:map(fun (_) -&gt;
<a name="8013"/> 8013:                              my_spawn_opt(fun () -&gt;
<a name="8014"/> 8014:                                                   _ = ets:all()
<a name="8015"/> 8015:                                           end,
<a name="8016"/> 8016:                                           [link, monitor])
<a name="8017"/> 8017:                      end, lists:seq(1, 50)),
<a name="8018"/> 8018:     lists:foreach(fun ({P, _M}) -&gt;
<a name="8019"/> 8019:                           P ! {Me, die}
<a name="8020"/> 8020:                   end, PMs0),
<a name="8021"/> 8021:     lists:foreach(fun ({P, M}) -&gt;
<a name="8022"/> 8022:                           receive
<a name="8023"/> 8023:                               {'DOWN', M, process, P, _} -&gt;
<a name="8024"/> 8024:                                   ok
<a name="8025"/> 8025:                           end
<a name="8026"/> 8026:                   end, PMs0 ++ PMs2),
<a name="8027"/> 8027:     EndTables = lists:sort(ets:all()),
<a name="8028"/> 8028:     io:format(&quot;EndTables=~p~n&quot;, [EndTables]),
<a name="8029"/> 8029:     InitTables = EndTables,
<a name="massive_ets_all-last_expr"/><a name="8030"/> 8030:     ok.
<a name="8031"/> 8031: 
<a name="8032"/> 8032: 
<a name="take-1"/><a name="8033"/> 8033: <b>take</b>(Config) when is_list(Config) -&gt;
<a name="8034"/> 8034:     %% Simple test for set tables.
<a name="8035"/> 8035:     T1 = ets_new(a, [set]),
<a name="8036"/> 8036:     [] = ets:take(T1, foo),
<a name="8037"/> 8037:     ets:insert(T1, {foo,bar}),
<a name="8038"/> 8038:     [] = ets:take(T1, bar),
<a name="8039"/> 8039:     [{foo,bar}] = ets:take(T1, foo),
<a name="8040"/> 8040:     [] = ets:tab2list(T1),
<a name="8041"/> 8041:     %% Non-immediate key.
<a name="8042"/> 8042:     ets:insert(T1, {{'not',&lt;&lt;&quot;immediate&quot;&gt;&gt;},ok}),
<a name="8043"/> 8043:     [{{'not',&lt;&lt;&quot;immediate&quot;&gt;&gt;},ok}] = ets:take(T1, {'not',&lt;&lt;&quot;immediate&quot;&gt;&gt;}),
<a name="8044"/> 8044:     %% Same with ordered tables.
<a name="8045"/> 8045:     repeat_for_all_ord_set_table_types(
<a name="8046"/> 8046:       fun(Opts) -&gt;
<a name="8047"/> 8047:               T2 = ets_new(b, Opts),
<a name="8048"/> 8048:               [] = ets:take(T2, foo),
<a name="8049"/> 8049:               ets:insert(T2, {foo,bar}),
<a name="8050"/> 8050:               [] = ets:take(T2, bar),
<a name="8051"/> 8051:               [{foo,bar}] = ets:take(T2, foo),
<a name="8052"/> 8052:               [] = ets:tab2list(T2),
<a name="8053"/> 8053:               ets:insert(T2, {{'not',&lt;&lt;&quot;immediate&quot;&gt;&gt;},ok}),
<a name="8054"/> 8054:               [{{'not',&lt;&lt;&quot;immediate&quot;&gt;&gt;},ok}] = ets:take(T2, {'not',&lt;&lt;&quot;immediate&quot;&gt;&gt;}),
<a name="8055"/> 8055:               %% Arithmetically-equal keys.
<a name="8056"/> 8056:               ets:insert(T2, [{1.0,float},{2,integer}]),
<a name="8057"/> 8057:               [{1.0,float}] = ets:take(T2, 1),
<a name="8058"/> 8058:               [{2,integer}] = ets:take(T2, 2.0),
<a name="8059"/> 8059:               [] = ets:tab2list(T2),
<a name="8060"/> 8060:               ets:delete(T2)
<a name="8061"/> 8061:       end),
<a name="8062"/> 8062:     %% Same with bag.
<a name="8063"/> 8063:     T3 = ets_new(c, [bag]),
<a name="8064"/> 8064:     ets:insert(T3, [{1,1},{1,2},{3,3}]),
<a name="8065"/> 8065:     R = lists:sort([{1,1},{1,2}]),
<a name="8066"/> 8066:     R = lists:sort(ets:take(T3, 1)),
<a name="8067"/> 8067:     [{3,3}] = ets:take(T3, 3),
<a name="8068"/> 8068:     [] = ets:tab2list(T3),
<a name="8069"/> 8069:     ets:delete(T1),
<a name="8070"/> 8070:     ets:delete(T3),
<a name="take-last_expr"/><a name="8071"/> 8071:     ok.
<a name="8072"/> 8072: 
<a name="whereis_table-1"/><a name="8073"/> 8073: <b>whereis_table</b>(Config) when is_list(Config) -&gt;
<a name="8074"/> 8074:     %% Do we return 'undefined' when the named table doesn't exist?
<a name="8075"/> 8075:     undefined = ets:whereis(whereis_test),
<a name="8076"/> 8076: 
<a name="8077"/> 8077:     %% Does the tid() refer to the same table as the name?
<a name="8078"/> 8078:     whereis_test = ets:new(whereis_test, [named_table]),
<a name="8079"/> 8079:     Tid = ets:whereis(whereis_test),
<a name="8080"/> 8080: 
<a name="8081"/> 8081:     ets:insert(whereis_test, [{hello}, {there}]),
<a name="8082"/> 8082:     CheckMatch =
<a name="8083"/> 8083:         fun(MatchRes) -&gt;
<a name="8084"/> 8084:                 case MatchRes of
<a name="8085"/> 8085:                     [[{there}],[{hello}]] -&gt; ok;
<a name="8086"/> 8086:                     [[{hello}],[{there}]] -&gt; ok
<a name="8087"/> 8087:                 end
<a name="8088"/> 8088:         end,
<a name="8089"/> 8089:     CheckMatch(ets:match(whereis_test, '$1')),
<a name="8090"/> 8090:     CheckMatch(ets:match(Tid, '$1')),
<a name="8091"/> 8091: 
<a name="8092"/> 8092:     true = ets:delete_all_objects(Tid),
<a name="8093"/> 8093: 
<a name="8094"/> 8094:     [] = ets:match(whereis_test, '$1'),
<a name="8095"/> 8095:     [] = ets:match(Tid, '$1'),
<a name="8096"/> 8096: 
<a name="8097"/> 8097:     %% Does the name disappear when deleted through the tid()?
<a name="8098"/> 8098:     true = ets:delete(Tid),
<a name="8099"/> 8099:     undefined = ets:info(whereis_test),
<a name="8100"/> 8100:     {'EXIT',{badarg, _}} = (catch ets:match(whereis_test, '$1')),
<a name="8101"/> 8101: 
<a name="8102"/> 8102:     %% Is the old tid() broken when the table is re-created with the same
<a name="8103"/> 8103:     %% name?
<a name="8104"/> 8104:     whereis_test = ets:new(whereis_test, [named_table]),
<a name="8105"/> 8105:     [] = ets:match(whereis_test, '$1'),
<a name="8106"/> 8106:     {'EXIT',{badarg, _}} = (catch ets:match(Tid, '$1')),
<a name="8107"/> 8107: 
<a name="whereis_table-last_expr"/><a name="8108"/> 8108:     ok.
<a name="8109"/> 8109: 
<a name="ms_excessive_nesting-1"/><a name="8110"/> 8110: <b>ms_excessive_nesting</b>(Config) when is_list(Config) -&gt;
<a name="8111"/> 8111:     MkMSCond = fun (_Fun, N) when N &lt; 0 -&gt; true;
<a name="8112"/> 8112:                    (Fun, N) -&gt; {'orelse', {'==', N, '$1'}, Fun(Fun, N-1)}
<a name="8113"/> 8113:                end,
<a name="8114"/> 8114:     %% Ensure it compiles with substantial but reasonable
<a name="8115"/> 8115:     %% (hmm...) nesting
<a name="8116"/> 8116:     MS = [{{'$1', '$2'}, [MkMSCond(MkMSCond, 100)], [{{'$1', blipp}}]}],
<a name="8117"/> 8117:     io:format(&quot;~p~n&quot;, [erlang:match_spec_test({1, blupp}, MS, table)]),
<a name="8118"/> 8118:     _ = ets:match_spec_compile(MS),
<a name="8119"/> 8119:     %% Now test match_spec_compile() and select_replace()
<a name="8120"/> 8120:     %% with tree and hash using excessive nesting. These
<a name="8121"/> 8121:     %% used to seg-fault the emulator due to recursion
<a name="8122"/> 8122:     %% beyond the end of the C-stack.
<a name="8123"/> 8123:     %%
<a name="8124"/> 8124:     %% We expect to get a system_limit error, but don't
<a name="8125"/> 8125:     %% fail if it compiles (someone must have rewritten
<a name="8126"/> 8126:     %% compilation of match specs to use an explicit
<a name="8127"/> 8127:     %% stack instead of using recursion).
<a name="8128"/> 8128:     ENMS = [{{'$1', '$2'}, [MkMSCond(MkMSCond, 1000000)], [{{'$1', blipp}}]}],
<a name="8129"/> 8129:     io:format(&quot;~p~n&quot;, [erlang:match_spec_test({1, blupp}, ENMS, table)]),
<a name="8130"/> 8130:     ENMSC = try
<a name="8131"/> 8131:                 ets:match_spec_compile(ENMS),
<a name="8132"/> 8132:                 &quot;compiled&quot;
<a name="8133"/> 8133:             catch
<a name="8134"/> 8134:                 error:system_limit -&gt;
<a name="8135"/> 8135:                     &quot;got system_limit&quot;
<a name="8136"/> 8136:             end,
<a name="8137"/> 8137:     Tree = ets:new(tree, [ordered_set]),
<a name="8138"/> 8138:     SRT = try
<a name="8139"/> 8139:               ets:select_replace(Tree, ENMS),
<a name="8140"/> 8140:               &quot;compiled&quot;
<a name="8141"/> 8141:           catch
<a name="8142"/> 8142:               error:system_limit -&gt;
<a name="8143"/> 8143:                   &quot;got system_limit&quot;
<a name="8144"/> 8144:           end,
<a name="8145"/> 8145:     Hash = ets:new(hash, [set]),
<a name="8146"/> 8146:     SRH = try
<a name="8147"/> 8147:               ets:select_replace(Hash, ENMS),
<a name="8148"/> 8148:               &quot;compiled&quot;
<a name="8149"/> 8149:           catch
<a name="8150"/> 8150:               error:system_limit -&gt;
<a name="8151"/> 8151:                   &quot;got system_limit&quot;
<a name="8152"/> 8152:           end,
<a name="ms_excessive_nesting-last_expr"/><a name="8153"/> 8153: <b>    {comment, &quot;match_spec_compile</b>() &quot;++ENMSC++&quot;; select_replace(_,[ordered_set]) &quot;++SRT++&quot;; select_replace(_,[set]) &quot;++SRH}.
<a name="8154"/> 8154: 
<a name="8155"/> 8155: <i>%% The following help functions are used by</i>
<a name="8156"/> 8156: <i>%% throughput_benchmark. They are declared on the top level beacuse</i>
<a name="8157"/> 8157: <i>%% declaring them as function local funs cause a scalability issue.</i>
<a name="get_op-2"/><a name="8158"/> 8158: <b>get_op</b>([{_,O}], _RandNum) -&gt;
<a name="8159"/> 8159:     O;
<a name="8160"/> 8160: <b>get_op</b>([{Prob,O}|Rest], RandNum) -&gt;
<a name="get_op-last_expr"/><a name="8161"/> 8161:     case RandNum &lt; Prob of
<a name="8162"/> 8162:         true -&gt; O;
<a name="8163"/> 8163:         false -&gt; get_op(Rest, RandNum)
<a name="8164"/> 8164:     end.
<a name="do_op-4"/><a name="8165"/> 8165: <b>do_op</b>(Table, ProbHelpTab, Range, Operations) -&gt;
<a name="8166"/> 8166:     RandNum = rand:uniform(),
<a name="8167"/> 8167:     Op = get_op(ProbHelpTab, RandNum),
<a name="8168"/> 8168:     #{ Op := TheOp} = Operations,
<a name="do_op-last_expr"/><a name="8169"/> 8169: <b>    TheOp</b>(Table, Range).
<a name="do_work-5"/><a name="8170"/> 8170: <b>do_work</b>(WorksDoneSoFar, Table, ProbHelpTab, Range, Operations) -&gt;
<a name="do_work-last_expr"/><a name="8171"/> 8171:     receive
<a name="8172"/> 8172:         stop -&gt; WorksDoneSoFar
<a name="8173"/> 8173:     after
<a name="8174"/> 8174:         0 -&gt; do_op(Table, ProbHelpTab, Range, Operations),
<a name="8175"/> 8175:              do_work(WorksDoneSoFar + 1, Table, ProbHelpTab, Range, Operations)
<a name="8176"/> 8176:     end.
<a name="8177"/> 8177: 
<a name="prefill_table-4"/><a name="8178"/> 8178: <b>prefill_table</b>(T, KeyRange, Num, ObjFun) -&gt;
<a name="8179"/> 8179:     Parent = self(),
<a name="8180"/> 8180:     spawn_link(fun() -&gt;
<a name="8181"/> 8181:                        prefill_table_helper(T, KeyRange, Num, ObjFun),
<a name="8182"/> 8182:                        Parent ! done
<a name="8183"/> 8183:                end),
<a name="prefill_table-last_expr"/><a name="8184"/> 8184:     receive done -&gt; ok end.
<a name="8185"/> 8185: 
<a name="prefill_table_helper-4"/><a name="8186"/> 8186: <b>prefill_table_helper</b>(T, KeyRange, Num, ObjFun) -&gt;
<a name="8187"/> 8187:     Seed = rand:uniform(KeyRange),
<a name="8188"/> 8188:     %%io:format(&quot;prefill_table: Seed = ~p\n&quot;, [Seed]),
<a name="8189"/> 8189:     RState = unique_rand_start(KeyRange, Seed),
<a name="prefill_table_helper-last_expr"/><a name="8190"/> 8190: <b>    prefill_table_loop</b>(T, RState, Num, ObjFun).
<a name="8191"/> 8191: 
<a name="prefill_table_loop-4"/><a name="8192"/> 8192: <b>prefill_table_loop</b>(_, _, 0, _) -&gt;
<a name="8193"/> 8193:     ok;
<a name="8194"/> 8194: <b>prefill_table_loop</b>(T, RS0, N, ObjFun) -&gt;
<a name="8195"/> 8195:     {Key, RS1} = unique_rand_next(RS0),
<a name="8196"/> 8196:     ets:insert(T, ObjFun(Key)),
<a name="prefill_table_loop-last_expr"/><a name="8197"/> 8197: <b>    prefill_table_loop</b>(T, RS1, N-1, ObjFun).
<a name="8198"/> 8198: 
<a name="inserter_proc_starter-3"/><a name="8199"/> 8199: <b>inserter_proc_starter</b>(T, ToInsert, Parent) -&gt;
<a name="8200"/> 8200:     receive
<a name="8201"/> 8201:         start -&gt; ok
<a name="8202"/> 8202:     end,
<a name="inserter_proc_starter-last_expr"/><a name="8203"/> 8203: <b>    inserter_proc</b>(T, ToInsert, [], Parent, false).
<a name="8204"/> 8204: 
<a name="inserter_proc-5"/><a name="8205"/> 8205: <b>inserter_proc</b>(T, [], Inserted, Parent, _) -&gt;
<a name="8206"/> 8206:     inserter_proc(T, Inserted, [], Parent, true);
<a name="8207"/> 8207: <b>inserter_proc</b>(T, [I | ToInsert], Inserted, Parent, CanStop) -&gt;
<a name="8208"/> 8208:     Stop =
<a name="8209"/> 8209:         case CanStop of
<a name="8210"/> 8210:             true -&gt;
<a name="8211"/> 8211:                 receive
<a name="8212"/> 8212:                     stop -&gt; Parent ! stopped
<a name="8213"/> 8213:                 after 0 -&gt; no_stop
<a name="8214"/> 8214:                 end;
<a name="8215"/> 8215:             false -&gt; no_stop
<a name="8216"/> 8216:         end,
<a name="inserter_proc-last_expr"/><a name="8217"/> 8217:     case Stop of
<a name="8218"/> 8218:         no_stop -&gt;
<a name="8219"/> 8219:             ets:insert(T, I),
<a name="8220"/> 8220:             inserter_proc(T, ToInsert, [I | Inserted], Parent, CanStop);
<a name="8221"/> 8221:         _ -&gt; ok
<a name="8222"/> 8222:     end.
<a name="8223"/> 8223: 
<a name="prefill_table_parallel-4"/><a name="8224"/> 8224: <b>prefill_table_parallel</b>(T, KeyRange, Num, ObjFun) -&gt;
<a name="8225"/> 8225:     Parent = self(),
<a name="8226"/> 8226:     spawn_link(fun() -&gt;
<a name="8227"/> 8227:                        prefill_table_parallel_helper(T, KeyRange, Num, ObjFun),
<a name="8228"/> 8228:                        Parent ! done
<a name="8229"/> 8229:                end),
<a name="prefill_table_parallel-last_expr"/><a name="8230"/> 8230:     receive done -&gt; ok end.
<a name="8231"/> 8231: 
<a name="prefill_table_parallel_helper-4"/><a name="8232"/> 8232: <b>prefill_table_parallel_helper</b>(T, KeyRange, Num, ObjFun) -&gt;
<a name="8233"/> 8233:     NrOfSchedulers = erlang:system_info(schedulers),
<a name="8234"/> 8234:     Seed = rand:uniform(KeyRange),
<a name="8235"/> 8235:     %%io:format(&quot;prefill_table: Seed = ~p\n&quot;, [Seed]),
<a name="8236"/> 8236:     RState = unique_rand_start(KeyRange, Seed),
<a name="8237"/> 8237:     InsertMap = prefill_insert_map_loop(T, RState, Num, ObjFun, #{}, NrOfSchedulers),
<a name="8238"/> 8238:     Self = self(),
<a name="8239"/> 8239:     Pids = [
<a name="8240"/> 8240:         begin
<a name="8241"/> 8241:             InserterFun =
<a name="8242"/> 8242:                 fun() -&gt;
<a name="8243"/> 8243:                     inserter_proc_starter(T, ToInsert, Self)
<a name="8244"/> 8244:                 end,
<a name="8245"/> 8245:             spawn_link(InserterFun)
<a name="8246"/> 8246:         end
<a name="8247"/> 8247:         || ToInsert &lt;- maps:values(InsertMap)],
<a name="8248"/> 8248:     [Pid ! start || Pid &lt;- Pids],
<a name="8249"/> 8249:     timer:sleep(1000),
<a name="8250"/> 8250:     [Pid ! stop || Pid &lt;- Pids],
<a name="prefill_table_parallel_helper-last_expr"/><a name="8251"/> 8251:     [receive stopped -&gt; ok end || _Pid &lt;- Pids].
<a name="8252"/> 8252: 
<a name="prefill_insert_map_loop-6"/><a name="8253"/> 8253: <b>prefill_insert_map_loop</b>(_, _, 0, _, InsertMap, _NrOfSchedulers) -&gt;
<a name="8254"/> 8254:     InsertMap;
<a name="8255"/> 8255: <b>prefill_insert_map_loop</b>(T, RS0, N, ObjFun, InsertMap, NrOfSchedulers) -&gt;
<a name="8256"/> 8256:     {Key, RS1} = unique_rand_next(RS0),
<a name="8257"/> 8257:     Sched = N rem NrOfSchedulers,
<a name="8258"/> 8258:     PrevInserts = maps:get(Sched, InsertMap, []),
<a name="8259"/> 8259:     NewPrevInserts = [ObjFun(Key) | PrevInserts],
<a name="8260"/> 8260:     NewInsertMap = maps:put(Sched, NewPrevInserts, InsertMap),
<a name="prefill_insert_map_loop-last_expr"/><a name="8261"/> 8261: <b>    prefill_insert_map_loop</b>(T, RS1, N-1, ObjFun, NewInsertMap, NrOfSchedulers).
<a name="8262"/> 8262: 
<a name="8263"/> 8263: <b>-record</b>(ets_throughput_bench_config,
<a name="8264"/> 8264:         {benchmark_duration_ms = 3000,
<a name="8265"/> 8265:          recover_time_ms = 1000,
<a name="8266"/> 8266:          thread_counts = not_set,
<a name="8267"/> 8267:          key_ranges = [1000000],
<a name="8268"/> 8268:          init_functions = [fun prefill_table/4],
<a name="8269"/> 8269:          nr_of_repeats = 1,
<a name="8270"/> 8270:          scenarios =
<a name="8271"/> 8271:              [
<a name="8272"/> 8272:               [
<a name="8273"/> 8273:                {0.5, insert},
<a name="8274"/> 8274:                {0.5, delete}
<a name="8275"/> 8275:               ],
<a name="8276"/> 8276:               [
<a name="8277"/> 8277:                {0.1, insert},
<a name="8278"/> 8278:                {0.1, delete},
<a name="8279"/> 8279:                {0.8, lookup}
<a name="8280"/> 8280:               ],
<a name="8281"/> 8281:               [
<a name="8282"/> 8282:                {0.01, insert},
<a name="8283"/> 8283:                {0.01, delete},
<a name="8284"/> 8284:                {0.98, lookup}
<a name="8285"/> 8285:               ],
<a name="8286"/> 8286:               [
<a name="8287"/> 8287:                {1.0, lookup}
<a name="8288"/> 8288:               ],
<a name="8289"/> 8289:               [
<a name="8290"/> 8290:                {0.1, insert},
<a name="8291"/> 8291:                {0.1, delete},
<a name="8292"/> 8292:                {0.4, lookup},
<a name="8293"/> 8293:                {0.4, nextseq10}
<a name="8294"/> 8294:               ],
<a name="8295"/> 8295:               [
<a name="8296"/> 8296:                {0.1, insert},
<a name="8297"/> 8297:                {0.1, delete},
<a name="8298"/> 8298:                {0.4, lookup},
<a name="8299"/> 8299:                {0.4, nextseq100}
<a name="8300"/> 8300:               ],
<a name="8301"/> 8301:               [
<a name="8302"/> 8302:                {0.1, insert},
<a name="8303"/> 8303:                {0.1, delete},
<a name="8304"/> 8304:                {0.4, lookup},
<a name="8305"/> 8305:                {0.4, nextseq1000}
<a name="8306"/> 8306:               ],
<a name="8307"/> 8307:               [
<a name="8308"/> 8308:                {1.0, nextseq1000}
<a name="8309"/> 8309:               ],
<a name="8310"/> 8310:               [
<a name="8311"/> 8311:                {0.1, insert},
<a name="8312"/> 8312:                {0.1, delete},
<a name="8313"/> 8313:                {0.79, lookup},
<a name="8314"/> 8314:                {0.01, selectAll}
<a name="8315"/> 8315:               ],
<a name="8316"/> 8316:               [
<a name="8317"/> 8317:                {0.1, insert},
<a name="8318"/> 8318:                {0.1, delete},
<a name="8319"/> 8319:                {0.7999, lookup},
<a name="8320"/> 8320:                {0.0001, selectAll}
<a name="8321"/> 8321:               ],
<a name="8322"/> 8322:               [
<a name="8323"/> 8323:                {0.1, insert},
<a name="8324"/> 8324:                {0.1, delete},
<a name="8325"/> 8325:                {0.799999, lookup},
<a name="8326"/> 8326:                {0.000001, selectAll}
<a name="8327"/> 8327:               ],
<a name="8328"/> 8328:               [
<a name="8329"/> 8329:                {0.1, insert},
<a name="8330"/> 8330:                {0.1, delete},
<a name="8331"/> 8331:                {0.79, lookup},
<a name="8332"/> 8332:                {0.01, partial_select1000}
<a name="8333"/> 8333:               ],
<a name="8334"/> 8334:               [
<a name="8335"/> 8335:                {0.1, insert},
<a name="8336"/> 8336:                {0.1, delete},
<a name="8337"/> 8337:                {0.7999, lookup},
<a name="8338"/> 8338:                {0.0001, partial_select1000}
<a name="8339"/> 8339:               ],
<a name="8340"/> 8340:               [
<a name="8341"/> 8341:                {0.1, insert},
<a name="8342"/> 8342:                {0.1, delete},
<a name="8343"/> 8343:                {0.799999, lookup},
<a name="8344"/> 8344:                {0.000001, partial_select1000}
<a name="8345"/> 8345:               ]
<a name="8346"/> 8346:              ],
<a name="8347"/> 8347:          table_types =
<a name="8348"/> 8348:              [
<a name="8349"/> 8349:               [ordered_set, public],
<a name="8350"/> 8350:               [ordered_set, public, {write_concurrency, true}],
<a name="8351"/> 8351:               [ordered_set, public, {read_concurrency, true}],
<a name="8352"/> 8352:               [ordered_set, public, {write_concurrency, true}, {read_concurrency, true}],
<a name="8353"/> 8353:               [set, public],
<a name="8354"/> 8354:               [set, public, {write_concurrency, true}],
<a name="8355"/> 8355:               [set, public, {read_concurrency, true}],
<a name="8356"/> 8356:               [set, public, {write_concurrency, true}, {read_concurrency, true}],
<a name="8357"/> 8357:               [set, public, {write_concurrency, auto}, {read_concurrency, true}],
<a name="8358"/> 8358:               [set, public, {write_concurrency, {debug_hash_fixed_number_of_locks, 16384}}]
<a name="8359"/> 8359:              ],
<a name="8360"/> 8360:          etsmem_fun = fun() -&gt; ok end,
<a name="8361"/> 8361:          verify_etsmem_fun = fun(_) -&gt; true end,
<a name="8362"/> 8362:          notify_res_fun = fun(_Name, _Throughput) -&gt; ok end,
<a name="8363"/> 8363:          print_result_paths_fun =
<a name="8364"/> 8364:              fun(ResultPath, _LatestResultPath) -&gt;
<a name="8365"/> 8365:                      Comment =
<a name="8366"/> 8366:                          io_lib:format(&quot;&lt;a href=\&quot;file:///~s\&quot;&gt;Result visualization&lt;/a&gt;&quot;,[ResultPath]),
<a name="8367"/> 8367:                      {comment, Comment}
<a name="8368"/> 8368:              end
<a name="8369"/> 8369:        }).
<a name="8370"/> 8370: 
<a name="stdout_notify_res-2"/><a name="8371"/> 8371: <b>stdout_notify_res</b>(ResultPath, LatestResultPath) -&gt;
<a name="8372"/> 8372:     io:format(&quot;Result Location: /~s~n&quot;, [ResultPath]),
<a name="stdout_notify_res-last_expr"/><a name="8373"/> 8373: <b>    io:format</b>(&quot;Latest Result Location: ~s~n&quot;, [LatestResultPath]).
<a name="8374"/> 8374: 
<a name="throughput_benchmark-0"/><a name="8375"/> 8375: <b>throughput_benchmark</b>() -&gt;
<a name="throughput_benchmark-last_expr"/><a name="8376"/> 8376: <b>    throughput_benchmark</b>(
<a name="8377"/> 8377:       #ets_throughput_bench_config{
<a name="8378"/> 8378:          print_result_paths_fun = fun stdout_notify_res/2}).
<a name="8379"/> 8379: 
<a name="throughput_benchmark-1"/><a name="8380"/> 8380: <b>throughput_benchmark</b>(
<a name="8381"/> 8381:   #ets_throughput_bench_config{
<a name="8382"/> 8382:      benchmark_duration_ms  = BenchmarkDurationMs,
<a name="8383"/> 8383:      recover_time_ms        = RecoverTimeMs,
<a name="8384"/> 8384:      thread_counts          = ThreadCountsOpt,
<a name="8385"/> 8385:      key_ranges             = KeyRanges,
<a name="8386"/> 8386:      init_functions         = InitFuns,
<a name="8387"/> 8387:      nr_of_repeats          = NrOfRepeats,
<a name="8388"/> 8388:      scenarios              = Scenarios,
<a name="8389"/> 8389:      table_types            = TableTypes,
<a name="8390"/> 8390:      etsmem_fun             = ETSMemFun,
<a name="8391"/> 8391:      verify_etsmem_fun      = VerifyETSMemFun,
<a name="8392"/> 8392:      notify_res_fun         = NotifyResFun,
<a name="8393"/> 8393:      print_result_paths_fun = PrintResultPathsFun}) -&gt;
<a name="8394"/> 8394:     NrOfSchedulers = erlang:system_info(schedulers),
<a name="8395"/> 8395:     %% Definitions of operations that are supported by the benchmark
<a name="8396"/> 8396:     NextSeqOp =
<a name="8397"/> 8397:         fun (T, KeyRange, SeqSize) -&gt;
<a name="8398"/> 8398:                 Start = rand:uniform(KeyRange),
<a name="8399"/> 8399:                 Last =
<a name="8400"/> 8400:                     lists:foldl(
<a name="8401"/> 8401:                       fun(_, Prev) -&gt;
<a name="8402"/> 8402:                               case Prev of
<a name="8403"/> 8403:                                   '$end_of_table'-&gt; ok;
<a name="8404"/> 8404:                                   _ -&gt;
<a name="8405"/> 8405:                                       try ets:next(T, Prev) of
<a name="8406"/> 8406:                                            Normal -&gt; Normal
<a name="8407"/> 8407:                                        catch
<a name="8408"/> 8408:                                            error:badarg -&gt;
<a name="8409"/> 8409:                                                % sets (not ordered_sets) cannot handle when the argument
<a name="8410"/> 8410:                                                % to next is not in the set
<a name="8411"/> 8411:                                                rand:uniform(KeyRange)
<a name="8412"/> 8412:                                        end
<a name="8413"/> 8413:                               end
<a name="8414"/> 8414:                       end,
<a name="8415"/> 8415:                       Start,
<a name="8416"/> 8416:                       lists:seq(1, SeqSize)),
<a name="8417"/> 8417:                 case Last =:= -1 of
<a name="8418"/> 8418:                     true -&gt; io:format(&quot;Will never be printed&quot;);
<a name="8419"/> 8419:                     false -&gt; ok
<a name="8420"/> 8420:                 end
<a name="8421"/> 8421:         end,
<a name="8422"/> 8422:     PartialSelectOp =
<a name="8423"/> 8423:         fun (T, KeyRange, SeqSize) -&gt;
<a name="8424"/> 8424:                 Start = rand:uniform(KeyRange),
<a name="8425"/> 8425:                 Last = Start + SeqSize,
<a name="8426"/> 8426:                 case -1 =:= ets:select_count(T,
<a name="8427"/> 8427:                                              ets:fun2ms(fun({X}) when X &gt; Start andalso X =&lt; Last  -&gt; true end)) of
<a name="8428"/> 8428:                     true -&gt; io:format(&quot;Will never be printed&quot;);
<a name="8429"/> 8429:                     false -&gt; ok
<a name="8430"/> 8430:                 end
<a name="8431"/> 8431: 
<a name="8432"/> 8432:         end,
<a name="8433"/> 8433:     %% Mapping benchmark operation names to their corresponding functions that do them
<a name="8434"/> 8434:     Operations =
<a name="8435"/> 8435:         #{insert =&gt;
<a name="8436"/> 8436:               fun(T,KeyRange) -&gt;
<a name="8437"/> 8437:                       Num = rand:uniform(KeyRange),
<a name="8438"/> 8438:                       ets:insert(T, {Num})
<a name="8439"/> 8439:               end,
<a name="8440"/> 8440:           delete =&gt;
<a name="8441"/> 8441:               fun(T,KeyRange) -&gt;
<a name="8442"/> 8442:                       Num = rand:uniform(KeyRange),
<a name="8443"/> 8443:                       ets:delete(T, Num)
<a name="8444"/> 8444:               end,
<a name="8445"/> 8445:           lookup =&gt;
<a name="8446"/> 8446:               fun(T,KeyRange) -&gt;
<a name="8447"/> 8447:                       Num = rand:uniform(KeyRange),
<a name="8448"/> 8448:                       ets:lookup(T, Num)
<a name="8449"/> 8449:               end,
<a name="8450"/> 8450:           nextseq10 =&gt;
<a name="8451"/> 8451:               fun(T,KeyRange) -&gt; NextSeqOp(T,KeyRange,10) end,
<a name="8452"/> 8452:           nextseq100 =&gt;
<a name="8453"/> 8453:               fun(T,KeyRange) -&gt; NextSeqOp(T,KeyRange,100) end,
<a name="8454"/> 8454:           nextseq1000 =&gt;
<a name="8455"/> 8455:               fun(T,KeyRange) -&gt; NextSeqOp(T,KeyRange,1000) end,
<a name="8456"/> 8456:           selectAll =&gt;
<a name="8457"/> 8457:               fun(T,_KeyRange) -&gt;
<a name="8458"/> 8458:                       case -1 =:= ets:select_count(T, ets:fun2ms(fun(_X) -&gt; true end)) of
<a name="8459"/> 8459:                           true -&gt; io:format(&quot;Will never be printed&quot;);
<a name="8460"/> 8460:                           false -&gt; ok
<a name="8461"/> 8461:                       end
<a name="8462"/> 8462:               end,
<a name="8463"/> 8463:           partial_select1000 =&gt;
<a name="8464"/> 8464:               fun(T,KeyRange) -&gt; PartialSelectOp(T,KeyRange,1000) end
<a name="8465"/> 8465:          },
<a name="8466"/> 8466:     %% Helper functions
<a name="8467"/> 8467:     CalculateThreadCounts = fun Calculate([Count|Rest]) -&gt;
<a name="8468"/> 8468:                                     case Count &gt; NrOfSchedulers of
<a name="8469"/> 8469:                                         true -&gt; lists:reverse(Rest);
<a name="8470"/> 8470:                                         false -&gt; Calculate([Count*2,Count|Rest])
<a name="8471"/> 8471:                                     end
<a name="8472"/> 8472:                             end,
<a name="8473"/> 8473:     CalculateOpsProbHelpTab =
<a name="8474"/> 8474:         fun Calculate([{_, OpName}], _) -&gt;
<a name="8475"/> 8475:                 [{1.0, OpName}];
<a name="8476"/> 8476:             Calculate([{OpPropability, OpName}|Res], Current) -&gt;
<a name="8477"/> 8477:                 NewCurrent = Current + OpPropability,
<a name="8478"/> 8478:                 [{NewCurrent, OpName}| Calculate(Res, NewCurrent)]
<a name="8479"/> 8479:         end,
<a name="8480"/> 8480:     RenderScenario =
<a name="8481"/> 8481:         fun R([], StringSoFar) -&gt;
<a name="8482"/> 8482:                 StringSoFar;
<a name="8483"/> 8483:             R([{Fraction, Operation}], StringSoFar) -&gt;
<a name="8484"/> 8484:                 io_lib:format(&quot;~s ~f% ~p&quot;,[StringSoFar, Fraction * 100.0, Operation]);
<a name="8485"/> 8485:             R([{Fraction, Operation}|Rest], StringSoFar) -&gt;
<a name="8486"/> 8486:                 R(Rest,
<a name="8487"/> 8487:                   io_lib:format(&quot;~s ~f% ~p, &quot;,[StringSoFar, Fraction * 100.0, Operation]))
<a name="8488"/> 8488:         end,
<a name="8489"/> 8489:     SafeFixTableIfRequired =
<a name="8490"/> 8490:         fun(Table, Scenario, On) -&gt;
<a name="8491"/> 8491:                 case set =:= ets:info(Table, type) of
<a name="8492"/> 8492:                     true -&gt;
<a name="8493"/> 8493:                         HasNotRequiringOp  =
<a name="8494"/> 8494:                             lists:search(
<a name="8495"/> 8495:                               fun({_,nextseq10}) -&gt; true;
<a name="8496"/> 8496:                                  ({_,nextseq100}) -&gt; true;
<a name="8497"/> 8497:                                  ({_,nextseq1000}) -&gt; true;
<a name="8498"/> 8498:                                  (_) -&gt; false
<a name="8499"/> 8499:                               end, Scenario),
<a name="8500"/> 8500:                         case HasNotRequiringOp of
<a name="8501"/> 8501:                             false -&gt; ok;
<a name="8502"/> 8502:                             _ -&gt; ets:safe_fixtable(Table, On)
<a name="8503"/> 8503:                         end;
<a name="8504"/> 8504:                     false -&gt; ok
<a name="8505"/> 8505:                 end
<a name="8506"/> 8506:         end,
<a name="8507"/> 8507:     DataHolder =
<a name="8508"/> 8508:         fun DataHolderFun(Data)-&gt;
<a name="8509"/> 8509:                 receive
<a name="8510"/> 8510:                     {get_data, Pid} -&gt; Pid ! {ets_bench_data, Data};
<a name="8511"/> 8511:                     D -&gt; DataHolderFun([Data,D])
<a name="8512"/> 8512:                 end
<a name="8513"/> 8513:         end,
<a name="8514"/> 8514:     DataHolderPid = spawn_link(fun()-&gt; DataHolder([]) end),
<a name="8515"/> 8515:     PrintData =
<a name="8516"/> 8516:         fun (Str, List) -&gt;
<a name="8517"/> 8517:                 io:format(Str, List),
<a name="8518"/> 8518:                 DataHolderPid ! io_lib:format(Str, List)
<a name="8519"/> 8519:         end,
<a name="8520"/> 8520:     GetData =
<a name="8521"/> 8521:         fun () -&gt;
<a name="8522"/> 8522:                 DataHolderPid ! {get_data, self()},
<a name="8523"/> 8523:                 receive {ets_bench_data, Data} -&gt; Data end
<a name="8524"/> 8524:         end,
<a name="8525"/> 8525:     %% Function that runs a benchmark instance and returns the number
<a name="8526"/> 8526:     %% of operations that were performed
<a name="8527"/> 8527:     RunBenchmark =
<a name="8528"/> 8528:         fun({NrOfProcs, TableConfig, Scenario, Range, Duration, InitFun}) -&gt;
<a name="8529"/> 8529:                 ProbHelpTab = CalculateOpsProbHelpTab(Scenario, 0),
<a name="8530"/> 8530:                 Table = ets:new(t, TableConfig),
<a name="8531"/> 8531:                 Nobj = Range div 2,
<a name="8532"/> 8532:                 case InitFun of
<a name="8533"/> 8533:                     not_set -&gt; prefill_table(Table, Range, Nobj, fun(K) -&gt; {K} end);
<a name="8534"/> 8534:                     _ -&gt; InitFun(Table, Range, Nobj, fun(K) -&gt; {K} end)
<a name="8535"/> 8535:                 end,
<a name="8536"/> 8536:                 Nobj = ets:info(Table, size),
<a name="8537"/> 8537:                 SafeFixTableIfRequired(Table, Scenario, true),
<a name="8538"/> 8538:                 ParentPid = self(),
<a name="8539"/> 8539:                 Worker =
<a name="8540"/> 8540:                     fun() -&gt;
<a name="8541"/> 8541:                             receive start -&gt; ok end,
<a name="8542"/> 8542:                             WorksDone =
<a name="8543"/> 8543:                                 do_work(0, Table, ProbHelpTab, Range, Operations),
<a name="8544"/> 8544:                             ParentPid ! WorksDone
<a name="8545"/> 8545:                     end,
<a name="8546"/> 8546:                 ChildPids =
<a name="8547"/> 8547:                     lists:map(fun(_N) -&gt;spawn_link(Worker)end, lists:seq(1, NrOfProcs)),
<a name="8548"/> 8548:                 erlang:garbage_collect(),
<a name="8549"/> 8549:                 timer:sleep(RecoverTimeMs),
<a name="8550"/> 8550:                 lists:foreach(fun(Pid) -&gt; Pid ! start end, ChildPids),
<a name="8551"/> 8551:                 timer:sleep(Duration),
<a name="8552"/> 8552:                 lists:foreach(fun(Pid) -&gt; Pid ! stop end, ChildPids),
<a name="8553"/> 8553:                 TotalWorksDone = lists:foldl(
<a name="8554"/> 8554:                                    fun(_, Sum) -&gt;
<a name="8555"/> 8555:                                            receive
<a name="8556"/> 8556:                                                Count -&gt; Sum + Count
<a name="8557"/> 8557:                                            end
<a name="8558"/> 8558:                                    end, 0, ChildPids),
<a name="8559"/> 8559:                 SafeFixTableIfRequired(Table, Scenario, false),
<a name="8560"/> 8560:                 ets:delete(Table),
<a name="8561"/> 8561:                 TotalWorksDone
<a name="8562"/> 8562:         end,
<a name="8563"/> 8563:     RunBenchmarkInSepProcess =
<a name="8564"/> 8564:         fun(ParameterTuple) -&gt;
<a name="8565"/> 8565:                 P = self(),
<a name="8566"/> 8566:                 Results =
<a name="8567"/> 8567:                     [begin
<a name="8568"/> 8568:                          spawn_link(fun()-&gt; P ! {bench_result, RunBenchmark(ParameterTuple)} end),
<a name="8569"/> 8569:                          receive {bench_result, Res} -&gt; Res end
<a name="8570"/> 8570:                      end || _ &lt;- lists:seq(1, NrOfRepeats)],
<a name="8571"/> 8571:                 lists:sum(Results) / NrOfRepeats
<a name="8572"/> 8572:         end,
<a name="8573"/> 8573:     RunBenchmarkAndReport =
<a name="8574"/> 8574:         fun(ThreadCount,
<a name="8575"/> 8575:             TableType,
<a name="8576"/> 8576:             Scenario,
<a name="8577"/> 8577:             KeyRange,
<a name="8578"/> 8578:             Duration,
<a name="8579"/> 8579:             InitFunName,
<a name="8580"/> 8580:             InitFun) -&gt;
<a name="8581"/> 8581:                 Result = RunBenchmarkInSepProcess({ThreadCount,
<a name="8582"/> 8582:                                                    TableType,
<a name="8583"/> 8583:                                                    Scenario,
<a name="8584"/> 8584:                                                    KeyRange,
<a name="8585"/> 8585:                                                    Duration,
<a name="8586"/> 8586:                                                    InitFun}),
<a name="8587"/> 8587:                 Throughput = Result/(Duration/1000.0),
<a name="8588"/> 8588:                 PrintData(&quot;; ~f&quot;,[Throughput]),
<a name="8589"/> 8589:                 Name = io_lib:format(&quot;Scenario: ~s, ~w, Key Range Size: ~w, &quot;
<a name="8590"/> 8590:                                      &quot;# of Processes: ~w, Table Type: ~w&quot;,
<a name="8591"/> 8591:                                      [InitFunName, Scenario, KeyRange, ThreadCount, TableType]),
<a name="8592"/> 8592:                 NotifyResFun(Name, Throughput)
<a name="8593"/> 8593:         end,
<a name="8594"/> 8594:     ThreadCounts =
<a name="8595"/> 8595:         case ThreadCountsOpt of
<a name="8596"/> 8596:             not_set -&gt;
<a name="8597"/> 8597:                 CalculateThreadCounts([1]);
<a name="8598"/> 8598:             _ -&gt; ThreadCountsOpt
<a name="8599"/> 8599:         end,
<a name="8600"/> 8600:     %% Run the benchmark
<a name="8601"/> 8601:     PrintData(&quot;# Each instance of the benchmark runs for ~w seconds:~n&quot;, [BenchmarkDurationMs/1000]),
<a name="8602"/> 8602:     PrintData(&quot;# The result of a benchmark instance is presented as a number representing~n&quot;,[]),
<a name="8603"/> 8603:     PrintData(&quot;# the number of operations performed per second:~n~n~n&quot;,[]),
<a name="8604"/> 8604:     PrintData(&quot;# To plot graphs for the results below:~n&quot;,[]),
<a name="8605"/> 8605:     PrintData(&quot;# 1. Open \&quot;$ERL_TOP/lib/stdlib/test/ets_SUITE_data/visualize_throughput.html\&quot; in a web browser~n&quot;,[]),
<a name="8606"/> 8606:     PrintData(&quot;# 2. Copy the lines between \&quot;#BENCHMARK STARTED$\&quot; and \&quot;#BENCHMARK ENDED$\&quot; below~n&quot;,[]),
<a name="8607"/> 8607:     PrintData(&quot;# 3. Paste the lines copied in step 2 to the text box in the browser window opened in~n&quot;,[]),
<a name="8608"/> 8608:     PrintData(&quot;#    step 1 and press the Render button~n~n&quot;,[]),
<a name="8609"/> 8609:     PrintData(&quot;#BENCHMARK STARTED$~n&quot;,[]),
<a name="8610"/> 8610:     EtsMem = ETSMemFun(),
<a name="8611"/> 8611:     %% The following loop runs all benchmark scenarios and prints the results (i.e, operations/second)
<a name="8612"/> 8612:     lists:foreach(
<a name="8613"/> 8613:       fun(KeyRange) -&gt;
<a name="8614"/> 8614:               lists:foreach(
<a name="8615"/> 8615:                 fun(Scenario) -&gt;
<a name="8616"/> 8616:                         PrintData(&quot;Scenario: ~s | Key Range Size: ~w$~n&quot;,
<a name="8617"/> 8617:                                   [RenderScenario(Scenario, &quot;&quot;), KeyRange]),
<a name="8618"/> 8618:                         lists:foreach(
<a name="8619"/> 8619:                           fun(ThreadCount) -&gt;
<a name="8620"/> 8620:                                   PrintData(&quot;; ~w&quot;,[ThreadCount])
<a name="8621"/> 8621:                           end,
<a name="8622"/> 8622:                           ThreadCounts),
<a name="8623"/> 8623:                         PrintData(&quot;$~n&quot;,[]),
<a name="8624"/> 8624:                         lists:foreach(
<a name="8625"/> 8625:                           fun(TableType) -&gt;
<a name="8626"/> 8626:                                   lists:foreach(
<a name="8627"/> 8627:                                     fun(InitFunArg) -&gt;
<a name="8628"/> 8628:                                             {InitFunName, InitFun} =
<a name="8629"/> 8629:                                                 case InitFunArg of
<a name="8630"/> 8630:                                                     {FunName, Fun} -&gt; {FunName, Fun};
<a name="8631"/> 8631:                                                     Fun -&gt; {&quot;&quot;, Fun}
<a name="8632"/> 8632:                                                 end,
<a name="8633"/> 8633:                                             PrintData(&quot;~s,~w &quot;,[InitFunName,TableType]),
<a name="8634"/> 8634:                                             lists:foreach(
<a name="8635"/> 8635:                                               fun(ThreadCount) -&gt;
<a name="8636"/> 8636:                                                       RunBenchmarkAndReport(ThreadCount,
<a name="8637"/> 8637:                                                                             TableType,
<a name="8638"/> 8638:                                                                             Scenario,
<a name="8639"/> 8639:                                                                             KeyRange,
<a name="8640"/> 8640:                                                                             BenchmarkDurationMs,
<a name="8641"/> 8641:                                                                             InitFunName,
<a name="8642"/> 8642:                                                                             InitFun)
<a name="8643"/> 8643:                                               end,
<a name="8644"/> 8644:                                               ThreadCounts),
<a name="8645"/> 8645:                                             PrintData(&quot;$~n&quot;,[])
<a name="8646"/> 8646:                                     end,
<a name="8647"/> 8647:                                     InitFuns)
<a name="8648"/> 8648: 
<a name="8649"/> 8649:                           end,
<a name="8650"/> 8650:                           TableTypes)
<a name="8651"/> 8651:                 end,
<a name="8652"/> 8652:                 Scenarios)
<a name="8653"/> 8653:       end,
<a name="8654"/> 8654:       KeyRanges),
<a name="8655"/> 8655:     PrintData(&quot;~n#BENCHMARK ENDED$~n~n&quot;,[]),
<a name="8656"/> 8656:     VerifyETSMemFun(EtsMem),
<a name="8657"/> 8657:     DataDir = filename:join(filename:dirname(code:which(?MODULE)), &quot;ets_SUITE_data&quot;),
<a name="8658"/> 8658:     TemplatePath = filename:join(DataDir, &quot;visualize_throughput.html&quot;),
<a name="8659"/> 8659:     {ok, Template} = file:read_file(TemplatePath),
<a name="8660"/> 8660:     OutputData = string:replace(Template, &quot;#bench_data_placeholder&quot;, GetData()),
<a name="8661"/> 8661:     OutputPath1 = filename:join(DataDir, &quot;ets_bench_result.html&quot;),
<a name="8662"/> 8662:     {{Year, Month, Day}, {Hour, Minute, Second}} = calendar:now_to_datetime(erlang:timestamp()),
<a name="8663"/> 8663:     StrTime = lists:flatten(io_lib:format(&quot;~4..0w-~2..0w-~2..0wT~2..0w:~2..0w:~2..0w&quot;,[Year,Month,Day,Hour,Minute,Second])),
<a name="8664"/> 8664:     OutputPath2 = filename:join(DataDir, io_lib:format(&quot;ets_bench_result_~s.html&quot;, [StrTime])),
<a name="8665"/> 8665:     file:write_file(OutputPath1, OutputData),
<a name="8666"/> 8666:     file:write_file(OutputPath2, OutputData),
<a name="throughput_benchmark-last_expr"/><a name="8667"/> 8667: <b>    PrintResultPathsFun</b>(OutputPath2, OutputPath1).
<a name="8668"/> 8668: 
<a name="test_throughput_benchmark-1"/><a name="8669"/> 8669: <b>test_throughput_benchmark</b>(Config) when is_list(Config) -&gt;
<a name="test_throughput_benchmark-last_expr"/><a name="8670"/> 8670: <b>    throughput_benchmark</b>(
<a name="8671"/> 8671:       #ets_throughput_bench_config{
<a name="8672"/> 8672:          benchmark_duration_ms = 100,
<a name="8673"/> 8673:          recover_time_ms = 0,
<a name="8674"/> 8674:          thread_counts = [1, erlang:system_info(schedulers)],
<a name="8675"/> 8675:          key_ranges = [50000],
<a name="8676"/> 8676:          etsmem_fun = fun etsmem/0,
<a name="8677"/> 8677:          verify_etsmem_fun = fun verify_etsmem/1}).
<a name="8678"/> 8678: 
<a name="long_throughput_benchmark-1"/><a name="8679"/> 8679: <b>long_throughput_benchmark</b>(Config) when is_list(Config) -&gt;
<a name="8680"/> 8680:     N = erlang:system_info(schedulers),
<a name="long_throughput_benchmark-last_expr"/><a name="8681"/> 8681: <b>    throughput_benchmark</b>(
<a name="8682"/> 8682:       #ets_throughput_bench_config{
<a name="8683"/> 8683:          benchmark_duration_ms = 3000,
<a name="8684"/> 8684:          recover_time_ms = 1000,
<a name="8685"/> 8685:          thread_counts = [1, N div 2, N],
<a name="8686"/> 8686:          key_ranges = [1000000],
<a name="8687"/> 8687:          scenarios =
<a name="8688"/> 8688:              [
<a name="8689"/> 8689:               [
<a name="8690"/> 8690:                {0.5, insert},
<a name="8691"/> 8691:                {0.5, delete}
<a name="8692"/> 8692:               ],
<a name="8693"/> 8693:               [
<a name="8694"/> 8694:                {0.1, insert},
<a name="8695"/> 8695:                {0.1, delete},
<a name="8696"/> 8696:                {0.8, lookup}
<a name="8697"/> 8697:               ],
<a name="8698"/> 8698:               [
<a name="8699"/> 8699:                {0.01, insert},
<a name="8700"/> 8700:                {0.01, delete},
<a name="8701"/> 8701:                {0.98, lookup}
<a name="8702"/> 8702:               ],
<a name="8703"/> 8703:               [
<a name="8704"/> 8704:                {0.1, insert},
<a name="8705"/> 8705:                {0.1, delete},
<a name="8706"/> 8706:                {0.4, lookup},
<a name="8707"/> 8707:                {0.4, nextseq100}
<a name="8708"/> 8708:               ],
<a name="8709"/> 8709:               [
<a name="8710"/> 8710:                {0.1, insert},
<a name="8711"/> 8711:                {0.1, delete},
<a name="8712"/> 8712:                {0.79, lookup},
<a name="8713"/> 8713:                {0.01, selectAll}
<a name="8714"/> 8714:               ],
<a name="8715"/> 8715:               [
<a name="8716"/> 8716:                {0.1, insert},
<a name="8717"/> 8717:                {0.1, delete},
<a name="8718"/> 8718:                {0.79, lookup},
<a name="8719"/> 8719:                {0.01, partial_select1000}
<a name="8720"/> 8720:               ]
<a name="8721"/> 8721:              ],
<a name="8722"/> 8722:          table_types =
<a name="8723"/> 8723:              ([
<a name="8724"/> 8724:                [ordered_set, public, {write_concurrency, true}, {read_concurrency, true}],
<a name="8725"/> 8725:                [set, public, {write_concurrency, true}, {read_concurrency, true}]
<a name="8726"/> 8726:               ] ++
<a name="8727"/> 8727:                   case catch list_to_integer(erlang:system_info(otp_release)) of
<a name="8728"/> 8728:                       Recent when is_integer(Recent), Recent &gt;= 25 -&gt;
<a name="8729"/> 8729:                           [[set, public, {write_concurrency, auto}, {read_concurrency, true}]];
<a name="8730"/> 8730:                       _Old -&gt; []
<a name="8731"/> 8731:                   end),
<a name="8732"/> 8732:          etsmem_fun = fun etsmem/0,
<a name="8733"/> 8733:          verify_etsmem_fun = fun verify_etsmem/1,
<a name="8734"/> 8734:          notify_res_fun =
<a name="8735"/> 8735:              fun(Name, Throughput) -&gt;
<a name="8736"/> 8736:                      SummaryTable =
<a name="8737"/> 8737:                          proplists:get_value(ets_benchmark_result_summary_tab, Config),
<a name="8738"/> 8738:                      AddToSummaryCounter =
<a name="8739"/> 8739:                          case SummaryTable of
<a name="8740"/> 8740:                              undefined -&gt;
<a name="8741"/> 8741:                                  fun(_, _) -&gt;
<a name="8742"/> 8742:                                          ok
<a name="8743"/> 8743:                                  end;
<a name="8744"/> 8744:                              Tab -&gt;
<a name="8745"/> 8745:                                  fun(CounterName, ToAdd) -&gt;
<a name="8746"/> 8746:                                          OldVal = ets:lookup_element(Tab, CounterName, 2),
<a name="8747"/> 8747:                                          NewVal = OldVal + ToAdd,
<a name="8748"/> 8748:                                          ets:insert(Tab, {CounterName, NewVal})
<a name="8749"/> 8749:                                  end
<a name="8750"/> 8750:                          end,
<a name="8751"/> 8751:                      Record =
<a name="8752"/> 8752:                          fun(NoOfBenchsCtr, TotThrputCtr) -&gt;
<a name="8753"/> 8753:                                  AddToSummaryCounter(NoOfBenchsCtr, 1),
<a name="8754"/> 8754:                                  AddToSummaryCounter(TotThrputCtr, Throughput)
<a name="8755"/> 8755:                          end,
<a name="8756"/> 8756:                      Record(nr_of_benchmarks, total_throughput),
<a name="8757"/> 8757:                      case string:find(Name, &quot;ordered_set&quot;) of
<a name="8758"/> 8758:                          nomatch -&gt;
<a name="8759"/> 8759:                              Record(nr_of_set_benchmarks, total_throughput_set);
<a name="8760"/> 8760:                          _ -&gt;
<a name="8761"/> 8761:                              Record(nr_of_ordered_set_benchmarks,
<a name="8762"/> 8762:                                     total_throughput_ordered_set)
<a name="8763"/> 8763:                      end,
<a name="8764"/> 8764:                      ct_event:notify(
<a name="8765"/> 8765:                           #event{name = benchmark_data,
<a name="8766"/> 8766:                                  data = [{suite,&quot;ets_bench&quot;},
<a name="8767"/> 8767:                                          {name, Name},
<a name="8768"/> 8768:                                          {value,Throughput}]})
<a name="8769"/> 8769:              end
<a name="8770"/> 8770:         }).
<a name="8771"/> 8771: 
<a name="8772"/> 8772: <i>%% This function compares the lookup operation's performance for</i>
<a name="8773"/> 8773: <i>%% ordered_set ETS tables with and without write_concurrency enabled</i>
<a name="8774"/> 8774: <i>%% when the data structures have been populated in parallel and</i>
<a name="8775"/> 8775: <i>%% sequentially.</i>
<a name="8776"/> 8776: <i>%%</i>
<a name="8777"/> 8777: <i>%% The main purpose of this function is to check that the</i>
<a name="8778"/> 8778: <i>%% implementation of ordered_set with write_concurrency (CA tree)</i>
<a name="8779"/> 8779: <i>%% adapts its structure to contention even when only lookup operations</i>
<a name="8780"/> 8780: <i>%% are used.</i>
<a name="lookup_catree_par_vs_seq_init_benchmark-0"/><a name="8781"/> 8781: <b>lookup_catree_par_vs_seq_init_benchmark</b>() -&gt;
<a name="8782"/> 8782:     N = erlang:system_info(schedulers),
<a name="lookup_catree_par_vs_seq_init_benchmark-last_expr"/><a name="8783"/> 8783: <b>    throughput_benchmark</b>(
<a name="8784"/> 8784:       #ets_throughput_bench_config{
<a name="8785"/> 8785:          benchmark_duration_ms = 600000,
<a name="8786"/> 8786:          recover_time_ms = 1000,
<a name="8787"/> 8787:          thread_counts = [1, N div 2, N],
<a name="8788"/> 8788:          key_ranges = [1000000],
<a name="8789"/> 8789:          init_functions = [{&quot;seq_init&quot;, fun prefill_table/4},
<a name="8790"/> 8790:                            {&quot;par_init&quot;, fun prefill_table_parallel/4}],
<a name="8791"/> 8791:          nr_of_repeats = 1,
<a name="8792"/> 8792:          scenarios =
<a name="8793"/> 8793:              [
<a name="8794"/> 8794:               [
<a name="8795"/> 8795:                {1.0, lookup}
<a name="8796"/> 8796:               ]
<a name="8797"/> 8797:              ],
<a name="8798"/> 8798:          table_types =
<a name="8799"/> 8799:              [
<a name="8800"/> 8800:               [ordered_set, public, {write_concurrency, true}],
<a name="8801"/> 8801:               [ordered_set, public]
<a name="8802"/> 8802:              ],
<a name="8803"/> 8803:           print_result_paths_fun = fun stdout_notify_res/2
<a name="8804"/> 8804:         }).
<a name="8805"/> 8805: 
<a name="add_lists-2"/><a name="8806"/> 8806: <b>add_lists</b>(L1,L2) -&gt;
<a name="add_lists-last_expr"/><a name="8807"/> 8807: <b>    add_lists</b>(L1,L2,[]).
<a name="add_lists-3"/><a name="8808"/> 8808: <b>add_lists</b>([],[],Acc) -&gt;
<a name="8809"/> 8809:     lists:reverse(Acc);
<a name="8810"/> 8810: <b>add_lists</b>([E1|T1], [E2|T2], Acc) -&gt;
<a name="add_lists-last_expr"/><a name="8811"/> 8811: <b>    add_lists</b>(T1, T2, [E1+E2 | Acc]).
<a name="8812"/> 8812: 
<a name="run_smp_workers-4"/><a name="8813"/> 8813: <b>run_smp_workers</b>(InitF,ExecF,FiniF,Laps) -&gt;
<a name="run_smp_workers-last_expr"/><a name="8814"/> 8814: <b>    run_smp_workers</b>(InitF,ExecF,FiniF,Laps, 0).
<a name="run_smp_workers-5"/><a name="8815"/> 8815: <b>run_smp_workers</b>(InitF,ExecF,FiniF,Laps, Exclude) -&gt;
<a name="run_smp_workers-last_expr"/><a name="8816"/> 8816: <b>    case erlang:system_info</b>(schedulers_online) of
<a name="8817"/> 8817:         N when N &gt; Exclude -&gt;
<a name="8818"/> 8818:             run_workers_do(InitF,ExecF,FiniF,Laps, N - Exclude);
<a name="8819"/> 8819:         _ -&gt;
<a name="8820"/> 8820:             {skipped, &quot;Too few schedulers online&quot;}
<a name="8821"/> 8821:     end.
<a name="8822"/> 8822: 
<a name="run_sched_workers-4"/><a name="8823"/> 8823: <b>run_sched_workers</b>(InitF,ExecF,FiniF,Laps) -&gt;
<a name="run_sched_workers-last_expr"/><a name="8824"/> 8824: <b>    run_workers_do</b>(InitF,ExecF,FiniF,Laps,
<a name="8825"/> 8825:                    erlang:system_info(schedulers)).
<a name="8826"/> 8826: 
<a name="run_workers_do-5"/><a name="8827"/> 8827: <b>run_workers_do</b>(InitF,ExecF,FiniF,Laps, NumOfProcs) -&gt;
<a name="8828"/> 8828:     io:format(&quot;starting ~p workers\n&quot;,[NumOfProcs]),
<a name="8829"/> 8829:     Seeds = [{ProcN,rand:uniform(9999)} || ProcN &lt;- lists:seq(1,NumOfProcs)],
<a name="8830"/> 8830:     Parent = self(),
<a name="8831"/> 8831:     Pids = [my_spawn_link(fun()-&gt; worker(Seed,InitF,ExecF,FiniF,Laps,Parent,NumOfProcs) end)
<a name="8832"/> 8832: 	    || Seed &lt;- Seeds],
<a name="run_workers_do-last_expr"/><a name="8833"/> 8833:     case Laps of
<a name="8834"/> 8834: 	infinite -&gt; Pids;
<a name="8835"/> 8835: 	_ -&gt; wait_pids(Pids)
<a name="8836"/> 8836:     end.
<a name="8837"/> 8837: 
<a name="worker-7"/><a name="8838"/> 8838: <b>worker</b>({ProcN,Seed}, InitF, ExecF, FiniF, Laps, Parent, NumOfProcs) -&gt;
<a name="8839"/> 8839:     io:format(&quot;smp worker ~p, seed=~p~n&quot;,[self(),Seed]),
<a name="8840"/> 8840:     rand:seed(default, {Seed,Seed,Seed}),
<a name="8841"/> 8841:     State1 = InitF([ProcN, NumOfProcs]),
<a name="8842"/> 8842:     State2 = worker_loop(Laps, ExecF, State1),
<a name="8843"/> 8843:     Result = FiniF(State2),
<a name="8844"/> 8844:     io:format(&quot;worker ~p done\n&quot;,[self()]),
<a name="worker-last_expr"/><a name="8845"/> 8845: <b>    Parent ! {self</b>(), Result}.
<a name="8846"/> 8846: 
<a name="worker_loop-3"/><a name="8847"/> 8847: <b>worker_loop</b>(0, _, State) -&gt;
<a name="8848"/> 8848:     State;
<a name="8849"/> 8849: <b>worker_loop</b>(_, _, [end_of_work|State]) -&gt;
<a name="8850"/> 8850:     State;
<a name="8851"/> 8851: <b>worker_loop</b>(infinite, ExecF, State) -&gt;
<a name="8852"/> 8852:     worker_loop(infinite,ExecF,ExecF(State));
<a name="8853"/> 8853: <b>worker_loop</b>(N, ExecF, State) -&gt;
<a name="worker_loop-last_expr"/><a name="8854"/> 8854: <b>    worker_loop</b>(N-1,ExecF,ExecF(State)).
<a name="8855"/> 8855: 
<a name="wait_pids-1"/><a name="8856"/> 8856: <b>wait_pids</b>(Pids) -&gt;
<a name="wait_pids-last_expr"/><a name="8857"/> 8857: <b>    wait_pids</b>(Pids,[]).
<a name="wait_pids-2"/><a name="8858"/> 8858: <b>wait_pids</b>([],Acc) -&gt;
<a name="8859"/> 8859:     Acc;
<a name="8860"/> 8860: <b>wait_pids</b>(Pids, Acc) -&gt;
<a name="wait_pids-last_expr"/><a name="8861"/> 8861:     receive
<a name="8862"/> 8862: 	{Pid,Result} -&gt;
<a name="8863"/> 8863: 	    true = lists:member(Pid,Pids),
<a name="8864"/> 8864: 	    Others = lists:delete(Pid,Pids),
<a name="8865"/> 8865: 	    %%io:format(&quot;wait_pid got ~p from ~p\n&quot;,[Result,Pid]),
<a name="8866"/> 8866: 	    wait_pids(Others,[Result | Acc])
<a name="8867"/> 8867:     after 60*1000 -&gt;
<a name="8868"/> 8868: 	    io:format(&quot;Still waiting for workers ~p\n&quot;,[Pids]),
<a name="8869"/> 8869:             wait_pids(Pids, Acc)
<a name="8870"/> 8870:     end.
<a name="8871"/> 8871: 
<a name="8872"/> 8872: 
<a name="8873"/> 8873: 
<a name="8874"/> 8874: 
<a name="my_tab_to_list-1"/><a name="8875"/> 8875: <b>my_tab_to_list</b>(Ts) -&gt;
<a name="8876"/> 8876:     Key = ets:first(Ts),
<a name="my_tab_to_list-last_expr"/><a name="8877"/> 8877: <b>    my_tab_to_list</b>(Ts,ets:next(Ts,Key),[ets:lookup(Ts, Key)]).
<a name="8878"/> 8878: 
<a name="my_tab_to_list-3"/><a name="8879"/> 8879: <b>my_tab_to_list</b>(_Ts,'$end_of_table', Acc) -&gt; lists:reverse(Acc);
<a name="8880"/> 8880: <b>my_tab_to_list</b>(Ts,Key, Acc) -&gt;
<a name="my_tab_to_list-last_expr"/><a name="8881"/> 8881: <b>    my_tab_to_list</b>(Ts,ets:next(Ts,Key),[ets:lookup(Ts, Key)| Acc]).
<a name="8882"/> 8882: 
<a name="8883"/> 8883: 
<a name="wait_for_memory_deallocations-0"/><a name="8884"/> 8884: <b>wait_for_memory_deallocations</b>() -&gt;
<a name="wait_for_memory_deallocations-last_expr"/><a name="8885"/> 8885:     try
<a name="8886"/> 8886: 	erts_debug:set_internal_state(wait, thread_progress),
<a name="8887"/> 8887: 	erts_debug:set_internal_state(wait, deallocations)
<a name="8888"/> 8888:     catch
<a name="8889"/> 8889: 	error:undef -&gt;
<a name="8890"/> 8890: 	    erts_debug:set_internal_state(available_internal_state, true),
<a name="8891"/> 8891: 	    wait_for_memory_deallocations();
<a name="8892"/> 8892:         error:badarg -&gt;
<a name="8893"/> 8893:             %% The emulator we run on does not have the wait internal state
<a name="8894"/> 8894:             %% so we just sleep some time instead...
<a name="8895"/> 8895:             timer:sleep(100)
<a name="8896"/> 8896:     end.
<a name="8897"/> 8897: 
<a name="etsmem-0"/><a name="8898"/> 8898: <b>etsmem</b>() -&gt;
<a name="etsmem-last_expr"/><a name="8899"/> 8899: <b>    etsmem</b>(get_etsmem(), 1).
<a name="8900"/> 8900: 
<a name="etsmem-2"/><a name="8901"/> 8901: <b>etsmem</b>(PrevEtsMem, Try) when Try &lt; 10 -&gt;
<a name="8902"/> 8902:     case get_etsmem() of
<a name="8903"/> 8903:         PrevEtsMem -&gt;
<a name="8904"/> 8904:             PrevEtsMem;
<a name="8905"/> 8905:         EtsMem -&gt;
<a name="8906"/> 8906:             io:format(&quot;etsmem(): Change in attempt ~p~n~nbefore:~n~p~n~nafter:~n~p~n~n&quot;,
<a name="8907"/> 8907:                       [Try, PrevEtsMem, EtsMem]),
<a name="8908"/> 8908:             etsmem(EtsMem, Try+1)
<a name="8909"/> 8909:     end;
<a name="8910"/> 8910: <b>etsmem</b>(_, _) -&gt;
<a name="etsmem-last_expr"/><a name="8911"/> 8911: <b>    ct:fail</b>(&quot;Failed to get a stable/consistent memory snapshot&quot;).
<a name="8912"/> 8912: 
<a name="get_etsmem-0"/><a name="8913"/> 8913: <b>get_etsmem</b>() -&gt;
<a name="8914"/> 8914:     AllTabsExceptions = [logger, code],
<a name="8915"/> 8915:     %% The logger table is excluded from the AllTabs list
<a name="8916"/> 8916:     %% below because it uses decentralized counters to keep
<a name="8917"/> 8917:     %% track of the size and the memory counters. This cause
<a name="8918"/> 8918:     %% ets:info(T,size) and ets:info(T,memory) to trigger
<a name="8919"/> 8919:     %% allocations and frees that may change the amount of
<a name="8920"/> 8920:     %% memory that is allocated for ETS.
<a name="8921"/> 8921:     %%
<a name="8922"/> 8922:     %% The code table is excluded from the list below
<a name="8923"/> 8923:     %% because the amount of memory allocated for it may
<a name="8924"/> 8924:     %% change if the tested code loads a new module.
<a name="8925"/> 8925:     AllTabs =
<a name="8926"/> 8926:         lists:sort(
<a name="8927"/> 8927:           [begin
<a name="8928"/> 8928:                try ets:info(T, decentralized_counters) of
<a name="8929"/> 8929:                    true -&gt;
<a name="8930"/> 8930:                        ct:fail(&quot;Background ETS table (~p) that &quot;
<a name="8931"/> 8931:                                &quot;uses decentralized counters (Add exception?)&quot;,
<a name="8932"/> 8932:                                [ets:info(T,name)]);
<a name="8933"/> 8933:                    _ -&gt; ok
<a name="8934"/> 8934:                catch _:_ -&gt;
<a name="8935"/> 8935:                        ok
<a name="8936"/> 8936:                end,
<a name="8937"/> 8937:                {T,
<a name="8938"/> 8938:                 ets:info(T,name),
<a name="8939"/> 8939:                 ets:info(T,size),
<a name="8940"/> 8940:                 ets:info(T,memory),
<a name="8941"/> 8941:                 ets:info(T,type)}
<a name="8942"/> 8942:            end
<a name="8943"/> 8943:            || T &lt;- ets:all(),
<a name="8944"/> 8944:               not lists:member(ets:info(T, name), AllTabsExceptions)]),
<a name="8945"/> 8945:     wait_for_memory_deallocations(),
<a name="8946"/> 8946:     EtsAllocSize = erts_debug:alloc_blocks_size(ets_alloc),
<a name="8947"/> 8947:     ErlangMemoryEts = try erlang:memory(ets)
<a name="8948"/> 8948:                       catch error:notsup -&gt; notsup end,
<a name="8949"/> 8949:     FlxCtrMemUsage = try erts_debug:get_internal_state(flxctr_memory_usage)
<a name="8950"/> 8950:                      catch error:badarg -&gt; notsup end,
<a name="8951"/> 8951:     Mem = {ErlangMemoryEts, EtsAllocSize, FlxCtrMemUsage},
<a name="get_etsmem-last_expr"/><a name="8952"/> 8952:     {Mem, AllTabs}.
<a name="8953"/> 8953: 
<a name="verify_etsmem-1"/><a name="8954"/> 8954: <b>verify_etsmem</b>(MI) -&gt;
<a name="8955"/> 8955:     wait_for_test_procs(),
<a name="verify_etsmem-last_expr"/><a name="8956"/> 8956: <b>    verify_etsmem</b>(MI, 1).
<a name="8957"/> 8957: 
<a name="verify_etsmem-2"/><a name="8958"/> 8958: <b>verify_etsmem</b>({MemInfo,AllTabs}, Try) -&gt;
<a name="verify_etsmem-last_expr"/><a name="8959"/> 8959: <b>    case etsmem</b>() of
<a name="8960"/> 8960: 	{MemInfo,_} -&gt;
<a name="8961"/> 8961: 	    io:format(&quot;Ets mem info: ~p&quot;, [MemInfo]),
<a name="8962"/> 8962: 	    case {MemInfo, Try} of
<a name="8963"/> 8963: 		{{ErlMem,EtsAlloc},_} when ErlMem == notsup; EtsAlloc == undefined -&gt;
<a name="8964"/> 8964: 		    %% Use 'erl +Mea max' to do more complete memory leak testing.
<a name="8965"/> 8965: 		    {comment,&quot;Incomplete or no mem leak testing&quot;};
<a name="8966"/> 8966: 		{_, 1} -&gt;
<a name="8967"/> 8967:                     ok;
<a name="8968"/> 8968:                 _ -&gt;
<a name="8969"/> 8969:                     {comment, &quot;Transient memory discrepancy&quot;}
<a name="8970"/> 8970: 	    end;
<a name="8971"/> 8971: 
<a name="8972"/> 8972: 	{MemInfo2, AllTabs2} -&gt;
<a name="8973"/> 8973: 	    io:format(&quot;#Expected: ~p&quot;, [MemInfo]),
<a name="8974"/> 8974: 	    io:format(&quot;#Actual:   ~p&quot;, [MemInfo2]),
<a name="8975"/> 8975: 	    io:format(&quot;#Changed tables before: ~p\n&quot;,[AllTabs -- AllTabs2]),
<a name="8976"/> 8976: 	    io:format(&quot;#Changed tables after: ~p\n&quot;, [AllTabs2 -- AllTabs]),
<a name="8977"/> 8977:             case Try &lt; 2 of
<a name="8978"/> 8978:                 true -&gt;
<a name="8979"/> 8979:                     io:format(&quot;\n#This discrepancy could be caused by an &quot;
<a name="8980"/> 8980:                               &quot;inconsistent memory \&quot;snapshot\&quot;&quot;
<a name="8981"/> 8981:                               &quot;\n#Try again...\n&quot;, []),
<a name="8982"/> 8982:                     verify_etsmem({MemInfo, AllTabs}, Try+1);
<a name="8983"/> 8983:                 false -&gt;
<a name="8984"/> 8984:                     ct:fail(&quot;Failed memory check&quot;)
<a name="8985"/> 8985:             end
<a name="8986"/> 8986:     end.
<a name="8987"/> 8987: 
<a name="8988"/> 8988: 
<a name="start_loopers-4"/><a name="8989"/> 8989: <b>start_loopers</b>(N, Prio, Fun, State) -&gt;
<a name="start_loopers-last_expr"/><a name="8990"/> 8990: <b>    lists:map</b>(fun (_) -&gt;
<a name="8991"/> 8991: 		      my_spawn_opt(fun () -&gt; looper(Fun, State) end,
<a name="8992"/> 8992: 				   [{priority, Prio}, link])
<a name="8993"/> 8993: 	      end,
<a name="8994"/> 8994: 	      lists:seq(1, N)).
<a name="8995"/> 8995: 
<a name="stop_loopers-1"/><a name="8996"/> 8996: <b>stop_loopers</b>(Loopers) -&gt;
<a name="8997"/> 8997:     lists:foreach(fun (P) -&gt;
<a name="8998"/> 8998: 			  unlink(P),
<a name="8999"/> 8999: 			  exit(P, bang)
<a name="9000"/> 9000: 		  end,
<a name="9001"/> 9001: 		  Loopers),
<a name="stop_loopers-last_expr"/><a name="9002"/> 9002:     ok.
<a name="9003"/> 9003: 
<a name="looper-2"/><a name="9004"/> 9004: <b>looper</b>(Fun, State) -&gt;
<a name="looper-last_expr"/><a name="9005"/> 9005: <b>    looper</b>(Fun, Fun(State)).
<a name="9006"/> 9006: 
<a name="spawn_logger-1"/><a name="9007"/> 9007: <b>spawn_logger</b>(Procs) -&gt;
<a name="spawn_logger-last_expr"/><a name="9008"/> 9008:     receive
<a name="9009"/> 9009: 	{new_test_proc, Proc} -&gt;
<a name="9010"/> 9010: 	    spawn_logger([Proc|Procs]);
<a name="9011"/> 9011: 	{sync_test_procs, Kill, From} -&gt;
<a name="9012"/> 9012: 	    lists:foreach(fun (Proc) when From == Proc -&gt;
<a name="9013"/> 9013: 				  ok;
<a name="9014"/> 9014: 			      (Proc) -&gt;
<a name="9015"/> 9015: 				  Mon = erlang:monitor(process, Proc),
<a name="9016"/> 9016: 				  ok = receive
<a name="9017"/> 9017: 				      {'DOWN', Mon, _, _, _} -&gt;
<a name="9018"/> 9018: 					  ok
<a name="9019"/> 9019: 				  after 0 -&gt;
<a name="9020"/> 9020: 					  case Kill of
<a name="9021"/> 9021: 					      true -&gt; exit(Proc, kill);
<a name="9022"/> 9022: 					      _ -&gt; ok
<a name="9023"/> 9023: 					  end,
<a name="9024"/> 9024: 					  receive
<a name="9025"/> 9025: 					      {'DOWN', Mon, _, _, _} -&gt;
<a name="9026"/> 9026: 						  ok
<a name="9027"/> 9027:                                           after 5000 -&gt;
<a name="9028"/> 9028: 						  io:format(&quot;Waiting for 'DOWN' from ~w, status=~w\n&quot;
<a name="9029"/> 9029:                                                             &quot;info = ~p\n&quot;, [Proc,
<a name="9030"/> 9030:                                                                             pid_status(Proc),
<a name="9031"/> 9031:                                                                             process_info(Proc)]),
<a name="9032"/> 9032:                                                   timeout
<a name="9033"/> 9033: 					  end
<a name="9034"/> 9034: 				  end
<a name="9035"/> 9035: 			  end, Procs),
<a name="9036"/> 9036: 	    From ! test_procs_synced,
<a name="9037"/> 9037: 	    spawn_logger([From])
<a name="9038"/> 9038:     end.
<a name="9039"/> 9039: 
<a name="pid_status-1"/><a name="9040"/> 9040: <b>pid_status</b>(Pid) -&gt;
<a name="pid_status-last_expr"/><a name="9041"/> 9041:     try
<a name="9042"/> 9042: 	erts_debug:get_internal_state({process_status, Pid})
<a name="9043"/> 9043:     catch
<a name="9044"/> 9044: 	error:undef -&gt;
<a name="9045"/> 9045: 	    erts_debug:set_internal_state(available_internal_state, true),
<a name="9046"/> 9046: 	    pid_status(Pid)
<a name="9047"/> 9047:     end. 
<a name="9048"/> 9048: 
<a name="start_spawn_logger-0"/><a name="9049"/> 9049: <b>start_spawn_logger</b>() -&gt;
<a name="start_spawn_logger-last_expr"/><a name="9050"/> 9050: <b>    case whereis</b>(ets_test_spawn_logger) of
<a name="9051"/> 9051: 	Pid when is_pid(Pid) -&gt; true;
<a name="9052"/> 9052: 	_ -&gt; register(ets_test_spawn_logger,
<a name="9053"/> 9053: 		      spawn_opt(fun () -&gt; spawn_logger([]) end,
<a name="9054"/> 9054: 				[{priority, max}]))
<a name="9055"/> 9055:     end.
<a name="9056"/> 9056: 
<a name="9057"/> 9057: <i>%% restart_spawn_logger() -&gt;</i>
<a name="9058"/> 9058: <i>%%     stop_spawn_logger(),</i>
<a name="9059"/> 9059: <i>%%     start_spawn_logger().</i>
<a name="9060"/> 9060: 
<a name="stop_spawn_logger-0"/><a name="9061"/> 9061: <b>stop_spawn_logger</b>() -&gt;
<a name="9062"/> 9062:     Mon = erlang:monitor(process, ets_test_spawn_logger),
<a name="9063"/> 9063:     (catch exit(whereis(ets_test_spawn_logger), kill)),
<a name="stop_spawn_logger-last_expr"/><a name="9064"/> 9064:     receive {'DOWN', Mon, _, _, _} -&gt; ok end.
<a name="9065"/> 9065: 
<a name="wait_for_test_procs-0"/><a name="9066"/> 9066: <b>wait_for_test_procs</b>() -&gt;
<a name="wait_for_test_procs-last_expr"/><a name="9067"/> 9067: <b>    wait_for_test_procs</b>(false).
<a name="9068"/> 9068: 
<a name="wait_for_test_procs-1"/><a name="9069"/> 9069: <b>wait_for_test_procs</b>(Kill) -&gt;
<a name="9070"/> 9070:     ets_test_spawn_logger ! {sync_test_procs, Kill, self()},
<a name="wait_for_test_procs-last_expr"/><a name="9071"/> 9071:     receive test_procs_synced -&gt; ok end.
<a name="9072"/> 9072: 
<a name="log_test_proc-1"/><a name="9073"/> 9073: <b>log_test_proc</b>(Proc) when is_pid(Proc) -&gt;
<a name="9074"/> 9074:     ets_test_spawn_logger ! {new_test_proc, Proc},
<a name="log_test_proc-last_expr"/><a name="9075"/> 9075:     Proc.
<a name="9076"/> 9076: 
<a name="my_spawn-1"/><a name="my_spawn-last_expr"/><a name="9077"/> 9077: <b>my_spawn</b>(Fun) -&gt; log_test_proc(spawn(Fun)).
<a name="9078"/> 9078: 
<a name="my_spawn_link-1"/><a name="my_spawn_link-last_expr"/><a name="9079"/> 9079: <b>my_spawn_link</b>(Fun) -&gt; log_test_proc(spawn_link(Fun)).
<a name="9080"/> 9080: 
<a name="my_spawn_opt-2"/><a name="9081"/> 9081: <b>my_spawn_opt</b>(Fun,Opts) -&gt;
<a name="my_spawn_opt-last_expr"/><a name="9082"/> 9082: <b>    case spawn_opt</b>(Fun,Opts) of
<a name="9083"/> 9083: 	Pid when is_pid(Pid) -&gt; log_test_proc(Pid);
<a name="9084"/> 9084: 	{Pid, _} = Res when is_pid(Pid) -&gt; log_test_proc(Pid), Res
<a name="9085"/> 9085:     end.
<a name="9086"/> 9086: 
<a name="my_spawn_monitor-1"/><a name="9087"/> 9087: <b>my_spawn_monitor</b>(Fun) -&gt;
<a name="9088"/> 9088:     Res = spawn_monitor(Fun),
<a name="9089"/> 9089:     {Pid, _} = Res,
<a name="9090"/> 9090:     log_test_proc(Pid),
<a name="my_spawn_monitor-last_expr"/><a name="9091"/> 9091:     Res.
<a name="9092"/> 9092: 
<a name="repeat-2"/><a name="9093"/> 9093: <b>repeat</b>(_Fun, 0) -&gt;
<a name="9094"/> 9094:     ok;
<a name="9095"/> 9095: <b>repeat</b>(Fun, N) -&gt;
<a name="9096"/> 9096:     Fun(),
<a name="repeat-last_expr"/><a name="9097"/> 9097: <b>    repeat</b>(Fun, N-1).
<a name="9098"/> 9098: 
<a name="repeat_while-1"/><a name="9099"/> 9099: <b>repeat_while</b>(Fun) -&gt;
<a name="repeat_while-last_expr"/><a name="9100"/> 9100: <b>    case Fun</b>() of
<a name="9101"/> 9101: 	true -&gt; repeat_while(Fun);
<a name="9102"/> 9102: 	false -&gt; false
<a name="9103"/> 9103:     end.
<a name="9104"/> 9104: 
<a name="repeat_while-2"/><a name="9105"/> 9105: <b>repeat_while</b>(Fun, Arg0) -&gt;
<a name="repeat_while-last_expr"/><a name="9106"/> 9106: <b>    case Fun</b>(Arg0) of
<a name="9107"/> 9107: 	{true,Arg1} -&gt; repeat_while(Fun,Arg1);
<a name="9108"/> 9108: 	{false,Ret} -&gt; Ret
<a name="9109"/> 9109:     end.
<a name="9110"/> 9110: 
<a name="9111"/> 9111: <i>%% Some (but not all) permutations of List</i>
<a name="repeat_for_permutations-2"/><a name="9112"/> 9112: <b>repeat_for_permutations</b>(Fun, List) -&gt;
<a name="repeat_for_permutations-last_expr"/><a name="9113"/> 9113: <b>    repeat_for_permutations</b>(Fun, List, length(List)-1).
<a name="repeat_for_permutations-3"/><a name="9114"/> 9114: <b>repeat_for_permutations</b>(Fun, List, 0) -&gt;
<a name="9115"/> 9115:     Fun(List);
<a name="9116"/> 9116: <b>repeat_for_permutations</b>(Fun, List, N) -&gt;
<a name="9117"/> 9117:     {A,B} = lists:split(N, List),
<a name="9118"/> 9118:     L1 = B++A,
<a name="9119"/> 9119:     L2 = lists:reverse(L1),
<a name="9120"/> 9120:     L3 = B++lists:reverse(A),
<a name="9121"/> 9121:     L4 = lists:reverse(B)++A,
<a name="9122"/> 9122:     Fun(L1), Fun(L2), Fun(L3), Fun(L4),
<a name="repeat_for_permutations-last_expr"/><a name="9123"/> 9123: <b>    repeat_for_permutations</b>(Fun, List, N-1).
<a name="9124"/> 9124: 
<a name="receive_any-0"/><a name="9125"/> 9125: <b>receive_any</b>() -&gt;
<a name="receive_any-last_expr"/><a name="9126"/> 9126:     receive M -&gt;
<a name="9127"/> 9127: 	    %%io:format(&quot;Process ~p got msg ~p\n&quot;, [self(),M]),
<a name="9128"/> 9128: 	    M
<a name="9129"/> 9129:     end.
<a name="9130"/> 9130: 
<a name="receive_any_spinning-0"/><a name="9131"/> 9131: <b>receive_any_spinning</b>() -&gt;
<a name="receive_any_spinning-last_expr"/><a name="9132"/> 9132: <b>    receive_any_spinning</b>(1000000).
<a name="receive_any_spinning-1"/><a name="9133"/> 9133: <b>receive_any_spinning</b>(Loops) -&gt;
<a name="receive_any_spinning-last_expr"/><a name="9134"/> 9134: <b>    receive_any_spinning</b>(Loops,Loops,1).
<a name="receive_any_spinning-3"/><a name="9135"/> 9135: <b>receive_any_spinning</b>(Loops,0,Tries) -&gt;
<a name="9136"/> 9136:     receive M -&gt;
<a name="9137"/> 9137: 	    io:format(&quot;Spinning process ~p got msg ~p after ~p tries\n&quot;, [self(),M,Tries]),
<a name="9138"/> 9138: 	    M
<a name="9139"/> 9139:     after 0 -&gt;
<a name="9140"/> 9140: 	    receive_any_spinning(Loops, Loops, Tries+1)
<a name="9141"/> 9141:     end;
<a name="9142"/> 9142: <b>receive_any_spinning</b>(Loops, N, Tries) when N&gt;0 -&gt;
<a name="receive_any_spinning-last_expr"/><a name="9143"/> 9143: <b>    receive_any_spinning</b>(Loops, N-1, Tries).
<a name="9144"/> 9144: 
<a name="9145"/> 9145: 
<a name="9146"/> 9146: 
<a name="spawn_monitor_with_pid-2"/><a name="9147"/> 9147: <b>spawn_monitor_with_pid</b>(Pid, Fun) when is_pid(Pid) -&gt;
<a name="spawn_monitor_with_pid-last_expr"/><a name="9148"/> 9148: <b>    spawn_monitor_with_pid</b>(Pid, Fun, 10).
<a name="9149"/> 9149: 
<a name="spawn_monitor_with_pid-3"/><a name="9150"/> 9150: <b>spawn_monitor_with_pid</b>(_, _, 0) -&gt;
<a name="9151"/> 9151:     failed;
<a name="9152"/> 9152: <b>spawn_monitor_with_pid</b>(Pid, Fun, N) -&gt;
<a name="spawn_monitor_with_pid-last_expr"/><a name="9153"/> 9153: <b>    case my_spawn</b>(fun()-&gt; case self() of
<a name="9154"/> 9154: 			      Pid -&gt; Fun();
<a name="9155"/> 9155: 			      _ -&gt; die
<a name="9156"/> 9156: 			  end
<a name="9157"/> 9157: 		  end) of
<a name="9158"/> 9158: 	Pid -&gt;
<a name="9159"/> 9159: 	    {Pid, erlang:monitor(process, Pid)};
<a name="9160"/> 9160: 	_Other -&gt;
<a name="9161"/> 9161: 	    spawn_monitor_with_pid(Pid,Fun,N-1)
<a name="9162"/> 9162:     end.
<a name="9163"/> 9163: 
<a name="9164"/> 9164: 
<a name="only_if_smp-1"/><a name="9165"/> 9165: <b>only_if_smp</b>(Func) -&gt;
<a name="only_if_smp-last_expr"/><a name="9166"/> 9166: <b>    only_if_smp</b>(2, Func).
<a name="only_if_smp-2"/><a name="9167"/> 9167: <b>only_if_smp</b>(Schedulers, Func) -&gt;
<a name="only_if_smp-last_expr"/><a name="9168"/> 9168: <b>    case erlang:system_info</b>(schedulers_online) of
<a name="9169"/> 9169: 	N when N &lt; Schedulers -&gt; {skip,&quot;Too few schedulers online&quot;};
<a name="9170"/> 9170: 	_ -&gt; Func()
<a name="9171"/> 9171:     end.
<a name="9172"/> 9172: 
<a name="9173"/> 9173: <i>%% Copy-paste from emulator/test/binary_SUITE.erl</i>
<a name="test_terms-2"/><a name="9174"/> 9174: <b>test_terms</b>(Test_Func, Mode) -&gt;
<a name="9175"/> 9175:     garbage_collect(),
<a name="9176"/> 9176:     Pib0 = process_info(self(),binary),
<a name="9177"/> 9177: 
<a name="9178"/> 9178:     Test_Func(atom),
<a name="9179"/> 9179:     Test_Func(''),
<a name="9180"/> 9180:     Test_Func('a'),
<a name="9181"/> 9181:     Test_Func('ab'),
<a name="9182"/> 9182:     Test_Func('abc'),
<a name="9183"/> 9183:     Test_Func('abcd'),
<a name="9184"/> 9184:     Test_Func('abcde'),
<a name="9185"/> 9185:     Test_Func('abcdef'),
<a name="9186"/> 9186:     Test_Func('abcdefg'),
<a name="9187"/> 9187:     Test_Func('abcdefgh'),
<a name="9188"/> 9188: 
<a name="9189"/> 9189:     Test_Func(fun() -&gt; ok end),
<a name="9190"/> 9190:     X = id([a,{b,c},c]),
<a name="9191"/> 9191:     Y = id({x,y,z}),
<a name="9192"/> 9192:     Z = id(1 bsl 8*257),
<a name="9193"/> 9193:     Test_Func(fun() -&gt; X end),
<a name="9194"/> 9194:     Test_Func(fun() -&gt; {X,Y} end),
<a name="9195"/> 9195:     Test_Func([fun() -&gt; {X,Y,Z} end,
<a name="9196"/> 9196: 	       fun() -&gt; {Z,X,Y} end,
<a name="9197"/> 9197: 	       fun() -&gt; {Y,Z,X} end]),
<a name="9198"/> 9198: 
<a name="9199"/> 9199:     Test_Func({trace_ts,{even_bigger,{some_data,fun() -&gt; ok end}},{1,2,3}}),
<a name="9200"/> 9200:     Test_Func({trace_ts,{even_bigger,{some_data,&lt;&lt;1,2,3,4,5,6,7,8,9,10&gt;&gt;}},
<a name="9201"/> 9201: 	       {1,2,3}}),
<a name="9202"/> 9202: 
<a name="9203"/> 9203:     Test_Func(1),
<a name="9204"/> 9204:     Test_Func(42),
<a name="9205"/> 9205:     Test_Func(-23),
<a name="9206"/> 9206:     Test_Func(256),
<a name="9207"/> 9207:     Test_Func(25555),
<a name="9208"/> 9208:     Test_Func(-3333),
<a name="9209"/> 9209: 
<a name="9210"/> 9210:     Test_Func(1.0),
<a name="9211"/> 9211: 
<a name="9212"/> 9212:     Test_Func(183749783987483978498378478393874),
<a name="9213"/> 9213:     Test_Func(-37894183749783987483978498378478393874),
<a name="9214"/> 9214:     Very_Big = very_big_num(),
<a name="9215"/> 9215:     Test_Func(Very_Big),
<a name="9216"/> 9216:     Test_Func(-Very_Big+1),
<a name="9217"/> 9217: 
<a name="9218"/> 9218:     Test_Func([]),
<a name="9219"/> 9219:     Test_Func(&quot;abcdef&quot;),
<a name="9220"/> 9220:     Test_Func([a, b, 1, 2]),
<a name="9221"/> 9221:     Test_Func([a|b]),
<a name="9222"/> 9222: 
<a name="9223"/> 9223:     Test_Func({}),
<a name="9224"/> 9224:     Test_Func({1}),
<a name="9225"/> 9225:     Test_Func({a, b}),
<a name="9226"/> 9226:     Test_Func({a, b, c}),
<a name="9227"/> 9227:     Test_Func(list_to_tuple(lists:seq(0, 255))),
<a name="9228"/> 9228:     Test_Func(list_to_tuple(lists:seq(0, 256))),
<a name="9229"/> 9229: 
<a name="9230"/> 9230:     Test_Func(make_ref()),
<a name="9231"/> 9231:     Test_Func([make_ref(), make_ref()]),
<a name="9232"/> 9232: 
<a name="9233"/> 9233:     Test_Func(make_port()),
<a name="9234"/> 9234: 
<a name="9235"/> 9235:     Test_Func(make_pid()),
<a name="9236"/> 9236:     Test_Func(make_ext_pid()),
<a name="9237"/> 9237:     Test_Func(make_ext_port()),
<a name="9238"/> 9238:     Test_Func(make_ext_ref()),
<a name="9239"/> 9239: 
<a name="9240"/> 9240:     Bin0 = list_to_binary(lists:seq(0, 14)),
<a name="9241"/> 9241:     Test_Func(Bin0),
<a name="9242"/> 9242:     Bin1 = list_to_binary(lists:seq(0, ?heap_binary_size)),
<a name="9243"/> 9243:     Test_Func(Bin1),
<a name="9244"/> 9244:     Bin2 = list_to_binary(lists:seq(0, ?heap_binary_size+1)),
<a name="9245"/> 9245:     Test_Func(Bin2),
<a name="9246"/> 9246:     Bin3 = list_to_binary(lists:seq(0, 255)),
<a name="9247"/> 9247:     garbage_collect(),
<a name="9248"/> 9248:     Pib = process_info(self(),binary),
<a name="9249"/> 9249:     Test_Func(Bin3),
<a name="9250"/> 9250:     garbage_collect(),
<a name="9251"/> 9251:     case Mode of
<a name="9252"/> 9252: 	strict -&gt; Pib = process_info(self(),binary);
<a name="9253"/> 9253: 	skip_refc_check -&gt; ok
<a name="9254"/> 9254:     end,
<a name="9255"/> 9255: 
<a name="9256"/> 9256:     Test_Func(make_unaligned_sub_binary(Bin0)),
<a name="9257"/> 9257:     Test_Func(make_unaligned_sub_binary(Bin1)),
<a name="9258"/> 9258:     Test_Func(make_unaligned_sub_binary(Bin2)),
<a name="9259"/> 9259:     Test_Func(make_unaligned_sub_binary(Bin3)),
<a name="9260"/> 9260: 
<a name="9261"/> 9261:     Test_Func(make_sub_binary(lists:seq(42, 43))),
<a name="9262"/> 9262:     Test_Func(make_sub_binary([42,43,44])),
<a name="9263"/> 9263:     Test_Func(make_sub_binary([42,43,44,45])),
<a name="9264"/> 9264:     Test_Func(make_sub_binary([42,43,44,45,46])),
<a name="9265"/> 9265:     Test_Func(make_sub_binary([42,43,44,45,46,47])),
<a name="9266"/> 9266:     Test_Func(make_sub_binary([42,43,44,45,46,47,48])),
<a name="9267"/> 9267:     Test_Func(make_sub_binary(lists:seq(42, 49))),
<a name="9268"/> 9268:     Test_Func(make_sub_binary(lists:seq(0, 14))),
<a name="9269"/> 9269:     Test_Func(make_sub_binary(lists:seq(0, ?heap_binary_size))),
<a name="9270"/> 9270:     Test_Func(make_sub_binary(lists:seq(0, ?heap_binary_size+1))),
<a name="9271"/> 9271:     Test_Func(make_sub_binary(lists:seq(0, 255))),
<a name="9272"/> 9272: 
<a name="9273"/> 9273:     Test_Func(make_unaligned_sub_binary(lists:seq(42, 43))),
<a name="9274"/> 9274:     Test_Func(make_unaligned_sub_binary([42,43,44])),
<a name="9275"/> 9275:     Test_Func(make_unaligned_sub_binary([42,43,44,45])),
<a name="9276"/> 9276:     Test_Func(make_unaligned_sub_binary([42,43,44,45,46])),
<a name="9277"/> 9277:     Test_Func(make_unaligned_sub_binary([42,43,44,45,46,47])),
<a name="9278"/> 9278:     Test_Func(make_unaligned_sub_binary([42,43,44,45,46,47,48])),
<a name="9279"/> 9279:     Test_Func(make_unaligned_sub_binary(lists:seq(42, 49))),
<a name="9280"/> 9280:     Test_Func(make_unaligned_sub_binary(lists:seq(0, 14))),
<a name="9281"/> 9281:     Test_Func(make_unaligned_sub_binary(lists:seq(0, ?heap_binary_size))),
<a name="9282"/> 9282:     Test_Func(make_unaligned_sub_binary(lists:seq(0, ?heap_binary_size+1))),
<a name="9283"/> 9283:     Test_Func(make_unaligned_sub_binary(lists:seq(0, 255))),
<a name="9284"/> 9284: 
<a name="9285"/> 9285:     %% Bit level binaries.
<a name="9286"/> 9286:     Test_Func(&lt;&lt;1:1&gt;&gt;),
<a name="9287"/> 9287:     Test_Func(&lt;&lt;2:2&gt;&gt;),
<a name="9288"/> 9288:     Test_Func(&lt;&lt;42:10&gt;&gt;),
<a name="9289"/> 9289:     Test_Func(list_to_bitstring([&lt;&lt;5:6&gt;&gt;|lists:seq(0, 255)])),
<a name="9290"/> 9290: 
<a name="9291"/> 9291:     Test_Func(F = fun(A) -&gt; 42*A end),
<a name="9292"/> 9292:     Test_Func(lists:duplicate(32, F)),
<a name="9293"/> 9293: 
<a name="9294"/> 9294:     Test_Func(FF = fun binary_SUITE:all/1),
<a name="9295"/> 9295:     Test_Func(lists:duplicate(32, FF)),
<a name="9296"/> 9296: 
<a name="9297"/> 9297:     garbage_collect(),
<a name="9298"/> 9298:     case Mode of
<a name="9299"/> 9299: 	strict -&gt; Pib0 = process_info(self(),binary);
<a name="9300"/> 9300: 	skip_refc_check -&gt; ok
<a name="9301"/> 9301:     end,
<a name="test_terms-last_expr"/><a name="9302"/> 9302:     ok.
<a name="9303"/> 9303: 
<a name="error_info-1"/><a name="9304"/> 9304: <b>error_info</b>(_Config) -&gt;
<a name="9305"/> 9305:     Ms = [{{'$1','$2','$3'},[],['$$']}],
<a name="9306"/> 9306:     BagTab = fun(_Type) -&gt; ets:new(table, [set,bag,private]) end,
<a name="9307"/> 9307:     OneKeyTab = fun(Type) -&gt;
<a name="9308"/> 9308:                         T = ets:new(table, [Type, private]),
<a name="9309"/> 9309:                         true = ets:insert(T, {one,two,3}),
<a name="9310"/> 9310:                         T
<a name="9311"/> 9311:                 end,
<a name="9312"/> 9312:     Set = fun(_Type) -&gt; ets:new(table, [set, private]) end,
<a name="9313"/> 9313:     OrderedSet = fun(_Type) -&gt; ets:new(table, [ordered_set, private]) end,
<a name="9314"/> 9314:     NamedTable = fun(Type) -&gt; ets:new('$named_table', [Type, named_table, private]) end,
<a name="9315"/> 9315:     UnownedTable = fun(Type) -&gt;
<a name="9316"/> 9316:                            Parent = self(),
<a name="9317"/> 9317:                            spawn_link(fun() -&gt;
<a name="9318"/> 9318:                                               T = ets:new(table, [Type, public]),
<a name="9319"/> 9319:                                               Parent ! T,
<a name="9320"/> 9320:                                               receive ok -&gt; ok end
<a name="9321"/> 9321:                                       end),
<a name="9322"/> 9322:                            receive T -&gt; T end
<a name="9323"/> 9323:                    end,
<a name="9324"/> 9324:     _ = ets:new(name_already_exists, [named_table]),
<a name="9325"/> 9325: 
<a name="9326"/> 9326:     L = [{delete, ['$Tab']},
<a name="9327"/> 9327:          {delete, ['$Tab', no_key], [no_fail]},
<a name="9328"/> 9328:          {delete_all_objects, ['$Tab'], [renamed]},
<a name="9329"/> 9329:          {delete_object, ['$Tab', bad_object]},
<a name="9330"/> 9330:          {delete_object, ['$Tab', {tag,non_existing}], [no_fail]},
<a name="9331"/> 9331: 
<a name="9332"/> 9332:          {file2tab, 1},                          %Not BIF.
<a name="9333"/> 9333:          {file2tab, 2},                          %Not BIF.
<a name="9334"/> 9334: 
<a name="9335"/> 9335:          {first, ['$Tab']},
<a name="9336"/> 9336: 
<a name="9337"/> 9337:          {foldl, 3},                            %Not BIF.
<a name="9338"/> 9338:          {foldr, 3},                            %Not BIF.
<a name="9339"/> 9339: 
<a name="9340"/> 9340:          {from_dets, 2},                        %Not BIF.
<a name="9341"/> 9341: 
<a name="9342"/> 9342:          {fun2ms, 1},                           %Not BIF.
<a name="9343"/> 9343: 
<a name="9344"/> 9344:          {give_away, ['$Tab', not_a_pid, bad_pid]},
<a name="9345"/> 9345:          {give_away, ['$Tab', '$Self', already_owner], [{error_term,owner}]},
<a name="9346"/> 9346:          {give_away, ['$Tab', '$Living', living_process], [only_bad_table]},
<a name="9347"/> 9347:          {give_away, ['$Tab', '$Dead', dead_process]},
<a name="9348"/> 9348: 
<a name="9349"/> 9349:          {give_away, [UnownedTable, '$Living', gift_data], [{error_term,not_owner}]},
<a name="9350"/> 9350: 
<a name="9351"/> 9351:          {i, 1},                                %Not BIF.
<a name="9352"/> 9352:          {i, 2},                                %Not BIF.
<a name="9353"/> 9353:          {i, 3},                                %Not BIF.
<a name="9354"/> 9354: 
<a name="9355"/> 9355:          {info, ['$Tab']},
<a name="9356"/> 9356:          {info, ['$Tab', invalid_item]},
<a name="9357"/> 9357: 
<a name="9358"/> 9358:          {init_table, 2},                       %Not BIF.
<a name="9359"/> 9359: 
<a name="9360"/> 9360:          {insert, ['$Tab', bad_object]},
<a name="9361"/> 9361:          {insert, ['$Tab', {}]},
<a name="9362"/> 9362:          {insert, ['$Tab', [a,{a,b,c}]]},
<a name="9363"/> 9363:          {insert, ['$Tab', [a|b]]},
<a name="9364"/> 9364:          {insert, ['$Tab', {a,b,c}], [no_fail]},
<a name="9365"/> 9365:          {insert, ['$Tab', [{a,b,c}]], [no_fail]},
<a name="9366"/> 9366:          {insert, ['$Tab', [{a,b,c},{d,e,f}]], [no_fail]},
<a name="9367"/> 9367:          {insert, ['$Tab', [{I,b,c} || I &lt;- lists:seq(1,10_000)]], [no_fail]},
<a name="9368"/> 9368: 
<a name="9369"/> 9369:          {insert_new, ['$Tab', bad_object]},
<a name="9370"/> 9370:          {insert_new, ['$Tab', {a,b,c}], [no_fail]},
<a name="9371"/> 9371:          {insert_new, ['$Tab', [a,{a,b,c}]]},
<a name="9372"/> 9372:          {insert_new, ['$Tab', [a|b]]},
<a name="9373"/> 9373: 
<a name="9374"/> 9374:          {internal_delete_all, 2},              %Internal function.
<a name="9375"/> 9375:          {internal_select_delete, 2},           %Internal function.
<a name="9376"/> 9376: 
<a name="9377"/> 9377:          {is_compiled_ms, [bad_ms], [no_fail, no_table]},
<a name="9378"/> 9378: 
<a name="9379"/> 9379:          {last, ['$Tab']},
<a name="9380"/> 9380: 
<a name="9381"/> 9381:          {lookup, ['$Tab', no_key], [no_fail]},
<a name="9382"/> 9382: 
<a name="9383"/> 9383:          {lookup_element, ['$Tab', no_key, 0]},
<a name="9384"/> 9384:          {lookup_element, ['$Tab', no_key, 1], [{error_term,badkey}]},
<a name="9385"/> 9385:          {lookup_element, ['$Tab', no_key, bad_pos]},
<a name="9386"/> 9386: 
<a name="9387"/> 9387:          {lookup_element, [OneKeyTab, one, 4]},
<a name="9388"/> 9388: 
<a name="9389"/> 9389:          {lookup_element, ['$Tab', no_key, 1, default_value], [no_fail]},
<a name="9390"/> 9390:          {lookup_element, [OneKeyTab, one, 4, default_value]},
<a name="9391"/> 9391: 
<a name="9392"/> 9392:          {match, [bad_continuation], [no_table]},
<a name="9393"/> 9393: 
<a name="9394"/> 9394:          {match, ['$Tab', &lt;&lt;1,2,3&gt;&gt;], [no_fail]},
<a name="9395"/> 9395:          {match, ['$Tab', &lt;&lt;1,2,3&gt;&gt;, 0]},
<a name="9396"/> 9396:          {match, ['$Tab', &lt;&lt;1,2,3&gt;&gt;, bad_limit]},
<a name="9397"/> 9397:          {match_delete, ['$Tab', &lt;&lt;1,2,3&gt;&gt;], [no_fail,renamed]},
<a name="9398"/> 9398: 
<a name="9399"/> 9399:          {match_object, [bad_continuation], [no_table]},
<a name="9400"/> 9400: 
<a name="9401"/> 9401:          {match_object, ['$Tab', &lt;&lt;1,2,3&gt;&gt;], [no_fail]},
<a name="9402"/> 9402:          {match_object, ['$Tab', &lt;&lt;1,2,3&gt;&gt;, bad_limit]},
<a name="9403"/> 9403: 
<a name="9404"/> 9404:          {match_spec_compile, [bad_match_spec], [no_table]},
<a name="9405"/> 9405:          {match_spec_run, 2},                   %Not BIF.
<a name="9406"/> 9406:          {match_spec_run_r, 3},                 %Internal BIF.
<a name="9407"/> 9407: 
<a name="9408"/> 9408:          {member, ['$Tab', no_key], [no_fail]},
<a name="9409"/> 9409: 
<a name="9410"/> 9410:          {new, [name, not_list], [no_table]},
<a name="9411"/> 9411:          {new, [name, [a|b]], [no_table]},
<a name="9412"/> 9412:          {new, [name, [a,b]], [no_table]},
<a name="9413"/> 9413:          {new, [{bad,name}, [a,b]], [no_table]},
<a name="9414"/> 9414:          {new, [name_already_exists, [named_table]], [no_table,
<a name="9415"/> 9415:                                                       {error_term,already_exists}]},
<a name="9416"/> 9416: 
<a name="9417"/> 9417:          %% For a set, ets:next/2 and ets:prev/2 fails if the key does
<a name="9418"/> 9418:          %% not exist.
<a name="9419"/> 9419:          {next, [Set, no_key]},
<a name="9420"/> 9420:          {prev, [Set, no_key]},
<a name="9421"/> 9421: 
<a name="9422"/> 9422:          %% For an ordered set, ets:next/2 and ets:prev/2 succeeds
<a name="9423"/> 9423:          %% even if the key does not exist.
<a name="9424"/> 9424:          {next, [OrderedSet, no_key], [no_fail]},
<a name="9425"/> 9425:          {prev, [OrderedSet, no_key], [no_fail]},
<a name="9426"/> 9426: 
<a name="9427"/> 9427:          {rename, ['$Tab', {bad,name}]},
<a name="9428"/> 9428:          {rename, [NamedTable, '$named_table']},
<a name="9429"/> 9429:          {rename, [NamedTable, {bad,name}]},
<a name="9430"/> 9430: 
<a name="9431"/> 9431:          {repair_continuation, 2},              %Not BIF.
<a name="9432"/> 9432: 
<a name="9433"/> 9433:          {safe_fixtable, ['$Tab', true], [no_fail]},
<a name="9434"/> 9434:          {safe_fixtable, ['$Tab', not_boolean]},
<a name="9435"/> 9435: 
<a name="9436"/> 9436:          {select, [bad_continuation], [no_table]},
<a name="9437"/> 9437: 
<a name="9438"/> 9438:          {select, ['$Tab', Ms], [no_fail]},
<a name="9439"/> 9439:          {select, ['$Tab', bad_match_spec]},
<a name="9440"/> 9440:          {select, ['$Tab', Ms, bad_limit]},
<a name="9441"/> 9441:          {select, ['$Tab', Ms, 0]},
<a name="9442"/> 9442:          {select, ['$Tab', bad_match_spec, bad_limit]},
<a name="9443"/> 9443:          {select, ['$Tab', bad_match_spec, 1]},
<a name="9444"/> 9444: 
<a name="9445"/> 9445:          {select_count, ['$Tab', Ms], [no_fail]},
<a name="9446"/> 9446:          {select_count, ['$Tab', bad_match_spec]},
<a name="9447"/> 9447: 
<a name="9448"/> 9448:          {select_delete, ['$Tab', Ms], [no_fail,renamed]},
<a name="9449"/> 9449:          {select_delete, ['$Tab', bad_match_spec], [renamed]},
<a name="9450"/> 9450: 
<a name="9451"/> 9451:          {select_replace, ['$Tab', [{{'$1','$2','$3'},[],[{{'$1','$3','$2'}}]}]], [no_fail]},
<a name="9452"/> 9452:          {select_replace, ['$Tab', [{{'$1','$2','$3'},[],[{{'key_destroyed'}}]}]]},
<a name="9453"/> 9453:          {select_replace, ['$Tab', bad_match_spec]},
<a name="9454"/> 9454: 
<a name="9455"/> 9455:          {select_replace, [BagTab, [{{'$1','$2','$3'},[],[{{'$1','$3','$2'}}]}]], [{error_term,table_type}]},
<a name="9456"/> 9456: 
<a name="9457"/> 9457:          {select_reverse, [bad_continuation], [no_table]},
<a name="9458"/> 9458: 
<a name="9459"/> 9459:          {select_reverse, ['$Tab', Ms], [no_fail]},
<a name="9460"/> 9460:          {select_reverse, ['$Tab', bad_match_spec]},
<a name="9461"/> 9461: 
<a name="9462"/> 9462:          {select_reverse, ['$Tab', Ms, 0]},
<a name="9463"/> 9463:          {select_reverse, ['$Tab', Ms, bad_limit]},
<a name="9464"/> 9464:          {select_reverse, ['$Tab', bad_match_spec, bad_limit]},
<a name="9465"/> 9465: 
<a name="9466"/> 9466:          {setopts, ['$Tab', bad_opts]},
<a name="9467"/> 9467: 
<a name="9468"/> 9468:          {slot, ['$Tab', -1]},
<a name="9469"/> 9469:          {slot, ['$Tab', not_an_integer]},
<a name="9470"/> 9470: 
<a name="9471"/> 9471:          {tab2file, 2},                         %Not BIF.
<a name="9472"/> 9472:          {tab2file, 3},                         %Not BIF.
<a name="9473"/> 9473:          {tab2list, 1},                         %Not BIF.
<a name="9474"/> 9474:          {tabfile_info, 1},                     %Not BIF.
<a name="9475"/> 9475:          {table, 1},                            %Not BIF.
<a name="9476"/> 9476:          {table, 2},                            %Not BIF.
<a name="9477"/> 9477: 
<a name="9478"/> 9478:          {take, ['$Tab', no_key], [no_fail]},
<a name="9479"/> 9479: 
<a name="9480"/> 9480:          {test_ms, 2},                          %Not BIF.
<a name="9481"/> 9481:          {to_dets, 2},                          %Not BIF.
<a name="9482"/> 9482: 
<a name="9483"/> 9483:          {update_counter, ['$Tab', no_key, 1], [{error_term,badkey}]},
<a name="9484"/> 9484:          {update_counter, ['$Tab', no_key, bad_increment], [{error_term,badkey}]},
<a name="9485"/> 9485:          {update_counter, ['$Tab', no_key, {1, 42}], [{error_term,badkey}]},
<a name="9486"/> 9486:          {update_counter, ['$Tab', no_key, {1, bad_increment}], [{error_term,badkey}]},
<a name="9487"/> 9487: 
<a name="9488"/> 9488:          {update_counter, [OneKeyTab, one, {2, 1}]},
<a name="9489"/> 9489:          {update_counter, [OneKeyTab, one, {2, bad_increment}]},
<a name="9490"/> 9490:          {update_counter, [OneKeyTab, one, {3, bad_increment}]},
<a name="9491"/> 9491:          {update_counter, [OneKeyTab, one, {4, 1}], [{error_term,position}]},
<a name="9492"/> 9492:          {update_counter, [OneKeyTab, one, {4, bad_increment}]},
<a name="9493"/> 9493: 
<a name="9494"/> 9494:          {update_counter, [BagTab, bag_key, 1], [{error_term,table_type}]},
<a name="9495"/> 9495:          {update_counter, [BagTab, bag_key, bad_increment], [{error_term,table_type}]},
<a name="9496"/> 9496: 
<a name="9497"/> 9497:          {update_counter, ['$Tab', key, 2, {key,0}], [no_fail]},
<a name="9498"/> 9498:          {update_counter, ['$Tab', key, {1,42}, {key,0}], [{error_term,keypos}]},
<a name="9499"/> 9499:          {update_counter, ['$Tab', key, 2, {key,not_integer}]},
<a name="9500"/> 9500:          {update_counter, ['$Tab', key, 3, {key,whatever}]},
<a name="9501"/> 9501: 
<a name="9502"/> 9502:          {update_counter, ['$Tab', no_key, 1, default]},
<a name="9503"/> 9503:          {update_counter, ['$Tab', no_key, bad_increment, {tag,0}]},
<a name="9504"/> 9504:          {update_counter, ['$Tab', no_key, {1, bad_increment}, {tag,0}]},
<a name="9505"/> 9505:          {update_counter, ['$Tab', no_key, {1, 42}, {tag,0}], [{error_term,keypos}]},
<a name="9506"/> 9506:          {update_counter, ['$Tab', no_key, {2, 42}, {tag,not_integer}]},
<a name="9507"/> 9507:          {update_counter, ['$Tab', no_key, {3, 42}, {tag,not_integer}], [{error_term,position}]},
<a name="9508"/> 9508: 
<a name="9509"/> 9509:          {update_counter, [OneKeyTab, one, {2, 1}, {tag,val}]},
<a name="9510"/> 9510:          {update_counter, [OneKeyTab, one, {2, bad_increment}, {tag,val}]},
<a name="9511"/> 9511:          {update_counter, [OneKeyTab, one, {3, bad_increment}, {tag,val}]},
<a name="9512"/> 9512:          {update_counter, [OneKeyTab, one, {4, 1}, {tag,val}], [{error_term,position}]},
<a name="9513"/> 9513:          {update_counter, [OneKeyTab, one, {4, bad_increment}, {tag,val}]},
<a name="9514"/> 9514: 
<a name="9515"/> 9515:          {update_element, ['$Tab', no_key, {2, new}], [no_fail]},
<a name="9516"/> 9516:          {update_element, [BagTab, no_key, {2, bagged}]},
<a name="9517"/> 9517:          {update_element, [OneKeyTab, one, not_tuple]},
<a name="9518"/> 9518:          {update_element, [OneKeyTab, one, {0, new}]},
<a name="9519"/> 9519:          {update_element, [OneKeyTab, one, {1, new}], [{error_term,keypos}]},
<a name="9520"/> 9520:          {update_element, [OneKeyTab, one, {4, new}]},
<a name="9521"/> 9521: 
<a name="9522"/> 9522:          {whereis, [{bad,name}], [no_table]}
<a name="9523"/> 9523:         ],
<a name="9524"/> 9524:     put(errors, []),
<a name="9525"/> 9525:     eval_ets_bif_errors(L),
<a name="9526"/> 9526:     io:nl(),
<a name="error_info-last_expr"/><a name="9527"/> 9527: <b>    case lists:sort</b>(get(errors)) of
<a name="9528"/> 9528:         [] -&gt;
<a name="9529"/> 9529:             ok;
<a name="9530"/> 9530:         [_|_]=Errors -&gt;
<a name="9531"/> 9531:             io:format(&quot;~P\n&quot;, [Errors, 100]),
<a name="9532"/> 9532:             ct:fail({length(Errors),errors})
<a name="9533"/> 9533:     end.
<a name="9534"/> 9534: 
<a name="eval_ets_bif_errors-1"/><a name="9535"/> 9535: <b>eval_ets_bif_errors</b>(L0) -&gt;
<a name="9536"/> 9536:     L1 = lists:foldl(fun({_,A}, Acc) when is_integer(A) -&gt; Acc;
<a name="9537"/> 9537:                         ({F,A}, Acc) -&gt; [{F,A,[]}|Acc];
<a name="9538"/> 9538:                         ({F,A,Opts}, Acc) -&gt; [{F,A,Opts}|Acc]
<a name="9539"/> 9539:                      end, [], L0),
<a name="9540"/> 9540:     Tests = ordsets:from_list([{F,length(A)} || {F,A,_} &lt;- L1] ++
<a name="9541"/> 9541:                                   [{F,A} || {F,A} &lt;- L0, is_integer(A)]),
<a name="9542"/> 9542:     Bifs0 = [{F,A} || {F,A} &lt;- ets:module_info(exports),
<a name="9543"/> 9543:                       A =/= 0,
<a name="9544"/> 9544:                       F =/= module_info],
<a name="9545"/> 9545:     Bifs = ordsets:from_list(Bifs0),
<a name="9546"/> 9546:     NYI = [{F,lists:duplicate(A, '*'),nyi} || {F,A} &lt;- Bifs -- Tests],
<a name="9547"/> 9547:     L = lists:sort(NYI ++ L1),
<a name="9548"/> 9548: 
<a name="9549"/> 9549:     spawn(fun() -&gt;
<a name="9550"/> 9550:                   true = register(living, self()),
<a name="9551"/> 9551:                   Ref = make_ref(),
<a name="9552"/> 9552:                   receive
<a name="9553"/> 9553:                       Ref -&gt;
<a name="9554"/> 9554:                           ok
<a name="9555"/> 9555:                   end
<a name="9556"/> 9556:           end),
<a name="9557"/> 9557: 
<a name="eval_ets_bif_errors-last_expr"/><a name="9558"/> 9558: <b>    do_eval_ets_bif_errors</b>(L).
<a name="9559"/> 9559: 
<a name="do_eval_ets_bif_errors-1"/><a name="9560"/> 9560: <b>do_eval_ets_bif_errors</b>([H|T]) -&gt;
<a name="9561"/> 9561:     case H of
<a name="9562"/> 9562:         {F, Args} -&gt;
<a name="9563"/> 9563:             eval_ets_bif_errors(F, Args, []);
<a name="9564"/> 9564:         {_, Args, nyi} -&gt;
<a name="9565"/> 9565:             case lists:all(fun(A) -&gt; A =:= '*' end, Args) of
<a name="9566"/> 9566:                 true -&gt;
<a name="9567"/> 9567:                     store_error(nyi, H, error);
<a name="9568"/> 9568:                 false -&gt;
<a name="9569"/> 9569:                     store_error(bad_nyi, H, error)
<a name="9570"/> 9570:             end;
<a name="9571"/> 9571:         {F, Args, Opts} when is_list(Opts) -&gt;
<a name="9572"/> 9572:             case lists:member(no_table, Opts) of
<a name="9573"/> 9573:                 true -&gt;
<a name="9574"/> 9574:                     ets_eval_bif_errors_once(F, Args, Opts);
<a name="9575"/> 9575:                 false -&gt;
<a name="9576"/> 9576:                     eval_ets_bif_errors(F, Args, Opts)
<a name="9577"/> 9577:             end
<a name="9578"/> 9578:     end,
<a name="9579"/> 9579:     do_eval_ets_bif_errors(T);
<a name="9580"/> 9580: <b>do_eval_ets_bif_errors</b>([]) -&gt;
<a name="do_eval_ets_bif_errors-last_expr"/><a name="9581"/> 9581:     ok.
<a name="9582"/> 9582: 
<a name="ets_eval_bif_errors_once-3"/><a name="9583"/> 9583: <b>ets_eval_bif_errors_once</b>(F, Args, Opts) -&gt;
<a name="9584"/> 9584:     MFA = {ets,F,Args},
<a name="9585"/> 9585:     io:format(&quot;\n\n*** ets:~p/~p&quot;, [F,length(Args)]),
<a name="9586"/> 9586: 
<a name="9587"/> 9587:     NoFail = lists:member(no_fail, Opts),
<a name="9588"/> 9588:     ErrorTerm = proplists:get_value(error_term, Opts, none),
<a name="ets_eval_bif_errors_once-last_expr"/><a name="9589"/> 9589: <b>    case ets_apply</b>(F, Args, Opts) of
<a name="9590"/> 9590:         {error,ErrorTerm} when not NoFail -&gt;
<a name="9591"/> 9591:             ok;
<a name="9592"/> 9592:         {error,Info} -&gt;
<a name="9593"/> 9593:             store_error(wrong_failure_reason, MFA, Info);
<a name="9594"/> 9594:         ok when NoFail -&gt;
<a name="9595"/> 9595:             ok;
<a name="9596"/> 9596:         ok when not NoFail -&gt;
<a name="9597"/> 9597:             %% This ETS function was supposed to fail.
<a name="9598"/> 9598:             store_error(expected_failure, MFA, ok)
<a name="9599"/> 9599:     end.
<a name="9600"/> 9600: 
<a name="eval_ets_bif_errors-3"/><a name="9601"/> 9601: <b>eval_ets_bif_errors</b>(F, Args0, Opts) -&gt;
<a name="9602"/> 9602:     MFA = {ets,F,Args0},
<a name="9603"/> 9603:     io:format(&quot;\n\n*** ets:~p/~p&quot;, [F,length(Args0)]),
<a name="9604"/> 9604: 
<a name="9605"/> 9605:     %% Test the ETS function with a valid table argument.
<a name="9606"/> 9606:     %% Test both for sets and ordered sets.
<a name="9607"/> 9607:     _ = eval_ets_valid_tid(F, Args0, Opts, set),
<a name="9608"/> 9608:     Args = eval_ets_valid_tid(F, Args0, Opts, ordered_set),
<a name="9609"/> 9609: 
<a name="9610"/> 9610:     %% Replace the table id with a plain ref to provoke a type error.
<a name="9611"/> 9611:     BadArgs = eval_expand_bad_args(Args),
<a name="eval_ets_bif_errors-last_expr"/><a name="9612"/> 9612: <b>    case ets_apply</b>(F, BadArgs, Opts) of
<a name="9613"/> 9613:         {error,type} -&gt;
<a name="9614"/> 9614:             ok;
<a name="9615"/> 9615:         BadIdResult -&gt;
<a name="9616"/> 9616:             store_error(bad_table_id, MFA, BadIdResult)
<a name="9617"/> 9617:     end.
<a name="9618"/> 9618: 
<a name="eval_ets_valid_tid-4"/><a name="9619"/> 9619: <b>eval_ets_valid_tid</b>(F, Args0, Opts, Type) -&gt;
<a name="9620"/> 9620:     MFA = {ets,F,Args0},
<a name="9621"/> 9621:     Args = eval_expand_args(Args0, Type),
<a name="9622"/> 9622:     case should_apply(Args, Opts) of
<a name="9623"/> 9623:         false -&gt;
<a name="9624"/> 9624:             %% Applying this function will never fail.
<a name="9625"/> 9625:             ok;
<a name="9626"/> 9626:         true -&gt;
<a name="9627"/> 9627:             NoFail = lists:member(no_fail, Opts),
<a name="9628"/> 9628:             ErrorTerm = proplists:get_value(error_term, Opts, none),
<a name="9629"/> 9629:             case ets_apply(F, Args, Opts) of
<a name="9630"/> 9630:                 {error,ErrorTerm} when not NoFail -&gt;
<a name="9631"/> 9631:                     ok;
<a name="9632"/> 9632:                 {error,Info} when not NoFail -&gt;
<a name="9633"/> 9633:                     store_error(wrong_failure_reason, MFA, Info);
<a name="9634"/> 9634:                 {error,Info} when NoFail -&gt;
<a name="9635"/> 9635:                     store_error(expected_success, MFA, Info);
<a name="9636"/> 9636:                 ok when NoFail -&gt;
<a name="9637"/> 9637:                     ok;
<a name="9638"/> 9638:                 ok when not NoFail -&gt;
<a name="9639"/> 9639:                     %% This ETS function was supposed to fail.
<a name="9640"/> 9640:                     store_error(expected_failure, MFA, ok)
<a name="9641"/> 9641:             end
<a name="9642"/> 9642:     end,
<a name="9643"/> 9643: 
<a name="9644"/> 9644:     %% Test the ETS function from another process to provoke an error
<a name="9645"/> 9645:     %% because of missing access rights. (The table is private.)
<a name="9646"/> 9646:     {Pid,Ref} = spawn_monitor(fun() -&gt; exit(ets_apply(F, Args, Opts)) end),
<a name="9647"/> 9647:     receive
<a name="9648"/> 9648:         {'DOWN',Ref,process,Pid,Result} -&gt;
<a name="9649"/> 9649:             case Result of
<a name="9650"/> 9650:                 {error,access} -&gt;
<a name="9651"/> 9651:                     ok;
<a name="9652"/> 9652:                 {error,not_owner} when F =:= give_away -&gt;
<a name="9653"/> 9653:                     ok;
<a name="9654"/> 9654:                 {error,none} when F =:= info -&gt;
<a name="9655"/> 9655:                     ok;
<a name="9656"/> 9656:                 ok when F =:= info -&gt;
<a name="9657"/> 9657:                     ok;
<a name="9658"/> 9658:                 Other -&gt;
<a name="9659"/> 9659:                     store_error(access, MFA, Other)
<a name="9660"/> 9660:             end
<a name="9661"/> 9661:     end,
<a name="9662"/> 9662: 
<a name="9663"/> 9663:     %% Delete the ETS table.
<a name="9664"/> 9664:     eval_delete_tab(Args),
<a name="9665"/> 9665:     case ets_apply(F, Args, Opts) of
<a name="9666"/> 9666:         {error,id} -&gt;
<a name="9667"/> 9667:             ok;
<a name="9668"/> 9668:         ok when F =:= info -&gt;
<a name="9669"/> 9669:             %% ets:info/1,2 returns `undefined` instead of failing if the
<a name="9670"/> 9670:             %% table has been deleted.
<a name="9671"/> 9671:             ok;
<a name="9672"/> 9672:         DeadTableResult -&gt;
<a name="9673"/> 9673:             store_error(dead_table, MFA, DeadTableResult)
<a name="9674"/> 9674:     end,
<a name="9675"/> 9675: 
<a name="eval_ets_valid_tid-last_expr"/><a name="9676"/> 9676:     Args.
<a name="9677"/> 9677: 
<a name="should_apply-2"/><a name="9678"/> 9678: <b>should_apply</b>([_], _Opts) -&gt;
<a name="9679"/> 9679:     %% An ETS function with a single argument can't fail if
<a name="9680"/> 9680:     %% the argument is valid.
<a name="9681"/> 9681:     false;
<a name="9682"/> 9682: <b>should_apply</b>([_,_|_], Opts) -&gt;
<a name="9683"/> 9683:     %% Applying the function on a valid table would have side effects
<a name="9684"/> 9684:     %% that would cause problems down the line (e.g. successfully
<a name="9685"/> 9685:     %% giving away a table).
<a name="should_apply-last_expr"/><a name="9686"/> 9686: <b>    not lists:member</b>(only_bad_table, Opts).
<a name="9687"/> 9687: 
<a name="store_error-3"/><a name="9688"/> 9688: <b>store_error</b>(What, MFA, Wrong) -&gt;
<a name="store_error-last_expr"/><a name="9689"/> 9689: <b>    put</b>(errors, [{What,MFA,Wrong}|get(errors)]).
<a name="9690"/> 9690: 
<a name="eval_expand_args-2"/><a name="9691"/> 9691: <b>eval_expand_args</b>(Args, Type) -&gt;
<a name="eval_expand_args-last_expr"/><a name="9692"/> 9692: <b>    [expand_arg</b>(A, Type) || A &lt;- Args].
<a name="9693"/> 9693: 
<a name="expand_arg-2"/><a name="9694"/> 9694: <b>expand_arg</b>('$Tab', Type) -&gt; ets:new(table, [Type, private]);
<a name="9695"/> 9695: <b>expand_arg</b>('$Self', _Type) -&gt; self();
<a name="9696"/> 9696: <b>expand_arg</b>('$Living', _Type) -&gt; whereis(living);
<a name="9697"/> 9697: <b>expand_arg</b>('$Dead', _Type) -&gt;
<a name="9698"/> 9698:     {Pid,Ref} = spawn_monitor(fun() -&gt; ok end),
<a name="9699"/> 9699:     receive
<a name="9700"/> 9700:         {'DOWN',Ref,process,Pid,normal} -&gt; Pid
<a name="9701"/> 9701:     end;
<a name="9702"/> 9702: <b>expand_arg</b>(Fun, Type) when is_function(Fun, 1) -&gt; Fun(Type);
<a name="expand_arg-last_expr"/><a name="9703"/> 9703: <b>expand_arg</b>(Arg, _Type) -&gt; Arg.
<a name="9704"/> 9704: 
<a name="eval_delete_tab-1"/><a name="9705"/> 9705: <b>eval_delete_tab</b>(['$named_table'=H|_]) -&gt;
<a name="9706"/> 9706:     ets:delete(H);
<a name="9707"/> 9707: <b>eval_delete_tab</b>([H|_]) when is_reference(H) -&gt;
<a name="9708"/> 9708:     ets:delete(H);
<a name="9709"/> 9709: <b>eval_delete_tab</b>([_|T]) -&gt;
<a name="eval_delete_tab-last_expr"/><a name="9710"/> 9710: <b>    eval_delete_tab</b>(T).
<a name="9711"/> 9711: 
<a name="eval_expand_bad_args-1"/><a name="9712"/> 9712: <b>eval_expand_bad_args</b>(['$named_table'|T]) -&gt;
<a name="9713"/> 9713:     [make_ref()|T];
<a name="9714"/> 9714: <b>eval_expand_bad_args</b>([H|T]) when is_reference(H) -&gt;
<a name="9715"/> 9715:     [make_ref()|T];
<a name="9716"/> 9716: <b>eval_expand_bad_args</b>([H|T]) -&gt;
<a name="eval_expand_bad_args-last_expr"/><a name="9717"/> 9717: <b>    [H|eval_expand_bad_args</b>(T)].
<a name="9718"/> 9718: 
<a name="ets_apply-3"/><a name="9719"/> 9719: <b>ets_apply</b>(F, Args, Opts) -&gt;
<a name="ets_apply-last_expr"/><a name="9720"/> 9720:     try
<a name="9721"/> 9721:         apply(ets, F, Args),
<a name="9722"/> 9722:         io:format(&quot;\nets:~p(~s) succeeded&quot;, [F,ets_format_args(Args)])
<a name="9723"/> 9723:     catch
<a name="9724"/> 9724:         C:R:Stk -&gt;
<a name="9725"/> 9725:             SF = fun(Mod, _, _) -&gt; Mod =:= test_server end,
<a name="9726"/> 9726:             Str = erl_error:format_exception(C, R, Stk, #{stack_trim_fun =&gt; SF}),
<a name="9727"/> 9727:             BinStr = iolist_to_binary(Str),
<a name="9728"/> 9728:             io:format(&quot;\nets:~p(~s)\n~ts&quot;, [F,ets_format_args(Args),BinStr]),
<a name="9729"/> 9729: 
<a name="9730"/> 9730:             {ets,ActualF,ActualArgs,Info} = hd(Stk),
<a name="9731"/> 9731: 
<a name="9732"/> 9732:             RE = &lt;&lt;&quot;[*][*][*] argument \\d+:&quot;&gt;&gt;,
<a name="9733"/> 9733:             case re:run(BinStr, RE, [{capture, none}]) of
<a name="9734"/> 9734:                 match -&gt;
<a name="9735"/> 9735:                     ok;
<a name="9736"/> 9736:                 nomatch -&gt;
<a name="9737"/> 9737:                     store_error(no_explanation, {ets,F,Args}, Info)
<a name="9738"/> 9738:             end,
<a name="9739"/> 9739: 
<a name="9740"/> 9740:             case {ActualF,ActualArgs} of
<a name="9741"/> 9741:                 {F,Args} -&gt;
<a name="9742"/> 9742:                     ok;
<a name="9743"/> 9743:                 _ -&gt;
<a name="9744"/> 9744:                     case lists:member(renamed, Opts) of
<a name="9745"/> 9745:                         true -&gt;
<a name="9746"/> 9746:                             ok;
<a name="9747"/> 9747:                         false -&gt;
<a name="9748"/> 9748:                             store_error(renamed, {ets,F,length(Args)}, {ActualF,ActualArgs})
<a name="9749"/> 9749:                     end
<a name="9750"/> 9750:             end,
<a name="9751"/> 9751:             [{error_info, ErrorInfoMap}] = Info,
<a name="9752"/> 9752:             Cause = maps:get(cause, ErrorInfoMap, none),
<a name="9753"/> 9753:             {error,Cause}
<a name="9754"/> 9754:     end.
<a name="9755"/> 9755: 
<a name="ets_format_args-1"/><a name="9756"/> 9756: <b>ets_format_args</b>(Args) -&gt;
<a name="ets_format_args-last_expr"/><a name="9757"/> 9757: <b>    lists:join</b>(&quot;, &quot;, [io_lib:format(&quot;~P&quot;, [A,10]) || A &lt;- Args]).
<a name="9758"/> 9758: 
<a name="9759"/> 9759: <i>%%%</i>
<a name="9760"/> 9760: <i>%%% Common utility functions.</i>
<a name="9761"/> 9761: <i>%%%</i>
<a name="9762"/> 9762: 
<a name="id-1"/><a name="id-last_expr"/><a name="9763"/> 9763: <b>id</b>(I) -&gt; I.
<a name="9764"/> 9764: 
<a name="very_big_num-0"/><a name="9765"/> 9765: <b>very_big_num</b>() -&gt;
<a name="very_big_num-last_expr"/><a name="9766"/> 9766: <b>    very_big_num</b>(33, 1).
<a name="9767"/> 9767: 
<a name="very_big_num-2"/><a name="9768"/> 9768: <b>very_big_num</b>(Left, Result) when Left &gt; 0 -&gt;
<a name="9769"/> 9769:     very_big_num(Left-1, Result*256);
<a name="9770"/> 9770: <b>very_big_num</b>(0, Result) -&gt;
<a name="very_big_num-last_expr"/><a name="9771"/> 9771:     Result.
<a name="9772"/> 9772: 
<a name="make_port-0"/><a name="9773"/> 9773: <b>make_port</b>() -&gt;
<a name="make_port-last_expr"/><a name="9774"/> 9774: <b>    hd</b>(erlang:ports()).
<a name="9775"/> 9775: 
<a name="make_pid-0"/><a name="9776"/> 9776: <b>make_pid</b>() -&gt;
<a name="make_pid-last_expr"/><a name="9777"/> 9777: <b>    spawn_link</b>(fun sleeper/0).
<a name="9778"/> 9778: 
<a name="sleeper-0"/><a name="9779"/> 9779: <b>sleeper</b>() -&gt;
<a name="sleeper-last_expr"/><a name="9780"/> 9780:     receive after infinity -&gt; ok end.
<a name="9781"/> 9781: 
<a name="make_ext_pid-0"/><a name="9782"/> 9782: <b>make_ext_pid</b>() -&gt;
<a name="9783"/> 9783:     {Pid, _, _} = get(externals),
<a name="make_ext_pid-last_expr"/><a name="9784"/> 9784:     Pid.
<a name="9785"/> 9785: 
<a name="make_ext_port-0"/><a name="9786"/> 9786: <b>make_ext_port</b>() -&gt;
<a name="9787"/> 9787:     {_, Port, _} = get(externals),
<a name="make_ext_port-last_expr"/><a name="9788"/> 9788:     Port.
<a name="make_ext_ref-0"/><a name="9789"/> 9789: <b>make_ext_ref</b>() -&gt;
<a name="9790"/> 9790:     {_, _, Ref} = get(externals),
<a name="make_ext_ref-last_expr"/><a name="9791"/> 9791:     Ref.
<a name="9792"/> 9792: 
<a name="init_externals-0"/><a name="9793"/> 9793: <b>init_externals</b>() -&gt;
<a name="init_externals-last_expr"/><a name="9794"/> 9794: <b>    case get</b>(externals) of
<a name="9795"/> 9795: 	undefined -&gt;
<a name="9796"/> 9796: 	    OtherNode = {gurka@sallad, 1},
<a name="9797"/> 9797: 	    Res = {mk_pid(OtherNode, 7645, 8123),
<a name="9798"/> 9798: 		   mk_port(OtherNode, 187489773),
<a name="9799"/> 9799: 		   mk_ref(OtherNode, [262143, 1293964255, 3291964278])},
<a name="9800"/> 9800: 	    put(externals, Res);
<a name="9801"/> 9801: 
<a name="9802"/> 9802: 	{_,_,_} -&gt; ok
<a name="9803"/> 9803:     end.
<a name="9804"/> 9804: 
<a name="9805"/> 9805: <i>%%</i>
<a name="9806"/> 9806: <i>%% Node container constructor functions</i>
<a name="9807"/> 9807: <i>%%</i>
<a name="9808"/> 9808: 
<a name="9809"/> 9809: <b>-define</b>(VERSION_MAGIC,       131).
<a name="9810"/> 9810: <b>-define</b>(PORT_EXT,            102).
<a name="9811"/> 9811: <b>-define</b>(PID_EXT,             103).
<a name="9812"/> 9812: <b>-define</b>(NEW_REFERENCE_EXT,   114).
<a name="9813"/> 9813: 
<a name="uint32_be-1"/><a name="9814"/> 9814: <b>uint32_be</b>(Uint) when is_integer(Uint), 0 =&lt; Uint, Uint &lt; 1 bsl 32 -&gt;
<a name="9815"/> 9815:     [(Uint bsr 24) band 16#ff,
<a name="9816"/> 9816:      (Uint bsr 16) band 16#ff,
<a name="9817"/> 9817:      (Uint bsr 8) band 16#ff,
<a name="9818"/> 9818:      Uint band 16#ff];
<a name="9819"/> 9819: <b>uint32_be</b>(Uint) -&gt;
<a name="uint32_be-last_expr"/><a name="9820"/> 9820: <b>    exit</b>({badarg, uint32_be, [Uint]}).
<a name="9821"/> 9821: 
<a name="uint16_be-1"/><a name="9822"/> 9822: <b>uint16_be</b>(Uint) when is_integer(Uint), 0 =&lt; Uint, Uint &lt; 1 bsl 16 -&gt;
<a name="9823"/> 9823:     [(Uint bsr 8) band 16#ff,
<a name="9824"/> 9824:      Uint band 16#ff];
<a name="9825"/> 9825: <b>uint16_be</b>(Uint) -&gt;
<a name="uint16_be-last_expr"/><a name="9826"/> 9826: <b>    exit</b>({badarg, uint16_be, [Uint]}).
<a name="9827"/> 9827: 
<a name="uint8-1"/><a name="9828"/> 9828: <b>uint8</b>(Uint) when is_integer(Uint), 0 =&lt; Uint, Uint &lt; 1 bsl 8 -&gt;
<a name="9829"/> 9829:     Uint band 16#ff;
<a name="9830"/> 9830: <b>uint8</b>(Uint) -&gt;
<a name="uint8-last_expr"/><a name="9831"/> 9831: <b>    exit</b>({badarg, uint8, [Uint]}).
<a name="9832"/> 9832: 
<a name="mk_pid-3"/><a name="9833"/> 9833: <b>mk_pid</b>({NodeName, Creation}, Number, Serial) when is_atom(NodeName) -&gt;
<a name="9834"/> 9834:     &lt;&lt;?VERSION_MAGIC, NodeNameExt/binary&gt;&gt; = term_to_binary(NodeName),
<a name="9835"/> 9835:     mk_pid({NodeNameExt, Creation}, Number, Serial);
<a name="9836"/> 9836: <b>mk_pid</b>({NodeNameExt, Creation}, Number, Serial) -&gt;
<a name="mk_pid-last_expr"/><a name="9837"/> 9837: <b>    case catch binary_to_term</b>(list_to_binary([?VERSION_MAGIC,
<a name="9838"/> 9838: 					      ?PID_EXT,
<a name="9839"/> 9839: 					      NodeNameExt,
<a name="9840"/> 9840: 					      uint32_be(Number),
<a name="9841"/> 9841: 					      uint32_be(Serial),
<a name="9842"/> 9842: 					      uint8(Creation)])) of
<a name="9843"/> 9843: 	Pid when is_pid(Pid) -&gt;
<a name="9844"/> 9844: 	    Pid;
<a name="9845"/> 9845: 	{'EXIT', {badarg, _}} -&gt;
<a name="9846"/> 9846: 	    exit({badarg, mk_pid, [{NodeNameExt, Creation}, Number, Serial]});
<a name="9847"/> 9847: 	Other -&gt;
<a name="9848"/> 9848: 	    exit({unexpected_binary_to_term_result, Other})
<a name="9849"/> 9849:     end.
<a name="9850"/> 9850: 
<a name="mk_port-2"/><a name="9851"/> 9851: <b>mk_port</b>({NodeName, Creation}, Number) when is_atom(NodeName) -&gt;
<a name="9852"/> 9852:     &lt;&lt;?VERSION_MAGIC, NodeNameExt/binary&gt;&gt; = term_to_binary(NodeName),
<a name="9853"/> 9853:     mk_port({NodeNameExt, Creation}, Number);
<a name="9854"/> 9854: <b>mk_port</b>({NodeNameExt, Creation}, Number) -&gt;
<a name="mk_port-last_expr"/><a name="9855"/> 9855: <b>    case catch binary_to_term</b>(list_to_binary([?VERSION_MAGIC,
<a name="9856"/> 9856: 					      ?PORT_EXT,
<a name="9857"/> 9857: 					      NodeNameExt,
<a name="9858"/> 9858: 					      uint32_be(Number),
<a name="9859"/> 9859: 					      uint8(Creation)])) of
<a name="9860"/> 9860: 	Port when is_port(Port) -&gt;
<a name="9861"/> 9861: 	    Port;
<a name="9862"/> 9862: 	{'EXIT', {badarg, _}} -&gt;
<a name="9863"/> 9863: 	    exit({badarg, mk_port, [{NodeNameExt, Creation}, Number]});
<a name="9864"/> 9864: 	Other -&gt;
<a name="9865"/> 9865: 	    exit({unexpected_binary_to_term_result, Other})
<a name="9866"/> 9866:     end.
<a name="9867"/> 9867: 
<a name="mk_ref-2"/><a name="9868"/> 9868: <b>mk_ref</b>({NodeName, Creation}, Numbers) when is_atom(NodeName),
<a name="9869"/> 9869: 					   is_integer(Creation),
<a name="9870"/> 9870: 					   is_list(Numbers) -&gt;
<a name="9871"/> 9871:     &lt;&lt;?VERSION_MAGIC, NodeNameExt/binary&gt;&gt; = term_to_binary(NodeName),
<a name="9872"/> 9872:     mk_ref({NodeNameExt, Creation}, Numbers);
<a name="9873"/> 9873: <b>mk_ref</b>({NodeNameExt, Creation}, Numbers) when is_binary(NodeNameExt),
<a name="9874"/> 9874: 					      is_integer(Creation),
<a name="9875"/> 9875: 					      is_list(Numbers) -&gt;
<a name="mk_ref-last_expr"/><a name="9876"/> 9876: <b>    case catch binary_to_term</b>(list_to_binary([?VERSION_MAGIC,
<a name="9877"/> 9877: 					      ?NEW_REFERENCE_EXT,
<a name="9878"/> 9878: 					      uint16_be(length(Numbers)),
<a name="9879"/> 9879: 					      NodeNameExt,
<a name="9880"/> 9880: 					      uint8(Creation),
<a name="9881"/> 9881: 					      lists:map(fun (N) -&gt;
<a name="9882"/> 9882: 								uint32_be(N)
<a name="9883"/> 9883: 							end,
<a name="9884"/> 9884: 							Numbers)])) of
<a name="9885"/> 9885: 	Ref when is_reference(Ref) -&gt;
<a name="9886"/> 9886: 	    Ref;
<a name="9887"/> 9887: 	{'EXIT', {badarg, _}} -&gt;
<a name="9888"/> 9888: 	    exit({badarg, mk_ref, [{NodeNameExt, Creation}, Numbers]});
<a name="9889"/> 9889: 	Other -&gt;
<a name="9890"/> 9890: 	    exit({unexpected_binary_to_term_result, Other})
<a name="9891"/> 9891:     end.
<a name="9892"/> 9892: 
<a name="9893"/> 9893: 
<a name="make_sub_binary-1"/><a name="9894"/> 9894: <b>make_sub_binary</b>(Bin) when is_binary(Bin) -&gt;
<a name="9895"/> 9895:     {_,B} = split_binary(list_to_binary([0,1,3,Bin]), 3),
<a name="9896"/> 9896:     B;
<a name="9897"/> 9897: <b>make_sub_binary</b>(List) -&gt;
<a name="make_sub_binary-last_expr"/><a name="9898"/> 9898: <b>    make_sub_binary</b>(list_to_binary(List)).
<a name="9899"/> 9899: 
<a name="make_unaligned_sub_binary-1"/><a name="9900"/> 9900: <b>make_unaligned_sub_binary</b>(Bin0) when is_binary(Bin0) -&gt;
<a name="9901"/> 9901:     Bin1 = &lt;&lt;0:3,Bin0/binary,31:5&gt;&gt;,
<a name="9902"/> 9902:     Sz = size(Bin0),
<a name="9903"/> 9903:     &lt;&lt;0:3,Bin:Sz/binary,31:5&gt;&gt; = id(Bin1),
<a name="9904"/> 9904:     Bin;
<a name="9905"/> 9905: <b>make_unaligned_sub_binary</b>(List) -&gt;
<a name="make_unaligned_sub_binary-last_expr"/><a name="9906"/> 9906: <b>    make_unaligned_sub_binary</b>(list_to_binary(List)).
<a name="9907"/> 9907: 
<a name="replace_dbg_hash_fixed_nr_of_locks-1"/><a name="9908"/> 9908: <b>replace_dbg_hash_fixed_nr_of_locks</b>(Opts) -&gt;
<a name="replace_dbg_hash_fixed_nr_of_locks-last_expr"/><a name="9909"/> 9909:     [case X of
<a name="9910"/> 9910:          {write_concurrency, {debug_hash_fixed_number_of_locks, _}} -&gt;
<a name="9911"/> 9911:              {write_concurrency, true};
<a name="9912"/> 9912:          _ -&gt; X
<a name="9913"/> 9913:      end || X &lt;- Opts].
<a name="9914"/> 9914: 
<a name="9915"/> 9915: <i>%% Repeat test function with different combination of table options</i>
<a name="9916"/> 9916: <i>%%</i>
<a name="repeat_for_opts_extra_opt-2"/><a name="9917"/> 9917: <b>repeat_for_opts_extra_opt</b>(F, Extra) -&gt;
<a name="repeat_for_opts_extra_opt-last_expr"/><a name="9918"/> 9918: <b>    repeat_for_opts</b>(
<a name="9919"/> 9919:       fun(Opts) -&gt;
<a name="9920"/> 9920:               WithExtra =
<a name="9921"/> 9921:                   case erlang:is_list(Extra) of
<a name="9922"/> 9922:                       true -&gt; Extra ++ Opts;
<a name="9923"/> 9923:                       false -&gt;[Extra | Opts]
<a name="9924"/> 9924:                   end,
<a name="9925"/> 9925:               case is_invalid_opts_combo(WithExtra) of
<a name="9926"/> 9926:                   true -&gt; ok;
<a name="9927"/> 9927:                   false -&gt; F(WithExtra)
<a name="9928"/> 9928:               end
<a name="9929"/> 9929:       end,
<a name="9930"/> 9930:       [write_concurrency, read_concurrency, compressed]).
<a name="9931"/> 9931: 
<a name="repeat_for_opts-1"/><a name="9932"/> 9932: <b>repeat_for_opts</b>(F) -&gt;
<a name="repeat_for_opts-last_expr"/><a name="9933"/> 9933: <b>    repeat_for_opts</b>(F, [write_concurrency, read_concurrency, compressed]).
<a name="9934"/> 9934: 
<a name="repeat_for_opts_all_table_types-1"/><a name="9935"/> 9935: <b>repeat_for_opts_all_table_types</b>(F) -&gt;
<a name="repeat_for_opts_all_table_types-last_expr"/><a name="9936"/> 9936: <b>    repeat_for_opts</b>(F, [all_types, write_concurrency, read_concurrency, compressed]).
<a name="9937"/> 9937: 
<a name="repeat_for_opts_all_non_stim_table_types-1"/><a name="9938"/> 9938: <b>repeat_for_opts_all_non_stim_table_types</b>(F) -&gt;
<a name="repeat_for_opts_all_non_stim_table_types-last_expr"/><a name="9939"/> 9939: <b>    repeat_for_opts</b>(F, [all_non_stim_types, write_concurrency, read_concurrency, compressed]).
<a name="9940"/> 9940: 
<a name="repeat_for_opts_all_set_table_types-1"/><a name="9941"/> 9941: <b>repeat_for_opts_all_set_table_types</b>(F) -&gt;
<a name="repeat_for_opts_all_set_table_types-last_expr"/><a name="9942"/> 9942: <b>    repeat_for_opts</b>(F, [set_types, write_concurrency, read_concurrency, compressed]).
<a name="9943"/> 9943: 
<a name="repeat_for_all_set_table_types-1"/><a name="9944"/> 9944: <b>repeat_for_all_set_table_types</b>(F) -&gt;
<a name="repeat_for_all_set_table_types-last_expr"/><a name="9945"/> 9945: <b>    repeat_for_opts</b>(F, [set_types]).
<a name="9946"/> 9946: 
<a name="repeat_for_all_ord_set_table_types-1"/><a name="9947"/> 9947: <b>repeat_for_all_ord_set_table_types</b>(F) -&gt;
<a name="repeat_for_all_ord_set_table_types-last_expr"/><a name="9948"/> 9948: <b>    repeat_for_opts</b>(F, [ord_set_types]).
<a name="9949"/> 9949: 
<a name="repeat_for_all_non_stim_set_table_types-1"/><a name="9950"/> 9950: <b>repeat_for_all_non_stim_set_table_types</b>(F) -&gt;
<a name="repeat_for_all_non_stim_set_table_types-last_expr"/><a name="9951"/> 9951: <b>    repeat_for_opts</b>(F, [all_non_stim_set_types]).
<a name="9952"/> 9952: 
<a name="repeat_for_opts_all_ord_set_table_types-1"/><a name="9953"/> 9953: <b>repeat_for_opts_all_ord_set_table_types</b>(F) -&gt;
<a name="repeat_for_opts_all_ord_set_table_types-last_expr"/><a name="9954"/> 9954: <b>    repeat_for_opts</b>(F, [ord_set_types, write_concurrency, read_concurrency, compressed]).
<a name="9955"/> 9955: 
<a name="repeat_for_opts-2"/><a name="9956"/> 9956: <b>repeat_for_opts</b>(F, OptGenList) when is_function(F, 1) -&gt;
<a name="repeat_for_opts-last_expr"/><a name="9957"/> 9957: <b>    repeat_for_opts</b>(F, OptGenList, []).
<a name="9958"/> 9958: 
<a name="repeat_for_opts-3"/><a name="9959"/> 9959: <b>repeat_for_opts</b>(F, [], Acc) -&gt;
<a name="9960"/> 9960:     lists:foldl(fun(Opts, RV_Acc) -&gt;
<a name="9961"/> 9961: 			OptList = lists:filter(fun(E) -&gt; E =/= void end, Opts),
<a name="9962"/> 9962:                         case is_redundant_opts_combo(OptList) of
<a name="9963"/> 9963:                             true -&gt;
<a name="9964"/> 9964:                                 %%io:format(&quot;Ignoring redundant options ~p\n&quot;,[OptList]),
<a name="9965"/> 9965:                                 ok;
<a name="9966"/> 9966:                             false -&gt;
<a name="9967"/> 9967:                                 io:format(&quot;Calling with options ~p\n&quot;,[OptList]),
<a name="9968"/> 9968:                                 RV = F(OptList),
<a name="9969"/> 9969:                                 case RV_Acc of
<a name="9970"/> 9970:                                     {comment,_} -&gt; RV_Acc;
<a name="9971"/> 9971:                                     _ -&gt; case RV of
<a name="9972"/> 9972:                                              {comment,_} -&gt; RV;
<a name="9973"/> 9973:                                              _ -&gt; [RV | RV_Acc]
<a name="9974"/> 9974:                                          end
<a name="9975"/> 9975:                                 end
<a name="9976"/> 9976:                         end
<a name="9977"/> 9977:                 end, [], Acc);
<a name="9978"/> 9978: <b>repeat_for_opts</b>(F, [OptList | Tail], []) when is_list(OptList) -&gt;
<a name="9979"/> 9979:     repeat_for_opts(F, Tail, [[Opt] || Opt &lt;- OptList]);
<a name="9980"/> 9980: <b>repeat_for_opts</b>(F, [OptList | Tail], AccList) when is_list(OptList) -&gt;
<a name="9981"/> 9981:     repeat_for_opts(F, Tail, [[Opt|Acc] || Opt &lt;- OptList, Acc &lt;- AccList]);
<a name="9982"/> 9982: <b>repeat_for_opts</b>(F, [Atom | Tail], AccList) when is_atom(Atom) -&gt;
<a name="repeat_for_opts-last_expr"/><a name="9983"/> 9983: <b>    repeat_for_opts</b>(F, [repeat_for_opts_atom2list(Atom) | Tail ], AccList).
<a name="9984"/> 9984: 
<a name="repeat_for_opts_atom2list-1"/><a name="9985"/> 9985: <b>repeat_for_opts_atom2list</b>(set_types) -&gt; [set,ordered_set,stim_cat_ord_set,cat_ord_set];
<a name="9986"/> 9986: <b>repeat_for_opts_atom2list</b>(ord_set_types) -&gt; [ordered_set,stim_cat_ord_set,cat_ord_set];
<a name="9987"/> 9987: <b>repeat_for_opts_atom2list</b>(all_types) -&gt; [set,ordered_set,stim_cat_ord_set,cat_ord_set,bag,duplicate_bag];
<a name="9988"/> 9988: <b>repeat_for_opts_atom2list</b>(all_non_stim_types) -&gt; [set,ordered_set,cat_ord_set,bag,duplicate_bag];
<a name="9989"/> 9989: <b>repeat_for_opts_atom2list</b>(all_non_stim_set_types) -&gt; [set,ordered_set,cat_ord_set];
<a name="9990"/> 9990: <b>repeat_for_opts_atom2list</b>(write_concurrency) -&gt; [{write_concurrency,false},
<a name="9991"/> 9991:                                                  {write_concurrency,true},
<a name="9992"/> 9992:                                                  {write_concurrency, {debug_hash_fixed_number_of_locks, 2048}},
<a name="9993"/> 9993:                                                  {write_concurrency,auto}];
<a name="9994"/> 9994: <b>repeat_for_opts_atom2list</b>(read_concurrency) -&gt; [{read_concurrency,false},{read_concurrency,true}];
<a name="repeat_for_opts_atom2list-last_expr"/><a name="9995"/> 9995: <b>repeat_for_opts_atom2list</b>(compressed) -&gt; [void,compressed].
<a name="9996"/> 9996: 
<a name="has_fixed_number_of_locks-1"/><a name="9997"/> 9997: <b>has_fixed_number_of_locks</b>(Opts) -&gt;
<a name="has_fixed_number_of_locks-last_expr"/><a name="9998"/> 9998: <b>    lists:any</b>(
<a name="9999"/> 9999:       fun({write_concurrency, {debug_hash_fixed_number_of_locks, _}}) -&gt;
<a name="10000"/>10000:               true;
<a name="10001"/>10001:          (_) -&gt;
<a name="10002"/>10002:               false
<a name="10003"/>10003:       end,
<a name="10004"/>10004:       Opts).
<a name="10005"/>10005: 
<a name="is_invalid_opts_combo-1"/><a name="10006"/>10006: <b>is_invalid_opts_combo</b>(Opts) -&gt;
<a name="10007"/>10007:     OrderedSet = lists:member(ordered_set, Opts) orelse
<a name="10008"/>10008:                  lists:member(stim_cat_ord_set, Opts) orelse
<a name="10009"/>10009:                  lists:member(cat_ord_set, Opts),
<a name="is_invalid_opts_combo-last_expr"/><a name="10010"/>10010: <b>    OrderedSet andalso has_fixed_number_of_locks</b>(Opts).
<a name="10011"/>10011: 
<a name="run_if_valid_opts-2"/><a name="10012"/>10012: <b>run_if_valid_opts</b>(Opts, F) -&gt;
<a name="run_if_valid_opts-last_expr"/><a name="10013"/>10013: <b>    case is_invalid_opts_combo</b>(Opts) of
<a name="10014"/>10014:         true -&gt; ignore;
<a name="10015"/>10015:         false -&gt; F(Opts)
<a name="10016"/>10016:     end.
<a name="10017"/>10017: 
<a name="is_redundant_opts_combo-1"/><a name="10018"/>10018: <b>is_redundant_opts_combo</b>(Opts) -&gt;
<a name="10019"/>10019:     IsRed1 =
<a name="10020"/>10020:         ((lists:member(stim_cat_ord_set, Opts) orelse
<a name="10021"/>10021:           lists:member(cat_ord_set, Opts))
<a name="10022"/>10022:          andalso
<a name="10023"/>10023:            (lists:member({write_concurrency, false}, Opts) orelse
<a name="10024"/>10024:             lists:member(private, Opts) orelse
<a name="10025"/>10025:             lists:member(protected, Opts))),
<a name="10026"/>10026:     IsRed2 = is_invalid_opts_combo(Opts),
<a name="is_redundant_opts_combo-last_expr"/><a name="10027"/>10027:     IsRed1 orelse IsRed2.
<a name="10028"/>10028: 
<a name="10029"/>10029: <i>%% Add fake table option with info about key range.</i>
<a name="10030"/>10030: <i>%% Will be consumed by ets_new and used for stim_cat_ord_set.</i>
<a name="key_range-2"/><a name="10031"/>10031: <b>key_range</b>(Opts, KeyRange) -&gt;
<a name="key_range-last_expr"/><a name="10032"/>10032:     [{key_range, KeyRange} | Opts].
<a name="10033"/>10033: 
<a name="ets_new-2"/><a name="10034"/>10034: <b>ets_new</b>(Name, Opts0) -&gt;
<a name="10035"/>10035:     {KeyRange, Opts1} = case lists:keytake(key_range, 1, Opts0) of
<a name="10036"/>10036:                             {value, {key_range, KR}, Rest1} -&gt;
<a name="10037"/>10037:                                 {KR, Rest1};
<a name="10038"/>10038:                             false -&gt;
<a name="10039"/>10039:                                 {1000*1000, Opts0}
<a name="10040"/>10040:                         end,
<a name="ets_new-last_expr"/><a name="10041"/>10041: <b>    ets_new</b>(Name, Opts1, KeyRange).
<a name="10042"/>10042: 
<a name="ets_new-3"/><a name="10043"/>10043: <b>ets_new</b>(Name, Opts, KeyRange) -&gt;
<a name="ets_new-last_expr"/><a name="10044"/>10044: <b>    ets_new</b>(Name, Opts, KeyRange, fun id/1).
<a name="10045"/>10045: 
<a name="ets_new-4"/><a name="10046"/>10046: <b>ets_new</b>(Name, Opts0, KeyRange, KeyFun) -&gt;
<a name="10047"/>10047:     {_Smp, CATree, Stimulate, RevOpts} =
<a name="10048"/>10048:         lists:foldl(fun(cat_ord_set, {Smp, false, false, Lacc}) -&gt;
<a name="10049"/>10049:                             {Smp, Smp, false, [ordered_set | Lacc]};
<a name="10050"/>10050:                        (stim_cat_ord_set, {Smp, false, false, Lacc}) -&gt;
<a name="10051"/>10051:                             {Smp, Smp, Smp, [ordered_set | Lacc]};
<a name="10052"/>10052:                        (Other, {Smp, CAT, STIM, Lacc}) -&gt;
<a name="10053"/>10053:                             {Smp, CAT, STIM, [Other | Lacc]}
<a name="10054"/>10054:                     end,
<a name="10055"/>10055:                     {erlang:system_info(schedulers) &gt; 1,false, false, []},
<a name="10056"/>10056:                     Opts0),
<a name="10057"/>10057:     Opts = lists:reverse(RevOpts),
<a name="10058"/>10058:     EtsNewHelper = 
<a name="10059"/>10059:         fun (UseOpts) -&gt;
<a name="10060"/>10060:                 case get(ets_new_opts) of
<a name="10061"/>10061:                     UseOpts -&gt;
<a name="10062"/>10062:                         silence; %% suppress identical table opts spam
<a name="10063"/>10063:                     _ -&gt;
<a name="10064"/>10064:                         put(ets_new_opts, UseOpts),
<a name="10065"/>10065:                         io:format(&quot;ets:new(~p, ~p)~n&quot;, [Name, UseOpts])
<a name="10066"/>10066:                 end,
<a name="10067"/>10067:                 ets:new(Name, UseOpts)
<a name="10068"/>10068:         end,
<a name="ets_new-last_expr"/><a name="10069"/>10069:     case CATree andalso
<a name="10070"/>10070:         (not lists:member({write_concurrency, false}, Opts)) andalso
<a name="10071"/>10071:         (not lists:member(private, Opts)) andalso
<a name="10072"/>10072:         (not lists:member(protected, Opts)) of
<a name="10073"/>10073:         true -&gt;
<a name="10074"/>10074:             NewOpts1 = 
<a name="10075"/>10075:                 case lists:member({write_concurrency, true}, Opts) of
<a name="10076"/>10076:                     true -&gt; Opts;
<a name="10077"/>10077:                     false -&gt; [{write_concurrency, true}|Opts]
<a name="10078"/>10078:                 end,
<a name="10079"/>10079:             NewOpts2 = 
<a name="10080"/>10080:                 case lists:member(public, NewOpts1) of
<a name="10081"/>10081:                     true -&gt; NewOpts1;
<a name="10082"/>10082:                     false -&gt; [public|NewOpts1]
<a name="10083"/>10083:                 end,
<a name="10084"/>10084:             T = EtsNewHelper(NewOpts2),
<a name="10085"/>10085:             case Stimulate of
<a name="10086"/>10086:                 false -&gt; ok;
<a name="10087"/>10087:                 true -&gt; stimulate_contention(T, KeyRange, KeyFun)
<a name="10088"/>10088:             end,
<a name="10089"/>10089:             T;
<a name="10090"/>10090:         false -&gt;
<a name="10091"/>10091:             EtsNewHelper(Opts)
<a name="10092"/>10092:     end.
<a name="10093"/>10093: 
<a name="10094"/>10094: <i>% The purpose of this function is to stimulate fine grained locking in</i>
<a name="10095"/>10095: <i>% tables of types ordered_set with the write_concurrency options</i>
<a name="10096"/>10096: <i>% turned on. The erts_debug feature 'ets_force_split' is used to easier</i>
<a name="10097"/>10097: <i>% generate a routing tree with fine grained locking without having to</i>
<a name="10098"/>10098: <i>% provoke lots of actual lock contentions.</i>
<a name="stimulate_contention-3"/><a name="10099"/>10099: <b>stimulate_contention</b>(Tid, KeyRange, KeyFun) -&gt;
<a name="10100"/>10100:     T = case Tid of
<a name="10101"/>10101:             A when is_atom(A) -&gt; ets:whereis(A);
<a name="10102"/>10102:             _ -&gt; Tid
<a name="10103"/>10103:         end,
<a name="10104"/>10104:     erts_debug:set_internal_state(ets_force_split, {T, true}),
<a name="10105"/>10105:     Num = case KeyRange &gt; 50 of
<a name="10106"/>10106:               true -&gt; 50;
<a name="10107"/>10107:               false -&gt; KeyRange
<a name="10108"/>10108:           end,
<a name="10109"/>10109:     Seed = rand:uniform(KeyRange),
<a name="10110"/>10110:     %%io:format(&quot;prefill_table: Seed = ~p\n&quot;, [Seed]),
<a name="10111"/>10111:     RState = unique_rand_start(KeyRange, Seed),
<a name="10112"/>10112:     stim_inserter_loop(T, RState, Num, KeyFun),
<a name="10113"/>10113:     Num = ets:info(T, size),
<a name="10114"/>10114:     ets:match_delete(T, {'$1','$1','$1'}),
<a name="10115"/>10115:     0 = ets:info(T, size),
<a name="10116"/>10116:     erts_debug:set_internal_state(ets_force_split, {T, false}),
<a name="stimulate_contention-last_expr"/><a name="10117"/>10117: <b>    case ets:info</b>(T,stats) of
<a name="10118"/>10118:         {0, _, _} -&gt;
<a name="10119"/>10119:             io:format(&quot;No routing nodes in table?\n&quot;
<a name="10120"/>10120:                       &quot;Debug feature 'ets_force_split' does not seem to work.\n&quot;, []),
<a name="10121"/>10121:             ct:fail(&quot;No ets_force_split?&quot;);
<a name="10122"/>10122:         Stats -&gt;
<a name="10123"/>10123:             io:format(&quot;stimulated ordered_set: ~p\n&quot;, [Stats])
<a name="10124"/>10124:     end.
<a name="10125"/>10125: 
<a name="stim_inserter_loop-4"/><a name="10126"/>10126: <b>stim_inserter_loop</b>(_, _, 0, _) -&gt;
<a name="10127"/>10127:     ok;
<a name="10128"/>10128: <b>stim_inserter_loop</b>(T, RS0, N, KeyFun) -&gt;
<a name="10129"/>10129:     {K, RS1} = unique_rand_next(RS0),
<a name="10130"/>10130:     Key = KeyFun(K),
<a name="10131"/>10131:     ets:insert(T, {Key, Key, Key}),
<a name="stim_inserter_loop-last_expr"/><a name="10132"/>10132: <b>    stim_inserter_loop</b>(T, RS1, N-1, KeyFun).
<a name="10133"/>10133: 
<a name="do_tc-2"/><a name="10134"/>10134: <b>do_tc</b>(Do, Report) -&gt;
<a name="10135"/>10135:     T1 = erlang:monotonic_time(),
<a name="10136"/>10136:     Do(),
<a name="10137"/>10137:     T2 = erlang:monotonic_time(),
<a name="10138"/>10138:     Elapsed = erlang:convert_time_unit(T2 - T1, native, millisecond),
<a name="do_tc-last_expr"/><a name="10139"/>10139: <b>    Report</b>(Elapsed).
<a name="10140"/>10140: 
<a name="syrup_factor-0"/><a name="10141"/>10141: <b>syrup_factor</b>() -&gt;
<a name="syrup_factor-last_expr"/><a name="10142"/>10142: <b>    case erlang:system_info</b>(build_type) of
<a name="10143"/>10143:         valgrind -&gt; 20;
<a name="10144"/>10144:         _ -&gt; 1
<a name="10145"/>10145:     end.
<a name="10146"/>10146: 
<a name="10147"/>10147: 
<a name="10148"/>10148: <i>%%</i>
<a name="10149"/>10149: <i>%% This is a pseudo random number generator for UNIQUE integers.</i>
<a name="10150"/>10150: <i>%% All integers between 1 and Max will be generated before it repeat itself.</i>
<a name="10151"/>10151: <i>%% It's a variant of this one using quadratic residues by Jeff Preshing:</i>
<a name="10152"/>10152: <i>%% http://preshing.com/20121224/how-to-generate-a-sequence-of-unique-random-integers/</i>
<a name="10153"/>10153: <i>%%</i>
<a name="unique_rand_start-2"/><a name="10154"/>10154: <b>unique_rand_start</b>(Max, Seed) -&gt;
<a name="10155"/>10155:     L = lists:dropwhile(fun(P) -&gt; P &lt; Max end,
<a name="10156"/>10156:                         primes_3mod4()),
<a name="10157"/>10157:     [P | _] = case L of
<a name="10158"/>10158:                       [] -&gt;
<a name="10159"/>10159:                           error(&quot;Random range too large&quot;);
<a name="10160"/>10160:                       _ -&gt;
<a name="10161"/>10161:                           L
<a name="10162"/>10162:                   end,
<a name="10163"/>10163:     3 = P rem 4,
<a name="unique_rand_start-last_expr"/><a name="10164"/>10164:     {0, {Max, P, Seed}}.
<a name="10165"/>10165: 
<a name="unique_rand_next-1"/><a name="10166"/>10166: <b>unique_rand_next</b>({N, {Max, P, Seed}=Const}) -&gt;
<a name="unique_rand_next-last_expr"/><a name="10167"/>10167: <b>    case dquad</b>(P, N, Seed) + 1 of
<a name="10168"/>10168:         RND when RND &gt; Max -&gt;  % Too large, skip
<a name="10169"/>10169:             unique_rand_next({N+1, Const});
<a name="10170"/>10170:         RND -&gt;
<a name="10171"/>10171:             {RND, {N+1, Const}}
<a name="10172"/>10172:     end.
<a name="10173"/>10173: 
<a name="10174"/>10174: <i>%% A one-to-one relation between all integers 0 =&lt; X &lt; Prime</i>
<a name="10175"/>10175: <i>%% if Prime rem 4 == 3.</i>
<a name="quad-2"/><a name="10176"/>10176: <b>quad</b>(Prime, X) -&gt;
<a name="10177"/>10177:     Rem = X*X rem Prime,
<a name="quad-last_expr"/><a name="10178"/>10178:     case 2*X &lt; Prime of
<a name="10179"/>10179:         true -&gt;
<a name="10180"/>10180:             Rem;
<a name="10181"/>10181:         false -&gt;
<a name="10182"/>10182:             Prime - Rem
<a name="10183"/>10183:     end.
<a name="10184"/>10184: 
<a name="dquad-3"/><a name="10185"/>10185: <b>dquad</b>(Prime, X, Seed) -&gt;
<a name="dquad-last_expr"/><a name="10186"/>10186: <b>    quad</b>(Prime, (quad(Prime, X) + Seed) rem Prime).
<a name="10187"/>10187: 
<a name="10188"/>10188: <i>%% Primes where P rem 4 == 3.</i>
<a name="primes_3mod4-0"/><a name="10189"/>10189: <b>primes_3mod4</b>() -&gt;
<a name="primes_3mod4-last_expr"/><a name="10190"/>10190:     [103, 211, 503, 1019, 2003, 5003, 10007, 20011, 50023,
<a name="10191"/>10191:      100003, 200003, 500083, 1000003, 2000003, 5000011,
<a name="10192"/>10192:      10000019, 20000003, 50000047, 100000007].
</pre>
</body>
</html>
