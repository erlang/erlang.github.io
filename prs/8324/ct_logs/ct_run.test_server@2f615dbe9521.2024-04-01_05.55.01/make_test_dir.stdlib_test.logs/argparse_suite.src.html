<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/lib/stdlib/make_test_dir/stdlib_test/argparse_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%</i>
<a name="2"/>    2: <i>%%</i>
<a name="3"/>    3: <i>%% Copyright Maxim Fedorov</i>
<a name="4"/>    4: <i>%%</i>
<a name="5"/>    5: <i>%%</i>
<a name="6"/>    6: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="7"/>    7: <i>%% you may not use this file except in compliance with the License.</i>
<a name="8"/>    8: <i>%% You may obtain a copy of the License at</i>
<a name="9"/>    9: <i>%%</i>
<a name="10"/>   10: <i>%%     http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="11"/>   11: <i>%%</i>
<a name="12"/>   12: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="13"/>   13: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="14"/>   14: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="15"/>   15: <i>%% See the License for the specific language governing permissions and</i>
<a name="16"/>   16: <i>%% limitations under the License.</i>
<a name="17"/>   17: 
<a name="18"/>   18: <b>-module</b>(argparse_SUITE).
<a name="19"/>   19: <b>-author</b>(&quot;maximfca@gmail.com&quot;).
<a name="20"/>   20: 
<a name="21"/>   21: <b>-export</b>([suite/0, all/0, groups/0]).
<a name="22"/>   22: 
<a name="23"/>   23: <b>-export</b>([
<a name="24"/>   24:     readme/0, readme/1,
<a name="25"/>   25:     basic/0, basic/1,
<a name="26"/>   26:     long_form_eq/0, long_form_eq/1,
<a name="27"/>   27:     built_in_types/0, built_in_types/1,
<a name="28"/>   28:     type_validators/0, type_validators/1,
<a name="29"/>   29:     invalid_arguments/0, invalid_arguments/1,
<a name="30"/>   30:     complex_command/0, complex_command/1,
<a name="31"/>   31:     unicode/0, unicode/1,
<a name="32"/>   32:     parser_error/0, parser_error/1,
<a name="33"/>   33:     nargs/0, nargs/1,
<a name="34"/>   34:     argparse/0, argparse/1,
<a name="35"/>   35:     negative/0, negative/1,
<a name="36"/>   36:     nodigits/0, nodigits/1,
<a name="37"/>   37:     pos_mixed_with_opt/0, pos_mixed_with_opt/1,
<a name="38"/>   38:     default_for_not_required/0, default_for_not_required/1,
<a name="39"/>   39:     global_default/0, global_default/1,
<a name="40"/>   40:     subcommand/0, subcommand/1,
<a name="41"/>   41:     very_short/0, very_short/1,
<a name="42"/>   42:     multi_short/0, multi_short/1,
<a name="43"/>   43:     proxy_arguments/0, proxy_arguments/1,
<a name="44"/>   44: 
<a name="45"/>   45:     usage/0, usage/1,
<a name="46"/>   46:     usage_required_args/0, usage_required_args/1,
<a name="47"/>   47:     usage_template/0, usage_template/1,
<a name="48"/>   48:     usage_args_ordering/0, usage_args_ordering/1,
<a name="49"/>   49:     parser_error_usage/0, parser_error_usage/1,
<a name="50"/>   50:     command_usage/0, command_usage/1,
<a name="51"/>   51:     usage_width/0, usage_width/1,
<a name="52"/>   52: 
<a name="53"/>   53:     validator_exception/0, validator_exception/1,
<a name="54"/>   54:     validator_exception_format/0, validator_exception_format/1,
<a name="55"/>   55: 
<a name="56"/>   56:     run_handle/0, run_handle/1,
<a name="57"/>   57:     run_args_ordering/0, run_args_ordering/1
<a name="58"/>   58: ]).
<a name="59"/>   59: 
<a name="60"/>   60: <b>-include_lib</b>(&quot;stdlib/include/assert.hrl&quot;).
<a name="61"/>   61: 
<a name="suite-0"/><a name="62"/>   62: <b>suite</b>() -&gt;
<a name="suite-last_expr"/><a name="63"/>   63:     [{timetrap, {seconds, 30}}].
<a name="64"/>   64: 
<a name="groups-0"/><a name="65"/>   65: <b>groups</b>() -&gt;
<a name="groups-last_expr"/><a name="66"/>   66:     [
<a name="67"/>   67:         {parser, [parallel], [
<a name="68"/>   68:             readme, basic, long_form_eq, built_in_types, type_validators,
<a name="69"/>   69:             invalid_arguments, complex_command, unicode, parser_error,
<a name="70"/>   70:             nargs, argparse, negative, nodigits, pos_mixed_with_opt,
<a name="71"/>   71:             default_for_not_required, global_default, subcommand,
<a name="72"/>   72:             very_short, multi_short, proxy_arguments
<a name="73"/>   73:         ]},
<a name="74"/>   74:         {usage, [parallel], [
<a name="75"/>   75:             usage, usage_required_args, usage_template, usage_args_ordering,
<a name="76"/>   76:             parser_error_usage, command_usage, usage_width
<a name="77"/>   77:         ]},
<a name="78"/>   78:         {validator, [parallel], [
<a name="79"/>   79:             validator_exception, validator_exception_format
<a name="80"/>   80:         ]},
<a name="81"/>   81:         {run, [parallel], [
<a name="82"/>   82:             run_handle, run_args_ordering
<a name="83"/>   83:         ]}
<a name="84"/>   84:     ].
<a name="85"/>   85: 
<a name="all-0"/><a name="86"/>   86: <b>all</b>() -&gt;
<a name="all-last_expr"/><a name="87"/>   87:     [{group, parser}, {group, validator}, {group, usage}].
<a name="88"/>   88: 
<a name="89"/>   89: <i>%%--------------------------------------------------------------------</i>
<a name="90"/>   90: <i>%% Helpers</i>
<a name="91"/>   91: 
<a name="prog-0"/><a name="92"/>   92: <b>prog</b>() -&gt;
<a name="prog-last_expr"/><a name="93"/>   93: <b>    {ok, [[ProgStr]]} = init:get_argument</b>(progname), ProgStr.
<a name="94"/>   94: 
<a name="parser_error-2"/><a name="95"/>   95: <b>parser_error</b>(CmdLine, CmdMap) -&gt;
<a name="96"/>   96:     {error, Reason} = parse(CmdLine, CmdMap),
<a name="parser_error-last_expr"/><a name="97"/>   97: <b>    unicode:characters_to_list</b>(argparse:format_error(Reason)).
<a name="98"/>   98: 
<a name="parse_opts-2"/><a name="99"/>   99: <b>parse_opts</b>(Args, Opts) -&gt;
<a name="parse_opts-last_expr"/><a name="100"/>  100: <b>    argparse:parse</b>(string:lexemes(Args, &quot; &quot;), #{arguments =&gt; Opts}).
<a name="101"/>  101: 
<a name="parse-2"/><a name="102"/>  102: <b>parse</b>(Args, Command) -&gt;
<a name="parse-last_expr"/><a name="103"/>  103: <b>    argparse:parse</b>(string:lexemes(Args, &quot; &quot;), Command).
<a name="104"/>  104: 
<a name="parse_cmd-2"/><a name="105"/>  105: <b>parse_cmd</b>(Args, Command) -&gt;
<a name="parse_cmd-last_expr"/><a name="106"/>  106: <b>    argparse:parse</b>(string:lexemes(Args, &quot; &quot;), #{commands =&gt; Command}).
<a name="107"/>  107: 
<a name="108"/>  108: <i>%% ubiquitous command, containing sub-commands, and all possible option types</i>
<a name="109"/>  109: <i>%% with all nargs. Not all combinations though.</i>
<a name="ubiq_cmd-0"/><a name="110"/>  110: <b>ubiq_cmd</b>() -&gt;
<a name="ubiq_cmd-last_expr"/><a name="111"/>  111:     #{
<a name="112"/>  112:         arguments =&gt; [
<a name="113"/>  113:             #{name =&gt; r, short =&gt; $r, type =&gt; boolean, help =&gt; &quot;recursive&quot;},
<a name="114"/>  114:             #{name =&gt; f, short =&gt; $f, type =&gt; boolean, long =&gt; &quot;-force&quot;, help =&gt; &quot;force&quot;},
<a name="115"/>  115:             #{name =&gt; v, short =&gt; $v, type =&gt; boolean, action =&gt; count, help =&gt; &quot;verbosity level&quot;},
<a name="116"/>  116:             #{name =&gt; interval, short =&gt; $i, type =&gt; {integer, [{min, 1}]}, help =&gt; &quot;interval set&quot;},
<a name="117"/>  117:             #{name =&gt; weird, long =&gt; &quot;-req&quot;, help =&gt; &quot;required optional, right?&quot;},
<a name="118"/>  118:             #{name =&gt; float, long =&gt; &quot;-float&quot;, type =&gt; float, default =&gt; 3.14, help =&gt; &quot;floating-point long form argument&quot;}
<a name="119"/>  119:         ],
<a name="120"/>  120:         commands =&gt; #{
<a name="121"/>  121:             &quot;start&quot; =&gt; #{help =&gt; &quot;verifies configuration and starts server&quot;,
<a name="122"/>  122:                 arguments =&gt; [
<a name="123"/>  123:                     #{name =&gt; server, help =&gt; &quot;server to start&quot;},
<a name="124"/>  124:                     #{name =&gt; shard, short =&gt; $s, type =&gt; integer, nargs =&gt; nonempty_list, help =&gt; &quot;initial shards&quot;},
<a name="125"/>  125:                     #{name =&gt; part, short =&gt; $p, type =&gt; integer, nargs =&gt; list, help =&gt; hidden},
<a name="126"/>  126:                     #{name =&gt; z, short =&gt; $z, type =&gt; {integer, [{min, 1}, {max, 10}]}, help =&gt; &quot;between&quot;},
<a name="127"/>  127:                     #{name =&gt; l, short =&gt; $l, type =&gt; {integer, [{max, 10}]}, nargs =&gt; 'maybe', help =&gt; &quot;maybe lower&quot;},
<a name="128"/>  128:                     #{name =&gt; more, short =&gt; $m, type =&gt; {integer, [{max, 10}]}, help =&gt; &quot;less than 10&quot;},
<a name="129"/>  129:                     #{name =&gt; optpos, required =&gt; false, type =&gt; {integer, []}, help =&gt; &quot;optional positional&quot;},
<a name="130"/>  130:                     #{name =&gt; bin, short =&gt; $b, type =&gt; {binary, &lt;&lt;&quot;m&quot;&gt;&gt;}, help =&gt; &quot;binary with re&quot;},
<a name="131"/>  131:                     #{name =&gt; g, short =&gt; $g, type =&gt; {binary, &lt;&lt;&quot;m&quot;&gt;&gt;, []}, help =&gt; &quot;binary with re&quot;},
<a name="132"/>  132:                     #{name =&gt; t, short =&gt; $t, type =&gt; {string, &quot;m&quot;}, help =&gt; &quot;string with re&quot;},
<a name="133"/>  133:                     #{name =&gt; e, long =&gt; &quot;--maybe-req&quot;, required =&gt; true, type =&gt; integer, nargs =&gt; 'maybe', help =&gt; &quot;maybe required int&quot;},
<a name="134"/>  134:                     #{name =&gt; y, required =&gt; true, long =&gt; &quot;-yyy&quot;, short =&gt; $y, type =&gt; {string, &quot;m&quot;, []}, help =&gt; &quot;string with re&quot;},
<a name="135"/>  135:                     #{name =&gt; u, short =&gt; $u, type =&gt; {string, [&quot;1&quot;, &quot;2&quot;]}, help =&gt; &quot;string choices&quot;},
<a name="136"/>  136:                     #{name =&gt; choice, short =&gt; $c, type =&gt; {integer, [1,2,3]}, help =&gt; &quot;tough choice&quot;},
<a name="137"/>  137:                     #{name =&gt; fc, short =&gt; $q, type =&gt; {float, [2.1,1.2]}, help =&gt; &quot;floating choice&quot;},
<a name="138"/>  138:                     #{name =&gt; ac, short =&gt; $w, type =&gt; {atom, [one, two]}, help =&gt; &quot;atom choice&quot;},
<a name="139"/>  139:                     #{name =&gt; au, long =&gt; &quot;-unsafe&quot;, type =&gt; {atom, unsafe}, help =&gt; &quot;unsafe atom&quot;},
<a name="140"/>  140:                     #{name =&gt; as, long =&gt; &quot;-safe&quot;, type =&gt; atom, help =&gt; &lt;&lt;&quot;safe atom&quot;&gt;&gt;},
<a name="141"/>  141:                     #{name =&gt; name, required =&gt; false, nargs =&gt; list, help =&gt; hidden},
<a name="142"/>  142:                     #{name =&gt; long, long =&gt; &quot;foobar&quot;, required =&gt; false, help =&gt; [&lt;&lt;&quot;foobaring option&quot;&gt;&gt;]}
<a name="143"/>  143:                 ], commands =&gt; #{
<a name="144"/>  144:                     &quot;crawler&quot; =&gt; #{arguments =&gt; [
<a name="145"/>  145:                         #{name =&gt; extra, long =&gt; &quot;--extra&quot;, help =&gt; &quot;extra option very deep&quot;}
<a name="146"/>  146:                     ],
<a name="147"/>  147:                         help =&gt; &quot;controls crawler behaviour&quot;},
<a name="148"/>  148:                     &quot;doze&quot; =&gt; #{help =&gt; &quot;dozes a bit&quot;}}
<a name="149"/>  149:             },
<a name="150"/>  150:             &quot;stop&quot; =&gt; #{help =&gt; &lt;&lt;&quot;stops running server&quot;&gt;&gt;, arguments =&gt; []
<a name="151"/>  151:             },
<a name="152"/>  152:             &quot;status&quot; =&gt; #{help =&gt; &quot;prints server status&quot;, arguments =&gt; [],
<a name="153"/>  153:                 commands =&gt; #{
<a name="154"/>  154:                     &quot;crawler&quot; =&gt; #{
<a name="155"/>  155:                         arguments =&gt; [#{name =&gt; extra, long =&gt; &quot;--extra&quot;, help =&gt; &quot;extra option very deep&quot;}],
<a name="156"/>  156:                         help =&gt; &quot;crawler status&quot;}}
<a name="157"/>  157:             },
<a name="158"/>  158:             &quot;restart&quot; =&gt; #{help =&gt; hidden, arguments =&gt; [
<a name="159"/>  159:                 #{name =&gt; server, help =&gt; &quot;server to restart&quot;},
<a name="160"/>  160:                 #{name =&gt; duo, short =&gt; $d, long =&gt; &quot;-duo&quot;, help =&gt; &quot;dual option&quot;}
<a name="161"/>  161:             ]}
<a name="162"/>  162:     }
<a name="163"/>  163:     }.
<a name="164"/>  164: 
<a name="165"/>  165: <i>%%--------------------------------------------------------------------</i>
<a name="166"/>  166: <i>%% Parser Test Cases</i>
<a name="167"/>  167: 
<a name="readme-0"/><a name="168"/>  168: <b>readme</b>() -&gt;
<a name="readme-last_expr"/><a name="169"/>  169:     [{doc, &quot;Test cases covered in the README&quot;}].
<a name="170"/>  170: 
<a name="readme-1"/><a name="171"/>  171: <b>readme</b>(Config) when is_list(Config) -&gt;
<a name="172"/>  172:     Prog = prog(),
<a name="173"/>  173:     Rm = #{
<a name="174"/>  174:         arguments =&gt; [
<a name="175"/>  175:             #{name =&gt; dir},
<a name="176"/>  176:             #{name =&gt; force, short =&gt; $f, type =&gt; boolean, default =&gt; false},
<a name="177"/>  177:             #{name =&gt; recursive, short =&gt; $r, type =&gt; boolean}
<a name="178"/>  178:         ]
<a name="179"/>  179:     },
<a name="180"/>  180:     ?assertEqual({ok, #{dir =&gt; &quot;dir&quot;, force =&gt; true, recursive =&gt; true}, [Prog], Rm},
<a name="181"/>  181:         argparse:parse([&quot;-rf&quot;, &quot;dir&quot;], Rm)),
<a name="182"/>  182:     %% override progname
<a name="183"/>  183:     ?assertEqual(&quot;Usage:\n  readme\n&quot;,
<a name="184"/>  184:         unicode:characters_to_list(argparse:help(#{}, #{progname =&gt; &quot;readme&quot;}))),
<a name="185"/>  185:     ?assertEqual(&quot;Usage:\n  readme\n&quot;,
<a name="186"/>  186:         unicode:characters_to_list(argparse:help(#{}, #{progname =&gt; readme}))),
<a name="187"/>  187:     ?assertEqual(&quot;Usage:\n  readme\n&quot;,
<a name="188"/>  188:         unicode:characters_to_list(argparse:help(#{}, #{progname =&gt; &lt;&lt;&quot;readme&quot;&gt;&gt;}))),
<a name="189"/>  189:     %% test that command has priority over just a positional argument:
<a name="190"/>  190:     %%  - parsing &quot;opt sub&quot; means &quot;find positional argument &quot;pos&quot;, then enter subcommand
<a name="191"/>  191:     %%  - parsing &quot;sub opt&quot; means &quot;enter sub-command, and then find positional argument&quot;
<a name="192"/>  192:     Cmd = #{
<a name="193"/>  193:         commands =&gt; #{&quot;sub&quot; =&gt; #{}},
<a name="194"/>  194:         arguments =&gt; [#{name =&gt; pos}]
<a name="195"/>  195:     },
<a name="readme-last_expr"/><a name="196"/>  196: <b>    ?assertEqual</b>(parse(&quot;opt sub&quot;, Cmd), parse(&quot;sub opt&quot;, Cmd)).
<a name="197"/>  197: 
<a name="basic-0"/><a name="198"/>  198: <b>basic</b>() -&gt;
<a name="basic-last_expr"/><a name="199"/>  199:     [{doc, &quot;Basic cases&quot;}].
<a name="200"/>  200: 
<a name="basic-1"/><a name="201"/>  201: <b>basic</b>(Config) when is_list(Config) -&gt;
<a name="202"/>  202:     Prog = prog(),
<a name="203"/>  203:     %% empty command, with full options path
<a name="204"/>  204:     ?assertMatch({ok, #{}, [Prog, &quot;cmd&quot;], #{}},
<a name="205"/>  205:         argparse:parse([&quot;cmd&quot;], #{commands =&gt; #{&quot;cmd&quot; =&gt; #{}}})),
<a name="206"/>  206:     %% sub-command, with no path, but user-supplied argument
<a name="207"/>  207:     ?assertEqual({ok, #{}, [Prog, &quot;cmd&quot;, &quot;sub&quot;], #{attr =&gt; pos}},
<a name="208"/>  208:         argparse:parse([&quot;cmd&quot;, &quot;sub&quot;], #{commands =&gt; #{&quot;cmd&quot; =&gt; #{commands =&gt; #{&quot;sub&quot; =&gt; #{attr =&gt; pos}}}}})),
<a name="209"/>  209:     %% command with positional argument
<a name="210"/>  210:     PosCmd = #{arguments =&gt; [#{name =&gt; pos}]},
<a name="211"/>  211:     ?assertEqual({ok, #{pos =&gt; &quot;arg&quot;}, [Prog, &quot;cmd&quot;], PosCmd},
<a name="212"/>  212:         argparse:parse([&quot;cmd&quot;, &quot;arg&quot;], #{commands =&gt; #{&quot;cmd&quot; =&gt; PosCmd}})),
<a name="213"/>  213:     %% command with optional argument
<a name="214"/>  214:     OptCmd = #{arguments =&gt; [#{name =&gt; force, short =&gt; $f, type =&gt; boolean}]},
<a name="215"/>  215:     ?assertEqual({ok, #{force =&gt; true}, [Prog, &quot;rm&quot;], OptCmd},
<a name="216"/>  216:         parse([&quot;rm -f&quot;], #{commands =&gt; #{&quot;rm&quot; =&gt; OptCmd}}), &quot;rm -f&quot;),
<a name="217"/>  217:     %% command with optional and positional argument
<a name="218"/>  218:     PosOptCmd = #{arguments =&gt; [#{name =&gt; force, short =&gt; $f, type =&gt; boolean}, #{name =&gt; dir}]},
<a name="219"/>  219:     ?assertEqual({ok, #{force =&gt; true, dir =&gt; &quot;dir&quot;}, [Prog, &quot;rm&quot;], PosOptCmd},
<a name="220"/>  220:         parse([&quot;rm -f dir&quot;], #{commands =&gt; #{&quot;rm&quot; =&gt; PosOptCmd}}), &quot;rm -f dir&quot;),
<a name="221"/>  221:     %% no command, just argument list
<a name="222"/>  222:     KernelCmd = #{arguments =&gt; [#{name =&gt; kernel, long =&gt; &quot;kernel&quot;, type =&gt; atom, nargs =&gt; 2}]},
<a name="223"/>  223:     ?assertEqual({ok, #{kernel =&gt; [port, dist]}, [Prog], KernelCmd},
<a name="224"/>  224:         parse([&quot;-kernel port dist&quot;], KernelCmd)),
<a name="225"/>  225:     %% same but positional
<a name="226"/>  226:     ArgListCmd = #{arguments =&gt; [#{name =&gt; arg, nargs =&gt; 2, type =&gt; boolean}]},
<a name="basic-last_expr"/><a name="227"/>  227: <b>    ?assertEqual</b>({ok, #{arg =&gt; [true, false]}, [Prog], ArgListCmd},
<a name="228"/>  228:         parse([&quot;true false&quot;], ArgListCmd)).
<a name="229"/>  229: 
<a name="long_form_eq-0"/><a name="230"/>  230: <b>long_form_eq</b>() -&gt;
<a name="long_form_eq-last_expr"/><a name="231"/>  231:     [{doc, &quot;Tests that long form supports --arg=value&quot;}].
<a name="232"/>  232: 
<a name="long_form_eq-1"/><a name="233"/>  233: <b>long_form_eq</b>(Config) when is_list(Config) -&gt;
<a name="234"/>  234:     Prog = prog(),
<a name="235"/>  235:     %% cmd --arg=value
<a name="236"/>  236:     PosOptCmd = #{arguments =&gt; [#{name =&gt; arg, long =&gt; &quot;-arg&quot;}]},
<a name="237"/>  237:     ?assertEqual({ok, #{arg =&gt; &quot;value&quot;}, [Prog, &quot;cmd&quot;], PosOptCmd},
<a name="238"/>  238:         parse([&quot;cmd --arg=value&quot;], #{commands =&gt; #{&quot;cmd&quot; =&gt; PosOptCmd}})),
<a name="239"/>  239:     %% --integer=10
<a name="long_form_eq-last_expr"/><a name="240"/>  240: <b>    ?assertMatch</b>({ok, #{int := 10}, _, _},
<a name="241"/>  241:         parse([&quot;--int=10&quot;], #{arguments =&gt; [#{name =&gt; int, type =&gt; integer, long =&gt; &quot;-int&quot;}]})).
<a name="242"/>  242: 
<a name="built_in_types-0"/><a name="243"/>  243: <b>built_in_types</b>() -&gt;
<a name="built_in_types-last_expr"/><a name="244"/>  244:     [{doc, &quot;Tests all built-in types supplied as a single argument&quot;}].
<a name="245"/>  245: 
<a name="246"/>  246: <i>% built-in types testing</i>
<a name="built_in_types-1"/><a name="247"/>  247: <b>built_in_types</b>(Config) when is_list(Config) -&gt;
<a name="248"/>  248:     Prog = [prog()],
<a name="249"/>  249:     Bool = #{arguments =&gt; [#{name =&gt; meta, type =&gt; boolean, short =&gt; $b, long =&gt; &quot;-boolean&quot;}]},
<a name="250"/>  250:     ?assertEqual({ok, #{}, Prog, Bool}, parse([&quot;&quot;], Bool)),
<a name="251"/>  251:     ?assertEqual({ok, #{meta =&gt; true}, Prog, Bool}, parse([&quot;-b&quot;], Bool)),
<a name="252"/>  252:     ?assertEqual({ok, #{meta =&gt; true}, Prog, Bool}, parse([&quot;--boolean&quot;], Bool)),
<a name="253"/>  253:     ?assertEqual({ok, #{meta =&gt; false}, Prog, Bool}, parse([&quot;--boolean false&quot;], Bool)),
<a name="254"/>  254:     %% integer tests
<a name="255"/>  255:     Int = #{arguments =&gt; [#{name =&gt; int, type =&gt; integer, short =&gt; $i, long =&gt; &quot;-int&quot;}]},
<a name="256"/>  256:     ?assertEqual({ok, #{int =&gt; 1}, Prog, Int}, parse([&quot; -i 1&quot;], Int)),
<a name="257"/>  257:     ?assertEqual({ok, #{int =&gt; 1}, Prog, Int}, parse([&quot;--int 1&quot;], Int)),
<a name="258"/>  258:     ?assertEqual({ok, #{int =&gt; -1}, Prog, Int}, parse([&quot;-i -1&quot;], Int)),
<a name="259"/>  259:     %% floating point
<a name="260"/>  260:     Float = #{arguments =&gt; [#{name =&gt; f, type =&gt; float, short =&gt; $f}]},
<a name="261"/>  261:     ?assertEqual({ok, #{f =&gt; 44.44}, Prog, Float}, parse([&quot;-f 44.44&quot;], Float)),
<a name="262"/>  262:     %% atoms, existing
<a name="263"/>  263:     Atom = #{arguments =&gt; [#{name =&gt; atom, type =&gt; atom, short =&gt; $a, long =&gt; &quot;-atom&quot;}]},
<a name="264"/>  264:     ?assertEqual({ok, #{atom =&gt; atom}, Prog, Atom}, parse([&quot;-a atom&quot;], Atom)),
<a name="built_in_types-last_expr"/><a name="265"/>  265: <b>    ?assertEqual</b>({ok, #{atom =&gt; atom}, Prog, Atom}, parse([&quot;--atom atom&quot;], Atom)).
<a name="266"/>  266: 
<a name="type_validators-0"/><a name="267"/>  267: <b>type_validators</b>() -&gt;
<a name="type_validators-last_expr"/><a name="268"/>  268:     [{doc, &quot;Test that parser return expected conversions for valid arguments&quot;}].
<a name="269"/>  269: 
<a name="type_validators-1"/><a name="270"/>  270: <b>type_validators</b>(Config) when is_list(Config) -&gt;
<a name="271"/>  271:     %% successful string regexes
<a name="272"/>  272:     ?assertMatch({ok, #{str := &quot;me&quot;}, _, _},
<a name="273"/>  273:         parse_opts(&quot;me&quot;, [#{name =&gt; str, type =&gt; {string, &quot;m.&quot;}}])),
<a name="274"/>  274:     ?assertMatch({ok, #{str := &quot;me&quot;}, _, _},
<a name="275"/>  275:         parse_opts(&quot;me&quot;, [#{name =&gt; str, type =&gt; {string, &quot;m.&quot;, []}}])),
<a name="276"/>  276:     ?assertMatch({ok, #{&quot;str&quot; := &quot;me&quot;}, _, _},
<a name="277"/>  277:         parse_opts(&quot;me&quot;, [#{name =&gt; &quot;str&quot;, type =&gt; {string, &quot;m.&quot;, [{capture, none}]}}])),
<a name="278"/>  278:     %% and binary too...
<a name="279"/>  279:     ?assertMatch({ok, #{bin := &lt;&lt;&quot;me&quot;&gt;&gt;}, _, _},
<a name="280"/>  280:         parse_opts(&quot;me&quot;, [#{name =&gt; bin, type =&gt; {binary, &lt;&lt;&quot;m.&quot;&gt;&gt;}}])),
<a name="281"/>  281:     ?assertMatch({ok, #{&lt;&lt;&quot;bin&quot;&gt;&gt; := &lt;&lt;&quot;me&quot;&gt;&gt;}, _, _},
<a name="282"/>  282:         parse_opts(&quot;me&quot;, [#{name =&gt; &lt;&lt;&quot;bin&quot;&gt;&gt;, type =&gt; {binary, &lt;&lt;&quot;m.&quot;&gt;&gt;, []}}])),
<a name="283"/>  283:     ?assertMatch({ok, #{bin := &lt;&lt;&quot;me&quot;&gt;&gt;}, _, _},
<a name="284"/>  284:         parse_opts(&quot;me&quot;, [#{name =&gt; bin, type =&gt; {binary, &lt;&lt;&quot;m.&quot;&gt;&gt;, [{capture, none}]}}])),
<a name="285"/>  285:     %% successful integer with range validators
<a name="286"/>  286:     ?assertMatch({ok, #{int := 5}, _, _},
<a name="287"/>  287:         parse_opts(&quot;5&quot;, [#{name =&gt; int, type =&gt; {integer, [{min, 0}, {max, 10}]}}])),
<a name="288"/>  288:     ?assertMatch({ok, #{bin := &lt;&lt;&quot;5&quot;&gt;&gt;}, _, _},
<a name="289"/>  289:         parse_opts(&quot;5&quot;, [#{name =&gt; bin, type =&gt; binary}])),
<a name="290"/>  290:     ?assertMatch({ok, #{str := &quot;011&quot;}, _, _},
<a name="291"/>  291:         parse_opts(&quot;11&quot;, [#{name =&gt; str, type =&gt; {custom, fun(S) -&gt; [$0|S] end}}])),
<a name="292"/>  292:     %% choices: valid
<a name="293"/>  293:     ?assertMatch({ok, #{bin := &lt;&lt;&quot;K&quot;&gt;&gt;}, _, _},
<a name="294"/>  294:         parse_opts(&quot;K&quot;, [#{name =&gt; bin, type =&gt; {binary, [&lt;&lt;&quot;M&quot;&gt;&gt;, &lt;&lt;&quot;K&quot;&gt;&gt;]}}])),
<a name="295"/>  295:     ?assertMatch({ok, #{str := &quot;K&quot;}, _, _},
<a name="296"/>  296:         parse_opts(&quot;K&quot;, [#{name =&gt; str, type =&gt; {string, [&quot;K&quot;, &quot;N&quot;]}}])),
<a name="297"/>  297:     ?assertMatch({ok, #{atom := one}, _, _},
<a name="298"/>  298:         parse_opts(&quot;one&quot;, [#{name =&gt; atom, type =&gt; {atom, [one, two]}}])),
<a name="299"/>  299:     ?assertMatch({ok, #{int := 12}, _, _},
<a name="300"/>  300:         parse_opts(&quot;12&quot;, [#{name =&gt; int, type =&gt; {integer, [10, 12]}}])),
<a name="301"/>  301:     ?assertMatch({ok, #{float := 1.3}, _, _},
<a name="302"/>  302:         parse_opts(&quot;1.3&quot;, [#{name =&gt; float, type =&gt; {float, [1.3, 1.4]}}])),
<a name="303"/>  303:     %% test for unsafe atom
<a name="304"/>  304:     %% ensure the atom does not exist
<a name="305"/>  305:     ?assertException(error, badarg, list_to_existing_atom(&quot;$can_never_be&quot;)),
<a name="306"/>  306:     {ok, ArgMap, _, _} = parse_opts(&quot;$can_never_be&quot;, [#{name =&gt; atom, type =&gt; {atom, unsafe}}]),
<a name="307"/>  307:     argparse:validate(#{arguments =&gt; [#{name =&gt; atom, type =&gt; {atom, unsafe}}]}),
<a name="308"/>  308:     %% now that atom exists, because argparse created it (in an unsafe way!)
<a name="309"/>  309:     ?assertEqual(list_to_existing_atom(&quot;$can_never_be&quot;), maps:get(atom, ArgMap)),
<a name="310"/>  310:     %% test successful user-defined conversion
<a name="type_validators-last_expr"/><a name="311"/>  311: <b>    ?assertMatch</b>({ok, #{user := &quot;VER&quot;}, _, _},
<a name="312"/>  312:         parse_opts(&quot;REV&quot;, [#{name =&gt; user, type =&gt; {custom, fun (Str) -&gt; lists:reverse(Str) end}}])).
<a name="313"/>  313: 
<a name="invalid_arguments-0"/><a name="314"/>  314: <b>invalid_arguments</b>() -&gt;
<a name="invalid_arguments-last_expr"/><a name="315"/>  315:     [{doc, &quot;Test that parser return errors for invalid arguments&quot;}].
<a name="316"/>  316: 
<a name="invalid_arguments-1"/><a name="317"/>  317: <b>invalid_arguments</b>(Config) when is_list(Config) -&gt;
<a name="318"/>  318:     %% {float, [{min, float()} | {max, float()}]} |
<a name="319"/>  319:     Prog = [prog()],
<a name="320"/>  320:     MinFloat = #{name =&gt; float, type =&gt; {float, [{min, 1.0}]}},
<a name="321"/>  321:     ?assertEqual({error, {Prog, MinFloat, &quot;0.0&quot;, &lt;&lt;&quot;is less than accepted minimum&quot;&gt;&gt;}},
<a name="322"/>  322:         parse_opts(&quot;0.0&quot;, [MinFloat])),
<a name="323"/>  323:     MaxFloat = #{name =&gt; float, type =&gt; {float, [{max, 1.0}]}},
<a name="324"/>  324:     ?assertEqual({error, {Prog, MaxFloat, &quot;2.0&quot;, &lt;&lt;&quot;is greater than accepted maximum&quot;&gt;&gt;}},
<a name="325"/>  325:         parse_opts(&quot;2.0&quot;, [MaxFloat])),
<a name="326"/>  326:     %% {int, [{min, integer()} | {max, integer()}]} |
<a name="327"/>  327:     MinInt = #{name =&gt; int, type =&gt; {integer, [{min, 20}]}},
<a name="328"/>  328:     ?assertEqual({error, {Prog, MinInt, &quot;10&quot;, &lt;&lt;&quot;is less than accepted minimum&quot;&gt;&gt;}},
<a name="329"/>  329:         parse_opts(&quot;10&quot;, [MinInt])),
<a name="330"/>  330:     MaxInt = #{name =&gt; int, type =&gt; {integer, [{max, -10}]}},
<a name="331"/>  331:     ?assertEqual({error, {Prog, MaxInt, &quot;-5&quot;, &lt;&lt;&quot;is greater than accepted maximum&quot;&gt;&gt;}},
<a name="332"/>  332:         parse_opts(&quot;-5&quot;, [MaxInt])),
<a name="333"/>  333:     %% string: regex &amp; regex with options
<a name="334"/>  334:     %% {string, string()} | {string, string(), []}
<a name="335"/>  335:     StrRegex = #{name =&gt; str, type =&gt; {string, &quot;me.me&quot;}},
<a name="336"/>  336:     ?assertEqual({error, {Prog, StrRegex, &quot;me&quot;, &lt;&lt;&quot;does not match&quot;&gt;&gt;}},
<a name="337"/>  337:         parse_opts(&quot;me&quot;, [StrRegex])),
<a name="338"/>  338:     StrRegexOpt = #{name =&gt; str, type =&gt; {string, &quot;me.me&quot;, []}},
<a name="339"/>  339:     ?assertEqual({error, {Prog, StrRegexOpt, &quot;me&quot;, &lt;&lt;&quot;does not match&quot;&gt;&gt;}},
<a name="340"/>  340:         parse_opts(&quot;me&quot;, [StrRegexOpt])),
<a name="341"/>  341:     %% {binary, {re, binary()} | {re, binary(), []}
<a name="342"/>  342:     BinRegex = #{name =&gt; bin, type =&gt; {binary, &lt;&lt;&quot;me.me&quot;&gt;&gt;}},
<a name="343"/>  343:     ?assertEqual({error, {Prog, BinRegex, &quot;me&quot;, &lt;&lt;&quot;does not match&quot;&gt;&gt;}},
<a name="344"/>  344:         parse_opts(&quot;me&quot;, [BinRegex])),
<a name="345"/>  345:     BinRegexOpt = #{name =&gt; bin, type =&gt; {binary, &lt;&lt;&quot;me.me&quot;&gt;&gt;, []}},
<a name="346"/>  346:     ?assertEqual({error, {Prog, BinRegexOpt, &quot;me&quot;, &lt;&lt;&quot;does not match&quot;&gt;&gt;}},
<a name="347"/>  347:         parse_opts(&quot;me&quot;, [BinRegexOpt])),
<a name="348"/>  348:     %% invalid integer (comma , is not parsed)
<a name="349"/>  349:     ?assertEqual({error, {Prog, MinInt, &quot;1,&quot;, &lt;&lt;&quot;is not an integer&quot;&gt;&gt;}},
<a name="350"/>  350:         parse_opts([&quot;1,&quot;], [MinInt])),
<a name="351"/>  351:     %% test invalid choices
<a name="352"/>  352:     BinChoices = #{name =&gt; bin, type =&gt; {binary, [&lt;&lt;&quot;M&quot;&gt;&gt;, &lt;&lt;&quot;N&quot;&gt;&gt;]}},
<a name="353"/>  353:     ?assertEqual({error, {Prog, BinChoices, &quot;K&quot;, &lt;&lt;&quot;is not one of the choices&quot;&gt;&gt;}},
<a name="354"/>  354:         parse_opts(&quot;K&quot;, [BinChoices])),
<a name="355"/>  355:     StrChoices = #{name =&gt; str, type =&gt; {string, [&quot;M&quot;, &quot;N&quot;]}},
<a name="356"/>  356:     ?assertEqual({error, {Prog, StrChoices, &quot;K&quot;, &lt;&lt;&quot;is not one of the choices&quot;&gt;&gt;}},
<a name="357"/>  357:         parse_opts(&quot;K&quot;, [StrChoices])),
<a name="358"/>  358:     AtomChoices = #{name =&gt; atom, type =&gt; {atom, [one, two]}},
<a name="359"/>  359:     ?assertEqual({error, {Prog, AtomChoices, &quot;K&quot;, &lt;&lt;&quot;is not one of the choices&quot;&gt;&gt;}},
<a name="360"/>  360:         parse_opts(&quot;K&quot;, [AtomChoices])),
<a name="361"/>  361:     IntChoices = #{name =&gt; int, type =&gt; {integer, [10, 11]}},
<a name="362"/>  362:     ?assertEqual({error, {Prog, IntChoices, &quot;12&quot;, &lt;&lt;&quot;is not one of the choices&quot;&gt;&gt;}},
<a name="363"/>  363:         parse_opts(&quot;12&quot;, [IntChoices])),
<a name="364"/>  364:     FloatChoices = #{name =&gt; float, type =&gt; {float, [1.2, 1.4]}},
<a name="365"/>  365:     ?assertEqual({error, {Prog, FloatChoices, &quot;1.3&quot;, &lt;&lt;&quot;is not one of the choices&quot;&gt;&gt;}},
<a name="366"/>  366:         parse_opts(&quot;1.3&quot;, [FloatChoices])),
<a name="367"/>  367:     %% unsuccessful user-defined conversion
<a name="invalid_arguments-last_expr"/><a name="368"/>  368: <b>    ?assertMatch</b>({error, {Prog, _, &quot;REV&quot;, &lt;&lt;&quot;failed validation&quot;&gt;&gt;}},
<a name="369"/>  369:         parse_opts(&quot;REV&quot;, [#{name =&gt; user, type =&gt; {custom, fun (Str) -&gt; integer_to_binary(Str) end}}])).
<a name="370"/>  370: 
<a name="complex_command-0"/><a name="371"/>  371: <b>complex_command</b>() -&gt;
<a name="complex_command-last_expr"/><a name="372"/>  372:     [{doc, &quot;Parses a complex command that has a mix of optional and positional arguments&quot;}].
<a name="373"/>  373: 
<a name="complex_command-1"/><a name="374"/>  374: <b>complex_command</b>(Config) when is_list(Config) -&gt;
<a name="375"/>  375:     Command = #{arguments =&gt; [
<a name="376"/>  376:         %% options
<a name="377"/>  377:         #{name =&gt; string, short =&gt; $s, long =&gt; &quot;-string&quot;, action =&gt; append, help =&gt; &quot;String list option&quot;},
<a name="378"/>  378:         #{name =&gt; boolean, type =&gt; boolean, short =&gt; $b, action =&gt; append, help =&gt; &quot;Boolean list option&quot;},
<a name="379"/>  379:         #{name =&gt; float, type =&gt; float, short =&gt; $f, long =&gt; &quot;-float&quot;, action =&gt; append, help =&gt; &quot;Float option&quot;},
<a name="380"/>  380:         %% positional args
<a name="381"/>  381:         #{name =&gt; integer, type =&gt; integer, help =&gt; &quot;Integer variable&quot;},
<a name="382"/>  382:         #{name =&gt; string, help =&gt; &quot;alias for string option&quot;, action =&gt; extend, nargs =&gt; list}
<a name="383"/>  383:     ]},
<a name="384"/>  384:     CmdMap = #{commands =&gt; #{&quot;start&quot; =&gt; Command}},
<a name="385"/>  385:     Parsed = argparse:parse(string:lexemes(&quot;start --float 1.04 -f 112 -b -b -s s1 42 --string s2 s3 s4&quot;, &quot; &quot;), CmdMap),
<a name="386"/>  386:     Expected = #{float =&gt; [1.04, 112], boolean =&gt; [true, true], integer =&gt; 42, string =&gt; [&quot;s1&quot;, &quot;s2&quot;, &quot;s3&quot;, &quot;s4&quot;]},
<a name="complex_command-last_expr"/><a name="387"/>  387: <b>    ?assertEqual</b>({ok, Expected, [prog(), &quot;start&quot;], Command}, Parsed).
<a name="388"/>  388: 
<a name="unicode-0"/><a name="389"/>  389: <b>unicode</b>() -&gt;
<a name="unicode-last_expr"/><a name="390"/>  390:     [{doc, &quot;Tests basic unicode support&quot;}].
<a name="391"/>  391: 
<a name="unicode-1"/><a name="392"/>  392: <b>unicode</b>(Config) when is_list(Config) -&gt;
<a name="393"/>  393:     %% test unicode short &amp; long
<a name="394"/>  394:     ?assertMatch({ok, #{one := true}, _, _},
<a name="395"/>  395:         parse([&quot;-Ф&quot;], #{arguments =&gt; [#{name =&gt; one, short =&gt; $Ф, type =&gt; boolean}]})),
<a name="396"/>  396:     ?assertMatch({ok, #{long := true}, _, _},
<a name="397"/>  397:         parse([&quot;--åäö&quot;], #{arguments =&gt; [#{name =&gt; long, long =&gt; &quot;-åäö&quot;, type =&gt; boolean}]})),
<a name="398"/>  398:     %% test default, help and value in unicode
<a name="399"/>  399:     Cmd = #{arguments =&gt; [#{name =&gt; text, type =&gt; binary, help =&gt; &quot;åäö&quot;, default =&gt; &lt;&lt;&quot;★&quot;/utf8&gt;&gt;}]},
<a name="400"/>  400:     Expected = #{text =&gt; &lt;&lt;&quot;★&quot;/utf8&gt;&gt;},
<a name="401"/>  401:     Prog = [prog()],
<a name="402"/>  402:     ?assertEqual({ok, Expected, Prog, Cmd}, argparse:parse([], Cmd)), %% default
<a name="403"/>  403:     ?assertEqual({ok, Expected, Prog, Cmd}, argparse:parse([&quot;★&quot;], Cmd)), %% specified in the command line
<a name="404"/>  404:     ?assertEqual(&quot;Usage:\n  &quot; ++ prog() ++ &quot; &lt;text&gt;\n\nArguments:\n  text åäö (binary), default: ★\n&quot;,
<a name="405"/>  405:         unicode:characters_to_list(argparse:help(Cmd))),
<a name="406"/>  406:     %% test command name and argument name in unicode
<a name="407"/>  407:     Uni = #{commands =&gt; #{&quot;åäö&quot; =&gt; #{help =&gt; &quot;öФ&quot;}}, handler =&gt; optional,
<a name="408"/>  408:         arguments =&gt; [#{name =&gt; &quot;Ф&quot;, short =&gt; $ä, long =&gt; &quot;åäö&quot;}]},
<a name="409"/>  409:     UniExpected = &quot;Usage:\n  &quot; ++ prog() ++
<a name="410"/>  410:         &quot; {åäö} [-ä &lt;Ф&gt;] [-åäö &lt;Ф&gt;]\n\nSubcommands:\n  åäö      öФ\n\nOptional arguments:\n  -ä, -åäö Ф\n&quot;,
<a name="411"/>  411:     ?assertEqual(UniExpected, unicode:characters_to_list(argparse:help(Uni))),
<a name="412"/>  412:     ParsedExpected = #{&quot;Ф&quot; =&gt; &quot;öФ&quot;},
<a name="unicode-last_expr"/><a name="413"/>  413: <b>    ?assertEqual</b>({ok, ParsedExpected, Prog, Uni}, argparse:parse([&quot;-ä&quot;, &quot;öФ&quot;], Uni)).
<a name="414"/>  414: 
<a name="parser_error-0"/><a name="415"/>  415: <b>parser_error</b>() -&gt;
<a name="parser_error-last_expr"/><a name="416"/>  416:     [{doc, &quot;Tests error tuples that the parser returns&quot;}].
<a name="417"/>  417: 
<a name="parser_error-1"/><a name="418"/>  418: <b>parser_error</b>(Config) when is_list(Config) -&gt;
<a name="419"/>  419:     Prog = prog(),
<a name="420"/>  420:     %% unknown option at the top of the path
<a name="421"/>  421:     ?assertEqual({error, {[Prog], undefined, &quot;arg&quot;, &lt;&lt;&gt;&gt;}},
<a name="422"/>  422:         parse_cmd([&quot;arg&quot;], #{})),
<a name="423"/>  423:     %% positional argument missing in a sub-command
<a name="424"/>  424:     Opt = #{name =&gt; mode, required =&gt; true},
<a name="425"/>  425:     ?assertMatch({error, {[Prog, &quot;start&quot;], _, undefined, &lt;&lt;&gt;&gt;}},
<a name="426"/>  426:         parse_cmd([&quot;start&quot;], #{&quot;start&quot; =&gt; #{arguments =&gt; [Opt]}})),
<a name="427"/>  427:     %% optional argument missing in a sub-command
<a name="428"/>  428:     Opt1 = #{name =&gt; mode, short =&gt; $o, required =&gt; true},
<a name="429"/>  429:     ?assertMatch({error, {[Prog, &quot;start&quot;], _, undefined, &lt;&lt;&gt;&gt;}},
<a name="430"/>  430:         parse_cmd([&quot;start&quot;], #{&quot;start&quot; =&gt; #{arguments =&gt; [Opt1]}})),
<a name="431"/>  431:     %% positional argument: an atom that does not exist
<a name="432"/>  432:     Opt2 = #{name =&gt; atom, type =&gt; atom},
<a name="433"/>  433:     ?assertEqual({error, {[Prog], Opt2, &quot;boo-foo&quot;, &lt;&lt;&quot;is not an existing atom&quot;&gt;&gt;}},
<a name="434"/>  434:         parse_opts([&quot;boo-foo&quot;], [Opt2])),
<a name="435"/>  435:     %% optional argument missing some items
<a name="436"/>  436:     Opt3 = #{name =&gt; kernel, long =&gt; &quot;kernel&quot;, type =&gt; atom, nargs =&gt; 2},
<a name="437"/>  437:     ?assertEqual({error, {[Prog], Opt3, [&quot;port&quot;], &quot;expected 2, found 1 argument(s)&quot;}},
<a name="438"/>  438:         parse_opts([&quot;-kernel port&quot;], [Opt3])),
<a name="439"/>  439:     %% positional argument missing some items
<a name="440"/>  440:     Opt4 = #{name =&gt; arg, type =&gt; atom, nargs =&gt; 3},
<a name="441"/>  441:     ?assertEqual({error, {[Prog], Opt4, [&quot;p1&quot;], &quot;expected 3, found 1 argument(s)&quot;}},
<a name="442"/>  442:         parse_opts([&quot;p1&quot;], [Opt4])),
<a name="443"/>  443:     %% short option with no argument, when it's needed
<a name="parser_error-last_expr"/><a name="444"/>  444: <b>    ?assertMatch</b>({error, {_, _, undefined, &lt;&lt;&quot;expected argument&quot;&gt;&gt;}},
<a name="445"/>  445:         parse(&quot;-1&quot;, #{arguments =&gt; [#{name =&gt; short49, short =&gt; 49}]})).
<a name="446"/>  446: 
<a name="nargs-0"/><a name="447"/>  447: <b>nargs</b>() -&gt;
<a name="nargs-last_expr"/><a name="448"/>  448:     [{doc, &quot;Tests argument consumption option, with nargs&quot;}].
<a name="449"/>  449: 
<a name="nargs-1"/><a name="450"/>  450: <b>nargs</b>(Config) when is_list(Config) -&gt;
<a name="451"/>  451:     Prog = [prog()],
<a name="452"/>  452:     %% consume optional list arguments
<a name="453"/>  453:     Opts = [
<a name="454"/>  454:         #{name =&gt; arg, short =&gt; $s, nargs =&gt; list, type =&gt; integer},
<a name="455"/>  455:         #{name =&gt; bool, short =&gt; $b, type =&gt; boolean}
<a name="456"/>  456:     ],
<a name="457"/>  457:     ?assertMatch({ok, #{arg := [1, 2, 3], bool := true}, _, _},
<a name="458"/>  458:         parse_opts([&quot;-s 1 2 3 -b&quot;], Opts)),
<a name="459"/>  459:     %% consume one_or_more arguments in an optional list
<a name="460"/>  460:     Opts2 = [
<a name="461"/>  461:         #{name =&gt; arg, short =&gt; $s, nargs =&gt; nonempty_list},
<a name="462"/>  462:         #{name =&gt; extra, short =&gt; $x}
<a name="463"/>  463:         ],
<a name="464"/>  464:     ?assertMatch({ok, #{extra := &quot;X&quot;, arg := [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]}, _, _},
<a name="465"/>  465:         parse_opts([&quot;-s port -s a b c -x X&quot;], Opts2)),
<a name="466"/>  466:     %% error if there is no argument to consume
<a name="467"/>  467:     ?assertMatch({error, {_, _, [&quot;-x&quot;], &lt;&lt;&quot;expected argument&quot;&gt;&gt;}},
<a name="468"/>  468:         parse_opts([&quot;-s -x&quot;], Opts2)),
<a name="469"/>  469:     %% error when positional has nargs = nonempty_list or pos_integer
<a name="470"/>  470:     ?assertMatch({error, {_, _, undefined, &lt;&lt;&gt;&gt;}},
<a name="471"/>  471:         parse_opts([&quot;&quot;], [#{name =&gt; req, nargs =&gt; nonempty_list}])),
<a name="472"/>  472:     %% positional arguments consumption: one or more positional argument
<a name="473"/>  473:     OptsPos1 = #{arguments =&gt; [
<a name="474"/>  474:         #{name =&gt; arg, nargs =&gt; nonempty_list},
<a name="475"/>  475:         #{name =&gt; extra, short =&gt; $x}
<a name="476"/>  476:     ]},
<a name="477"/>  477:     ?assertEqual({ok, #{extra =&gt; &quot;X&quot;, arg =&gt; [&quot;b&quot;,&quot;c&quot;]}, Prog, OptsPos1},
<a name="478"/>  478:         parse([&quot;-x port -x a b c -x X&quot;], OptsPos1)),
<a name="479"/>  479:     %% positional arguments consumption, any number (maybe zero)
<a name="480"/>  480:     OptsPos2 = #{arguments =&gt; [
<a name="481"/>  481:         #{name =&gt; arg, nargs =&gt; list},
<a name="482"/>  482:         #{name =&gt; extra, short =&gt; $x}
<a name="483"/>  483:     ]},
<a name="484"/>  484:     ?assertEqual({ok, #{extra =&gt; &quot;X&quot;, arg =&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]}, Prog, OptsPos2},
<a name="485"/>  485:         parse([&quot;-x port a b c -x X&quot;], OptsPos2)),
<a name="486"/>  486:     %% positional: consume ALL arguments!
<a name="487"/>  487:     OptsAll = #{arguments =&gt; [
<a name="488"/>  488:         #{name =&gt; arg, nargs =&gt; all},
<a name="489"/>  489:         #{name =&gt; extra, short =&gt; $x}
<a name="490"/>  490:     ]},
<a name="491"/>  491:     ?assertEqual({ok, #{extra =&gt; &quot;port&quot;, arg =&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;, &quot;-x&quot;, &quot;X&quot;]}, Prog, OptsAll},
<a name="492"/>  492:         parse([&quot;-x port a b c -x X&quot;], OptsAll)),
<a name="493"/>  493:     %% maybe with a specified default
<a name="494"/>  494:     OptMaybe = [
<a name="495"/>  495:         #{name =&gt; foo, long =&gt; &quot;-foo&quot;, nargs =&gt; {'maybe', c}, default =&gt; d},
<a name="496"/>  496:         #{name =&gt; bar, nargs =&gt; 'maybe', default =&gt; d}
<a name="497"/>  497:     ],
<a name="498"/>  498:     ?assertMatch({ok, #{foo := &quot;YY&quot;, bar := &quot;XX&quot;}, Prog, _},
<a name="499"/>  499:         parse_opts([&quot;XX --foo YY&quot;], OptMaybe)),
<a name="500"/>  500:     ?assertMatch({ok, #{foo := c, bar := &quot;XX&quot;}, Prog, _},
<a name="501"/>  501:         parse_opts([&quot;XX --foo&quot;], OptMaybe)),
<a name="502"/>  502:     ?assertMatch({ok, #{foo := d, bar := d}, Prog, _},
<a name="503"/>  503:         parse_opts([&quot;&quot;], OptMaybe)),
<a name="504"/>  504:     %% maybe with default provided by argparse
<a name="505"/>  505:     ?assertMatch({ok, #{foo := d, bar := &quot;XX&quot;, baz := ok}, _, _},
<a name="506"/>  506:         parse_opts([&quot;XX -b&quot;], [#{name =&gt; baz, nargs =&gt; 'maybe', short =&gt; $b, default =&gt; ok} | OptMaybe])),
<a name="507"/>  507:     %% maybe arg - with no default given
<a name="508"/>  508:     ?assertMatch({ok, #{foo := d, bar := &quot;XX&quot;, baz := 0}, _, _},
<a name="509"/>  509:         parse_opts([&quot;XX -b&quot;], [#{name =&gt; baz, nargs =&gt; 'maybe', short =&gt; $b, type =&gt; integer} | OptMaybe])),
<a name="510"/>  510:     ?assertMatch({ok, #{foo := d, bar := &quot;XX&quot;, baz := &quot;&quot;}, _, _},
<a name="511"/>  511:         parse_opts([&quot;XX -b&quot;], [#{name =&gt; baz, nargs =&gt; 'maybe', short =&gt; $b, type =&gt; string} | OptMaybe])),
<a name="512"/>  512:     ?assertMatch({ok, #{foo := d, bar := &quot;XX&quot;, baz := undefined}, _, _},
<a name="513"/>  513:         parse_opts([&quot;XX -b&quot;], [#{name =&gt; baz, nargs =&gt; 'maybe', short =&gt; $b, type =&gt; atom} | OptMaybe])),
<a name="514"/>  514:     ?assertMatch({ok, #{foo := d, bar := &quot;XX&quot;, baz := &lt;&lt;&quot;&quot;&gt;&gt;}, _, _},
<a name="515"/>  515:         parse_opts([&quot;XX -b&quot;], [#{name =&gt; baz, nargs =&gt; 'maybe', short =&gt; $b, type =&gt; binary} | OptMaybe])),
<a name="516"/>  516:     %% nargs: optional list, yet it still needs to be 'not required'!
<a name="517"/>  517:     OptList = [#{name =&gt; arg, nargs =&gt; list, required =&gt; false, type =&gt; integer}],
<a name="518"/>  518:     ?assertEqual({ok, #{}, Prog, #{arguments =&gt; OptList}}, parse_opts(&quot;&quot;, OptList)),
<a name="519"/>  519:     %% tests that action &quot;count&quot; with nargs &quot;maybe&quot; counts two times, first time
<a name="520"/>  520:     %% consuming an argument (for &quot;maybe&quot;), second time just counting
<a name="521"/>  521:     Cmd = #{arguments =&gt; [
<a name="522"/>  522:         #{name =&gt; short49, short =&gt; $1, long =&gt; &quot;-force&quot;, action =&gt; count, nargs =&gt; 'maybe'}]},
<a name="nargs-last_expr"/><a name="523"/>  523: <b>    ?assertEqual</b>({ok, #{short49 =&gt; 2}, Prog, Cmd},
<a name="524"/>  524:         parse(&quot;-1 arg1 --force&quot;, Cmd)).
<a name="525"/>  525: 
<a name="argparse-0"/><a name="526"/>  526: <b>argparse</b>() -&gt;
<a name="argparse-last_expr"/><a name="527"/>  527:     [{doc, &quot;Tests success cases, inspired by argparse in Python&quot;}].
<a name="528"/>  528: 
<a name="argparse-1"/><a name="529"/>  529: <b>argparse</b>(Config) when is_list(Config) -&gt;
<a name="530"/>  530:     Prog = [prog()],
<a name="531"/>  531:     Parser = #{arguments =&gt; [
<a name="532"/>  532:         #{name =&gt; sum, long =&gt; &quot;-sum&quot;, action =&gt; {store, sum}, default =&gt; max},
<a name="533"/>  533:         #{name =&gt; integers, type =&gt; integer, nargs =&gt; nonempty_list}
<a name="534"/>  534:         ]},
<a name="535"/>  535:     ?assertEqual({ok, #{integers =&gt; [1, 2, 3, 4], sum =&gt; max}, Prog, Parser},
<a name="536"/>  536:         parse(&quot;1 2 3 4&quot;, Parser)),
<a name="537"/>  537:     ?assertEqual({ok, #{integers =&gt; [1, 2, 3, 4], sum =&gt; sum}, Prog, Parser},
<a name="538"/>  538:         parse(&quot;1 2 3 4 --sum&quot;, Parser)),
<a name="539"/>  539:     ?assertEqual({ok, #{integers =&gt; [7, -1, 42], sum =&gt; sum}, Prog, Parser},
<a name="540"/>  540:         parse(&quot;--sum 7 -1 42&quot;, Parser)),
<a name="541"/>  541:     %% name or flags
<a name="542"/>  542:     Parser2 = #{arguments =&gt; [
<a name="543"/>  543:         #{name =&gt; bar, required =&gt; true},
<a name="544"/>  544:         #{name =&gt; foo, short =&gt; $f, long =&gt; &quot;-foo&quot;}
<a name="545"/>  545:     ]},
<a name="546"/>  546:     ?assertEqual({ok, #{bar =&gt; &quot;BAR&quot;}, Prog, Parser2}, parse(&quot;BAR&quot;, Parser2)),
<a name="547"/>  547:     ?assertEqual({ok, #{bar =&gt; &quot;BAR&quot;, foo =&gt; &quot;FOO&quot;}, Prog, Parser2}, parse(&quot;BAR --foo FOO&quot;, Parser2)),
<a name="548"/>  548:     %PROG: error: the following arguments are required: bar
<a name="549"/>  549:     ?assertMatch({error, {Prog, _, undefined, &lt;&lt;&gt;&gt;}}, parse(&quot;--foo FOO&quot;, Parser2)),
<a name="550"/>  550:     %% action tests: default
<a name="551"/>  551:     ?assertMatch({ok, #{foo := &quot;1&quot;}, Prog, _},
<a name="552"/>  552:         parse(&quot;--foo 1&quot;, #{arguments =&gt; [#{name =&gt; foo, long =&gt; &quot;-foo&quot;}]})),
<a name="553"/>  553:     %% action test: store
<a name="554"/>  554:     ?assertMatch({ok, #{foo := 42}, Prog, _},
<a name="555"/>  555:         parse(&quot;--foo&quot;, #{arguments =&gt; [#{name =&gt; foo, long =&gt; &quot;-foo&quot;, action =&gt; {store, 42}}]})),
<a name="556"/>  556:     %% action tests: boolean (variants)
<a name="557"/>  557:     ?assertMatch({ok, #{foo := true}, Prog, _},
<a name="558"/>  558:         parse(&quot;--foo&quot;, #{arguments =&gt; [#{name =&gt; foo, long =&gt; &quot;-foo&quot;, action =&gt; {store, true}}]})),
<a name="559"/>  559:     ?assertMatch({ok, #{foo := 42}, Prog, _},
<a name="560"/>  560:         parse(&quot;--foo&quot;, #{arguments =&gt; [#{name =&gt; foo, long =&gt; &quot;-foo&quot;, type =&gt; boolean, action =&gt; {store, 42}}]})),
<a name="561"/>  561:     ?assertMatch({ok, #{foo := true}, Prog, _},
<a name="562"/>  562:         parse(&quot;--foo&quot;, #{arguments =&gt; [#{name =&gt; foo, long =&gt; &quot;-foo&quot;, type =&gt; boolean}]})),
<a name="563"/>  563:     ?assertMatch({ok, #{foo := true}, Prog, _},
<a name="564"/>  564:         parse(&quot;--foo true&quot;, #{arguments =&gt; [#{name =&gt; foo, long =&gt; &quot;-foo&quot;, type =&gt; boolean}]})),
<a name="565"/>  565:     ?assertMatch({ok, #{foo := false}, Prog, _},
<a name="566"/>  566:         parse(&quot;--foo false&quot;, #{arguments =&gt; [#{name =&gt; foo, long =&gt; &quot;-foo&quot;, type =&gt; boolean}]})),
<a name="567"/>  567:     %% action tests: append &amp; append_const
<a name="568"/>  568:     ?assertMatch({ok, #{all := [1, &quot;1&quot;]}, Prog, _},
<a name="569"/>  569:         parse(&quot;--x 1 -x 1&quot;, #{arguments =&gt; [
<a name="570"/>  570:             #{name =&gt; all, long =&gt; &quot;-x&quot;, type =&gt; integer, action =&gt; append},
<a name="571"/>  571:             #{name =&gt; all, short =&gt; $x, action =&gt; append}]})),
<a name="572"/>  572:     ?assertMatch({ok, #{all := [&quot;Z&quot;, 2]}, Prog, _},
<a name="573"/>  573:         parse(&quot;--x -x&quot;, #{arguments =&gt; [
<a name="574"/>  574:             #{name =&gt; all, long =&gt; &quot;-x&quot;, action =&gt; {append, &quot;Z&quot;}},
<a name="575"/>  575:             #{name =&gt; all, short =&gt; $x, action =&gt; {append, 2}}]})),
<a name="576"/>  576:     %% count:
<a name="argparse-last_expr"/><a name="577"/>  577: <b>    ?assertMatch</b>({ok, #{v := 3}, Prog, _},
<a name="578"/>  578:         parse(&quot;-v -v -v&quot;, #{arguments =&gt; [#{name =&gt; v, short =&gt; $v, action =&gt; count}]})).
<a name="579"/>  579: 
<a name="negative-0"/><a name="580"/>  580: <b>negative</b>() -&gt;
<a name="negative-last_expr"/><a name="581"/>  581:     [{doc, &quot;Test negative number parser&quot;}].
<a name="582"/>  582: 
<a name="negative-1"/><a name="583"/>  583: <b>negative</b>(Config) when is_list(Config) -&gt;
<a name="584"/>  584:     Parser = #{arguments =&gt; [
<a name="585"/>  585:         #{name =&gt; x, short =&gt; $x, type =&gt; integer, action =&gt; store},
<a name="586"/>  586:         #{name =&gt; foo, nargs =&gt; 'maybe', required =&gt; false}
<a name="587"/>  587:     ]},
<a name="588"/>  588:     ?assertMatch({ok, #{x := -1}, _, _}, parse(&quot;-x -1&quot;, Parser)),
<a name="589"/>  589:     ?assertMatch({ok, #{x := -1, foo := &quot;-5&quot;}, _, _}, parse(&quot;-x -1 -5&quot;, Parser)),
<a name="590"/>  590:     %%
<a name="591"/>  591:     Parser2 = #{arguments =&gt; [
<a name="592"/>  592:         #{name =&gt; one, short =&gt; $1},
<a name="593"/>  593:         #{name =&gt; foo, nargs =&gt; 'maybe', required =&gt; false}
<a name="594"/>  594:     ]},
<a name="595"/>  595: 
<a name="596"/>  596:     %% negative number options present, so -1 is an option
<a name="597"/>  597:     ?assertMatch({ok, #{one := &quot;X&quot;}, _, _}, parse(&quot;-1 X&quot;, Parser2)),
<a name="598"/>  598:     %% negative number options present, so -2 is an option
<a name="599"/>  599:     ?assertMatch({error, {_, undefined, &quot;-2&quot;, _}}, parse(&quot;-2&quot;, Parser2)),
<a name="600"/>  600: 
<a name="601"/>  601:     %% negative number options present, so both -1s are options
<a name="602"/>  602:     ?assertMatch({error, {_, _, undefined, _}}, parse(&quot;-1 -1&quot;, Parser2)),
<a name="603"/>  603:     %% no &quot;-&quot; prefix, can only be an integer
<a name="604"/>  604:     ?assertMatch({ok, #{foo := &quot;-1&quot;}, _, _}, argparse:parse([&quot;-1&quot;], Parser2, #{prefixes =&gt; &quot;+&quot;})),
<a name="605"/>  605:     %% no &quot;-&quot; prefix, can only be an integer, but just one integer!
<a name="606"/>  606:     ?assertMatch({error, {_, undefined, &quot;-1&quot;, _}},
<a name="607"/>  607:         argparse:parse([&quot;-2&quot;, &quot;-1&quot;], Parser2, #{prefixes =&gt; &quot;+&quot;})),
<a name="608"/>  608:     %% just in case, floats work that way too...
<a name="negative-last_expr"/><a name="609"/>  609: <b>    ?assertMatch</b>({error, {_, undefined, &quot;-2&quot;, _}},
<a name="610"/>  610:         parse(&quot;-2&quot;, #{arguments =&gt; [#{name =&gt; one, long =&gt; &quot;1.2&quot;}]})).
<a name="611"/>  611: 
<a name="nodigits-0"/><a name="612"/>  612: <b>nodigits</b>() -&gt;
<a name="nodigits-last_expr"/><a name="613"/>  613:     [{doc, &quot;Test prefixes and negative numbers together&quot;}].
<a name="614"/>  614: 
<a name="nodigits-1"/><a name="615"/>  615: <b>nodigits</b>(Config) when is_list(Config) -&gt;
<a name="616"/>  616:     %% verify nodigits working as expected
<a name="617"/>  617:     Parser3 = #{arguments =&gt; [
<a name="618"/>  618:         #{name =&gt; extra, short =&gt; $3},
<a name="619"/>  619:         #{name =&gt; arg, nargs =&gt; list}
<a name="620"/>  620:     ]},
<a name="621"/>  621:     %% ensure not to consume optional prefix
<a name="nodigits-last_expr"/><a name="622"/>  622: <b>    ?assertEqual</b>({ok, #{extra =&gt; &quot;X&quot;, arg =&gt; [&quot;a&quot;,&quot;b&quot;,&quot;3&quot;]}, [prog()], Parser3},
<a name="623"/>  623:         argparse:parse(string:lexemes(&quot;-3 port a b 3 +3 X&quot;, &quot; &quot;), Parser3, #{prefixes =&gt; &quot;-+&quot;})).
<a name="624"/>  624: 
<a name="pos_mixed_with_opt-0"/><a name="625"/>  625: <b>pos_mixed_with_opt</b>() -&gt;
<a name="pos_mixed_with_opt-last_expr"/><a name="626"/>  626:     [{doc, &quot;Tests that optional argument correctly consumes expected argument&quot;
<a name="627"/>  627:         &quot;inspired by https://github.com/python/cpython/issues/59317&quot;}].
<a name="628"/>  628: 
<a name="pos_mixed_with_opt-1"/><a name="629"/>  629: <b>pos_mixed_with_opt</b>(Config) when is_list(Config) -&gt;
<a name="630"/>  630:     Parser = #{arguments =&gt; [
<a name="631"/>  631:         #{name =&gt; pos},
<a name="632"/>  632:         #{name =&gt; opt, default =&gt; 24, type =&gt; integer, long =&gt; &quot;-opt&quot;},
<a name="633"/>  633:         #{name =&gt; vars, nargs =&gt; list}
<a name="634"/>  634:     ]},
<a name="pos_mixed_with_opt-last_expr"/><a name="635"/>  635: <b>    ?assertEqual</b>({ok, #{pos =&gt; &quot;1&quot;, opt =&gt; 8, vars =&gt; [&quot;8&quot;, &quot;9&quot;]}, [prog()], Parser},
<a name="636"/>  636:         parse(&quot;1 2 --opt 8 8 9&quot;, Parser)).
<a name="637"/>  637: 
<a name="default_for_not_required-0"/><a name="638"/>  638: <b>default_for_not_required</b>() -&gt;
<a name="default_for_not_required-last_expr"/><a name="639"/>  639:     [{doc, &quot;Tests that default value is used for non-required positional argument&quot;}].
<a name="640"/>  640: 
<a name="default_for_not_required-1"/><a name="641"/>  641: <b>default_for_not_required</b>(Config) when is_list(Config) -&gt;
<a name="642"/>  642:     ?assertMatch({ok, #{def := 1}, _, _},
<a name="643"/>  643:         parse(&quot;&quot;, #{arguments =&gt; [#{name =&gt; def, short =&gt; $d, required =&gt; false, default =&gt; 1}]})),
<a name="default_for_not_required-last_expr"/><a name="644"/>  644: <b>    ?assertMatch</b>({ok, #{def := 1}, _, _},
<a name="645"/>  645:         parse(&quot;&quot;, #{arguments =&gt; [#{name =&gt; def, required =&gt; false, default =&gt; 1}]})).
<a name="646"/>  646: 
<a name="global_default-0"/><a name="647"/>  647: <b>global_default</b>() -&gt;
<a name="global_default-last_expr"/><a name="648"/>  648:     [{doc, &quot;Tests that a global default can be enabled for all non-required arguments&quot;}].
<a name="649"/>  649: 
<a name="global_default-1"/><a name="650"/>  650: <b>global_default</b>(Config) when is_list(Config) -&gt;
<a name="global_default-last_expr"/><a name="651"/>  651: <b>    ?assertMatch</b>({ok, #{def := &quot;global&quot;}, _, _},
<a name="652"/>  652:         argparse:parse(&quot;&quot;, #{arguments =&gt; [#{name =&gt; def, type =&gt; integer, required =&gt; false}]},
<a name="653"/>  653:         #{default =&gt; &quot;global&quot;})).
<a name="654"/>  654: 
<a name="subcommand-0"/><a name="655"/>  655: <b>subcommand</b>() -&gt;
<a name="subcommand-last_expr"/><a name="656"/>  656:     [{doc, &quot;Tests subcommands parser&quot;}].
<a name="657"/>  657: 
<a name="subcommand-1"/><a name="658"/>  658: <b>subcommand</b>(Config) when is_list(Config) -&gt;
<a name="659"/>  659:     TwoCmd = #{arguments =&gt; [#{name =&gt; bar}]},
<a name="660"/>  660:     Cmd = #{
<a name="661"/>  661:         arguments =&gt; [#{name =&gt; force, type =&gt; boolean, short =&gt; $f}],
<a name="662"/>  662:         commands =&gt; #{&quot;one&quot; =&gt; #{
<a name="663"/>  663:             arguments =&gt; [#{name =&gt; foo, type =&gt; boolean, long =&gt; &quot;-foo&quot;}, #{name =&gt; baz}],
<a name="664"/>  664:             commands =&gt; #{
<a name="665"/>  665:                 &quot;two&quot; =&gt; TwoCmd}}}},
<a name="666"/>  666:     ?assertEqual({ok, #{force =&gt; true, baz =&gt; &quot;N1O1O&quot;, foo =&gt; true, bar =&gt; &quot;bar&quot;}, [prog(), &quot;one&quot;, &quot;two&quot;], TwoCmd},
<a name="667"/>  667:         parse(&quot;one N1O1O -f two --foo bar&quot;, Cmd)),
<a name="668"/>  668:     %% it is an error not to choose subcommand
<a name="subcommand-last_expr"/><a name="669"/>  669: <b>    ?assertEqual</b>({error, {[prog(), &quot;one&quot;], undefined, undefined, &lt;&lt;&quot;subcommand expected&quot;&gt;&gt;}},
<a name="670"/>  670:         parse(&quot;one N1O1O -f&quot;, Cmd)).
<a name="671"/>  671: 
<a name="very_short-0"/><a name="672"/>  672: <b>very_short</b>() -&gt;
<a name="very_short-last_expr"/><a name="673"/>  673:     [{doc, &quot;Tests short option appended to the optional itself&quot;}].
<a name="674"/>  674: 
<a name="very_short-1"/><a name="675"/>  675: <b>very_short</b>(Config) when is_list(Config) -&gt;
<a name="very_short-last_expr"/><a name="676"/>  676: <b>    ?assertMatch</b>({ok, #{x := &quot;V&quot;}, _, _},
<a name="677"/>  677:         parse(&quot;-xV&quot;, #{arguments =&gt; [#{name =&gt; x, short =&gt; $x}]})).
<a name="678"/>  678: 
<a name="multi_short-0"/><a name="679"/>  679: <b>multi_short</b>() -&gt;
<a name="multi_short-last_expr"/><a name="680"/>  680:     [{doc, &quot;Tests multiple short arguments blend into one&quot;}].
<a name="681"/>  681: 
<a name="multi_short-1"/><a name="682"/>  682: <b>multi_short</b>(Config) when is_list(Config) -&gt;
<a name="683"/>  683:     %% ensure non-flammable argument does not explode, even when it's possible
<a name="684"/>  684:     ?assertMatch({ok, #{v := &quot;xv&quot;}, _, _},
<a name="685"/>  685:         parse(&quot;-vxv&quot;, #{arguments =&gt; [#{name =&gt; v, short =&gt; $v}, #{name =&gt; x, short =&gt; $x}]})),
<a name="686"/>  686:     %% ensure 'verbosity' use-case works
<a name="687"/>  687:     ?assertMatch({ok, #{v := 3}, _, _},
<a name="688"/>  688:         parse(&quot;-vvv&quot;, #{arguments =&gt; [#{name =&gt; v, short =&gt; $v, action =&gt; count}]})),
<a name="689"/>  689:     %%
<a name="multi_short-last_expr"/><a name="690"/>  690: <b>    ?assertMatch</b>({ok, #{recursive := true, force := true, path := &quot;dir&quot;}, _, _},
<a name="691"/>  691:         parse(&quot;-rf dir&quot;, #{arguments =&gt; [
<a name="692"/>  692:             #{name =&gt; recursive, short =&gt; $r, type =&gt; boolean},
<a name="693"/>  693:             #{name =&gt; force, short =&gt; $f, type =&gt; boolean},
<a name="694"/>  694:             #{name =&gt; path}
<a name="695"/>  695:             ]})).
<a name="696"/>  696: 
<a name="proxy_arguments-0"/><a name="697"/>  697: <b>proxy_arguments</b>() -&gt;
<a name="proxy_arguments-last_expr"/><a name="698"/>  698:     [{doc, &quot;Tests nargs =&gt; all used to proxy arguments to another script&quot;}].
<a name="699"/>  699: 
<a name="proxy_arguments-1"/><a name="700"/>  700: <b>proxy_arguments</b>(Config) when is_list(Config) -&gt;
<a name="701"/>  701:     Cmd = #{
<a name="702"/>  702:         commands =&gt; #{
<a name="703"/>  703:             &quot;start&quot; =&gt; #{
<a name="704"/>  704:                 arguments =&gt; [
<a name="705"/>  705:                     #{name =&gt; shell, short =&gt; $s, long =&gt; &quot;-shell&quot;, type =&gt; boolean},
<a name="706"/>  706:                     #{name =&gt; skip, short =&gt; $x, long =&gt; &quot;-skip&quot;, type =&gt; boolean},
<a name="707"/>  707:                     #{name =&gt; args, required =&gt; false, nargs =&gt; all}
<a name="708"/>  708:                 ]
<a name="709"/>  709:             },
<a name="710"/>  710:             &quot;stop&quot; =&gt; #{},
<a name="711"/>  711:             &quot;status&quot; =&gt; #{
<a name="712"/>  712:                 arguments =&gt; [
<a name="713"/>  713:                     #{name =&gt; skip, required =&gt; false, default =&gt; &quot;ok&quot;},
<a name="714"/>  714:                     #{name =&gt; args, required =&gt; false, nargs =&gt; all}
<a name="715"/>  715:                 ]},
<a name="716"/>  716:             &quot;state&quot; =&gt; #{
<a name="717"/>  717:                 arguments =&gt; [
<a name="718"/>  718:                     #{name =&gt; skip, required =&gt; false},
<a name="719"/>  719:                     #{name =&gt; args, required =&gt; false, nargs =&gt; all}
<a name="720"/>  720:                 ]}
<a name="721"/>  721:         },
<a name="722"/>  722:         arguments =&gt; [
<a name="723"/>  723:             #{name =&gt; node}
<a name="724"/>  724:         ],
<a name="725"/>  725:         handler =&gt; fun (#{}) -&gt; ok end
<a name="726"/>  726:     },
<a name="727"/>  727:     Prog = prog(),
<a name="728"/>  728:     ?assertMatch({ok, #{node := &quot;node1&quot;}, _, _}, parse(&quot;node1&quot;, Cmd)),
<a name="729"/>  729:     ?assertMatch({ok, #{node := &quot;node1&quot;}, [Prog, &quot;stop&quot;], #{}}, parse(&quot;node1 stop&quot;, Cmd)),
<a name="730"/>  730:     ?assertMatch({ok, #{node := &quot;node2.org&quot;, shell := true, skip := true}, _, _}, parse(&quot;node2.org start -x -s&quot;, Cmd)),
<a name="731"/>  731:     ?assertMatch({ok, #{args := [&quot;-app&quot;,&quot;key&quot;,&quot;value&quot;],node := &quot;node1.org&quot;}, [Prog, &quot;start&quot;], _},
<a name="732"/>  732:         parse(&quot;node1.org start -app key value&quot;, Cmd)),
<a name="733"/>  733:     ?assertMatch({ok, #{args := [&quot;-app&quot;,&quot;key&quot;,&quot;value&quot;, &quot;-app2&quot;, &quot;key2&quot;, &quot;value2&quot;],
<a name="734"/>  734:         node := &quot;node3.org&quot;, shell := true}, [Prog, &quot;start&quot;], _},
<a name="735"/>  735:         parse(&quot;node3.org start -s -app key value -app2 key2 value2&quot;, Cmd)),
<a name="736"/>  736:     %% test that any non-required positionals are skipped
<a name="737"/>  737:     ?assertMatch({ok, #{args := [&quot;-a&quot;,&quot;bcd&quot;], node := &quot;node2.org&quot;, skip := &quot;ok&quot;}, _, _}, parse(&quot;node2.org status -a bcd&quot;, Cmd)),
<a name="proxy_arguments-last_expr"/><a name="738"/>  738: <b>    ?assertMatch</b>({ok, #{args := [&quot;-app&quot;, &quot;key&quot;], node := &quot;node2.org&quot;}, _, _}, parse(&quot;node2.org state -app key&quot;, Cmd)).
<a name="739"/>  739: 
<a name="740"/>  740: <i>%%--------------------------------------------------------------------</i>
<a name="741"/>  741: <i>%% Usage Test Cases</i>
<a name="742"/>  742: 
<a name="usage-0"/><a name="743"/>  743: <b>usage</b>() -&gt;
<a name="usage-last_expr"/><a name="744"/>  744:     [{doc, &quot;Basic tests for help formatter, including 'hidden' help&quot;}].
<a name="745"/>  745: 
<a name="usage-1"/><a name="746"/>  746: <b>usage</b>(Config) when is_list(Config) -&gt;
<a name="747"/>  747:     Cmd = ubiq_cmd(),
<a name="748"/>  748:     Usage = &quot;Usage:\n&quot;
<a name="749"/>  749:         &quot;  erl start {crawler|doze} [-rfvl] [--force] [-i &lt;interval&gt;] [--req &lt;weird&gt;]\n&quot;
<a name="750"/>  750:         &quot;      [--float &lt;float&gt;] [-s &lt;shard&gt;...] [-z &lt;z&gt;] [-m &lt;more&gt;] [-b &lt;bin&gt;] [-g &lt;g&gt;]\n&quot;
<a name="751"/>  751:         &quot;      [-t &lt;t&gt;] ---maybe-req -y &lt;y&gt; --yyy &lt;y&gt; [-u &lt;u&gt;] [-c &lt;choice&gt;] [-q &lt;fc&gt;]\n&quot;
<a name="752"/>  752:         &quot;      [-w &lt;ac&gt;] [--unsafe &lt;au&gt;] [--safe &lt;as&gt;] [-foobar &lt;long&gt;] &lt;server&gt; [&lt;optpos&gt;]\n&quot;
<a name="753"/>  753:         &quot;\n&quot;
<a name="754"/>  754:         &quot;Subcommands:\n&quot;
<a name="755"/>  755:         &quot;  crawler      controls crawler behaviour\n&quot;
<a name="756"/>  756:         &quot;  doze         dozes a bit\n\n&quot;
<a name="757"/>  757:         &quot;Arguments:\n&quot;
<a name="758"/>  758:         &quot;  server       server to start\n&quot;
<a name="759"/>  759:         &quot;  optpos       optional positional (int)\n\n&quot;
<a name="760"/>  760:         &quot;Optional arguments:\n&quot;
<a name="761"/>  761:         &quot;  -r           recursive\n&quot;
<a name="762"/>  762:         &quot;  -f, --force  force\n&quot;
<a name="763"/>  763:         &quot;  -v           verbosity level\n&quot;
<a name="764"/>  764:         &quot;  -i           interval set (int &gt;= 1)\n&quot;
<a name="765"/>  765:         &quot;  --req        required optional, right?\n&quot;
<a name="766"/>  766:         &quot;  --float      floating-point long form argument (float), default: 3.14\n&quot;
<a name="767"/>  767:         &quot;  -s           initial shards (int)\n&quot;
<a name="768"/>  768:         &quot;  -z           between (1 &lt;= int &lt;= 10)\n&quot;
<a name="769"/>  769:         &quot;  -l           maybe lower (int &lt;= 10)\n&quot;
<a name="770"/>  770:         &quot;  -m           less than 10 (int &lt;= 10)\n&quot;
<a name="771"/>  771:         &quot;  -b           binary with re (binary re: m)\n&quot;
<a name="772"/>  772:         &quot;  -g           binary with re (binary re: m)\n&quot;
<a name="773"/>  773:         &quot;  -t           string with re (string re: m)\n&quot;
<a name="774"/>  774:         &quot;  ---maybe-req maybe required int (int)\n&quot;
<a name="775"/>  775:         &quot;  -y, --yyy    string with re (string re: m)\n&quot;
<a name="776"/>  776:         &quot;  -u           string choices (choice: 1, 2)\n&quot;
<a name="777"/>  777:         &quot;  -c           tough choice (choice: 1, 2, 3)\n&quot;
<a name="778"/>  778:         &quot;  -q           floating choice (choice: 2.10000, 1.20000)\n&quot;
<a name="779"/>  779:         &quot;  -w           atom choice (choice: one, two)\n&quot;
<a name="780"/>  780:         &quot;  --unsafe     unsafe atom (atom)\n&quot;
<a name="781"/>  781:         &quot;  --safe       safe atom (existing atom)\n&quot;
<a name="782"/>  782:         &quot;  -foobar      foobaring option\n&quot;,
<a name="783"/>  783:     ?assertEqual(Usage, unicode:characters_to_list(argparse:help(Cmd,
<a name="784"/>  784:         #{progname =&gt; &quot;erl&quot;, command =&gt; [&quot;start&quot;]}))),
<a name="785"/>  785:     FullCmd = &quot;Usage:\n  erl&quot;
<a name="786"/>  786:         &quot; &lt;command&gt; [-rfv] [--force] [-i &lt;interval&gt;] [--req &lt;weird&gt;] [--float &lt;float&gt;]\n\n&quot;
<a name="787"/>  787:         &quot;Subcommands:\n&quot;
<a name="788"/>  788:         &quot;  start       verifies configuration and starts server\n&quot;
<a name="789"/>  789:         &quot;  status      prints server status\n&quot;
<a name="790"/>  790:         &quot;  stop        stops running server\n\n&quot;
<a name="791"/>  791:         &quot;Optional arguments:\n&quot;
<a name="792"/>  792:         &quot;  -r          recursive\n&quot;
<a name="793"/>  793:         &quot;  -f, --force force\n&quot;
<a name="794"/>  794:         &quot;  -v          verbosity level\n&quot;
<a name="795"/>  795:         &quot;  -i          interval set (int &gt;= 1)\n&quot;
<a name="796"/>  796:         &quot;  --req       required optional, right?\n&quot;
<a name="797"/>  797:         &quot;  --float     floating-point long form argument (float), default: 3.14\n&quot;,
<a name="798"/>  798:     ?assertEqual(FullCmd, unicode:characters_to_list(argparse:help(Cmd,
<a name="799"/>  799:         #{progname =&gt; erl}))),
<a name="800"/>  800:     CrawlerStatus = &quot;Usage:\n  erl status crawler [-rfv] [--force] [-i &lt;interval&gt;] [--req &lt;weird&gt;]\n&quot;
<a name="801"/>  801:         &quot;      [--float &lt;float&gt;] [---extra &lt;extra&gt;]\n\n&quot;
<a name="802"/>  802:         &quot;Optional arguments:\n&quot;
<a name="803"/>  803:         &quot;  -r          recursive\n&quot;
<a name="804"/>  804:         &quot;  -f, --force force\n&quot;
<a name="805"/>  805:         &quot;  -v          verbosity level\n&quot;
<a name="806"/>  806:         &quot;  -i          interval set (int &gt;= 1)\n&quot;
<a name="807"/>  807:         &quot;  --req       required optional, right?\n&quot;
<a name="808"/>  808:         &quot;  --float     floating-point long form argument (float), default: 3.14\n&quot;
<a name="809"/>  809:         &quot;  ---extra    extra option very deep\n&quot;,
<a name="810"/>  810:     ?assertEqual(CrawlerStatus, unicode:characters_to_list(argparse:help(Cmd,
<a name="811"/>  811:         #{progname =&gt; &quot;erl&quot;, command =&gt; [&quot;status&quot;, &quot;crawler&quot;]}))),
<a name="usage-last_expr"/><a name="812"/>  812:     ok.
<a name="813"/>  813: 
<a name="usage_required_args-0"/><a name="814"/>  814: <b>usage_required_args</b>() -&gt;
<a name="usage_required_args-last_expr"/><a name="815"/>  815:     [{doc, &quot;Verify that required args are printed as required in usage&quot;}].
<a name="816"/>  816: 
<a name="usage_required_args-1"/><a name="817"/>  817: <b>usage_required_args</b>(Config) when is_list(Config) -&gt;
<a name="818"/>  818:     Cmd = #{commands =&gt; #{&quot;test&quot; =&gt; #{arguments =&gt; [#{name =&gt; required, required =&gt; true, long =&gt; &quot;-req&quot;}]}}},
<a name="819"/>  819:     Expected = &quot;Usage:\n  &quot; ++ prog() ++ &quot; test --req &lt;required&gt;\n\nOptional arguments:\n  --req required\n&quot;,
<a name="usage_required_args-last_expr"/><a name="820"/>  820: <b>    ?assertEqual</b>(Expected, unicode:characters_to_list(argparse:help(Cmd, #{command =&gt; [&quot;test&quot;]}))).
<a name="821"/>  821: 
<a name="usage_template-0"/><a name="822"/>  822: <b>usage_template</b>() -&gt;
<a name="usage_template-last_expr"/><a name="823"/>  823:     [{doc, &quot;Tests templates in help/usage&quot;}].
<a name="824"/>  824: 
<a name="usage_template-1"/><a name="825"/>  825: <b>usage_template</b>(Config) when is_list(Config) -&gt;
<a name="826"/>  826:     %% Argument (positional)
<a name="827"/>  827:     Cmd = #{arguments =&gt; [#{
<a name="828"/>  828:         name =&gt; shard,
<a name="829"/>  829:         type =&gt; integer,
<a name="830"/>  830:         default =&gt; 0,
<a name="831"/>  831:         help =&gt; {&quot;[-s SHARD]&quot;, [&quot;initial number, &quot;, type, &lt;&lt;&quot; with a default value of &quot;&gt;&gt;, default]}}
<a name="832"/>  832:     ]},
<a name="833"/>  833:     ?assertEqual(&quot;Usage:\n  &quot; ++ prog() ++ &quot; [-s SHARD]\n\nArguments:\n  shard initial number, int with a default value of 0\n&quot;,
<a name="834"/>  834:         unicode:characters_to_list(argparse:help(Cmd, #{}))),
<a name="835"/>  835:     %% Optional
<a name="836"/>  836:     Cmd1 = #{arguments =&gt; [#{
<a name="837"/>  837:         name =&gt; shard,
<a name="838"/>  838:         short =&gt; $s,
<a name="839"/>  839:         type =&gt; integer,
<a name="840"/>  840:         default =&gt; 0,
<a name="841"/>  841:         help =&gt; {&lt;&lt;&quot;[-s SHARD]&quot;&gt;&gt;, [&quot;initial number&quot;]}}
<a name="842"/>  842:     ]},
<a name="843"/>  843:     ?assertEqual(&quot;Usage:\n  &quot; ++ prog() ++ &quot; [-s SHARD]\n\nOptional arguments:\n  -s initial number\n&quot;,
<a name="844"/>  844:         unicode:characters_to_list(argparse:help(Cmd1, #{}))),
<a name="845"/>  845:     %% ISO Date example
<a name="846"/>  846:     DefaultRange = {{2020, 1, 1}, {2020, 6, 22}},
<a name="847"/>  847:     CmdISO = #{
<a name="848"/>  848:         arguments =&gt; [
<a name="849"/>  849:             #{
<a name="850"/>  850:                 name =&gt; range,
<a name="851"/>  851:                 long =&gt; &quot;-range&quot;,
<a name="852"/>  852:                 short =&gt; $r,
<a name="853"/>  853:                 help =&gt; {&quot;[--range RNG]&quot;, fun() -&gt;
<a name="854"/>  854:                     {{FY, FM, FD}, {TY, TM, TD}} = DefaultRange,
<a name="855"/>  855:                     lists:flatten(io_lib:format(&quot;date range, ~b-~b-~b..~b-~b-~b&quot;, [FY, FM, FD, TY, TM, TD]))
<a name="856"/>  856:                                               end},
<a name="857"/>  857:                 type =&gt; {custom, fun(S) -&gt; [S, DefaultRange] end},
<a name="858"/>  858:                 default =&gt; DefaultRange
<a name="859"/>  859:             }
<a name="860"/>  860:         ]
<a name="861"/>  861:     },
<a name="862"/>  862:     ?assertEqual(&quot;Usage:\n  &quot; ++ prog() ++ &quot; [--range RNG]\n\nOptional arguments:\n  -r, --range date range, 2020-1-1..2020-6-22\n&quot;,
<a name="863"/>  863:         unicode:characters_to_list(argparse:help(CmdISO, #{}))),
<a name="usage_template-last_expr"/><a name="864"/>  864:     ok.
<a name="865"/>  865: 
<a name="usage_args_ordering-0"/><a name="866"/>  866: <b>usage_args_ordering</b>() -&gt;
<a name="usage_args_ordering-last_expr"/><a name="867"/>  867:     [{doc, &quot;Tests the ordering of arguments in usage text&quot;}].
<a name="868"/>  868: 
<a name="usage_args_ordering-1"/><a name="869"/>  869: <b>usage_args_ordering</b>(Config) when is_list(Config) -&gt;
<a name="870"/>  870:     Cmd = #{arguments =&gt; [
<a name="871"/>  871:         #{name =&gt; first},
<a name="872"/>  872:         #{name =&gt; second}
<a name="873"/>  873:         ],
<a name="874"/>  874:         commands =&gt; #{
<a name="875"/>  875:             &quot;cmd&quot; =&gt; #{arguments =&gt; [
<a name="876"/>  876:                 #{name =&gt; third},
<a name="877"/>  877:                 #{name =&gt; fourth}
<a name="878"/>  878:             ]}}
<a name="879"/>  879:     },
<a name="880"/>  880:     ?assertEqual(&quot;Usage:\n  &quot; ++ prog() ++ &quot; cmd &lt;first&gt; &lt;second&gt; &lt;third&gt; &lt;fourth&gt;\n&quot;
<a name="881"/>  881:         &quot;\n&quot;
<a name="882"/>  882:         &quot;Arguments:\n&quot;
<a name="883"/>  883:         &quot;  first  first\n&quot;
<a name="884"/>  884:         &quot;  second second\n&quot;
<a name="885"/>  885:         &quot;  third  third\n&quot;
<a name="886"/>  886:         &quot;  fourth fourth\n&quot;,
<a name="887"/>  887:         unicode:characters_to_list(argparse:help(Cmd, #{command =&gt; [&quot;cmd&quot;]}))),
<a name="usage_args_ordering-last_expr"/><a name="888"/>  888:     ok.
<a name="889"/>  889: 
<a name="parser_error_usage-0"/><a name="890"/>  890: <b>parser_error_usage</b>() -&gt;
<a name="parser_error_usage-last_expr"/><a name="891"/>  891:     [{doc, &quot;Tests that parser errors have corresponding usage text&quot;}].
<a name="892"/>  892: 
<a name="parser_error_usage-1"/><a name="893"/>  893: <b>parser_error_usage</b>(Config) when is_list(Config) -&gt;
<a name="894"/>  894:     %% unknown arguments
<a name="895"/>  895:     Prog = prog(),
<a name="896"/>  896:     ?assertEqual(Prog ++ &quot;: unknown argument: arg&quot;, parser_error([&quot;arg&quot;], #{})),
<a name="897"/>  897:     ?assertEqual(Prog ++ &quot;: unknown argument: -a&quot;, parser_error([&quot;-a&quot;], #{})),
<a name="898"/>  898:     %% missing argument
<a name="899"/>  899:     ?assertEqual(Prog ++ &quot;: required argument missing: need&quot;, parser_error([&quot;&quot;],
<a name="900"/>  900:         #{arguments =&gt; [#{name =&gt; need}]})),
<a name="901"/>  901:     ?assertEqual(Prog ++ &quot;: required argument missing: need&quot;, parser_error([&quot;&quot;],
<a name="902"/>  902:         #{arguments =&gt; [#{name =&gt; need, short =&gt; $n, required =&gt; true}]})),
<a name="903"/>  903:     %% invalid value
<a name="904"/>  904:     ?assertEqual(Prog ++ &quot;: invalid argument for need: foo is not an integer&quot;, parser_error([&quot;foo&quot;],
<a name="905"/>  905:         #{arguments =&gt; [#{name =&gt; need, type =&gt; integer}]})),
<a name="parser_error_usage-last_expr"/><a name="906"/>  906: <b>    ?assertEqual</b>(Prog ++ &quot;: invalid argument for need: cAnNotExIsT is not an existing atom&quot;, parser_error([&quot;cAnNotExIsT&quot;],
<a name="907"/>  907:         #{arguments =&gt; [#{name =&gt; need, type =&gt; atom}]})).
<a name="908"/>  908: 
<a name="command_usage-0"/><a name="909"/>  909: <b>command_usage</b>() -&gt;
<a name="command_usage-last_expr"/><a name="910"/>  910:     [{doc, &quot;Test command help template&quot;}].
<a name="911"/>  911: 
<a name="command_usage-1"/><a name="912"/>  912: <b>command_usage</b>(Config) when is_list(Config) -&gt;
<a name="913"/>  913:     Cmd = #{arguments =&gt; [
<a name="914"/>  914:         #{name =&gt; arg, help =&gt; &quot;argument help&quot;}, #{name =&gt; opt, short =&gt; $o, help =&gt; &quot;option help&quot;}],
<a name="915"/>  915:         help =&gt; [&quot;Options:\n&quot;, options, arguments, &lt;&lt;&quot;NOTAUSAGE&quot;&gt;&gt;, usage, &quot;\n&quot;]
<a name="916"/>  916:     },
<a name="command_usage-last_expr"/><a name="917"/>  917: <b>    ?assertEqual</b>(&quot;Options:\n  -o  option help\n  arg argument help\nNOTAUSAGE  &quot; ++ prog() ++ &quot; [-o &lt;opt&gt;] &lt;arg&gt;\n&quot;,
<a name="918"/>  918:         unicode:characters_to_list(argparse:help(Cmd, #{}))).
<a name="919"/>  919: 
<a name="usage_width-0"/><a name="920"/>  920: <b>usage_width</b>() -&gt;
<a name="usage_width-last_expr"/><a name="921"/>  921:     [{doc, &quot;Test usage fitting in the viewport&quot;}].
<a name="922"/>  922: 
<a name="usage_width-1"/><a name="923"/>  923: <b>usage_width</b>(Config) when is_list(Config) -&gt;
<a name="924"/>  924:     Cmd = #{arguments =&gt; [
<a name="925"/>  925:         #{name =&gt; arg, help =&gt; &quot;argument help that spans way over allowed viewport width, wrapping words&quot;},
<a name="926"/>  926:         #{name =&gt; opt, short =&gt; $o, long =&gt; &quot;-option_long_name&quot;,
<a name="927"/>  927:             help =&gt; &quot;another quite long word wrapped thing spanning over several lines&quot;},
<a name="928"/>  928:         #{name =&gt; v, short =&gt; $v, type =&gt; boolean},
<a name="929"/>  929:         #{name =&gt; q, short =&gt; $q, type =&gt; boolean}],
<a name="930"/>  930:         commands =&gt; #{
<a name="931"/>  931:             &quot;cmd1&quot; =&gt; #{help =&gt; &quot;Help for command number 1, not fitting at all&quot;},
<a name="932"/>  932:             &quot;cmd2&quot; =&gt; #{help =&gt; &lt;&lt;&quot;Short help&quot;&gt;&gt;},
<a name="933"/>  933:             &quot;cmd3&quot; =&gt; #{help =&gt; &quot;Yet another instance of a very long help message&quot;}
<a name="934"/>  934:         },
<a name="935"/>  935:         help =&gt; &quot;  Very long help line taking much more than 40 characters allowed by the test case.
<a name="936"/>  936: Also containing a few newlines.
<a name="937"/>  937: 
<a name="938"/>  938:    Indented new lines must be honoured!&quot;
<a name="939"/>  939:     },
<a name="940"/>  940: 
<a name="941"/>  941:     Expected = &quot;Usage:\n  erl {cmd1|cmd2|cmd3} [-vq] [-o &lt;opt&gt;]\n&quot;
<a name="942"/>  942:         &quot;      [--option_long_name &lt;opt&gt;] &lt;arg&gt;\n\n&quot;
<a name="943"/>  943:         &quot;  Very long help line taking much more\n&quot;
<a name="944"/>  944:         &quot;than 40 characters allowed by the test\n&quot;
<a name="945"/>  945:         &quot;case.\n&quot;
<a name="946"/>  946:         &quot;Also containing a few newlines.\n\n&quot;
<a name="947"/>  947:         &quot;   Indented new lines must be honoured!\n\n&quot;
<a name="948"/>  948:         &quot;Subcommands:\n&quot;
<a name="949"/>  949:         &quot;  cmd1                   Help for\n&quot;
<a name="950"/>  950:         &quot;                         command number\n&quot;
<a name="951"/>  951:         &quot;                         1, not fitting\n&quot;
<a name="952"/>  952:         &quot;                         at all\n&quot;
<a name="953"/>  953:         &quot;  cmd2                   Short help\n&quot;
<a name="954"/>  954:         &quot;  cmd3                   Yet another\n&quot;
<a name="955"/>  955:         &quot;                         instance of a\n&quot;
<a name="956"/>  956:         &quot;                         very long help\n&quot;
<a name="957"/>  957:         &quot;                         message\n\n&quot;
<a name="958"/>  958:         &quot;Arguments:\n&quot;
<a name="959"/>  959:         &quot;  arg                    argument help\n&quot;
<a name="960"/>  960:         &quot;                         that spans way\n&quot;
<a name="961"/>  961:         &quot;                         over allowed\n&quot;
<a name="962"/>  962:         &quot;                         viewport width,\n&quot;
<a name="963"/>  963:         &quot;                         wrapping words\n\n&quot;
<a name="964"/>  964:         &quot;Optional arguments:\n&quot;
<a name="965"/>  965:         &quot;  -o, --option_long_name another quite\n&quot;
<a name="966"/>  966:         &quot;                         long word\n&quot;
<a name="967"/>  967:         &quot;                         wrapped thing\n&quot;
<a name="968"/>  968:         &quot;                         spanning over\n&quot;
<a name="969"/>  969:         &quot;                         several lines\n&quot;
<a name="970"/>  970:         &quot;  -v                     v\n&quot;
<a name="971"/>  971:         &quot;  -q                     q\n&quot;,
<a name="972"/>  972: 
<a name="usage_width-last_expr"/><a name="973"/>  973: <b>    ?assertEqual</b>(Expected, unicode:characters_to_list(argparse:help(Cmd, #{columns =&gt; 40, progname =&gt; &quot;erl&quot;}))).
<a name="974"/>  974: 
<a name="975"/>  975: <i>%%--------------------------------------------------------------------</i>
<a name="976"/>  976: <i>%% Validator Test Cases</i>
<a name="977"/>  977: 
<a name="validator_exception-0"/><a name="978"/>  978: <b>validator_exception</b>() -&gt;
<a name="validator_exception-last_expr"/><a name="979"/>  979:     [{doc, &quot;Tests that the validator throws expected exceptions&quot;}].
<a name="980"/>  980: 
<a name="validator_exception-1"/><a name="981"/>  981: <b>validator_exception</b>(Config) when is_list(Config) -&gt;
<a name="982"/>  982:     Prg = [prog()],
<a name="983"/>  983:     %% conflicting option names
<a name="984"/>  984:     ?assertException(error, {argparse, argument, Prg, short, &quot;short conflicting with previously defined short for one&quot;},
<a name="985"/>  985:         argparse:validate(#{arguments =&gt; [#{name =&gt; one, short =&gt; $$}, #{name =&gt; two, short =&gt; $$}]})),
<a name="986"/>  986:     ?assertException(error, {argparse, argument, Prg, long, &quot;long conflicting with previously defined long for one&quot;},
<a name="987"/>  987:         argparse:validate(#{arguments =&gt; [#{name =&gt; one, long =&gt; &quot;a&quot;}, #{name =&gt; two, long =&gt; &quot;a&quot;}]})),
<a name="988"/>  988:     %% broken options
<a name="989"/>  989:     %% long must be a string
<a name="990"/>  990:     ?assertException(error, {argparse, argument, Prg, long, _},
<a name="991"/>  991:         argparse:validate(#{arguments =&gt; [#{name =&gt; one, long =&gt; ok}]})),
<a name="992"/>  992:     %% short must be a printable character
<a name="993"/>  993:     ?assertException(error, {argparse, argument, Prg, short, _},
<a name="994"/>  994:         argparse:validate(#{arguments =&gt; [#{name =&gt; one, short =&gt; ok}]})),
<a name="995"/>  995:     ?assertException(error, {argparse, argument, Prg, short, _},
<a name="996"/>  996:         argparse:validate(#{arguments =&gt; [#{name =&gt; one, short =&gt; 7}]})),
<a name="997"/>  997:     %% required is a boolean
<a name="998"/>  998:     ?assertException(error, {argparse, argument, Prg, required, _},
<a name="999"/>  999:         argparse:validate(#{arguments =&gt; [#{name =&gt; one, required =&gt; ok}]})),
<a name="1000"/> 1000:     ?assertException(error, {argparse, argument, Prg, help, _},
<a name="1001"/> 1001:         argparse:validate(#{arguments =&gt; [#{name =&gt; one, help =&gt; ok}]})),
<a name="1002"/> 1002:     %% tuple form of help must not have string as second argument
<a name="1003"/> 1003:     ?assertException(error, {argparse, argument, Prg, help, _},
<a name="1004"/> 1004:         argparse:validate(#{arguments =&gt; [#{name =&gt; one, help =&gt; {&quot;one&quot;, &quot;1&quot;}}]})),
<a name="1005"/> 1005:     %% broken commands
<a name="1006"/> 1006:     try argparse:help(#{}, #{progname =&gt; 123}), ?assert(false)
<a name="1007"/> 1007:     catch error:badarg:Stack -&gt;
<a name="1008"/> 1008:         [{_, _, _, Ext} | _] = Stack,
<a name="1009"/> 1009:         #{cause := #{2 := Detail}} = proplists:get_value(error_info, Ext),
<a name="1010"/> 1010:         ?assertEqual(&lt;&lt;&quot;progname is not valid&quot;&gt;&gt;, Detail)
<a name="1011"/> 1011:     end,
<a name="1012"/> 1012:     %% not-a-list of arguments provided to a subcommand
<a name="1013"/> 1013:     Prog = prog(),
<a name="1014"/> 1014:     ?assertException(error, {argparse, command, [Prog, &quot;start&quot;], arguments, &lt;&lt;&quot;expected a list, [argument()]&quot;&gt;&gt;},
<a name="1015"/> 1015:         argparse:validate(#{commands =&gt; #{&quot;start&quot; =&gt; #{arguments =&gt; atom}}})),
<a name="1016"/> 1016:     %% command is not a map
<a name="1017"/> 1017:     ?assertException(error, {argparse, command, Prg, commands, &lt;&lt;&quot;expected map of #{string() =&gt; command()}&quot;&gt;&gt;},
<a name="1018"/> 1018:         argparse:validate(#{commands =&gt; []})),
<a name="1019"/> 1019:     %% invalid commands field
<a name="1020"/> 1020:     ?assertException(error, {argparse, command, Prg, commands, _},
<a name="1021"/> 1021:         argparse:validate(#{commands =&gt; ok})),
<a name="1022"/> 1022:     ?assertException(error, {argparse, command, _, commands, _},
<a name="1023"/> 1023:         argparse:validate(#{commands =&gt; #{ok =&gt; #{}}})),
<a name="1024"/> 1024:     ?assertException(error, {argparse, command, _, help,
<a name="1025"/> 1025:         &lt;&lt;&quot;must be a printable unicode list, or a command help template&quot;&gt;&gt;},
<a name="1026"/> 1026:         argparse:validate(#{commands =&gt; #{&quot;ok&quot; =&gt; #{help =&gt; ok}}})),
<a name="1027"/> 1027:     ?assertException(error, {argparse, command, _, handler, _},
<a name="1028"/> 1028:         argparse:validate(#{commands =&gt; #{&quot;ok&quot; =&gt; #{handler =&gt; fun validator_exception/0}}})),
<a name="1029"/> 1029:     %% extend + maybe: validator exception
<a name="validator_exception-last_expr"/><a name="1030"/> 1030: <b>    ?assertException</b>(error, {argparse, argument, _, action, &lt;&lt;&quot;extend action works only with lists&quot;&gt;&gt;},
<a name="1031"/> 1031:         parse(&quot;-1 -1&quot;, #{arguments =&gt;
<a name="1032"/> 1032:         [#{action =&gt; extend, name =&gt; short49, nargs =&gt; 'maybe', short =&gt; 49}]})).
<a name="1033"/> 1033: 
<a name="validator_exception_format-0"/><a name="1034"/> 1034: <b>validator_exception_format</b>() -&gt;
<a name="validator_exception_format-last_expr"/><a name="1035"/> 1035: <b>    [{doc, &quot;Tests human-readable </b>(EEP-54) format for exceptions thrown by the validator&quot;}].
<a name="1036"/> 1036: 
<a name="validator_exception_format-1"/><a name="1037"/> 1037: <b>validator_exception_format</b>(Config) when is_list(Config) -&gt;
<a name="1038"/> 1038:     %% set up as a contract: test that EEP-54 transformation is done (but don't check strings)
<a name="1039"/> 1039:     try
<a name="1040"/> 1040:         argparse:validate(#{commands =&gt; #{&quot;one&quot; =&gt; #{commands =&gt; #{&quot;two&quot; =&gt; atom}}}}),
<a name="1041"/> 1041:         ?assert(false)
<a name="1042"/> 1042:     catch
<a name="1043"/> 1043:         error:R1:S1 -&gt;
<a name="1044"/> 1044:             #{1 := Cmd, reason := RR1, general := G} = argparse:format_error(R1, S1),
<a name="1045"/> 1045:             ?assertEqual(&quot;command specification is invalid&quot;, unicode:characters_to_list(G)),
<a name="1046"/> 1046:             ?assertEqual(&quot;command \&quot;&quot; ++ prog() ++ &quot; one two\&quot;: invalid field 'commands', reason: expected command()&quot;,
<a name="1047"/> 1047:                 unicode:characters_to_list(RR1)),
<a name="1048"/> 1048:             ?assertEqual([&quot;atom&quot;], Cmd)
<a name="1049"/> 1049:     end,
<a name="1050"/> 1050:     %% check argument
<a name="validator_exception_format-last_expr"/><a name="1051"/> 1051:     try
<a name="1052"/> 1052:         argparse:validate(#{arguments =&gt; [#{}]}),
<a name="1053"/> 1053:         ?assert(false)
<a name="1054"/> 1054:     catch
<a name="1055"/> 1055:         error:R2:S2 -&gt;
<a name="1056"/> 1056:             #{1 := Cmd2, reason := RR2, general := G2} = argparse:format_error(R2, S2),
<a name="1057"/> 1057:             ?assertEqual(&quot;argument specification is invalid&quot;, unicode:characters_to_list(G2)),
<a name="1058"/> 1058:             ?assertEqual(&quot;command \&quot;&quot; ++ prog() ++
<a name="1059"/> 1059:                 &quot;\&quot;, argument '', invalid field 'name': argument must be a map containing 'name' field&quot;,
<a name="1060"/> 1060:                 unicode:characters_to_list(RR2)),
<a name="1061"/> 1061:             ?assertEqual([&quot;#{}&quot;], Cmd2)
<a name="1062"/> 1062:     end.
<a name="1063"/> 1063: 
<a name="1064"/> 1064: <i>%%--------------------------------------------------------------------</i>
<a name="1065"/> 1065: <i>%% Validator Test Cases</i>
<a name="1066"/> 1066: 
<a name="run_handle-0"/><a name="1067"/> 1067: <b>run_handle</b>() -&gt;
<a name="run_handle-last_expr"/><a name="1068"/> 1068:     [{doc, &quot;Very basic tests for argparse:run/3, choice of handlers formats&quot;}].
<a name="1069"/> 1069: 
<a name="1070"/> 1070: <i>%% fun((arg_map()) -&gt; term()) |    %% handler accepting arg_map</i>
<a name="1071"/> 1071: <i>%% {module(), Fn :: atom()} |      %% handler, accepting arg_map, Fn exported from module()</i>
<a name="1072"/> 1072: <i>%% {fun(() -&gt; term()), term()} |   %% handler, positional form (term() is supplied for omitted args)</i>
<a name="1073"/> 1073: <i>%% {module(), atom(), term()}</i>
<a name="1074"/> 1074: 
<a name="run_handle-1"/><a name="1075"/> 1075: <b>run_handle</b>(Config) when is_list(Config) -&gt;
<a name="1076"/> 1076:     %% no subcommand, basic fun handler with argmap
<a name="1077"/> 1077:     ?assertEqual(6,
<a name="1078"/> 1078:         argparse:run([&quot;-i&quot;, &quot;3&quot;], #{handler =&gt; fun (#{in := Val}) -&gt; Val * 2 end,
<a name="1079"/> 1079:         arguments =&gt; [#{name =&gt; in, short =&gt; $i, type =&gt; integer}]}, #{})),
<a name="1080"/> 1080:     %% subcommand, positional fun() handler
<a name="1081"/> 1081:     ?assertEqual(6,
<a name="1082"/> 1082:         argparse:run([&quot;mul&quot;, &quot;2&quot;, &quot;3&quot;], #{commands =&gt; #{&quot;mul&quot; =&gt; #{
<a name="1083"/> 1083:             handler =&gt; {fun (match, L, R) -&gt; L * R end, match},
<a name="1084"/> 1084:             arguments =&gt; [#{name =&gt; opt, short =&gt; $o},
<a name="1085"/> 1085:                 #{name =&gt; l, type =&gt; integer}, #{name =&gt; r, type =&gt; integer}]}}},
<a name="1086"/> 1086:         #{})),
<a name="1087"/> 1087:     %% no subcommand, positional module-based function
<a name="1088"/> 1088:     ?assertEqual(6,
<a name="1089"/> 1089:         argparse:run([&quot;2&quot;, &quot;3&quot;], #{handler =&gt; {erlang, '*', undefined},
<a name="1090"/> 1090:             arguments =&gt; [#{name =&gt; l, type =&gt; integer}, #{name =&gt; r, type =&gt; integer}]},
<a name="1091"/> 1091:             #{})),
<a name="1092"/> 1092:     %% subcommand, module-based function accepting argmap
<a name="run_handle-last_expr"/><a name="1093"/> 1093: <b>    ?assertEqual</b>([{arg, &quot;arg&quot;}],
<a name="1094"/> 1094:         argparse:run([&quot;map&quot;, &quot;arg&quot;], #{commands =&gt; #{&quot;map&quot; =&gt; #{
<a name="1095"/> 1095:             handler =&gt; {maps, to_list},
<a name="1096"/> 1096:             arguments =&gt; [#{name =&gt; arg}]}}},
<a name="1097"/> 1097:             #{})).
<a name="1098"/> 1098: 
<a name="run_args_ordering-0"/><a name="1099"/> 1099: <b>run_args_ordering</b>() -&gt;
<a name="run_args_ordering-last_expr"/><a name="1100"/> 1100:     [{doc, &quot;Test that positional arguments are parsed in the correct order&quot;}].
<a name="1101"/> 1101: 
<a name="run_args_ordering-1"/><a name="1102"/> 1102: <b>run_args_ordering</b>(Config) when is_list(Config) -&gt;
<a name="run_args_ordering-last_expr"/><a name="1103"/> 1103: <b>    ?assertEqual</b>([{first,&quot;1&quot;},{second,&quot;2&quot;},{third,&quot;3&quot;},{fourth,&quot;4&quot;}],
<a name="1104"/> 1104:         argparse:run([&quot;cmd&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;],
<a name="1105"/> 1105:             #{arguments =&gt; [#{name =&gt; first}, #{name =&gt; second}],
<a name="1106"/> 1106:             commands =&gt; #{
<a name="1107"/> 1107:                 &quot;cmd&quot; =&gt; #{
<a name="1108"/> 1108:                     handler =&gt; {maps, to_list},
<a name="1109"/> 1109:                     arguments =&gt; [#{name =&gt; third}, #{name =&gt; fourth}]}
<a name="1110"/> 1110:             }},
<a name="1111"/> 1111:             #{progname =&gt; example})).
</pre>
</body>
</html>
