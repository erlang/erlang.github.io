<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/lib/kernel/make_test_dir/kernel_test/pg_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%</i>
<a name="2"/>    2: <i>%%</i>
<a name="3"/>    3: <i>%% Copyright WhatsApp Inc. and its affiliates. All rights reserved.</i>
<a name="4"/>    4: <i>%%</i>
<a name="5"/>    5: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="6"/>    6: <i>%% you may not use this file except in compliance with the License.</i>
<a name="7"/>    7: <i>%% You may obtain a copy of the License at</i>
<a name="8"/>    8: <i>%%</i>
<a name="9"/>    9: <i>%%     http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="10"/>   10: <i>%%</i>
<a name="11"/>   11: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="12"/>   12: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="13"/>   13: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="14"/>   14: <i>%% See the License for the specific language governing permissions and</i>
<a name="15"/>   15: <i>%% limitations under the License.</i>
<a name="16"/>   16: <i>%%</i>
<a name="17"/>   17: <i>%%-------------------------------------------------------------------</i>
<a name="18"/>   18: <i>%% @author Maxim Fedorov &lt;maximfca@gmail.com&gt;</i>
<a name="19"/>   19: <i>%%     Process Groups smoke test.</i>
<a name="20"/>   20: <b>-module</b>(pg_SUITE).
<a name="21"/>   21: <b>-author</b>(&quot;maximfca@gmail.com&quot;).
<a name="22"/>   22: 
<a name="23"/>   23: <i>%% Test server callbacks</i>
<a name="24"/>   24: <b>-export</b>([
<a name="25"/>   25:     suite/0,
<a name="26"/>   26:     all/0,
<a name="27"/>   27:     groups/0,
<a name="28"/>   28:     init_per_testcase/2,
<a name="29"/>   29:     end_per_testcase/2,
<a name="30"/>   30:     init_per_group/2,
<a name="31"/>   31:     end_per_group/2,
<a name="32"/>   32:     stop_proc/1,
<a name="33"/>   33:     ensure_peers_info/2
<a name="34"/>   34: ]).
<a name="35"/>   35: 
<a name="36"/>   36: <i>%% Test cases exports</i>
<a name="37"/>   37: <b>-export</b>([
<a name="38"/>   38:     pg/0, pg/1,
<a name="39"/>   39:     errors/0, errors/1,
<a name="40"/>   40:     leave_exit_race/0, leave_exit_race/1,
<a name="41"/>   41:     dyn_distribution/0, dyn_distribution/1,
<a name="42"/>   42:     process_owner_check/0, process_owner_check/1,
<a name="43"/>   43:     overlay_missing/0, overlay_missing/1,
<a name="44"/>   44:     single/0, single/1,
<a name="45"/>   45:     two/1,
<a name="46"/>   46:     empty_group_by_remote_leave/0, empty_group_by_remote_leave/1,
<a name="47"/>   47:     thundering_herd/0, thundering_herd/1,
<a name="48"/>   48:     initial/1,
<a name="49"/>   49:     netsplit/1,
<a name="50"/>   50:     trisplit/1,
<a name="51"/>   51:     foursplit/1,
<a name="52"/>   52:     exchange/1,
<a name="53"/>   53:     nolocal/1,
<a name="54"/>   54:     double/1,
<a name="55"/>   55:     scope_restart/1,
<a name="56"/>   56:     missing_scope_join/1,
<a name="57"/>   57:     disconnected_start/1,
<a name="58"/>   58:     forced_sync/0, forced_sync/1,
<a name="59"/>   59:     group_leave/1,
<a name="60"/>   60:     monitor_nonempty_scope/0, monitor_nonempty_scope/1,
<a name="61"/>   61:     monitor_scope/0, monitor_scope/1,
<a name="62"/>   62:     monitor/1,
<a name="63"/>   63:     protocol_upgrade/1
<a name="64"/>   64: ]).
<a name="65"/>   65: 
<a name="66"/>   66: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="67"/>   67: <b>-include_lib</b>(&quot;stdlib/include/assert.hrl&quot;).
<a name="68"/>   68: 
<a name="suite-0"/><a name="69"/>   69: <b>suite</b>() -&gt;
<a name="suite-last_expr"/><a name="70"/>   70:     [{timetrap, {seconds, 60}}].
<a name="71"/>   71: 
<a name="init_per_testcase-2"/><a name="72"/>   72: <b>init_per_testcase</b>(TestCase, Config) -&gt;
<a name="73"/>   73:     {ok, Pid} = pg:start_link(TestCase),
<a name="init_per_testcase-last_expr"/><a name="74"/>   74: <b>    trace_start</b>(TestCase, Config, Pid).
<a name="75"/>   75: 
<a name="end_per_testcase-2"/><a name="76"/>   76: <b>end_per_testcase</b>(TestCase, Config) -&gt;
<a name="77"/>   77:     gen_server:stop(TestCase),
<a name="78"/>   78:     trace_end(Config),
<a name="end_per_testcase-last_expr"/><a name="79"/>   79:     ok.
<a name="80"/>   80: 
<a name="all-0"/><a name="81"/>   81: <b>all</b>() -&gt;
<a name="all-last_expr"/><a name="82"/>   82:     [dyn_distribution,
<a name="83"/>   83:      {group, basic},
<a name="84"/>   84:      {group, cluster},
<a name="85"/>   85:      {group, performance},
<a name="86"/>   86:      {group, monitor},
<a name="87"/>   87:      {group, old_release}].
<a name="88"/>   88: 
<a name="groups-0"/><a name="89"/>   89: <b>groups</b>() -&gt;
<a name="groups-last_expr"/><a name="90"/>   90:     [
<a name="91"/>   91:         {basic, [parallel], [errors, pg, leave_exit_race, single, overlay_missing,
<a name="92"/>   92:                              protocol_upgrade]},
<a name="93"/>   93:         {performance, [], [thundering_herd]},
<a name="94"/>   94:         {cluster, [parallel], [process_owner_check, two, initial, netsplit, trisplit, foursplit,
<a name="95"/>   95:             exchange, nolocal, double, scope_restart, missing_scope_join, empty_group_by_remote_leave,
<a name="96"/>   96:             disconnected_start, forced_sync, group_leave]},
<a name="97"/>   97:         {monitor, [parallel], [monitor_nonempty_scope, monitor_scope, monitor]},
<a name="98"/>   98:         {old_release, [parallel], [process_owner_check, two, overlay_missing,
<a name="99"/>   99:                                    empty_group_by_remote_leave, initial, netsplit,
<a name="100"/>  100:                                    nolocal]}
<a name="101"/>  101:     ].
<a name="102"/>  102: 
<a name="init_per_group-2"/><a name="103"/>  103: <b>init_per_group</b>(old_release, Config) -&gt;
<a name="104"/>  104:     PrevRel = integer_to_list(list_to_integer(erlang:system_info(otp_release)) - 1),
<a name="105"/>  105:     case test_server:is_release_available(PrevRel) of
<a name="106"/>  106:         true -&gt;
<a name="107"/>  107:             [{otp_release, PrevRel} | Config];
<a name="108"/>  108:         false -&gt;
<a name="109"/>  109:             {skip, &quot;No OTP &quot;++PrevRel++&quot; release found&quot;}
<a name="110"/>  110:     end;
<a name="111"/>  111: <b>init_per_group</b>(_, Config) -&gt;
<a name="init_per_group-last_expr"/><a name="112"/>  112:     Config.
<a name="113"/>  113: 
<a name="end_per_group-2"/><a name="end_per_group-last_expr"/><a name="114"/>  114: <b>end_per_group</b>(_,_) -&gt; ok.
<a name="115"/>  115: 
<a name="116"/>  116: 
<a name="117"/>  117: <i>%%--------------------------------------------------------------------</i>
<a name="118"/>  118: <i>%% TEST CASES</i>
<a name="119"/>  119: 
<a name="pg-0"/><a name="120"/>  120: <b>pg</b>() -&gt;
<a name="pg-last_expr"/><a name="121"/>  121:     [{doc, &quot;This test must be names pg, to stay inline with default scope&quot;}].
<a name="122"/>  122: 
<a name="pg-1"/><a name="123"/>  123: <b>pg</b>(_Config) -&gt;
<a name="124"/>  124:     ?assertNotEqual(undefined, whereis(?FUNCTION_NAME)), %% ensure scope was started
<a name="125"/>  125:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, self())),
<a name="126"/>  126:     ?assertEqual([self()], pg:get_local_members(?FUNCTION_NAME)),
<a name="127"/>  127:     ?assertEqual([?FUNCTION_NAME], pg:which_groups()),
<a name="128"/>  128:     ?assertEqual([?FUNCTION_NAME], pg:which_local_groups()),
<a name="129"/>  129:     ?assertEqual(ok, pg:leave(?FUNCTION_NAME, self())),
<a name="130"/>  130:     ?assertEqual([], pg:get_members(?FUNCTION_NAME)),
<a name="131"/>  131:     ?assertEqual([], pg:which_groups(?FUNCTION_NAME)),
<a name="pg-last_expr"/><a name="132"/>  132: <b>    ?assertEqual</b>([], pg:which_local_groups(?FUNCTION_NAME)).
<a name="133"/>  133: 
<a name="errors-0"/><a name="134"/>  134: <b>errors</b>() -&gt;
<a name="errors-last_expr"/><a name="135"/>  135:     [{doc, &quot;Tests that errors are handled as expected, for example pg server crashes when it needs to&quot;}].
<a name="136"/>  136: 
<a name="errors-1"/><a name="137"/>  137: <b>errors</b>(_Config) -&gt;
<a name="138"/>  138:     %% kill with 'info' and 'cast'
<a name="139"/>  139:     ?assertException(error, badarg, pg:handle_info(garbage, garbage)),
<a name="140"/>  140:     ?assertException(error, badarg, pg:handle_cast(garbage, garbage)),
<a name="141"/>  141:     %% kill with call
<a name="142"/>  142:     {ok, _Pid} = pg:start(second),
<a name="errors-last_expr"/><a name="143"/>  143: <b>    ?assertException</b>(exit, {{badarg, _}, _}, gen_server:call(second, garbage, infinity)).
<a name="144"/>  144: 
<a name="leave_exit_race-0"/><a name="145"/>  145: <b>leave_exit_race</b>() -&gt;
<a name="leave_exit_race-last_expr"/><a name="146"/>  146:     [{doc, &quot;Tests that pg correctly handles situation when leave and 'DOWN' messages are both in pg queue&quot;}].
<a name="147"/>  147: 
<a name="leave_exit_race-1"/><a name="148"/>  148: <b>leave_exit_race</b>(Config) when is_list(Config) -&gt;
<a name="149"/>  149:     process_flag(priority, high),
<a name="leave_exit_race-last_expr"/><a name="150"/>  150:     [
<a name="151"/>  151:         begin
<a name="152"/>  152:             Pid = spawn(fun () -&gt; ok end),
<a name="153"/>  153:             pg:join(leave_exit_race, test, Pid),
<a name="154"/>  154:             pg:leave(leave_exit_race, test, Pid)
<a name="155"/>  155:         end
<a name="156"/>  156:         || _ &lt;- lists:seq(1, 100)].
<a name="157"/>  157: 
<a name="single-0"/><a name="158"/>  158: <b>single</b>() -&gt;
<a name="single-last_expr"/><a name="159"/>  159:     [{doc, &quot;Tests single node groups&quot;}, {timetrap, {seconds, 5}}].
<a name="160"/>  160: 
<a name="single-1"/><a name="161"/>  161: <b>single</b>(Config) when is_list(Config) -&gt;
<a name="162"/>  162:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, self())),
<a name="163"/>  163:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [self(), self()])),
<a name="164"/>  164:     ?assertEqual([self(), self(), self()], pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="165"/>  165:     ?assertEqual([self(), self(), self()], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="166"/>  166:     ?assertEqual(not_joined, pg:leave(?FUNCTION_NAME, '$missing$', self())),
<a name="167"/>  167:     ?assertEqual(ok, pg:leave(?FUNCTION_NAME, ?FUNCTION_NAME, [self(), self()])),
<a name="168"/>  168:     ?assertEqual(ok, pg:leave(?FUNCTION_NAME, ?FUNCTION_NAME, self())),
<a name="169"/>  169:     ?assertEqual([], pg:which_groups(?FUNCTION_NAME)),
<a name="170"/>  170:     ?assertEqual([], pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="171"/>  171:     ?assertEqual([], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="172"/>  172:     %% double
<a name="173"/>  173:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, self())),
<a name="174"/>  174:     Pid = erlang:spawn(forever()),
<a name="175"/>  175:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, Pid)),
<a name="176"/>  176:     Expected = lists:sort([Pid, self()]),
<a name="177"/>  177:     ?assertEqual(Expected, lists:sort(pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="178"/>  178:     ?assertEqual(Expected, lists:sort(pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="179"/>  179: 
<a name="180"/>  180:     stop_proc(Pid),
<a name="181"/>  181:     sync(?FUNCTION_NAME),
<a name="182"/>  182:     ?assertEqual([self()], pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="183"/>  183:     ?assertEqual(ok, pg:leave(?FUNCTION_NAME, ?FUNCTION_NAME, self())),
<a name="single-last_expr"/><a name="184"/>  184:     ok.
<a name="185"/>  185: 
<a name="dyn_distribution-0"/><a name="186"/>  186: <b>dyn_distribution</b>() -&gt;
<a name="dyn_distribution-last_expr"/><a name="187"/>  187:     [{doc, &quot;Tests that local node when distribution is started dynamically is not treated as remote node&quot;}].
<a name="188"/>  188: 
<a name="dyn_distribution-1"/><a name="189"/>  189: <b>dyn_distribution</b>(Config) when is_list(Config) -&gt;
<a name="190"/>  190:     %% When distribution is started or stopped dynamically,
<a name="191"/>  191:     %%  there is a nodeup/nodedown message delivered to pg
<a name="192"/>  192:     %% It is possible but non-trivial to simulate this
<a name="193"/>  193:     %%  behaviour with starting slave nodes being not
<a name="194"/>  194:     %%  distributed, and calling net_kernel:start/1, however
<a name="195"/>  195:     %%  the effect is still the same as simply sending nodeup,
<a name="196"/>  196:     %%  which is also documented.
<a name="197"/>  197:     ?FUNCTION_NAME ! {nodeup, node()},
<a name="198"/>  198:     %%
<a name="199"/>  199:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, self())),
<a name="200"/>  200:     ?assertEqual([self()], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="dyn_distribution-last_expr"/><a name="201"/>  201:     ok.
<a name="202"/>  202: 
<a name="process_owner_check-0"/><a name="203"/>  203: <b>process_owner_check</b>() -&gt;
<a name="process_owner_check-last_expr"/><a name="204"/>  204:     [{doc, &quot;Tests that process owner is local node&quot;}].
<a name="205"/>  205: 
<a name="process_owner_check-1"/><a name="206"/>  206: <b>process_owner_check</b>(Config) when is_list(Config) -&gt;
<a name="207"/>  207:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="208"/>  208:     %% spawn remote process
<a name="209"/>  209:     LocalPid = erlang:spawn(forever()),
<a name="210"/>  210:     RemotePid = spawn_sleeper_at(Node),
<a name="211"/>  211:     %% check they can't be joined locally
<a name="212"/>  212:     ?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid)),
<a name="213"/>  213:     ?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [RemotePid, RemotePid])),
<a name="214"/>  214:     ?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [LocalPid, RemotePid])),
<a name="215"/>  215:     %% check that non-pid also triggers error
<a name="216"/>  216:     ?assertException(error, function_clause, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, undefined)),
<a name="217"/>  217:     ?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [undefined])),
<a name="218"/>  218:     %% stop the peer
<a name="219"/>  219:     peer:stop(Peer),
<a name="process_owner_check-last_expr"/><a name="220"/>  220:     ok.
<a name="221"/>  221: 
<a name="overlay_missing-0"/><a name="222"/>  222: <b>overlay_missing</b>() -&gt;
<a name="overlay_missing-last_expr"/><a name="223"/>  223:     [{doc, &quot;Tests that scope process that is not a part of overlay network does not change state&quot;}].
<a name="224"/>  224: 
<a name="overlay_missing-1"/><a name="225"/>  225: <b>overlay_missing</b>(Config) -&gt;
<a name="226"/>  226:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="227"/>  227:     %% join self (sanity check)
<a name="228"/>  228:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, group, self())),
<a name="229"/>  229:     %% remember pid from remote
<a name="230"/>  230:     PgPid = rpc:call(Node, erlang, whereis, [?FUNCTION_NAME]),
<a name="231"/>  231:     RemotePid = spawn_sleeper_at(Node),
<a name="232"/>  232:     %% stop remote scope
<a name="233"/>  233:     gen_server:stop(PgPid),
<a name="234"/>  234:     %% craft white-box request: ensure it's rejected
<a name="235"/>  235:     ?FUNCTION_NAME ! {join, PgPid, group, RemotePid},
<a name="236"/>  236:     %% rejected!
<a name="237"/>  237:     ?assertEqual([self()], pg:get_members(?FUNCTION_NAME, group)),
<a name="238"/>  238:     %% ... reject leave too
<a name="239"/>  239:     ?FUNCTION_NAME ! {leave, PgPid, RemotePid, [group]},
<a name="240"/>  240:     ?assertEqual([self()], pg:get_members(?FUNCTION_NAME, group)),
<a name="241"/>  241:     %% join many times on remote
<a name="242"/>  242:     %RemotePids = [erlang:spawn(TwoPeer, forever()) || _ &lt;- lists:seq(1, 1024)],
<a name="243"/>  243:     %?assertEqual(ok, rpc:call(TwoPeer, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, Pid2])),
<a name="244"/>  244:     %% check they can't be joined locally
<a name="245"/>  245:     %?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid)),
<a name="246"/>  246:     %?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [RemotePid, RemotePid])),
<a name="247"/>  247:     %?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [LocalPid, RemotePid])),
<a name="248"/>  248:     %% check that non-pid also triggers error
<a name="249"/>  249:     %?assertException(error, function_clause, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, undefined)),
<a name="250"/>  250:     %?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [undefined])),
<a name="251"/>  251:     %% stop the peer
<a name="overlay_missing-last_expr"/><a name="252"/>  252: <b>    peer:stop</b>(Peer).
<a name="253"/>  253: 
<a name="254"/>  254: 
<a name="two-1"/><a name="255"/>  255: <b>two</b>(Config) when is_list(Config) -&gt;
<a name="256"/>  256:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="257"/>  257:     Pid = erlang:spawn(forever()),
<a name="258"/>  258:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, Pid)),
<a name="259"/>  259:     ?assertEqual([Pid], pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="260"/>  260:     %% first RPC must be serialised 3 times
<a name="261"/>  261:     sync({?FUNCTION_NAME, Node}),
<a name="262"/>  262:     sync(?FUNCTION_NAME),
<a name="263"/>  263:     sync({?FUNCTION_NAME, Node}),
<a name="264"/>  264:     ?assertEqual([Pid], rpc:call(Node, pg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
<a name="265"/>  265:     ?assertEqual([], rpc:call(Node, pg, get_local_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
<a name="266"/>  266:     stop_proc(Pid),
<a name="267"/>  267:     %% again, must be serialised
<a name="268"/>  268:     sync(?FUNCTION_NAME),
<a name="269"/>  269:     sync({?FUNCTION_NAME, Node}),
<a name="270"/>  270:     ?assertEqual([], pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="271"/>  271:     ?assertEqual([], rpc:call(Node, pg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
<a name="272"/>  272: 
<a name="273"/>  273:     Pid2 = spawn_sleeper_at(Node),
<a name="274"/>  274:     Pid3 = spawn_sleeper_at(Node),
<a name="275"/>  275:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, Pid2])),
<a name="276"/>  276:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, Pid3])),
<a name="277"/>  277:     %% serialise through the *other* node
<a name="278"/>  278:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="279"/>  279:     ?assertEqual(lists:sort([Pid2, Pid3]),
<a name="280"/>  280:         lists:sort(pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="281"/>  281:     %% stop the peer
<a name="282"/>  282:     peer:stop(Peer),
<a name="283"/>  283:     %% hope that 'nodedown' comes before we route our request
<a name="284"/>  284:     sync(?FUNCTION_NAME),
<a name="two-last_expr"/><a name="285"/>  285:     ok.
<a name="286"/>  286: 
<a name="empty_group_by_remote_leave-0"/><a name="287"/>  287: <b>empty_group_by_remote_leave</b>() -&gt;
<a name="empty_group_by_remote_leave-last_expr"/><a name="288"/>  288:     [{doc, &quot;Empty group should be deleted from nodes.&quot;}].
<a name="289"/>  289: 
<a name="empty_group_by_remote_leave-1"/><a name="290"/>  290: <b>empty_group_by_remote_leave</b>(Config) when is_list(Config) -&gt;
<a name="291"/>  291:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="292"/>  292:     RemoteNode = rpc:call(Node, erlang, whereis, [?FUNCTION_NAME]),
<a name="293"/>  293:     RemotePid = spawn_sleeper_at(Node),
<a name="294"/>  294:     % remote join
<a name="295"/>  295:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
<a name="296"/>  296:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="297"/>  297:     ?assertEqual([RemotePid], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="298"/>  298:     % inspecting internal state is not best practice, but there's no other way to check if the state is correct.
<a name="299"/>  299:     {_, RemoteMap} = maps:get(RemoteNode, element(4, sys:get_state(?FUNCTION_NAME))),
<a name="300"/>  300:     ?assertEqual(#{?FUNCTION_NAME =&gt; [RemotePid]}, RemoteMap),
<a name="301"/>  301:     % remote leave
<a name="302"/>  302:     ?assertEqual(ok, rpc:call(Node, pg, leave, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
<a name="303"/>  303:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="304"/>  304:     ?assertEqual([], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="305"/>  305:     {_, NewRemoteMap} = maps:get(RemoteNode, element(4, sys:get_state(?FUNCTION_NAME))),
<a name="306"/>  306:     % empty group should be deleted.
<a name="307"/>  307:     ?assertEqual(#{}, NewRemoteMap),
<a name="308"/>  308: 
<a name="309"/>  309:     %% another variant of emptying a group remotely: join([Pi1, Pid2]) and leave ([Pid2, Pid1])
<a name="310"/>  310:     RemotePid2 = spawn_sleeper_at(Node),
<a name="311"/>  311:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, [RemotePid, RemotePid2]])),
<a name="312"/>  312:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="313"/>  313:     ?assertEqual([RemotePid, RemotePid2], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="314"/>  314:     %% now leave
<a name="315"/>  315:     ?assertEqual(ok, rpc:call(Node, pg, leave, [?FUNCTION_NAME, ?FUNCTION_NAME, [RemotePid2, RemotePid]])),
<a name="316"/>  316:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="317"/>  317:     ?assertEqual([], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="318"/>  318:     {_, NewRemoteMap} = maps:get(RemoteNode, element(4, sys:get_state(?FUNCTION_NAME))),
<a name="319"/>  319:     peer:stop(Peer),
<a name="empty_group_by_remote_leave-last_expr"/><a name="320"/>  320:     ok.
<a name="321"/>  321: 
<a name="thundering_herd-0"/><a name="322"/>  322: <b>thundering_herd</b>() -&gt;
<a name="thundering_herd-last_expr"/><a name="323"/>  323:     [{doc, &quot;Thousands of overlay network nodes sending sync to us, and we time out!&quot;}, {timetrap, {seconds, 5}}].
<a name="324"/>  324: 
<a name="thundering_herd-1"/><a name="325"/>  325: <b>thundering_herd</b>(Config) when is_list(Config) -&gt;
<a name="326"/>  326:     GroupCount = 10000,
<a name="327"/>  327:     SyncCount = 2000,
<a name="328"/>  328:     %% make up a large amount of groups
<a name="329"/>  329:     [pg:join(?FUNCTION_NAME, {group, Seq}, self()) || Seq &lt;- lists:seq(1, GroupCount)],
<a name="330"/>  330:     %% initiate a few syncs - and those are really slow...
<a name="331"/>  331:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="332"/>  332:     PeerPid = erlang:spawn(Node, forever()),
<a name="333"/>  333:     PeerPg = rpc:call(Node, erlang, whereis, [?FUNCTION_NAME], 1000),
<a name="334"/>  334:     %% WARNING: code below acts for white-box! %% WARNING
<a name="335"/>  335:     FakeSync = [{{group, 1}, [PeerPid, PeerPid]}],
<a name="336"/>  336:     [gen_server:cast(?FUNCTION_NAME, {sync, PeerPg, FakeSync}) || _ &lt;- lists:seq(1, SyncCount)],
<a name="337"/>  337:     %% next call must not timetrap, otherwise test fails
<a name="338"/>  338:     pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, self()),
<a name="thundering_herd-last_expr"/><a name="339"/>  339: <b>    peer:stop</b>(Peer).
<a name="340"/>  340: 
<a name="initial-1"/><a name="341"/>  341: <b>initial</b>(Config) when is_list(Config) -&gt;
<a name="342"/>  342:     Pid = erlang:spawn(forever()),
<a name="343"/>  343:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, Pid)),
<a name="344"/>  344:     ?assertEqual([Pid], pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="345"/>  345:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="346"/>  346:     %% first sync makes the peer node to process 'nodeup' (and send discover)
<a name="347"/>  347:     sync({?FUNCTION_NAME, Node}),
<a name="348"/>  348:     %% second sync makes origin node pg to reply to discover'
<a name="349"/>  349:     sync(?FUNCTION_NAME),
<a name="350"/>  350:     %% third sync makes peer node to finish processing 'exchange'
<a name="351"/>  351:     sync({?FUNCTION_NAME, Node}),
<a name="352"/>  352:     ?assertEqual([Pid], rpc:call(Node, pg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
<a name="353"/>  353: 
<a name="354"/>  354:     ?assertEqual([], rpc:call(Node, pg, get_local_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
<a name="355"/>  355:     stop_proc(Pid),
<a name="356"/>  356:     sync({?FUNCTION_NAME, Node}),
<a name="357"/>  357:     ?assertEqual([], rpc:call(Node, pg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
<a name="358"/>  358:     peer:stop(Peer),
<a name="initial-last_expr"/><a name="359"/>  359:     ok.
<a name="360"/>  360: 
<a name="netsplit-1"/><a name="361"/>  361: <b>netsplit</b>(Config) when is_list(Config) -&gt;
<a name="362"/>  362:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="363"/>  363:     ?assertEqual(Node, peer:call(Peer, erlang, node, [])), %% just to test RPC
<a name="364"/>  364:     RemoteOldPid = spawn_sleeper_at(Node),
<a name="365"/>  365:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, '$invisible', RemoteOldPid])),
<a name="366"/>  366:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="367"/>  367:     ?assertEqual([RemoteOldPid], pg:get_members(?FUNCTION_NAME, '$invisible')),
<a name="368"/>  368: 
<a name="369"/>  369:     %% hohoho, partition!
<a name="370"/>  370:     disconnect_nodes([Node]),
<a name="371"/>  371:     ?assertEqual(Node, peer:call(Peer, erlang, node, [])), %% just to ensure RPC still works
<a name="372"/>  372:     RemotePid = peer:call(Peer, erlang, spawn, sleeper_mfa()),
<a name="373"/>  373:     ?assertEqual([], peer:call(Peer, erlang, nodes, [])),
<a name="374"/>  374:     ?assertNot(lists:member(Node, nodes())), %% should be no nodes in the cluster
<a name="375"/>  375:     ?assertEqual(ok, peer:call(Peer, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])), %% join - in a partition!
<a name="376"/>  376: 
<a name="377"/>  377:     ?assertEqual(ok, peer:call(Peer, pg, leave, [?FUNCTION_NAME, '$invisible', RemoteOldPid])),
<a name="378"/>  378:     ?assertEqual(ok, peer:call(Peer, pg, join, [?FUNCTION_NAME, '$visible', RemoteOldPid])),
<a name="379"/>  379:     ?assertEqual([RemoteOldPid], peer:call(Peer, pg, get_local_members, [?FUNCTION_NAME, '$visible'])),
<a name="380"/>  380:     %% join locally too
<a name="381"/>  381:     LocalPid = erlang:spawn(forever()),
<a name="382"/>  382:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, LocalPid)),
<a name="383"/>  383: 
<a name="384"/>  384:     ?assertNot(lists:member(Node, nodes())), %% should be no nodes in the cluster
<a name="385"/>  385: 
<a name="386"/>  386:     PgPid = whereis(?FUNCTION_NAME),
<a name="387"/>  387:     1 = erlang:trace(PgPid, true, ['receive']),
<a name="388"/>  388:     pong = net_adm:ping(Node),
<a name="389"/>  389:     receive
<a name="390"/>  390:         {trace, PgPid, 'receive', {nodeup, Node}} -&gt; ok
<a name="391"/>  391:     end,
<a name="392"/>  392:     1 = erlang:trace(PgPid, false, ['receive']),
<a name="393"/>  393: 
<a name="394"/>  394:     %% now ensure sync happened
<a name="395"/>  395:     sync_via(?FUNCTION_NAME, {?FUNCTION_NAME, Node}),
<a name="396"/>  396:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="397"/>  397:     ?assertEqual(lists:sort([RemotePid, LocalPid]),
<a name="398"/>  398:                  lists:sort(rpc:call(Node, pg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME]))),
<a name="399"/>  399:     ?assertEqual([RemoteOldPid], pg:get_members(?FUNCTION_NAME, '$visible')),
<a name="400"/>  400:     peer:stop(Peer),
<a name="netsplit-last_expr"/><a name="401"/>  401:     ok.
<a name="402"/>  402: 
<a name="trisplit-1"/><a name="403"/>  403: <b>trisplit</b>(Config) when is_list(Config) -&gt;
<a name="404"/>  404:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="405"/>  405:     _PeerPid1 = spawn_sleeper_at(Node),
<a name="406"/>  406:     PeerPid2 = spawn_sleeper_at(Node),
<a name="407"/>  407:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, three, PeerPid2])),
<a name="408"/>  408:     disconnect_nodes([Node]),
<a name="409"/>  409:     ?assertEqual(true, net_kernel:connect_node(Node)),
<a name="410"/>  410:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, one, PeerPid2])),
<a name="411"/>  411:     %% now ensure sync happened
<a name="412"/>  412:     {Peer2, Node2} = spawn_node(?FUNCTION_NAME, Config),
<a name="413"/>  413:     ?assertEqual(true, rpc:call(Node2, net_kernel, connect_node, [Node])),
<a name="414"/>  414:     ?assertEqual(lists:sort([node(), Node]), lists:sort(rpc:call(Node2, erlang, nodes, []))),
<a name="415"/>  415:     ok = rpc:call(Node2, ?MODULE, ensure_peers_info, [?FUNCTION_NAME, [node(), Node]]),
<a name="416"/>  416:     ?assertEqual([PeerPid2], rpc:call(Node2, pg, get_members, [?FUNCTION_NAME, one])),
<a name="417"/>  417:     peer:stop(Peer),
<a name="418"/>  418:     peer:stop(Peer2),
<a name="trisplit-last_expr"/><a name="419"/>  419:     ok.
<a name="420"/>  420: 
<a name="foursplit-1"/><a name="421"/>  421: <b>foursplit</b>(Config) when is_list(Config) -&gt;
<a name="422"/>  422:     Pid = erlang:spawn(forever()),
<a name="423"/>  423:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="424"/>  424:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, one, Pid)),
<a name="425"/>  425:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, two, Pid)),
<a name="426"/>  426:     PeerPid1 = erlang:spawn(Node, forever()),
<a name="427"/>  427:     ?assertEqual(ok, pg:leave(?FUNCTION_NAME, one, Pid)),
<a name="428"/>  428:     ?assertEqual(not_joined, pg:leave(?FUNCTION_NAME, three, Pid)),
<a name="429"/>  429:     disconnect_nodes([Node]),
<a name="430"/>  430:     ?assertEqual(ok, peer:call(Peer, ?MODULE, stop_proc, [PeerPid1])),
<a name="431"/>  431:     ?assertEqual(not_joined, pg:leave(?FUNCTION_NAME, three, Pid)),
<a name="432"/>  432:     ?assertEqual(true, net_kernel:connect_node(Node)),
<a name="433"/>  433:     ?assertEqual([], pg:get_members(?FUNCTION_NAME, one)),
<a name="434"/>  434:     ?assertEqual([], peer:call(Peer, pg, get_members, [?FUNCTION_NAME, one])),
<a name="435"/>  435:     peer:stop(Peer),
<a name="foursplit-last_expr"/><a name="436"/>  436:     ok.
<a name="437"/>  437: 
<a name="exchange-1"/><a name="438"/>  438: <b>exchange</b>(Config) when is_list(Config) -&gt;
<a name="439"/>  439:     {Peer1, Node1} = spawn_node(?FUNCTION_NAME, Config),
<a name="440"/>  440:     {Peer2, Node2} = spawn_node(?FUNCTION_NAME, Config),
<a name="441"/>  441:     Pids10 = [peer:call(Peer1, erlang, spawn, [forever()]) || _ &lt;- lists:seq(1, 10)],
<a name="442"/>  442:     Pids2 = [peer:call(Peer2, erlang, spawn, [forever()]) || _ &lt;- lists:seq(1, 10)],
<a name="443"/>  443:     Pids11 = [peer:call(Peer1, erlang, spawn, [forever()]) || _ &lt;- lists:seq(1, 10)],
<a name="444"/>  444:     %% kill first 3 pids from node1
<a name="445"/>  445:     {PidsToKill, Pids1} = lists:split(3, Pids10),
<a name="446"/>  446: 
<a name="447"/>  447:     ?assertEqual(ok, peer:call(Peer1, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, Pids10])),
<a name="448"/>  448:     sync({?FUNCTION_NAME, Node1}), %% Join broadcast have reached local
<a name="449"/>  449:     sync(?FUNCTION_NAME), %% Join broadcast has been processed by local
<a name="450"/>  450:     ?assertEqual(lists:sort(Pids10), lists:sort(pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="451"/>  451:     [peer:call(Peer1, ?MODULE, stop_proc, [Pid]) || Pid &lt;- PidsToKill],
<a name="452"/>  452:     sync(?FUNCTION_NAME),
<a name="453"/>  453:     sync({?FUNCTION_NAME, Node1}),
<a name="454"/>  454: 
<a name="455"/>  455:     Pids = lists:sort(Pids1 ++ Pids2 ++ Pids11),
<a name="456"/>  456:     ?assert(lists:all(fun erlang:is_pid/1, Pids)),
<a name="457"/>  457: 
<a name="458"/>  458:     disconnect_nodes([Node1, Node2]),
<a name="459"/>  459: 
<a name="460"/>  460:     sync(?FUNCTION_NAME), %% Processed nodedowns...
<a name="461"/>  461:     ?assertEqual([], lists:sort(pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="462"/>  462: 
<a name="463"/>  463:     [?assertEqual(ok, peer:call(Peer2, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, Pid])) || Pid &lt;- Pids2],
<a name="464"/>  464:     [?assertEqual(ok, peer:call(Peer1, pg, join, [?FUNCTION_NAME, second, Pid])) || Pid &lt;- Pids11],
<a name="465"/>  465:     ?assertEqual(ok, peer:call(Peer1, pg, join, [?FUNCTION_NAME, third, Pids11])),
<a name="466"/>  466:     %% rejoin
<a name="467"/>  467:     ?assertEqual(true, net_kernel:connect_node(Node1)),
<a name="468"/>  468:     ?assertEqual(true, net_kernel:connect_node(Node2)),
<a name="469"/>  469:     %% need to sleep longer to ensure both nodes made the exchange
<a name="470"/>  470:     ensure_peers_info(?FUNCTION_NAME, [Node1, Node2]),
<a name="471"/>  471:     ?assertEqual(Pids, lists:sort(pg:get_members(?FUNCTION_NAME, second) ++ pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="472"/>  472:     ?assertEqual(lists:sort(Pids11), lists:sort(pg:get_members(?FUNCTION_NAME, third))),
<a name="473"/>  473: 
<a name="474"/>  474:     {Left, Stay} = lists:split(3, Pids11),
<a name="475"/>  475:     ?assertEqual(ok, peer:call(Peer1, pg, leave, [?FUNCTION_NAME, third, Left])),
<a name="476"/>  476:     sync({?FUNCTION_NAME, Node1}),
<a name="477"/>  477:     sync(?FUNCTION_NAME),
<a name="478"/>  478:     ?assertEqual(lists:sort(Stay), lists:sort(pg:get_members(?FUNCTION_NAME, third))),
<a name="479"/>  479:     ?assertEqual(not_joined, peer:call(Peer1, pg, leave, [?FUNCTION_NAME, left, Stay])),
<a name="480"/>  480:     ?assertEqual(ok, peer:call(Peer1, pg, leave, [?FUNCTION_NAME, third, Stay])),
<a name="481"/>  481:     sync({?FUNCTION_NAME, Node1}),
<a name="482"/>  482:     sync(?FUNCTION_NAME),
<a name="483"/>  483:     ?assertEqual([], lists:sort(pg:get_members(?FUNCTION_NAME, third))),
<a name="484"/>  484:     sync({?FUNCTION_NAME, Node1}),
<a name="485"/>  485:     sync(?FUNCTION_NAME),
<a name="486"/>  486: 
<a name="487"/>  487:     peer:stop(Peer1),
<a name="488"/>  488:     peer:stop(Peer2),
<a name="exchange-last_expr"/><a name="489"/>  489:     ok.
<a name="490"/>  490: 
<a name="nolocal-1"/><a name="491"/>  491: <b>nolocal</b>(Config) when is_list(Config) -&gt;
<a name="492"/>  492:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="493"/>  493:     RemotePid = spawn_sleeper_at(Node),
<a name="494"/>  494:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
<a name="495"/>  495:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
<a name="496"/>  496:     ?assertEqual([], pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="497"/>  497:     peer:stop(Peer),
<a name="nolocal-last_expr"/><a name="498"/>  498:     ok.
<a name="499"/>  499: 
<a name="double-1"/><a name="500"/>  500: <b>double</b>(Config) when is_list(Config) -&gt;
<a name="501"/>  501:     Pid = erlang:spawn(forever()),
<a name="502"/>  502:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, Pid)),
<a name="503"/>  503:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="504"/>  504:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [Pid])),
<a name="505"/>  505:     ?assertEqual([Pid, Pid], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="506"/>  506:     sync({?FUNCTION_NAME, Node}),
<a name="507"/>  507:     sync_via(?FUNCTION_NAME, {?FUNCTION_NAME, Node}),
<a name="508"/>  508:     ?assertEqual([Pid, Pid], rpc:call(Node, pg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
<a name="509"/>  509:     peer:stop(Peer),
<a name="double-last_expr"/><a name="510"/>  510:     ok.
<a name="511"/>  511: 
<a name="scope_restart-1"/><a name="512"/>  512: <b>scope_restart</b>(Config) when is_list(Config) -&gt;
<a name="513"/>  513:     Pid = erlang:spawn(forever()),
<a name="514"/>  514:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [Pid, Pid])),
<a name="515"/>  515:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="516"/>  516:     RemotePid = erlang:spawn(Node, forever()),
<a name="517"/>  517:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
<a name="518"/>  518:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="519"/>  519:     ?assertEqual(lists:sort([RemotePid, Pid, Pid]), lists:sort(pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="520"/>  520:     %% stop scope locally, and restart
<a name="521"/>  521:     gen_server:stop(?FUNCTION_NAME),
<a name="522"/>  522:     pg:start(?FUNCTION_NAME),
<a name="523"/>  523:     %% ensure remote pids joined, local are missing
<a name="524"/>  524:     sync(?FUNCTION_NAME),
<a name="525"/>  525:     sync({?FUNCTION_NAME, Node}),
<a name="526"/>  526:     sync(?FUNCTION_NAME),
<a name="527"/>  527:     ?assertEqual([RemotePid], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="528"/>  528:     peer:stop(Peer),
<a name="scope_restart-last_expr"/><a name="529"/>  529:     ok.
<a name="530"/>  530: 
<a name="missing_scope_join-1"/><a name="531"/>  531: <b>missing_scope_join</b>(Config) when is_list(Config) -&gt;
<a name="532"/>  532:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="533"/>  533:     ?assertEqual(ok, rpc:call(Node, gen_server, stop, [?FUNCTION_NAME])),
<a name="534"/>  534:     RemotePid = erlang:spawn(Node, forever()),
<a name="535"/>  535:     ?assertMatch({badrpc, {'EXIT', {noproc, _}}}, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
<a name="536"/>  536:     ?assertMatch({badrpc, {'EXIT', {noproc, _}}}, rpc:call(Node, pg, leave, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
<a name="537"/>  537:     peer:stop(Peer),
<a name="missing_scope_join-last_expr"/><a name="538"/>  538:     ok.
<a name="539"/>  539: 
<a name="disconnected_start-1"/><a name="540"/>  540: <b>disconnected_start</b>(Config) when is_list(Config) -&gt;
<a name="disconnected_start-last_expr"/><a name="541"/>  541: <b>    case test_server:is_cover</b>() of
<a name="542"/>  542:         true -&gt;
<a name="543"/>  543:             {skip, &quot;Cover is running&quot;};
<a name="544"/>  544:         false -&gt;
<a name="545"/>  545:             disconnected_start_test(Config)
<a name="546"/>  546:     end.
<a name="547"/>  547: 
<a name="disconnected_start_test-1"/><a name="548"/>  548: <b>disconnected_start_test</b>(Config) when is_list(Config) -&gt;
<a name="549"/>  549:     {Peer, Node} = spawn_disconnected_node(?FUNCTION_NAME, ?FUNCTION_NAME, Config),
<a name="550"/>  550:     ?assertNot(lists:member(Node, nodes())),
<a name="551"/>  551:     ?assertEqual(ok, peer:call(Peer, gen_server, stop, [?FUNCTION_NAME])),
<a name="552"/>  552:     ?assertMatch({ok, _Pid}, peer:call(Peer, pg, start,[?FUNCTION_NAME])),
<a name="553"/>  553:     ?assertEqual(ok, peer:call(Peer, gen_server, stop, [?FUNCTION_NAME])),
<a name="554"/>  554:     RemotePid = peer:call(Peer, erlang, spawn, [forever()]),
<a name="555"/>  555:     ?assert(is_pid(RemotePid)),
<a name="556"/>  556:     peer:stop(Peer),
<a name="disconnected_start_test-last_expr"/><a name="557"/>  557:     ok.
<a name="558"/>  558: 
<a name="forced_sync-0"/><a name="559"/>  559: <b>forced_sync</b>() -&gt;
<a name="forced_sync-last_expr"/><a name="560"/>  560:     [{doc, &quot;This test was added when lookup_element was erroneously used instead of lookup, crashing pg with badmatch, and it tests rare out-of-order sync operations&quot;}].
<a name="561"/>  561: 
<a name="forced_sync-1"/><a name="562"/>  562: <b>forced_sync</b>(Config) when is_list(Config) -&gt;
<a name="563"/>  563:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="564"/>  564:     Pid = erlang:spawn(forever()),
<a name="565"/>  565:     RemotePid = erlang:spawn(Node, forever()),
<a name="566"/>  566:     Expected = lists:sort([Pid, RemotePid]),
<a name="567"/>  567:     pg:join(?FUNCTION_NAME, one, Pid),
<a name="568"/>  568: 
<a name="569"/>  569:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, one, RemotePid])),
<a name="570"/>  570:     RemoteScopePid = rpc:call(Node, erlang, whereis, [?FUNCTION_NAME]),
<a name="571"/>  571:     ?assert(is_pid(RemoteScopePid)),
<a name="572"/>  572:     %% hohoho, partition!
<a name="573"/>  573:     disconnect_nodes([Node]),
<a name="574"/>  574:     ?assertEqual(true, net_kernel:connect_node(Node)),
<a name="575"/>  575:     ensure_peers_info(?FUNCTION_NAME, [Node]),
<a name="576"/>  576:     ?assertEqual(Expected, lists:sort(pg:get_members(?FUNCTION_NAME, one))),
<a name="577"/>  577: 
<a name="578"/>  578:     %% Do extra sync to make sure any redundant sync message has arrived
<a name="579"/>  579:     %% before we send our fake sync message below.
<a name="580"/>  580:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="581"/>  581: 
<a name="582"/>  582:     %% WARNING: this code uses pg as white-box, exploiting internals,
<a name="583"/>  583:     %%  only to simulate broken 'sync'
<a name="584"/>  584:     %% Fake Groups: one should disappear, one should be replaced, one stays
<a name="585"/>  585:     %% This tests handle_sync function.
<a name="586"/>  586:     FakeGroups = [{one, [RemotePid, RemotePid]}, {?FUNCTION_NAME, [RemotePid, RemotePid]}],
<a name="587"/>  587:     gen_server:cast(?FUNCTION_NAME, {sync, RemoteScopePid, FakeGroups}),
<a name="588"/>  588:     %% ensure it is broken well enough
<a name="589"/>  589:     sync(?FUNCTION_NAME),
<a name="590"/>  590:     ?assertEqual(lists:sort([RemotePid, RemotePid]), lists:sort(pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="591"/>  591:     ?assertEqual(lists:sort([RemotePid, RemotePid, Pid]), lists:sort(pg:get_members(?FUNCTION_NAME, one))),
<a name="592"/>  592:     %% simulate force-sync via 'discover' - ask peer to send sync to us
<a name="593"/>  593:     {?FUNCTION_NAME, Node} ! {discover, whereis(?FUNCTION_NAME)},
<a name="594"/>  594:     sync({?FUNCTION_NAME, Node}),
<a name="595"/>  595:     sync(?FUNCTION_NAME),
<a name="596"/>  596:     ?assertEqual(Expected, lists:sort(pg:get_members(?FUNCTION_NAME, one))),
<a name="597"/>  597:     ?assertEqual([], lists:sort(pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="598"/>  598:     %% and simulate extra sync
<a name="599"/>  599:     sync({?FUNCTION_NAME, Node}),
<a name="600"/>  600:     sync(?FUNCTION_NAME),
<a name="601"/>  601:     ?assertEqual(Expected, lists:sort(pg:get_members(?FUNCTION_NAME, one))),
<a name="602"/>  602: 
<a name="603"/>  603:     peer:stop(Peer),
<a name="forced_sync-last_expr"/><a name="604"/>  604:     ok.
<a name="605"/>  605: 
<a name="group_leave-1"/><a name="606"/>  606: <b>group_leave</b>(Config) when is_list(Config) -&gt;
<a name="607"/>  607:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="608"/>  608:     RemotePid = erlang:spawn(Node, forever()),
<a name="609"/>  609:     Total = lists:duplicate(16, RemotePid),
<a name="610"/>  610:     {Left, Remain} = lists:split(4, Total),
<a name="611"/>  611:     %% join 16 times!
<a name="612"/>  612:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, two, Total])),
<a name="613"/>  613:     ?assertEqual(ok, rpc:call(Node, pg, leave, [?FUNCTION_NAME, two, Left])),
<a name="614"/>  614: 
<a name="615"/>  615:     sync({?FUNCTION_NAME, Node}),
<a name="616"/>  616:     sync(?FUNCTION_NAME),
<a name="617"/>  617:     ?assertEqual(Remain, pg:get_members(?FUNCTION_NAME, two)),
<a name="618"/>  618: 
<a name="619"/>  619:     PgPid = whereis(?FUNCTION_NAME),
<a name="620"/>  620:     1 = erlang:trace(PgPid, true, ['receive']),
<a name="621"/>  621:     peer:stop(Peer),
<a name="622"/>  622:     receive
<a name="623"/>  623:         {trace, PgPid, 'receive', {nodedown, Node}} -&gt; ok
<a name="624"/>  624:     end,
<a name="625"/>  625:     1 = erlang:trace(PgPid, false, ['receive']),
<a name="626"/>  626:     sync(?FUNCTION_NAME),
<a name="627"/>  627:     ?assertEqual([], pg:get_members(?FUNCTION_NAME, two)),
<a name="group_leave-last_expr"/><a name="628"/>  628:     ok.
<a name="629"/>  629: 
<a name="monitor_nonempty_scope-0"/><a name="630"/>  630: <b>monitor_nonempty_scope</b>() -&gt;
<a name="monitor_nonempty_scope-last_expr"/><a name="631"/>  631:     [{doc, &quot;Ensure that monitor_scope returns full map of groups in the scope&quot;}].
<a name="632"/>  632: 
<a name="monitor_nonempty_scope-1"/><a name="633"/>  633: <b>monitor_nonempty_scope</b>(Config) when is_list(Config) -&gt;
<a name="634"/>  634:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="635"/>  635:     Pid = erlang:spawn_link(forever()),
<a name="636"/>  636:     RemotePid = erlang:spawn(Node, forever()),
<a name="637"/>  637:     Expected = lists:sort([Pid, RemotePid]),
<a name="638"/>  638:     pg:join(?FUNCTION_NAME, one, Pid),
<a name="639"/>  639:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, one, RemotePid])),
<a name="640"/>  640:     %% Ensure that initial monitoring request returns current map of groups to pids
<a name="641"/>  641:     {Ref, #{one := Actual} = FullScope} = pg:monitor_scope(?FUNCTION_NAME),
<a name="642"/>  642:     ?assertEqual(Expected, Actual),
<a name="643"/>  643:     %% just in case - check there are no extra groups in that scope
<a name="644"/>  644:     ?assertEqual(1, map_size(FullScope)),
<a name="645"/>  645:     pg:demonitor(?FUNCTION_NAME, Ref),
<a name="646"/>  646:     %% re-check
<a name="647"/>  647:     {_Ref, FullScope} = pg:monitor_scope(?FUNCTION_NAME),
<a name="648"/>  648:     peer:stop(Peer),
<a name="monitor_nonempty_scope-last_expr"/><a name="649"/>  649: <b>    exit</b>(Pid, normal).
<a name="650"/>  650: 
<a name="monitor_scope-0"/><a name="651"/>  651: <b>monitor_scope</b>() -&gt;
<a name="monitor_scope-last_expr"/><a name="652"/>  652:     [{doc, &quot;Tests monitor_scope/1 and demonitor/2&quot;}].
<a name="653"/>  653: 
<a name="monitor_scope-1"/><a name="654"/>  654: <b>monitor_scope</b>(Config) when is_list(Config) -&gt;
<a name="655"/>  655:     %% ensure that demonitoring returns 'false' when monitor is not installed
<a name="656"/>  656:     ?assertEqual(false, pg:demonitor(?FUNCTION_NAME, erlang:make_ref())),
<a name="657"/>  657:     InitialMonitor = fun (Scope) -&gt; {Ref, #{}} = pg:monitor_scope(Scope), Ref end,
<a name="658"/>  658:     SecondMonitor = fun (Scope, Group, Control) -&gt; {Ref, #{Group := [Control]}} = pg:monitor_scope(Scope), Ref end,
<a name="659"/>  659:     %% WHITE BOX: knowing pg state internals - only the original monitor should stay
<a name="660"/>  660:     DownMonitor = fun (Scope, Ref, Self) -&gt;
<a name="661"/>  661:         {state, _, _, _, ScopeMonitors, _, _} = sys:get_state(Scope),
<a name="662"/>  662:         ?assertEqual(#{Ref =&gt; Self}, ScopeMonitors, &quot;pg did not remove DOWNed scope monitor&quot;)
<a name="663"/>  663:                   end,
<a name="monitor_scope-last_expr"/><a name="664"/>  664: <b>    monitor_test_impl</b>(Config, ?FUNCTION_NAME, ?FUNCTION_ARITY, InitialMonitor,
<a name="665"/>  665:                       SecondMonitor, DownMonitor).
<a name="666"/>  666: 
<a name="monitor-1"/><a name="667"/>  667: <b>monitor</b>(Config) when is_list(Config) -&gt;
<a name="668"/>  668:     ExpectedGroup = {?FUNCTION_NAME, ?FUNCTION_ARITY},
<a name="669"/>  669:     InitialMonitor = fun (Scope) -&gt; {Ref, []} = pg:monitor(Scope, ExpectedGroup), Ref end,
<a name="670"/>  670:     SecondMonitor = fun (Scope, Group, Control) -&gt;
<a name="671"/>  671:         {Ref, [Control]} = pg:monitor(Scope, Group), Ref end,
<a name="672"/>  672:     DownMonitor = fun (Scope, Ref, Self) -&gt;
<a name="673"/>  673:         {state, _, _, _, _, GM, MG} = sys:get_state(Scope),
<a name="674"/>  674:         ?assertEqual(#{Ref =&gt; {Self, ExpectedGroup}}, GM, &quot;pg did not remove DOWNed group monitor&quot;),
<a name="675"/>  675:         ?assertEqual(#{ExpectedGroup =&gt; [{Self, Ref}]}, MG, &quot;pg did not remove DOWNed group&quot;)
<a name="676"/>  676:                   end,
<a name="monitor-last_expr"/><a name="677"/>  677: <b>    monitor_test_impl</b>(Config, ?FUNCTION_NAME, ExpectedGroup, InitialMonitor,
<a name="678"/>  678:                       SecondMonitor, DownMonitor).
<a name="679"/>  679: 
<a name="monitor_test_impl-6"/><a name="680"/>  680: <b>monitor_test_impl</b>(Config, Scope, Group, InitialMonitor, SecondMonitor, DownMonitor) -&gt;
<a name="681"/>  681:     Self = self(),
<a name="682"/>  682:     Ref = InitialMonitor(Scope),
<a name="683"/>  683:     %% local join
<a name="684"/>  684:     ?assertEqual(ok, pg:join(Scope, Group, Self)),
<a name="685"/>  685:     wait_message(Ref, join, Group, [Self], &quot;Local&quot;),
<a name="686"/>  686:     %% start second monitor (which has 1 local pid at the start)
<a name="687"/>  687:     ExtraMonitor = spawn_link(fun() -&gt; second_monitor(Scope, Group, Self, SecondMonitor) end),
<a name="688"/>  688:     Ref2 = receive {ExtraMonitor, SecondRef} -&gt; SecondRef end,
<a name="689"/>  689:     %% start a remote node, and a remote monitor
<a name="690"/>  690:     {Peer, Node} = spawn_node(Scope, Config),
<a name="691"/>  691:     ScopePid = whereis(Scope),
<a name="692"/>  692:     %% do not care about the remote monitor, it is started only to check DOWN handling
<a name="693"/>  693:     ThirdMonitor = spawn_link(Node, fun() -&gt; second_monitor(ScopePid, Group, Self, SecondMonitor) end),
<a name="694"/>  694:     Ref3 = receive {ThirdMonitor, ThirdRef} -&gt; ThirdRef end,
<a name="695"/>  695:     %% remote join
<a name="696"/>  696:     RemotePid = erlang:spawn(Node, forever()),
<a name="697"/>  697:     ?assertEqual(ok, rpc:call(Node, pg, join, [Scope, Group, [RemotePid, RemotePid]])),
<a name="698"/>  698:     wait_message(Ref, join, Group, [RemotePid, RemotePid], &quot;Remote&quot;),
<a name="699"/>  699:     %% verify leave event
<a name="700"/>  700:     ?assertEqual([Self], pg:get_local_members(Scope, Group)),
<a name="701"/>  701:     ?assertEqual(ok, pg:leave(Scope, Group, self())),
<a name="702"/>  702:     wait_message(Ref, leave, Group, [Self], &quot;Local&quot;),
<a name="703"/>  703:     %% remote leave
<a name="704"/>  704:     ?assertEqual(ok, rpc:call(Node, pg, leave, [Scope, Group, RemotePid])),
<a name="705"/>  705:     %% flush the local pg scope via remote pg (to ensure local pg finished sending notifications)
<a name="706"/>  706:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="707"/>  707:     wait_message(Ref, leave, Group, [RemotePid], &quot;Remote&quot;),
<a name="708"/>  708:     %% drop the ExtraMonitor - this keeps original and remote monitors
<a name="709"/>  709:     SecondMonMsgs = gen_server:call(ExtraMonitor, flush),
<a name="710"/>  710:     %% inspect the queue, it should contain double remote join, then single local and single remove leave
<a name="711"/>  711:     ExpectedLocalMessages = [
<a name="712"/>  712:         {Ref2, join, Group, [RemotePid, RemotePid]},
<a name="713"/>  713:         {Ref2, leave, Group, [Self]},
<a name="714"/>  714:         {Ref2, leave, Group, [RemotePid]}],
<a name="715"/>  715:     ?assertEqual(ExpectedLocalMessages, SecondMonMsgs, &quot;Local monitor failed&quot;),
<a name="716"/>  716:     %% inspect remote monitor queue
<a name="717"/>  717:     ThirdMonMsgs = gen_server:call(ThirdMonitor, flush),
<a name="718"/>  718:     ExpectedRemoteMessages = [
<a name="719"/>  719:         {Ref3, join, Group, [RemotePid, RemotePid]},
<a name="720"/>  720:         {Ref3, leave, Group, [Self]},
<a name="721"/>  721:         {Ref3, leave, Group, [RemotePid]}],
<a name="722"/>  722:     ?assertEqual(ExpectedRemoteMessages, ThirdMonMsgs, &quot;Remote monitor failed&quot;),
<a name="723"/>  723:     %% remote leave via stop (causes remote monitor to go DOWN)
<a name="724"/>  724:     ok = peer:stop(Peer),
<a name="725"/>  725:     wait_message(Ref, leave, Group, [RemotePid], &quot;Remote stop&quot;),
<a name="726"/>  726:     DownMonitor(Scope, Ref, Self),
<a name="727"/>  727:     %% demonitor
<a name="728"/>  728:     ?assertEqual(ok, pg:demonitor(Scope, Ref)),
<a name="729"/>  729:     ?assertEqual(false, pg:demonitor(Scope, Ref)),
<a name="730"/>  730:     %% ensure messages don't come
<a name="731"/>  731:     ?assertEqual(ok, pg:join(Scope, Group, Self)),
<a name="732"/>  732:     sync(Scope),
<a name="733"/>  733:     %% join should not be here
<a name="monitor_test_impl-last_expr"/><a name="734"/>  734: <b>    receive {Ref, Action, Group, [Self]} -&gt; ?assert</b>(false, lists:concat([&quot;Unexpected &quot;, Action, &quot;event&quot;]))
<a name="735"/>  735:     after 0 -&gt; ok end.
<a name="736"/>  736: 
<a name="wait_message-5"/><a name="737"/>  737: <b>wait_message</b>(Ref, Action, Group, Pids, Msg) -&gt;
<a name="wait_message-last_expr"/><a name="738"/>  738:     receive
<a name="739"/>  739:         {Ref, Action, Group, Pids} -&gt;
<a name="740"/>  740:             ok
<a name="741"/>  741:     after 1000 -&gt;
<a name="742"/>  742:         {messages, Msgs} = process_info(self(), messages),
<a name="743"/>  743:         ct:pal(&quot;Message queue: ~0p&quot;, [Msgs]),
<a name="744"/>  744:         ?assert(false, lists:flatten(io_lib:format(&quot;Expected ~s ~s for ~p&quot;, [Msg, Action, Group])))
<a name="745"/>  745:     end.
<a name="746"/>  746: 
<a name="second_monitor-4"/><a name="747"/>  747: <b>second_monitor</b>(Scope, Group, Control, SecondMonitor) -&gt;
<a name="748"/>  748:     Ref = SecondMonitor(Scope, Group, Control),
<a name="749"/>  749:     Control ! {self(), Ref},
<a name="second_monitor-last_expr"/><a name="750"/>  750: <b>    second_monitor</b>([]).
<a name="751"/>  751: 
<a name="second_monitor-1"/><a name="752"/>  752: <b>second_monitor</b>(Msgs) -&gt;
<a name="second_monitor-last_expr"/><a name="753"/>  753:     receive
<a name="754"/>  754:         {'$gen_call', Reply, flush} -&gt;
<a name="755"/>  755:             gen:reply(Reply, lists:reverse(Msgs));
<a name="756"/>  756:         Msg -&gt;
<a name="757"/>  757:             second_monitor([Msg | Msgs])
<a name="758"/>  758:     end.
<a name="759"/>  759: 
<a name="protocol_upgrade-1"/><a name="760"/>  760: <b>protocol_upgrade</b>(Config) when is_list(Config) -&gt;
<a name="761"/>  761:     Scope = ?FUNCTION_NAME,
<a name="762"/>  762:     Group = ?FUNCTION_NAME,
<a name="763"/>  763:     {Peer, Node} = spawn_node(Scope, Config),
<a name="764"/>  764:     PgPid = rpc:call(Node, erlang, whereis, [Scope]),
<a name="765"/>  765: 
<a name="766"/>  766:     RemotePid = erlang:spawn(Node, forever()),
<a name="767"/>  767:     ok = rpc:call(Node, pg, join, [Scope, Group, RemotePid]),
<a name="768"/>  768: 
<a name="769"/>  769:     %% OTP 26:
<a name="770"/>  770:     %% Just do a white-box test and verify that pg accepts
<a name="771"/>  771:     %% a &quot;future&quot; discover message and replies with a sync.
<a name="772"/>  772:     PgPid ! {discover, self(), &quot;Protocol version (ignore me)&quot;},
<a name="773"/>  773:     {'$gen_cast', {sync, PgPid, [{Group, [RemotePid]}]}} = receive_any(),
<a name="774"/>  774: 
<a name="775"/>  775:     %% stop the peer
<a name="776"/>  776:     peer:stop(Peer),
<a name="protocol_upgrade-last_expr"/><a name="777"/>  777:     ok.
<a name="778"/>  778: 
<a name="779"/>  779: 
<a name="780"/>  780: <i>%%--------------------------------------------------------------------</i>
<a name="781"/>  781: <i>%% Test Helpers - start/stop additional Erlang nodes</i>
<a name="782"/>  782: 
<a name="receive_any-0"/><a name="783"/>  783: <b>receive_any</b>() -&gt;
<a name="receive_any-last_expr"/><a name="784"/>  784:     receive M -&gt; M end.
<a name="785"/>  785: 
<a name="786"/>  786: <i>%% flushes GS (GenServer) queue, ensuring that all prior</i>
<a name="787"/>  787: <i>%%  messages have been processed</i>
<a name="sync-1"/><a name="788"/>  788: <b>sync</b>(GS) -&gt;
<a name="sync-last_expr"/><a name="789"/>  789: <b>    _ = sys:log</b>(GS, get).
<a name="790"/>  790: 
<a name="791"/>  791: <i>%% flushes GS queue from the point of view of a registered process RegName</i>
<a name="792"/>  792: <i>%%  running on the Node.</i>
<a name="sync_via-2"/><a name="793"/>  793: <b>sync_via</b>({RegName, Node}, GS) -&gt;
<a name="794"/>  794:     MyNode = node(),
<a name="795"/>  795:     rpc:call(Node, sys, replace_state,
<a name="796"/>  796:              [RegName, fun (S) -&gt; (catch sys:get_state({GS, MyNode})), S end]);
<a name="797"/>  797: 
<a name="798"/>  798: <i>%% flush remote GS queue from local process RegName</i>
<a name="799"/>  799: <b>sync_via</b>(RegName, {GS, Node}) -&gt;
<a name="sync_via-last_expr"/><a name="800"/>  800: <b>    sys:replace_state</b>(RegName,
<a name="801"/>  801:                       fun (S) -&gt; _R = (catch sys:get_state({GS, Node})),
<a name="802"/>  802:                                  %%io:format(&quot;sync_via: ~p -&gt; R = ~p\n&quot;, [{GS, Node},_R]),
<a name="803"/>  803:                                  S
<a name="804"/>  804:                       end).
<a name="805"/>  805: 
<a name="ensure_peers_info-2"/><a name="806"/>  806: <b>ensure_peers_info</b>(Scope, Nodes) -&gt;
<a name="807"/>  807:     %% Ensures that pg server on local node has gotten info from
<a name="808"/>  808:     %% pg servers on all Peer nodes passed as argument (assuming
<a name="809"/>  809:     %% no connection failures).
<a name="810"/>  810:     %% 
<a name="811"/>  811:     %% This function assumes that all nodeup messages has been
<a name="812"/>  812:     %% delivered to all local recipients (pg server) when called.
<a name="813"/>  813:     %%
<a name="814"/>  814:     %% Note that this relies on current ERTS implementation; not
<a name="815"/>  815:     %% language guarantees.
<a name="816"/>  816:     %%
<a name="817"/>  817: 
<a name="818"/>  818:     sync(Scope),
<a name="819"/>  819:     %% Known: nodeup handled and discover sent to Peer
<a name="820"/>  820: 
<a name="821"/>  821:     lists:foreach(fun (Node) -&gt; sync({Scope, Node}) end, Nodes),
<a name="822"/>  822:     %% Known: nodeup handled by Peers and discover sent to local
<a name="823"/>  823:     %% Known: discover received/handled by Peers and sync sent to local
<a name="824"/>  824:     %% Known: discover received from Peer
<a name="825"/>  825:     %% Known: sync received from Peer
<a name="826"/>  826: 
<a name="827"/>  827:     sync(Scope),
<a name="828"/>  828:     %% Known: discover handled from Peers and sync sent to Peers
<a name="829"/>  829:     %% Known: sync from Peers handled
<a name="ensure_peers_info-last_expr"/><a name="830"/>  830:     ok.
<a name="831"/>  831: 
<a name="832"/>  832: <b>-ifdef</b>(CURRENTLY_UNUSED_BUT_SERVES_AS_DOC).
<a name="833"/>  833: 
<a name="834"/>  834: ensure_synced(Scope, Nodes) -&gt;
<a name="835"/>  835:     %% Ensures that the pg server on local node have synced
<a name="836"/>  836:     %% with pg servers on all Peer nodes (assuming no connection
<a name="837"/>  837:     %% failures).
<a name="838"/>  838:     %% 
<a name="839"/>  839:     %% This function assumes that all nodeup messages has been
<a name="840"/>  840:     %% delivered to all local recipients (pg server) when called.
<a name="841"/>  841:     %%
<a name="842"/>  842:     %% Note that this relies on current ERTS implementation; not
<a name="843"/>  843:     %% language guarantees.
<a name="844"/>  844:     %%
<a name="845"/>  845:     ensure_peer_info(Scope, Node),
<a name="846"/>  846:     %% Known: local has gotten info from all Peers
<a name="847"/>  847:     %% Known: discover from Peers handled and sync sent to Peers
<a name="848"/>  848:     lists:foreach(fun (Node) -&gt; sync({Scope, Node}) end, Nodes),
<a name="849"/>  849:     %% Known: sync from local handled by Peers
<a name="850"/>  850:     ok.
<a name="851"/>  851: 
<a name="852"/>  852: -endif.
<a name="853"/>  853: 
<a name="disconnect_nodes-1"/><a name="854"/>  854: <b>disconnect_nodes</b>(Nodes) -&gt;
<a name="855"/>  855:     %% The following is not a language guarantee, but internal
<a name="856"/>  856:     %% knowledge about current implementation of ERTS and pg.
<a name="857"/>  857:     %%
<a name="858"/>  858:     %% The pg server reacts on 'DOWN's via process monitors of
<a name="859"/>  859:     %% its peers. These are delivered before 'nodedown's from
<a name="860"/>  860:     %% net_kernel:monitor_nodes(). That is, by waiting for
<a name="861"/>  861:     %% 'nodedown' from net_kernel:monitor_nodes() we know that
<a name="862"/>  862:     %% the 'DOWN' has been delivered to the pg server.
<a name="863"/>  863:     %%
<a name="864"/>  864:     %% We do this in a separate process to avoid stray
<a name="865"/>  865:     %% nodeup/nodedown messages in the test process after
<a name="866"/>  866:     %% the operation...
<a name="867"/>  867:     F = fun () -&gt;
<a name="868"/>  868:                 ok = net_kernel:monitor_nodes(true),
<a name="869"/>  869:                 lists:foreach(fun (Node) -&gt;
<a name="870"/>  870:                                       true = erlang:disconnect_node(Node)
<a name="871"/>  871:                               end,
<a name="872"/>  872:                               Nodes),
<a name="873"/>  873:                 lists:foreach(fun (Node) -&gt;
<a name="874"/>  874:                                       receive {nodedown, Node} -&gt; ok end
<a name="875"/>  875:                               end,
<a name="876"/>  876:                               Nodes)
<a name="877"/>  877:         end,
<a name="878"/>  878:     {Pid, Mon} = spawn_monitor(F),
<a name="879"/>  879:     receive
<a name="880"/>  880:         {'DOWN', Mon, process, Pid, Reason} -&gt;
<a name="881"/>  881:             ?assertEqual(normal, Reason)
<a name="882"/>  882:     end,
<a name="disconnect_nodes-last_expr"/><a name="883"/>  883:     ok.
<a name="884"/>  884: 
<a name="885"/>  885: <i>%% @doc Kills process Pid and waits for it to exit using monitor,</i>
<a name="886"/>  886: <i>%%      and yields after (for 1 ms).</i>
<a name="887"/>  887: <b>-spec stop_proc</b>(pid()) -&gt; ok.
<a name="stop_proc-1"/><a name="888"/>  888: <b>stop_proc</b>(Pid) -&gt;
<a name="889"/>  889:     monitor(process, Pid),
<a name="890"/>  890:     erlang:exit(Pid, kill),
<a name="stop_proc-last_expr"/><a name="891"/>  891:     receive
<a name="892"/>  892:         {'DOWN', _MRef, process, Pid, _Info} -&gt;
<a name="893"/>  893:             timer:sleep(1)
<a name="894"/>  894:     end.
<a name="895"/>  895: 
<a name="forever-0"/><a name="896"/>  896: <b>forever</b>() -&gt;
<a name="897"/>  897:     Parent = self(),
<a name="forever-last_expr"/><a name="898"/>  898: <b>    fun</b>() -&gt;
<a name="899"/>  899:             %% forever() is used both locally and on a remote node,
<a name="900"/>  900:             %% if used locally, we want to terminate when the
<a name="901"/>  901:             %% parent terminates in order to not leak process to
<a name="902"/>  902:             %% later test cases
<a name="903"/>  903:             Ref = monitor(process,Parent),
<a name="904"/>  904:             receive
<a name="905"/>  905:                 {'DOWN',Ref,_,_,_} when node() =:= node(Parent) -&gt;
<a name="906"/>  906:                     ok
<a name="907"/>  907:             end
<a name="908"/>  908:     end.
<a name="909"/>  909: 
<a name="910"/>  910: <i>%% Spawn a sleeping process on remote node.</i>
<a name="911"/>  911: <i>%% Works on older nodes also without having to run any specially compiled code.</i>
<a name="spawn_sleeper_at-1"/><a name="912"/>  912: <b>spawn_sleeper_at</b>(Node) when Node =/= node() -&gt;
<a name="spawn_sleeper_at-last_expr"/><a name="913"/>  913: <b>    spawn</b>(Node, erlang, hibernate, [?MODULE,dummy,[]]).
<a name="914"/>  914: 
<a name="sleeper_mfa-0"/><a name="915"/>  915: <b>sleeper_mfa</b>() -&gt;
<a name="sleeper_mfa-last_expr"/><a name="916"/>  916:     [erlang, hibernate, [?MODULE,dummy,[]]].
<a name="917"/>  917: 
<a name="spawn_node-2"/><a name="918"/>  918: <b>spawn_node</b>(TestCase, Config) -&gt;
<a name="919"/>  919:     {Peer, Node} = spawn_disconnected_node(TestCase, TestCase, Config),
<a name="920"/>  920:     true = net_kernel:connect_node(Node),
<a name="spawn_node-last_expr"/><a name="921"/>  921:     {Peer, Node}.
<a name="922"/>  922: 
<a name="spawn_disconnected_node-3"/><a name="923"/>  923: <b>spawn_disconnected_node</b>(Scope, TestCase, Config) -&gt;
<a name="924"/>  924:     Opts = #{name =&gt; ?CT_PEER_NAME(TestCase),
<a name="925"/>  925:              connection =&gt; 0,
<a name="926"/>  926:              args =&gt; [&quot;-connect_all&quot;, &quot;false&quot;,
<a name="927"/>  927:                       &quot;-kernel&quot;, &quot;dist_auto_connect&quot;, &quot;never&quot;]},
<a name="928"/>  928:     {ok, Peer, Node} =
<a name="929"/>  929:         case proplists:get_value(otp_release, Config) of
<a name="930"/>  930:             undefined -&gt;
<a name="931"/>  931:                 ?CT_PEER(Opts);
<a name="932"/>  932:             Release -&gt;
<a name="933"/>  933:                 TcPrivDir = filename:join(proplists:get_value(priv_dir, Config),
<a name="934"/>  934:                                           TestCase),
<a name="935"/>  935:                 ok = ensure_dir(TcPrivDir),
<a name="936"/>  936:                 ?CT_PEER_REL(Opts, Release, TcPrivDir)
<a name="937"/>  937:         end,
<a name="938"/>  938:     {ok, _Pid} = peer:call(Peer, pg, start, [Scope]),
<a name="spawn_disconnected_node-last_expr"/><a name="939"/>  939:     {Peer, Node}.
<a name="940"/>  940: 
<a name="ensure_dir-1"/><a name="941"/>  941: <b>ensure_dir</b>(Dir) -&gt;
<a name="ensure_dir-last_expr"/><a name="942"/>  942: <b>    case file:make_dir</b>(Dir) of
<a name="943"/>  943:         ok -&gt; ok;
<a name="944"/>  944:         {error, eexist} -&gt; ok;
<a name="945"/>  945:         E -&gt; E
<a name="946"/>  946:     end.
<a name="947"/>  947: 
<a name="948"/>  948: 
<a name="949"/>  949: <i>%%--------------------------------------------------------------------</i>
<a name="950"/>  950: <i>%% Debug Helpers</i>
<a name="951"/>  951: 
<a name="952"/>  952: <i>%% Add test cases here to enable 'receive' trace of the local pg process</i>
<a name="traced_testcases-0"/><a name="traced_testcases-last_expr"/><a name="953"/>  953: <b>traced_testcases</b>() -&gt; [].
<a name="954"/>  954: 
<a name="trace_start-3"/><a name="955"/>  955: <b>trace_start</b>(TestCase, Config, Tracee) -&gt;
<a name="trace_start-last_expr"/><a name="956"/>  956: <b>    case lists:member</b>(TestCase, traced_testcases()) of
<a name="957"/>  957:         true -&gt;
<a name="958"/>  958:             Tracer = spawn_link(fun() -&gt; tracer() end),
<a name="959"/>  959:             1 = erlang:trace(Tracee, true, ['receive', {tracer, Tracer}, timestamp]),
<a name="960"/>  960:             [{tracer, Tracer} | Config];
<a name="961"/>  961:         false -&gt;
<a name="962"/>  962:             Config
<a name="963"/>  963:     end.
<a name="964"/>  964: 
<a name="trace_end-1"/><a name="965"/>  965: <b>trace_end</b>(Config) -&gt;
<a name="trace_end-last_expr"/><a name="966"/>  966: <b>    case proplists:get_value</b>(tracer, Config) of
<a name="967"/>  967:         undefined -&gt; ok;
<a name="968"/>  968:         Tracer -&gt;
<a name="969"/>  969:             Mon = erlang:monitor(process, Tracer),
<a name="970"/>  970:             Tracer ! flush,
<a name="971"/>  971:             normal = receive
<a name="972"/>  972:                          {'DOWN', Mon, process, Tracer, R} -&gt; R
<a name="973"/>  973:                      end
<a name="974"/>  974:     end.
<a name="975"/>  975: 
<a name="tracer-0"/><a name="976"/>  976: <b>tracer</b>() -&gt;
<a name="977"/>  977:     receive flush -&gt; ok end,
<a name="978"/>  978:     io:format(&quot;Flush trace messages:\n&quot;),
<a name="tracer-last_expr"/><a name="979"/>  979: <b>    tracer_flush</b>().
<a name="980"/>  980: 
<a name="tracer_flush-0"/><a name="981"/>  981: <b>tracer_flush</b>() -&gt;
<a name="tracer_flush-last_expr"/><a name="982"/>  982:     receive M -&gt;
<a name="983"/>  983:             io:format(&quot;~p\n&quot;, [M]),
<a name="984"/>  984:             tracer_flush()
<a name="985"/>  985:     after 0 -&gt;
<a name="986"/>  986:             io:format(&quot;Flush done.\n&quot;)
<a name="987"/>  987:     end.
</pre>
</body>
</html>
