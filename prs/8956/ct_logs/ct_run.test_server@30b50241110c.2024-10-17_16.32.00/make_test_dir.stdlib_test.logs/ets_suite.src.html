<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/lib/stdlib/make_test_dir/stdlib_test/ets_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%</i>
<a name="2"/>    2: <i>%% %CopyrightBegin%</i>
<a name="3"/>    3: <i>%%</i>
<a name="4"/>    4: <i>%% Copyright Ericsson AB 1996-2024. All Rights Reserved.</i>
<a name="5"/>    5: <i>%%</i>
<a name="6"/>    6: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="7"/>    7: <i>%% you may not use this file except in compliance with the License.</i>
<a name="8"/>    8: <i>%% You may obtain a copy of the License at</i>
<a name="9"/>    9: <i>%%</i>
<a name="10"/>   10: <i>%%     http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="11"/>   11: <i>%%</i>
<a name="12"/>   12: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="13"/>   13: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="14"/>   14: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="15"/>   15: <i>%% See the License for the specific language governing permissions and</i>
<a name="16"/>   16: <i>%% limitations under the License.</i>
<a name="17"/>   17: <i>%%</i>
<a name="18"/>   18: <i>%% %CopyrightEnd%</i>
<a name="19"/>   19: <i>%%</i>
<a name="20"/>   20: <b>-module</b>(ets_SUITE).
<a name="21"/>   21: 
<a name="22"/>   22: <b>-export</b>([all/0, suite/0,groups/0,init_per_suite/1, end_per_suite/1,
<a name="23"/>   23: 	 init_per_group/2,end_per_group/2]).
<a name="24"/>   24: <b>-export</b>([default/1,setbag/1,badnew/1,verybadnew/1,named/1,keypos2/1,
<a name="25"/>   25: 	 privacy/1]).
<a name="26"/>   26: <b>-export</b>([empty/1,badinsert/1]).
<a name="27"/>   27: <b>-export</b>([badlookup/1,lookup_order/1]).
<a name="28"/>   28: <b>-export</b>([delete_elem/1,delete_tab/1,delete_large_tab/1,
<a name="29"/>   29: 	 delete_large_named_table/1,
<a name="30"/>   30: 	 evil_delete/1,baddelete/1,match_delete/1,table_leak/1]).
<a name="31"/>   31: <b>-export</b>([match_delete3/1]).
<a name="32"/>   32: <b>-export</b>([firstnext/1,firstnext_concurrent/1]).
<a name="33"/>   33: <b>-export</b>([firstnext_lookup/1,firstnext_lookup_concurrent/1]).
<a name="34"/>   34: <b>-export</b>([slot/1]).
<a name="35"/>   35: <b>-export</b>([hash_clash/1]).
<a name="36"/>   36: <b>-export</b>([match1/1, match2/1, match_object/1, match_object2/1]).
<a name="37"/>   37: <b>-export</b>([dups/1, misc1/1, safe_fixtable/1, info/1, tab2list/1]).
<a name="38"/>   38: <b>-export</b>([info_binary_stress/1]).
<a name="39"/>   39: <b>-export</b>([info_whereis_busy/1]).
<a name="40"/>   40: <b>-export</b>([insert_trap_delete/1, insert_trap_rename/1]).
<a name="41"/>   41: <b>-export</b>([tab2file/1, tab2file2/1, tabfile_ext1/1,
<a name="42"/>   42: 	 tabfile_ext2/1, tabfile_ext3/1, tabfile_ext4/1, badfile/1]).
<a name="43"/>   43: <b>-export</b>([heavy_lookup/1, heavy_lookup_element/1, heavy_concurrent/1]).
<a name="44"/>   44: <b>-export</b>([lookup_element_mult/1, lookup_element_default/1]).
<a name="45"/>   45: <b>-export</b>([foldl_ordered/1, foldr_ordered/1, foldl/1, foldr/1, fold_empty/1,
<a name="46"/>   46:          fold_badarg/1]).
<a name="47"/>   47: <b>-export</b>([t_delete_object/1, t_init_table/1, t_whitebox/1,
<a name="48"/>   48:          select_bound_chunk/1, t_delete_all_objects/1, t_test_ms/1,
<a name="49"/>   49:          t_delete_all_objects_trap/1,
<a name="50"/>   50: 	 t_select_delete/1,t_select_replace/1,t_select_replace_next_bug/1,
<a name="51"/>   51:          t_select_pam_stack_overflow_bug/1,
<a name="52"/>   52:          t_select_flatmap_term_copy_bug/1,
<a name="53"/>   53:          t_select_hashmap_term_copy_bug/1,
<a name="54"/>   54:          t_ets_dets/1]).
<a name="55"/>   55: <b>-export</b>([t_insert_list/1, t_insert_list_bag/1, t_insert_list_duplicate_bag/1,
<a name="56"/>   56:          t_insert_list_set/1, t_insert_list_delete_set/1,
<a name="57"/>   57:          t_insert_list_parallel/1, t_insert_list_delete_parallel/1,
<a name="58"/>   58:          t_insert_list_kill_process/1,
<a name="59"/>   59:          t_insert_list_insert_order_preserved/1]).
<a name="60"/>   60: <b>-export</b>([test_table_size_concurrency/1,test_table_memory_concurrency/1,
<a name="61"/>   61:          test_delete_table_while_size_snapshot/1, test_delete_table_while_size_snapshot_helper/1,
<a name="62"/>   62:          test_decentralized_counters_setting/1]).
<a name="63"/>   63: 
<a name="64"/>   64: <b>-export</b>([ordered/1, ordered_match/1, interface_equality/1,
<a name="65"/>   65: 	 fixtable_next/1, fixtable_iter_bag/1,
<a name="66"/>   66:          fixtable_insert/1, rename/1, rename_unnamed/1, evil_rename/1,
<a name="67"/>   67: 	 update_element/1, update_element_default/1, update_counter/1, evil_update_counter/1, partly_bound/1, match_heavy/1]).
<a name="68"/>   68: <b>-export</b>([update_counter_with_default/1]).
<a name="69"/>   69: <b>-export</b>([update_counter_with_default_bad_pos/1]).
<a name="70"/>   70: <b>-export</b>([update_counter_table_growth/1]).
<a name="71"/>   71: <b>-export</b>([member/1]).
<a name="72"/>   72: <b>-export</b>([memory/1]).
<a name="73"/>   73: <b>-export</b>([select_fail/1]).
<a name="74"/>   74: <b>-export</b>([t_insert_new/1]).
<a name="75"/>   75: <b>-export</b>([t_repair_continuation/1]).
<a name="76"/>   76: <b>-export</b>([t_match_spec_run/1]).
<a name="77"/>   77: <b>-export</b>([t_bucket_disappears/1]).
<a name="78"/>   78: <b>-export</b>([t_named_select/1]).
<a name="79"/>   79: <b>-export</b>([select_fixtab_owner_change/1]).
<a name="80"/>   80: <b>-export</b>([otp_5340/1]).
<a name="81"/>   81: <b>-export</b>([otp_6338/1]).
<a name="82"/>   82: <b>-export</b>([otp_6842_select_1000/1]).
<a name="83"/>   83: <b>-export</b>([select_mbuf_trapping/1]).
<a name="84"/>   84: <b>-export</b>([otp_7665/1]).
<a name="85"/>   85: <b>-export</b>([meta_wb/1]).
<a name="86"/>   86: <b>-export</b>([grow_shrink/1, grow_pseudo_deleted/1, shrink_pseudo_deleted/1]).
<a name="87"/>   87: <b>-export</b>([meta_lookup_unnamed_read/1, meta_lookup_unnamed_write/1,
<a name="88"/>   88: 	 meta_lookup_named_read/1, meta_lookup_named_write/1,
<a name="89"/>   89: 	 meta_newdel_unnamed/1, meta_newdel_named/1]).
<a name="90"/>   90: <b>-export</b>([smp_insert/1, smp_fixed_delete/1, smp_unfix_fix/1, smp_select_delete/1,
<a name="91"/>   91:          smp_ordered_iteration/1,
<a name="92"/>   92:          smp_select_replace/1, otp_8166/1, otp_8732/1, delete_unfix_race/1]).
<a name="93"/>   93: <b>-export</b>([throughput_benchmark/0,
<a name="94"/>   94:          throughput_benchmark/1,
<a name="95"/>   95:          test_throughput_benchmark/1,
<a name="96"/>   96:          long_throughput_benchmark/1,
<a name="97"/>   97:          lookup_catree_par_vs_seq_init_benchmark/0]).
<a name="98"/>   98: <b>-export</b>([exit_large_table_owner/1,
<a name="99"/>   99: 	 exit_many_large_table_owner/1,
<a name="100"/>  100: 	 exit_many_tables_owner/1,
<a name="101"/>  101: 	 exit_many_many_tables_owner/1]).
<a name="102"/>  102: <b>-export</b>([write_concurrency/1, heir/1, give_away/1, setopts/1]).
<a name="103"/>  103: <b>-export</b>([bad_table/1, types/1]).
<a name="104"/>  104: <b>-export</b>([otp_9932/1]).
<a name="105"/>  105: <b>-export</b>([otp_9423/1]).
<a name="106"/>  106: <b>-export</b>([otp_10182/1]).
<a name="107"/>  107: <b>-export</b>([compress_magic_ref/1]).
<a name="108"/>  108: <b>-export</b>([ets_all/1]).
<a name="109"/>  109: <b>-export</b>([massive_ets_all/1]).
<a name="110"/>  110: <b>-export</b>([take/1]).
<a name="111"/>  111: <b>-export</b>([whereis_table/1]).
<a name="112"/>  112: <b>-export</b>([ms_excessive_nesting/1]).
<a name="113"/>  113: <b>-export</b>([error_info/1]).
<a name="114"/>  114: <b>-export</b>([bound_maps/1]).
<a name="115"/>  115: 
<a name="116"/>  116: <b>-export</b>([init_per_testcase/2, end_per_testcase/2]).
<a name="117"/>  117: <i>%% Convenience for manual testing</i>
<a name="118"/>  118: <b>-export</b>([random_test/0]).
<a name="119"/>  119: 
<a name="120"/>  120: <b>-export</b>([t_select_reverse/1]).
<a name="121"/>  121: 
<a name="122"/>  122: <b>-include_lib</b>(&quot;stdlib/include/ms_transform.hrl&quot;). % ets:fun2ms
<a name="123"/>  123: <b>-include_lib</b>(&quot;stdlib/include/assert.hrl&quot;).
<a name="124"/>  124: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="125"/>  125: <b>-include_lib</b>(&quot;common_test/include/ct_event.hrl&quot;).
<a name="126"/>  126: 
<a name="127"/>  127: <b>-define</b>(m(A,B), assert_eq(A,B)).
<a name="128"/>  128: <b>-define</b>(heap_binary_size, 64).
<a name="129"/>  129: 
<a name="init_per_testcase-2"/><a name="130"/>  130: <b>init_per_testcase</b>(Case, Config) -&gt;
<a name="131"/>  131:     rand:seed(default),
<a name="132"/>  132:     io:format(&quot;*** SEED: ~p ***\n&quot;, [rand:export_seed()]),
<a name="133"/>  133:     start_spawn_logger(),
<a name="134"/>  134:     wait_for_test_procs(), %% Ensure previous case cleaned up
<a name="init_per_testcase-last_expr"/><a name="135"/>  135:     [{test_case, Case} | Config].
<a name="136"/>  136: 
<a name="end_per_testcase-2"/><a name="137"/>  137: <b>end_per_testcase</b>(_Func, _Config) -&gt;
<a name="end_per_testcase-last_expr"/><a name="138"/>  138: <b>    wait_for_test_procs</b>(true).
<a name="139"/>  139: 
<a name="140"/>  140: 
<a name="141"/>  141: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="142"/>  142: 
<a name="suite-0"/><a name="143"/>  143: <b>suite</b>() -&gt;
<a name="suite-last_expr"/><a name="144"/>  144:     [{ct_hooks,[ts_install_cth]},
<a name="145"/>  145:      {timetrap,{minutes,30}}].
<a name="146"/>  146: 
<a name="all-0"/><a name="147"/>  147: <b>all</b>() -&gt;
<a name="all-last_expr"/><a name="148"/>  148:     [{group, new}, {group, insert}, {group, lookup},
<a name="149"/>  149:      {group, delete}, firstnext, firstnext_concurrent,
<a name="150"/>  150:      firstnext_lookup, firstnext_lookup_concurrent, slot, hash_clash,
<a name="151"/>  151:      {group, match}, t_match_spec_run,
<a name="152"/>  152:      {group, lookup_element}, {group, misc}, {group, files},
<a name="153"/>  153:      {group, heavy}, {group, insert_list}, ordered, ordered_match,
<a name="154"/>  154:      interface_equality, fixtable_next, fixtable_iter_bag, fixtable_insert,
<a name="155"/>  155:      rename, rename_unnamed, evil_rename, update_element, update_element_default,
<a name="156"/>  156:      update_counter, evil_update_counter,
<a name="157"/>  157:      update_counter_with_default,
<a name="158"/>  158:      update_counter_with_default_bad_pos,
<a name="159"/>  159:      partly_bound,
<a name="160"/>  160:      update_counter_table_growth,
<a name="161"/>  161:      match_heavy, {group, fold}, member, t_delete_object,
<a name="162"/>  162:      select_bound_chunk,
<a name="163"/>  163:      t_init_table, t_whitebox, t_delete_all_objects,
<a name="164"/>  164:      t_delete_all_objects_trap,
<a name="165"/>  165:      t_test_ms, t_select_delete, t_select_replace,
<a name="166"/>  166:      t_select_replace_next_bug,
<a name="167"/>  167:      t_select_pam_stack_overflow_bug,
<a name="168"/>  168:      t_select_flatmap_term_copy_bug,
<a name="169"/>  169:      t_select_hashmap_term_copy_bug,
<a name="170"/>  170:      t_ets_dets, memory, t_select_reverse, t_bucket_disappears,
<a name="171"/>  171:      t_named_select, select_fixtab_owner_change,
<a name="172"/>  172:      select_fail, t_insert_new, t_repair_continuation,
<a name="173"/>  173:      otp_5340, otp_6338, otp_6842_select_1000, otp_7665,
<a name="174"/>  174:      select_mbuf_trapping,
<a name="175"/>  175:      otp_8732, meta_wb, grow_shrink, grow_pseudo_deleted,
<a name="176"/>  176:      shrink_pseudo_deleted, {group, meta_smp}, smp_insert,
<a name="177"/>  177:      smp_fixed_delete, smp_unfix_fix, smp_select_replace,
<a name="178"/>  178:      smp_ordered_iteration,
<a name="179"/>  179:      smp_select_delete, otp_8166, exit_large_table_owner,
<a name="180"/>  180:      exit_many_large_table_owner, exit_many_tables_owner,
<a name="181"/>  181:      exit_many_many_tables_owner, write_concurrency, heir,
<a name="182"/>  182:      give_away, setopts, bad_table, types,
<a name="183"/>  183:      otp_10182,
<a name="184"/>  184:      otp_9932,
<a name="185"/>  185:      otp_9423,
<a name="186"/>  186:      compress_magic_ref,
<a name="187"/>  187:      ets_all,
<a name="188"/>  188:      massive_ets_all,
<a name="189"/>  189:      take,
<a name="190"/>  190:      whereis_table,
<a name="191"/>  191:      delete_unfix_race,
<a name="192"/>  192:      test_throughput_benchmark,
<a name="193"/>  193:      {group, benchmark},
<a name="194"/>  194:      test_table_size_concurrency,
<a name="195"/>  195:      test_table_memory_concurrency,
<a name="196"/>  196:      test_delete_table_while_size_snapshot,
<a name="197"/>  197:      test_decentralized_counters_setting,
<a name="198"/>  198:      ms_excessive_nesting,
<a name="199"/>  199:      error_info,
<a name="200"/>  200:      bound_maps
<a name="201"/>  201:     ].
<a name="202"/>  202: 
<a name="203"/>  203: 
<a name="groups-0"/><a name="204"/>  204: <b>groups</b>() -&gt;
<a name="groups-last_expr"/><a name="205"/>  205:     [{new, [],
<a name="206"/>  206:       [default, setbag, badnew, verybadnew, named, keypos2,
<a name="207"/>  207:        privacy]},
<a name="208"/>  208:      {insert, [], [empty, badinsert]},
<a name="209"/>  209:      {lookup, [], [badlookup, lookup_order]},
<a name="210"/>  210:      {lookup_element, [], [lookup_element_mult, lookup_element_default]},
<a name="211"/>  211:      {delete, [],
<a name="212"/>  212:       [delete_elem, delete_tab, delete_large_tab,
<a name="213"/>  213:        delete_large_named_table, evil_delete, table_leak,
<a name="214"/>  214:        baddelete, match_delete, match_delete3]},
<a name="215"/>  215:      {match, [],
<a name="216"/>  216:       [match1, match2, match_object, match_object2]},
<a name="217"/>  217:      {misc, [],
<a name="218"/>  218:       [misc1, safe_fixtable, info, info_binary_stress, info_whereis_busy, dups, tab2list]},
<a name="219"/>  219:      {files, [],
<a name="220"/>  220:       [tab2file, tab2file2, tabfile_ext1,
<a name="221"/>  221:        tabfile_ext2, tabfile_ext3, tabfile_ext4, badfile]},
<a name="222"/>  222:      {heavy, [],
<a name="223"/>  223:       [heavy_lookup, heavy_lookup_element, heavy_concurrent]},
<a name="224"/>  224:      {fold, [],
<a name="225"/>  225:       [foldl_ordered, foldr_ordered, foldl, foldr,
<a name="226"/>  226:        fold_empty, fold_badarg]},
<a name="227"/>  227:      {meta_smp, [],
<a name="228"/>  228:       [meta_lookup_unnamed_read, meta_lookup_unnamed_write,
<a name="229"/>  229:        meta_lookup_named_read, meta_lookup_named_write,
<a name="230"/>  230:        meta_newdel_unnamed, meta_newdel_named]},
<a name="231"/>  231:      {benchmark, [],
<a name="232"/>  232:       [long_throughput_benchmark]},
<a name="233"/>  233:      {insert_list, [],
<a name="234"/>  234:       [t_insert_list, t_insert_list_set, t_insert_list_bag,
<a name="235"/>  235:        t_insert_list_duplicate_bag, t_insert_list_delete_set,
<a name="236"/>  236:        t_insert_list_parallel, t_insert_list_delete_parallel,
<a name="237"/>  237:        t_insert_list_kill_process,
<a name="238"/>  238:        t_insert_list_insert_order_preserved,
<a name="239"/>  239:        insert_trap_delete,
<a name="240"/>  240:        insert_trap_rename]}].
<a name="241"/>  241: 
<a name="init_per_suite-1"/><a name="242"/>  242: <b>init_per_suite</b>(Config) -&gt;
<a name="243"/>  243:     erts_debug:set_internal_state(available_internal_state, true),
<a name="init_per_suite-last_expr"/><a name="244"/>  244: <b>    case erts_debug:set_internal_state</b>(ets_force_trap, true) of
<a name="245"/>  245:         ok -&gt;
<a name="246"/>  246:             [{ets_force_trap, true} | Config];
<a name="247"/>  247:         notsup -&gt;
<a name="248"/>  248:             Config
<a name="249"/>  249:     end.
<a name="250"/>  250: 
<a name="end_per_suite-1"/><a name="251"/>  251: <b>end_per_suite</b>(_Config) -&gt;
<a name="252"/>  252:     stop_spawn_logger(),
<a name="253"/>  253:     erts_debug:set_internal_state(ets_force_trap, false),
<a name="254"/>  254:     catch erts_debug:set_internal_state(available_internal_state, false),
<a name="end_per_suite-last_expr"/><a name="255"/>  255:     ok.
<a name="256"/>  256: 
<a name="init_per_group-2"/><a name="257"/>  257: <b>init_per_group</b>(benchmark, Config) -&gt;
<a name="258"/>  258:     P = self(),
<a name="259"/>  259:     %% Spawn owner of ETS table that is alive until end_per_group is run
<a name="260"/>  260:     EtsProcess =
<a name="261"/>  261:         spawn(
<a name="262"/>  262:           fun()-&gt;
<a name="263"/>  263:                   Tab = ets:new(ets_benchmark_result_summary_tab, [public]),
<a name="264"/>  264:                   P ! {the_table, Tab},
<a name="265"/>  265:                   receive
<a name="266"/>  266:                       kill -&gt; ok
<a name="267"/>  267:                   end
<a name="268"/>  268:           end),
<a name="269"/>  269:     Tab = receive {the_table, T} -&gt; T end,
<a name="270"/>  270:     CounterNames = [nr_of_benchmarks,
<a name="271"/>  271:                     total_throughput,
<a name="272"/>  272:                     nr_of_set_benchmarks,
<a name="273"/>  273:                     total_throughput_set,
<a name="274"/>  274:                     nr_of_ordered_set_benchmarks,
<a name="275"/>  275:                     total_throughput_ordered_set],
<a name="276"/>  276:     lists:foreach(fun(CtrName) -&gt;
<a name="277"/>  277:                           ets:insert(Tab, {CtrName, 0.0})
<a name="278"/>  278:                   end,
<a name="279"/>  279:                   CounterNames),
<a name="280"/>  280:     [{ets_benchmark_result_summary_tab, Tab},
<a name="281"/>  281:      {ets_benchmark_result_summary_tab_process, EtsProcess} | Config];
<a name="282"/>  282: <b>init_per_group</b>(_GroupName, Config) -&gt;
<a name="init_per_group-last_expr"/><a name="283"/>  283:     Config.
<a name="284"/>  284: 
<a name="end_per_group-2"/><a name="285"/>  285: <b>end_per_group</b>(benchmark, Config) -&gt;
<a name="286"/>  286:     T = proplists:get_value(ets_benchmark_result_summary_tab, Config),
<a name="287"/>  287:     EtsProcess = proplists:get_value(ets_benchmark_result_summary_tab_process, Config),
<a name="288"/>  288:     Report =
<a name="289"/>  289:         fun(NOfBenchmarksCtr, TotThroughputCtr, Name) -&gt;
<a name="290"/>  290:                 NBench = ets:lookup_element(T, NOfBenchmarksCtr, 2),
<a name="291"/>  291:                 Average = if
<a name="292"/>  292:                     NBench == 0 -&gt; 0;
<a name="293"/>  293:                     true -&gt; ets:lookup_element(T, TotThroughputCtr, 2) / NBench
<a name="294"/>  294:                 end,
<a name="295"/>  295:                 io:format(&quot;~p ~p~n&quot;, [Name, Average]),
<a name="296"/>  296:                 ct_event:notify(
<a name="297"/>  297:                   #event{name = benchmark_data,
<a name="298"/>  298:                          data = [{suite,&quot;ets_bench&quot;},
<a name="299"/>  299:                                  {name, Name},
<a name="300"/>  300:                                  {value, Average}]})
<a name="301"/>  301:         end,
<a name="302"/>  302:     Report(nr_of_benchmarks,
<a name="303"/>  303:            total_throughput,
<a name="304"/>  304:            &quot;Average Throughput&quot;),
<a name="305"/>  305:     Report(nr_of_set_benchmarks,
<a name="306"/>  306:            total_throughput_set,
<a name="307"/>  307:            &quot;Average Throughput Set&quot;),
<a name="308"/>  308:     Report(nr_of_ordered_set_benchmarks,
<a name="309"/>  309:            total_throughput_ordered_set,
<a name="310"/>  310:            &quot;Average Throughput Ordered Set&quot;),
<a name="311"/>  311:     ets:delete(T),
<a name="312"/>  312:     EtsProcess ! kill,
<a name="313"/>  313:     Config;
<a name="314"/>  314: <b>end_per_group</b>(_GroupName, Config) -&gt;
<a name="end_per_group-last_expr"/><a name="315"/>  315:     Config.
<a name="316"/>  316: 
<a name="317"/>  317: 
<a name="318"/>  318: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="319"/>  319: 
<a name="320"/>  320: <i>%% Test that a disappearing bucket during select of a non-fixed table works.</i>
<a name="t_bucket_disappears-1"/><a name="321"/>  321: <b>t_bucket_disappears</b>(Config) when is_list(Config) -&gt;
<a name="t_bucket_disappears-last_expr"/><a name="322"/>  322: <b>    repeat_for_opts</b>(fun t_bucket_disappears_do/1).
<a name="323"/>  323: 
<a name="t_bucket_disappears_do-1"/><a name="324"/>  324: <b>t_bucket_disappears_do</b>(Opts) -&gt;
<a name="325"/>  325:     EtsMem = etsmem(),
<a name="326"/>  326:     ets_new(abcd, [named_table, public, {keypos, 2} | Opts]),
<a name="327"/>  327:     ets:insert(abcd, {abcd,1,2}),
<a name="328"/>  328:     ets:insert(abcd, {abcd,2,2}),
<a name="329"/>  329:     ets:insert(abcd, {abcd,3,2}),
<a name="330"/>  330:     {_, Cont} = ets:select(abcd, [{{'_', '$1', '_'},
<a name="331"/>  331: 				   [{'&lt;', '$1', {const, 10}}],
<a name="332"/>  332: 				   ['$1']}], 1),
<a name="333"/>  333:     ets:delete(abcd, 2),
<a name="334"/>  334:     ets:select(Cont),
<a name="335"/>  335:     true = ets:delete(abcd),
<a name="t_bucket_disappears_do-last_expr"/><a name="336"/>  336: <b>    verify_etsmem</b>(EtsMem).
<a name="337"/>  337: 
<a name="338"/>  338: <i>%% OTP-21: Test that select/1 fails if named table was deleted and recreated</i>
<a name="339"/>  339: <i>%%         and succeeds if table was renamed.</i>
<a name="t_named_select-1"/><a name="340"/>  340: <b>t_named_select</b>(_Config) -&gt;
<a name="t_named_select-last_expr"/><a name="341"/>  341: <b>    repeat_for_opts</b>(fun t_named_select_do/1).
<a name="342"/>  342: 
<a name="t_named_select_do-1"/><a name="343"/>  343: <b>t_named_select_do</b>(Opts) -&gt;
<a name="344"/>  344:     EtsMem = etsmem(),
<a name="345"/>  345:     T = t_name_tid_select,
<a name="346"/>  346:     ets_new(T, [named_table | Opts]),
<a name="347"/>  347:     ets:insert(T, {1,11}),
<a name="348"/>  348:     ets:insert(T, {2,22}),
<a name="349"/>  349:     ets:insert(T, {3,33}),
<a name="350"/>  350:     MS = [{{'$1', 22}, [], ['$1']}],
<a name="351"/>  351:     {[2], Cont1} = ets:select(T, MS, 1),
<a name="352"/>  352:     ets:delete(T),
<a name="353"/>  353:     {'EXIT',{badarg,_}} = (catch ets:select(Cont1)),
<a name="354"/>  354:     ets_new(T, [named_table | Opts]),
<a name="355"/>  355:     {'EXIT',{badarg,_}} = (catch ets:select(Cont1)),
<a name="356"/>  356: 
<a name="357"/>  357:     true = ets:insert_new(T, {1,22}),
<a name="358"/>  358:     true = ets:insert_new(T, {2,22}),
<a name="359"/>  359:     true = ets:insert_new(T, {4,22}),
<a name="360"/>  360:     {[A,B], Cont2} = ets:select(T, MS, 2),
<a name="361"/>  361:     ets:rename(T, abcd),
<a name="362"/>  362:     {[C], '$end_of_table'} = ets:select(Cont2),
<a name="363"/>  363:     7 = A + B + C,
<a name="364"/>  364: 
<a name="365"/>  365:     true = ets:delete(abcd),
<a name="t_named_select_do-last_expr"/><a name="366"/>  366: <b>    verify_etsmem</b>(EtsMem).
<a name="367"/>  367: 
<a name="368"/>  368: 
<a name="369"/>  369: <i>%% Verify select and friends release fixtab as they should</i>
<a name="370"/>  370: <i>%% even when owneship is changed between traps.</i>
<a name="select_fixtab_owner_change-1"/><a name="371"/>  371: <b>select_fixtab_owner_change</b>(_Config) -&gt;
<a name="372"/>  372:     T = ets:new(xxx, [protected]),
<a name="373"/>  373:     NKeys = 2000,
<a name="374"/>  374:     [ets:insert(T,{K,K band 7}) || K &lt;- lists:seq(1,NKeys)],
<a name="375"/>  375: 
<a name="376"/>  376:     %% Buddy and Papa will ping-pong table ownership between them
<a name="377"/>  377:     %% and the aim is to give Buddy the table when he is
<a name="378"/>  378:     %% in the middle of a yielding select* call.
<a name="379"/>  379:     {Buddy,_} = spawn_opt(fun() -&gt; sfoc_buddy_loop(T, 1, undefined) end,
<a name="380"/>  380:                           [link,monitor]),
<a name="381"/>  381: 
<a name="382"/>  382:     sfoc_papa_loop(T, Buddy),
<a name="383"/>  383: 
<a name="384"/>  384:     receive {'DOWN', _, process, Buddy, _} -&gt; ok end,
<a name="385"/>  385:     ets:delete(T),
<a name="select_fixtab_owner_change-last_expr"/><a name="386"/>  386:     ok.
<a name="387"/>  387: 
<a name="sfoc_buddy_loop-3"/><a name="388"/>  388: <b>sfoc_buddy_loop</b>(T, I, State0) -&gt;
<a name="sfoc_buddy_loop-last_expr"/><a name="389"/>  389:     receive
<a name="390"/>  390:         {'ETS-TRANSFER', T, Papa, _} -&gt;
<a name="391"/>  391:             ets:give_away(T, Papa, State0),
<a name="392"/>  392:             case State0 of
<a name="393"/>  393:                 done -&gt;
<a name="394"/>  394:                     ok;
<a name="395"/>  395:                 _ -&gt;
<a name="396"/>  396:                     State1 = sfoc_traverse(T, I, State0),
<a name="397"/>  397:                     %% Verify no fixation left
<a name="398"/>  398:                     {I, false} = {I, ets:info(T, safe_fixed_monotonic_time)},
<a name="399"/>  399:                     sfoc_buddy_loop(T, I+1, State1)
<a name="400"/>  400:             end
<a name="401"/>  401:     end.
<a name="402"/>  402: 
<a name="sfoc_papa_loop-2"/><a name="403"/>  403: <b>sfoc_papa_loop</b>(T, Buddy) -&gt;
<a name="404"/>  404:     ets:give_away(T, Buddy, &quot;Catch!&quot;),
<a name="sfoc_papa_loop-last_expr"/><a name="405"/>  405:     receive
<a name="406"/>  406:         {'ETS-TRANSFER', T, Buddy, State} -&gt;
<a name="407"/>  407:             case State of
<a name="408"/>  408:                 done -&gt;
<a name="409"/>  409:                     ok;
<a name="410"/>  410:                 _ -&gt;
<a name="411"/>  411:                     sfoc_papa_loop(T, Buddy)
<a name="412"/>  412:             end
<a name="413"/>  413:     end.
<a name="414"/>  414: 
<a name="sfoc_traverse-3"/><a name="415"/>  415: <b>sfoc_traverse</b>(T, 1, S) -&gt;
<a name="416"/>  416:     ets:select(T, [{{'$1',7}, [], ['$1']}]), S;
<a name="417"/>  417: <b>sfoc_traverse</b>(T, 2, S) -&gt;
<a name="418"/>  418:     0 = ets:select_count(T, [{{'$1',7}, [], [false]}]), S;
<a name="419"/>  419: <b>sfoc_traverse</b>(T, 3, _) -&gt;
<a name="420"/>  420:     Limit = ets:info(T, size) div 2,
<a name="421"/>  421:     {_, Continuation} = ets:select(T, [{{'$1',7}, [], ['$1']}],
<a name="422"/>  422:                                    Limit),
<a name="423"/>  423:     Continuation;
<a name="424"/>  424: <b>sfoc_traverse</b>(_T, 4, Continuation) -&gt;
<a name="425"/>  425:     _ = ets:select(Continuation),
<a name="sfoc_traverse-last_expr"/><a name="426"/>  426:     done.
<a name="427"/>  427: 
<a name="428"/>  428: <i>%% Check ets:match_spec_run/2.</i>
<a name="t_match_spec_run-1"/><a name="429"/>  429: <b>t_match_spec_run</b>(Config) when is_list(Config) -&gt;
<a name="430"/>  430:     ct:timetrap({minutes,30}), %% valgrind needs a lot
<a name="431"/>  431:     init_externals(),
<a name="432"/>  432:     EtsMem = etsmem(),
<a name="433"/>  433: 
<a name="434"/>  434:     t_match_spec_run_test([{1},{2},{3}],
<a name="435"/>  435: 			  [{{'$1'},[{'&gt;','$1',1}],['$1']}],
<a name="436"/>  436: 			  [2,3]),
<a name="437"/>  437: 
<a name="438"/>  438:     Huge = [{X} || X &lt;- lists:seq(1,2500)],
<a name="439"/>  439:     L = lists:seq(2476,2500),
<a name="440"/>  440:     t_match_spec_run_test(Huge, [{{'$1'},[{'&gt;','$1',2475}],['$1']}], L),
<a name="441"/>  441: 
<a name="442"/>  442:     L2 = [{X*16#FFFFFFF} || X &lt;- L],
<a name="443"/>  443:     t_match_spec_run_test(Huge,
<a name="444"/>  444: 			  [{{'$1'}, [{'&gt;','$1',2475}], [{{{'*','$1',16#FFFFFFF}}}]}],
<a name="445"/>  445: 			  L2),
<a name="446"/>  446: 
<a name="447"/>  447:     t_match_spec_run_test(Huge, [{{'$1'}, [{'=:=',{'rem','$1',500},0}], ['$1']}],
<a name="448"/>  448: 			  [500,1000,1500,2000,2500]),
<a name="449"/>  449: 
<a name="450"/>  450:     %% More matching fun with several match clauses and guards,
<a name="451"/>  451:     %% applied to a variety of terms.
<a name="452"/>  452:     Fun = fun(Term) -&gt;
<a name="453"/>  453: 		  CTerm = {const, Term},
<a name="454"/>  454: 
<a name="455"/>  455: 		  N_List = [{Term, &quot;0&quot;, &quot;v-element&quot;},
<a name="456"/>  456: 			    {&quot;=hidden_node&quot;, &quot;0&quot;, Term},
<a name="457"/>  457: 			    {&quot;0&quot;, Term, Term},
<a name="458"/>  458: 			    {&quot;something&quot;, Term, &quot;something else&quot;},
<a name="459"/>  459: 			    {&quot;guard and res&quot;, Term, 872346},
<a name="460"/>  460: 			    {Term, {'and',Term,'again'}, 3.14},
<a name="461"/>  461: 			    {Term, {'and',Term,'again'}, &quot;m&amp;g&quot;},
<a name="462"/>  462: 			    {Term, {'and',Term,'again'}, &quot;m&amp;g&amp;r&quot;},
<a name="463"/>  463: 			    {[{second,Term}, 'and', &quot;tail&quot;], Term, ['and',&quot;tail&quot;]}],
<a name="464"/>  464: 
<a name="465"/>  465: 		  N_MS = [{{'$1','$2','$3'},
<a name="466"/>  466: 			   [{'=:=','$1',CTerm}, {'=:=','$2',{const,&quot;0&quot;}}],
<a name="467"/>  467: 			   [{{&quot;Guard only for $1&quot;,'$3'}}]},
<a name="468"/>  468: 
<a name="469"/>  469: 			  {{'$3','$1','$4'},
<a name="470"/>  470: 			   [{'=:=','$3',&quot;=hidden_node&quot;}, {'=:=','$1',{const,&quot;0&quot;}}],
<a name="471"/>  471: 			   [{{&quot;Result only for $4&quot;,'$4'}}]},
<a name="472"/>  472: 
<a name="473"/>  473: 			  {{'$2','$1','$1'},
<a name="474"/>  474: 			   [{'=:=','$2',{const,&quot;0&quot;}}],
<a name="475"/>  475: 			   [{{&quot;Match only for $1&quot;,'$2'}}]},
<a name="476"/>  476: 
<a name="477"/>  477: 			  {{'$2',Term,['$3'|'_']},
<a name="478"/>  478: 			   [{is_list,'$2'},{'=:=','$3',$s}],
<a name="479"/>  479: 			   [{{&quot;Matching term&quot;,'$2'}}]},
<a name="480"/>  480: 
<a name="481"/>  481: 			  {{'$1','$2',872346},
<a name="482"/>  482: 			   [{'=:=','$2',CTerm}, {is_list,'$1'}],
<a name="483"/>  483: 			   [{{&quot;Guard and result&quot;,'$2'}}]},
<a name="484"/>  484: 
<a name="485"/>  485: 			  {{'$1', {'and','$1','again'}, '$2'},
<a name="486"/>  486: 			   [{is_float,'$2'}],
<a name="487"/>  487: 			   [{{&quot;Match and result&quot;,'$1'}}]},
<a name="488"/>  488: 
<a name="489"/>  489: 			  {{'$1', {'and','$1','again'}, '$2'},
<a name="490"/>  490: 			   [{'=:=','$1',CTerm}, {'=:=', '$2', &quot;m&amp;g&quot;}],
<a name="491"/>  491: 			   [{{&quot;Match and guard&quot;,'$2'}}]},
<a name="492"/>  492: 
<a name="493"/>  493: 			  {{'$1', {'and','$1','again'}, &quot;m&amp;g&amp;r&quot;},
<a name="494"/>  494: 			   [{'=:=','$1',CTerm}],
<a name="495"/>  495: 			   [{{&quot;Match, guard and result&quot;,'$1'}}]},
<a name="496"/>  496: 
<a name="497"/>  497: 			  {{'$1', '$2', '$3'},
<a name="498"/>  498: 			   [{'=:=','$1',[{{second,'$2'}} | '$3']}],
<a name="499"/>  499: 			   [{{&quot;Building guard&quot;}}]}
<a name="500"/>  500: 			 ],
<a name="501"/>  501: 
<a name="502"/>  502: 		  N_Result = [{&quot;Guard only for $1&quot;, &quot;v-element&quot;},
<a name="503"/>  503: 			      {&quot;Result only for $4&quot;, Term},
<a name="504"/>  504: 			      {&quot;Match only for $1&quot;, &quot;0&quot;},
<a name="505"/>  505: 			      {&quot;Matching term&quot;,&quot;something&quot;},
<a name="506"/>  506: 			      {&quot;Guard and result&quot;,Term},
<a name="507"/>  507: 			      {&quot;Match and result&quot;,Term},
<a name="508"/>  508: 			      {&quot;Match and guard&quot;,&quot;m&amp;g&quot;},
<a name="509"/>  509: 			      {&quot;Match, guard and result&quot;,Term},
<a name="510"/>  510: 			      {&quot;Building guard&quot;}],
<a name="511"/>  511: 
<a name="512"/>  512: 		  F = fun(N_MS_Perm) -&gt;
<a name="513"/>  513: 			      t_match_spec_run_test(N_List, N_MS_Perm, N_Result)
<a name="514"/>  514: 		      end,
<a name="515"/>  515: 		  repeat_for_permutations(F, N_MS)
<a name="516"/>  516: 	  end,
<a name="517"/>  517:     test_terms(Fun, skip_refc_check),
<a name="518"/>  518: 
<a name="t_match_spec_run-last_expr"/><a name="519"/>  519: <b>    verify_etsmem</b>(EtsMem).
<a name="520"/>  520: 
<a name="t_match_spec_run_test-3"/><a name="521"/>  521: <b>t_match_spec_run_test</b>(List, MS, Result) -&gt;
<a name="522"/>  522: 
<a name="523"/>  523:     %%io:format(&quot;ms = ~p\n&quot;,[MS]),
<a name="524"/>  524: 
<a name="525"/>  525:     ?m(Result, ets:match_spec_run(List, ets:match_spec_compile(MS))),
<a name="526"/>  526: 
<a name="527"/>  527:     %% Check that ets:select agree
<a name="528"/>  528:     Tab = ets:new(xxx, [bag]),
<a name="529"/>  529:     ets:insert(Tab, List),
<a name="530"/>  530:     SRes = lists:sort(Result),
<a name="531"/>  531:     ?m(SRes, lists:sort(ets:select(Tab, MS))),
<a name="532"/>  532:     ets:delete(Tab),
<a name="533"/>  533: 
<a name="534"/>  534:     %% Check that tracing agree
<a name="535"/>  535:     Self = self(),
<a name="536"/>  536:     {Tracee, MonRef} = my_spawn_monitor(fun() -&gt; ms_tracee(Self, List) end),
<a name="537"/>  537:     receive {Tracee, ready} -&gt; ok end,
<a name="538"/>  538: 
<a name="539"/>  539:     MST = lists:map(fun(Clause) -&gt; ms_clause_ets_to_trace(Clause) end, MS),
<a name="540"/>  540: 
<a name="541"/>  541:     %%io:format(&quot;MS = ~p\nMST= ~p\n&quot;,[MS,MST]),
<a name="542"/>  542: 
<a name="543"/>  543:     erlang:trace_pattern({?MODULE,ms_tracee_dummy,'_'}, MST , [local]),
<a name="544"/>  544:     erlang:trace(Tracee, true, [call]),
<a name="545"/>  545:     Tracee ! start,
<a name="546"/>  546:     TRes = ms_tracer_collect(Tracee, MonRef, []),
<a name="547"/>  547:     case TRes of
<a name="548"/>  548: 	SRes -&gt; ok;
<a name="549"/>  549: 	_ -&gt;
<a name="550"/>  550: 	    io:format(&quot;TRACE MATCH FAILED\n&quot;),
<a name="551"/>  551: 	    io:format(&quot;Input = ~p\nMST = ~p\nExpected = ~p\nGot = ~p\n&quot;, [List, MST, SRes, TRes]),
<a name="552"/>  552: 	    ct:fail(&quot;TRACE MATCH FAILED&quot;)
<a name="553"/>  553:     end,
<a name="t_match_spec_run_test-last_expr"/><a name="554"/>  554:     ok.
<a name="555"/>  555: 
<a name="556"/>  556: 
<a name="557"/>  557: 
<a name="ms_tracer_collect-3"/><a name="558"/>  558: <b>ms_tracer_collect</b>(Tracee, Ref, Acc) -&gt;
<a name="ms_tracer_collect-last_expr"/><a name="559"/>  559:     receive
<a name="560"/>  560: 	{trace, Tracee, call, _Args, [Msg]} -&gt;
<a name="561"/>  561: 	    ms_tracer_collect(Tracee, Ref, [Msg | Acc]);
<a name="562"/>  562: 
<a name="563"/>  563: 	{'DOWN', Ref, process, Tracee, _} -&gt;
<a name="564"/>  564: 	    TDRef = erlang:trace_delivered(Tracee),
<a name="565"/>  565: 	    ms_tracer_collect(Tracee, TDRef, Acc);
<a name="566"/>  566: 
<a name="567"/>  567: 	{trace_delivered, Tracee, Ref} -&gt;
<a name="568"/>  568: 	    lists:sort(Acc);
<a name="569"/>  569: 
<a name="570"/>  570: 	Other -&gt;
<a name="571"/>  571: 	    io:format(&quot;Unexpected message = ~p\n&quot;, [Other]),
<a name="572"/>  572: 	    ct:fail(&quot;Unexpected tracer msg&quot;)
<a name="573"/>  573:     end.
<a name="574"/>  574: 
<a name="575"/>  575: 
<a name="ms_tracee-2"/><a name="576"/>  576: <b>ms_tracee</b>(Parent, CallArgList) -&gt;
<a name="577"/>  577:     Parent ! {self(), ready},
<a name="578"/>  578:     receive start -&gt; ok end,
<a name="579"/>  579:     F = fun({A1}) -&gt;
<a name="580"/>  580:                 ms_tracee_dummy(A1);
<a name="581"/>  581:            ({A1,A2}) -&gt;
<a name="582"/>  582:                    ms_tracee_dummy(A1, A2);
<a name="583"/>  583:            ({A1,A2,A3}) -&gt;
<a name="584"/>  584:                 ms_tracee_dummy(A1, A2, A3);
<a name="585"/>  585:            ({A1,A2,A3,A4}) -&gt;
<a name="586"/>  586:                 ms_tracee_dummy(A1, A2, A3, A4)
<a name="587"/>  587:         end,
<a name="ms_tracee-last_expr"/><a name="588"/>  588: <b>    lists:foreach</b>(F, CallArgList).
<a name="589"/>  589: 
<a name="ms_tracee_dummy-1"/><a name="ms_tracee_dummy-last_expr"/><a name="590"/>  590: <b>ms_tracee_dummy</b>(_) -&gt; ok.
<a name="ms_tracee_dummy-2"/><a name="ms_tracee_dummy-last_expr"/><a name="591"/>  591: <b>ms_tracee_dummy</b>(_,_) -&gt; ok.
<a name="ms_tracee_dummy-3"/><a name="ms_tracee_dummy-last_expr"/><a name="592"/>  592: <b>ms_tracee_dummy</b>(_,_,_) -&gt; ok.
<a name="ms_tracee_dummy-4"/><a name="ms_tracee_dummy-last_expr"/><a name="593"/>  593: <b>ms_tracee_dummy</b>(_,_,_,_) -&gt; ok.
<a name="594"/>  594: 
<a name="ms_clause_ets_to_trace-1"/><a name="595"/>  595: <b>ms_clause_ets_to_trace</b>({Head, Guard, Body}) -&gt;
<a name="ms_clause_ets_to_trace-last_expr"/><a name="596"/>  596: <b>    {tuple_to_list</b>(Head), Guard, [{message, Body}]}.
<a name="597"/>  597: 
<a name="assert_eq-2"/><a name="598"/>  598: <b>assert_eq</b>(A,A) -&gt; ok;
<a name="599"/>  599: <b>assert_eq</b>(A,B) -&gt;
<a name="600"/>  600:     io:format(&quot;FAILED MATCH:\n~p\n =/=\n~p\n&quot;,[A,B]),
<a name="assert_eq-last_expr"/><a name="601"/>  601: <b>    ct:fail</b>(&quot;assert_eq failed&quot;).
<a name="602"/>  602: 
<a name="603"/>  603: 
<a name="604"/>  604: <i>%% Test ets:repair_continuation/2.</i>
<a name="t_repair_continuation-1"/><a name="605"/>  605: <b>t_repair_continuation</b>(Config) when is_list(Config) -&gt;
<a name="t_repair_continuation-last_expr"/><a name="606"/>  606: <b>    repeat_for_opts</b>(fun t_repair_continuation_do/1).
<a name="607"/>  607: 
<a name="608"/>  608: 
<a name="t_repair_continuation_do-1"/><a name="609"/>  609: <b>t_repair_continuation_do</b>(OptsIn) -&gt;
<a name="610"/>  610:     EtsMem = etsmem(),
<a name="611"/>  611:     MS = [{'_',[],[true]}],
<a name="612"/>  612:     MS2 = [{{{'$1','_'},'_'},[],['$1']}],
<a name="613"/>  613:     run_if_valid_opts(
<a name="614"/>  614:       [ordered_set|OptsIn],
<a name="615"/>  615:       fun(Opts) -&gt;
<a name="616"/>  616: 	     T = ets_new(x, Opts),
<a name="617"/>  617: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt; ets:insert(T,{N,N}), F(N-1,F) end,
<a name="618"/>  618: 	     F(1000,F),
<a name="619"/>  619: 	     {_,C} = ets:select(T,MS,5),
<a name="620"/>  620: 	     C2 = erlang:setelement(5,C,&lt;&lt;&gt;&gt;),
<a name="621"/>  621: 	     {'EXIT',{badarg,_}} = (catch ets:select(C2)),
<a name="622"/>  622: 	     C3 = ets:repair_continuation(C2,MS),
<a name="623"/>  623: 	     {[true,true,true,true,true],_} = ets:select(C3),
<a name="624"/>  624: 	     {[true,true,true,true,true],_} = ets:select(C),
<a name="625"/>  625: 	     true = ets:delete(T)
<a name="626"/>  626:       end),
<a name="627"/>  627:     run_if_valid_opts(
<a name="628"/>  628:       [ordered_set|OptsIn],
<a name="629"/>  629:       fun(Opts) -&gt;
<a name="630"/>  630: 	     T = ets_new(x, Opts),
<a name="631"/>  631: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt; ets:insert(T,{N,N}), F(N-1,F) end,
<a name="632"/>  632: 	     F(1000,F),
<a name="633"/>  633: 	     {_,C} = ets:select(T,MS,1001),
<a name="634"/>  634: 	     C = '$end_of_table',
<a name="635"/>  635: 	     C3 = ets:repair_continuation(C,MS),
<a name="636"/>  636: 	     '$end_of_table' = ets:select(C3),
<a name="637"/>  637: 	     '$end_of_table' = ets:select(C),
<a name="638"/>  638: 	     true = ets:delete(T)
<a name="639"/>  639:       end),
<a name="640"/>  640: 
<a name="641"/>  641:     run_if_valid_opts(
<a name="642"/>  642:       [ordered_set|OptsIn],
<a name="643"/>  643:       fun(Opts) -&gt;
<a name="644"/>  644: 	     T = ets_new(x, Opts),
<a name="645"/>  645: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt;
<a name="646"/>  646: 			 ets:insert(T,{integer_to_list(N),N}),
<a name="647"/>  647: 			 F(N-1,F)
<a name="648"/>  648: 		 end,
<a name="649"/>  649: 	     F(1000,F),
<a name="650"/>  650: 	     {_,C} = ets:select(T,MS,5),
<a name="651"/>  651: 	     C2 = erlang:setelement(5,C,&lt;&lt;&gt;&gt;),
<a name="652"/>  652: 	     {'EXIT',{badarg,_}} = (catch ets:select(C2)),
<a name="653"/>  653: 	     C3 = ets:repair_continuation(C2,MS),
<a name="654"/>  654: 	     {[true,true,true,true,true],_} = ets:select(C3),
<a name="655"/>  655: 	     {[true,true,true,true,true],_} = ets:select(C),
<a name="656"/>  656: 	     true = ets:delete(T)
<a name="657"/>  657:       end),
<a name="658"/>  658:     run_if_valid_opts(
<a name="659"/>  659:       [ordered_set|OptsIn],
<a name="660"/>  660:       fun(Opts) -&gt;
<a name="661"/>  661: 	     T = ets_new(x, Opts),
<a name="662"/>  662: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt;
<a name="663"/>  663: 			 ets:insert(T,{{integer_to_list(N),N},N}),
<a name="664"/>  664: 			 F(N-1,F)
<a name="665"/>  665: 		 end,
<a name="666"/>  666: 	     F(1000,F),
<a name="667"/>  667: 	     {_,C} = ets:select(T,MS2,5),
<a name="668"/>  668: 	     C2 = erlang:setelement(5,C,&lt;&lt;&gt;&gt;),
<a name="669"/>  669: 	     {'EXIT',{badarg,_}} = (catch ets:select(C2)),
<a name="670"/>  670: 	     C3 = ets:repair_continuation(C2,MS2),
<a name="671"/>  671: 	     {[_,_,_,_,_],_} = ets:select(C3),
<a name="672"/>  672: 	     {[_,_,_,_,_],_} = ets:select(C),
<a name="673"/>  673: 	     true = ets:delete(T)
<a name="674"/>  674:       end),
<a name="675"/>  675: 
<a name="676"/>  676:     (fun() -&gt;
<a name="677"/>  677: 	     T = ets_new(x,[set|OptsIn]),
<a name="678"/>  678: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt;
<a name="679"/>  679: 			 ets:insert(T,{N,N}),
<a name="680"/>  680: 			 F(N-1,F)
<a name="681"/>  681: 		 end,
<a name="682"/>  682: 	     F(1000,F),
<a name="683"/>  683: 	     {_,C} = ets:select(T,MS,5),
<a name="684"/>  684: 	     C2 = erlang:setelement(4,C,&lt;&lt;&gt;&gt;),
<a name="685"/>  685: 	     {'EXIT',{badarg,_}} = (catch ets:select(C2)),
<a name="686"/>  686: 	     C3 = ets:repair_continuation(C2,MS),
<a name="687"/>  687: 	     {[true,true,true,true,true],_} = ets:select(C3),
<a name="688"/>  688: 	     {[true,true,true,true,true],_} = ets:select(C),
<a name="689"/>  689: 	     true = ets:delete(T)
<a name="690"/>  690:      end)(),
<a name="691"/>  691:     (fun() -&gt;
<a name="692"/>  692: 	     T = ets_new(x,[set|OptsIn]),
<a name="693"/>  693: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt;
<a name="694"/>  694: 			 ets:insert(T,{integer_to_list(N),N}),
<a name="695"/>  695: 			 F(N-1,F)
<a name="696"/>  696: 		 end,
<a name="697"/>  697: 	     F(1000,F),
<a name="698"/>  698: 	     {_,C} = ets:select(T,MS,5),
<a name="699"/>  699: 	     C2 = erlang:setelement(4,C,&lt;&lt;&gt;&gt;),
<a name="700"/>  700: 	     {'EXIT',{badarg,_}} = (catch ets:select(C2)),
<a name="701"/>  701: 	     C3 = ets:repair_continuation(C2,MS),
<a name="702"/>  702: 	     {[true,true,true,true,true],_} = ets:select(C3),
<a name="703"/>  703: 	     {[true,true,true,true,true],_} = ets:select(C),
<a name="704"/>  704: 	     true = ets:delete(T)
<a name="705"/>  705:      end)(),
<a name="706"/>  706:     (fun() -&gt;
<a name="707"/>  707: 	     T = ets_new(x,[bag|OptsIn]),
<a name="708"/>  708: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt;
<a name="709"/>  709: 			 ets:insert(T,{integer_to_list(N),N}),
<a name="710"/>  710: 			 F(N-1,F)
<a name="711"/>  711: 		 end,
<a name="712"/>  712: 	     F(1000,F),
<a name="713"/>  713: 	     {_,C} = ets:select(T,MS,5),
<a name="714"/>  714: 	     C2 = erlang:setelement(4,C,&lt;&lt;&gt;&gt;),
<a name="715"/>  715: 	     {'EXIT',{badarg,_}} = (catch ets:select(C2)),
<a name="716"/>  716: 	     C3 = ets:repair_continuation(C2,MS),
<a name="717"/>  717: 	     {[true,true,true,true,true],_} = ets:select(C3),
<a name="718"/>  718: 	     {[true,true,true,true,true],_} = ets:select(C),
<a name="719"/>  719: 	     true = ets:delete(T)
<a name="720"/>  720:      end)(),
<a name="721"/>  721:     (fun() -&gt;
<a name="722"/>  722: 	     T = ets_new(x,[duplicate_bag|OptsIn]),
<a name="723"/>  723: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt;
<a name="724"/>  724: 			 ets:insert(T,{integer_to_list(N),N}),
<a name="725"/>  725: 			 F(N-1,F)
<a name="726"/>  726: 		 end,
<a name="727"/>  727: 	     F(1000,F),
<a name="728"/>  728: 	     {_,C} = ets:select(T,MS,5),
<a name="729"/>  729: 	     C2 = erlang:setelement(4,C,&lt;&lt;&gt;&gt;),
<a name="730"/>  730: 	     {'EXIT',{badarg,_}} = (catch ets:select(C2)),
<a name="731"/>  731: 	     C3 = ets:repair_continuation(C2,MS),
<a name="732"/>  732: 	     {[true,true,true,true,true],_} = ets:select(C3),
<a name="733"/>  733: 	     {[true,true,true,true,true],_} = ets:select(C),
<a name="734"/>  734: 	     true = ets:delete(T)
<a name="735"/>  735:      end)(),
<a name="736"/>  736:     false = ets:is_compiled_ms(&lt;&lt;&gt;&gt;),
<a name="737"/>  737:     true = ets:is_compiled_ms(ets:match_spec_compile(MS)),
<a name="t_repair_continuation_do-last_expr"/><a name="738"/>  738: <b>    verify_etsmem</b>(EtsMem).
<a name="739"/>  739: 
<a name="740"/>  740: 
<a name="741"/>  741: <i>%% Test correct default vaules of a new ets table.</i>
<a name="default-1"/><a name="742"/>  742: <b>default</b>(Config) when is_list(Config) -&gt;
<a name="743"/>  743:     %% Default should be set,protected
<a name="744"/>  744:     EtsMem = etsmem(),
<a name="745"/>  745:     Def = ets_new(def,[]),
<a name="746"/>  746:     set = ets:info(Def,type),
<a name="747"/>  747:     protected = ets:info(Def,protection),
<a name="748"/>  748:     Compressed = erlang:system_info(ets_always_compress),
<a name="749"/>  749:     Compressed = ets:info(Def,compressed),
<a name="750"/>  750:     Self = self(),
<a name="751"/>  751:     Self = ets:info(Def,owner),
<a name="752"/>  752:     none = ets:info(Def, heir),
<a name="753"/>  753:     false = ets:info(Def,named_table),
<a name="754"/>  754:     ets:delete(Def),
<a name="default-last_expr"/><a name="755"/>  755: <b>    verify_etsmem</b>(EtsMem).
<a name="756"/>  756: 
<a name="757"/>  757: <i>%% Test that select fails even if nothing can match.</i>
<a name="select_fail-1"/><a name="758"/>  758: <b>select_fail</b>(Config) when is_list(Config) -&gt;
<a name="759"/>  759:     EtsMem = etsmem(),
<a name="760"/>  760:     repeat_for_opts(fun select_fail_do/1,
<a name="761"/>  761:                     [all_types,write_concurrency]),
<a name="select_fail-last_expr"/><a name="762"/>  762: <b>    verify_etsmem</b>(EtsMem).
<a name="763"/>  763: 
<a name="select_fail_do-1"/><a name="764"/>  764: <b>select_fail_do</b>(Opts) -&gt;
<a name="765"/>  765:     T = ets_new(x,Opts),
<a name="766"/>  766:     ets:insert(T,{a,a}),
<a name="767"/>  767:     case (catch
<a name="768"/>  768: 	      ets:select(T,[{{a,'_'},[],[{snuffla}]}])) of
<a name="769"/>  769: 	{'EXIT',{badarg,_}} -&gt;
<a name="770"/>  770: 	    ok;
<a name="771"/>  771: 	Else0 -&gt;
<a name="772"/>  772: 	    exit({type,ets:info(T,type),
<a name="773"/>  773: 		  expected,'EXIT',got,Else0})
<a name="774"/>  774:     end,
<a name="775"/>  775:     case (catch
<a name="776"/>  776: 	      ets:select(T,[{{b,'_'},[],[{snuffla}]}])) of
<a name="777"/>  777: 	{'EXIT',{badarg,_}} -&gt;
<a name="778"/>  778: 	    ok;
<a name="779"/>  779: 	Else1 -&gt;
<a name="780"/>  780: 	    exit({type,ets:info(T,type),
<a name="781"/>  781: 		  expected,'EXIT',got,Else1})
<a name="782"/>  782:     end,
<a name="select_fail_do-last_expr"/><a name="783"/>  783: <b>    ets:delete</b>(T).
<a name="784"/>  784: 
<a name="785"/>  785: 
<a name="786"/>  786: <b>-define</b>(S(T),ets:info(T,memory)).
<a name="787"/>  787: 
<a name="788"/>  788: <i>%% Whitebox test of ets:info(X, memory).</i>
<a name="memory-1"/><a name="789"/>  789: <b>memory</b>(Config) when is_list(Config) -&gt;
<a name="790"/>  790:     ok = chk_normal_tab_struct_size(),
<a name="791"/>  791:     repeat_for_opts(fun memory_do/1, [compressed]),
<a name="memory-last_expr"/><a name="792"/>  792: <b>    catch erts_debug:set_internal_state</b>(available_internal_state, false).
<a name="793"/>  793: 
<a name="memory_do-1"/><a name="794"/>  794: <b>memory_do</b>(Opts) -&gt;
<a name="795"/>  795:     L = [T1,T2,T3,T4] = fill_sets_int(1000,Opts),
<a name="796"/>  796:     XR1 = case mem_mode(T1) of
<a name="797"/>  797: 	      {normal,_} -&gt;     {13836, 15346, 15346, 15346+6};
<a name="798"/>  798: 	      {compressed,4} -&gt; {11041, 12551, 12551, 12551+1};
<a name="799"/>  799: 	      {compressed,8} -&gt; {10050, 11560, 11560, 11560}
<a name="800"/>  800: 	  end,
<a name="801"/>  801:     XRes1 = adjust_xmem(L, XR1, 1),
<a name="802"/>  802:     Res1 = {?S(T1),?S(T2),?S(T3),?S(T4)},
<a name="803"/>  803:     lists:foreach(fun(T) -&gt;
<a name="804"/>  804: 			  Before = ets:info(T,size),
<a name="805"/>  805: 			  Key = 2, %894, %%ets:first(T),
<a name="806"/>  806: 			  Objs = ets:lookup(T,Key),
<a name="807"/>  807: 			  ets:delete(T,Key),
<a name="808"/>  808: 			  io:format(&quot;deleted key ~p from ~p changed size ~p to ~p: ~p\n&quot;,
<a name="809"/>  809: 				    [Key, ets:info(T,type), Before, ets:info(T,size), Objs])
<a name="810"/>  810: 		  end,
<a name="811"/>  811: 		  L),
<a name="812"/>  812:     XR2 = case mem_mode(T1) of
<a name="813"/>  813: 	      {normal,_} -&gt;     {13826, 15337, 15337-9, 15337-3};
<a name="814"/>  814: 	      {compressed,4} -&gt; {11031, 12542, 12542-9, 12542-8};
<a name="815"/>  815: 	      {compressed,8} -&gt; {10040, 11551, 11551-9, 11551-9}
<a name="816"/>  816: 	  end,
<a name="817"/>  817:     XRes2 = adjust_xmem(L, XR2, 1),
<a name="818"/>  818:     Res2 = {?S(T1),?S(T2),?S(T3),?S(T4)},
<a name="819"/>  819:     lists:foreach(fun(T) -&gt;
<a name="820"/>  820: 			  Before = ets:info(T,size),
<a name="821"/>  821: 			  Key = 4, %802, %ets:first(T),
<a name="822"/>  822: 			  Objs = ets:lookup(T,Key),
<a name="823"/>  823: 			  ets:match_delete(T,{Key,'_'}),
<a name="824"/>  824: 			  io:format(&quot;match_deleted key ~p from ~p changed size ~p to ~p: ~p\n&quot;,
<a name="825"/>  825: 				    [Key, ets:info(T,type), Before, ets:info(T,size), Objs])
<a name="826"/>  826: 		  end,
<a name="827"/>  827: 		  L),
<a name="828"/>  828:     XR3 = case mem_mode(T1) of
<a name="829"/>  829: 	      {normal,_} -&gt;     {13816, 15328, 15328-18, 15328-12};
<a name="830"/>  830: 	      {compressed,4} -&gt; {11021, 12533, 12533-18, 12533-17};
<a name="831"/>  831: 	      {compressed,8} -&gt; {10030, 11542, 11542-18, 11542-18}
<a name="832"/>  832: 	  end,
<a name="833"/>  833:     XRes3 = adjust_xmem(L, XR3, 1),
<a name="834"/>  834:     Res3 = {?S(T1),?S(T2),?S(T3),?S(T4)},
<a name="835"/>  835:     lists:foreach(fun(T) -&gt;
<a name="836"/>  836: 			  ets:delete_all_objects(T)
<a name="837"/>  837: 		  end,
<a name="838"/>  838: 		  L),
<a name="839"/>  839:     XRes4 = adjust_xmem(L, {50, 256, 256, 256}, 0),
<a name="840"/>  840:     Res4 = {?S(T1),?S(T2),?S(T3),?S(T4)},
<a name="841"/>  841:     lists:foreach(fun(T) -&gt;
<a name="842"/>  842: 			  ets:delete(T)
<a name="843"/>  843: 		  end,
<a name="844"/>  844: 		  L),
<a name="845"/>  845:     L2 =  [T11,T12,T13,T14] = fill_sets_int(1000),
<a name="846"/>  846:     lists:foreach(fun(T) -&gt;
<a name="847"/>  847: 			  ets:select_delete(T,[{'_',[],[true]}])
<a name="848"/>  848: 		  end,
<a name="849"/>  849: 		  L2),
<a name="850"/>  850:     XRes5 = adjust_xmem(L2, {50, 256, 256, 256}, 0),
<a name="851"/>  851:     Res5 = {?S(T11),?S(T12),?S(T13),?S(T14)},
<a name="852"/>  852:     io:format(&quot;XRes1 = ~p~n&quot;
<a name="853"/>  853: 	      &quot; Res1 = ~p~n~n&quot;
<a name="854"/>  854: 	      &quot;XRes2 = ~p~n&quot;
<a name="855"/>  855: 	      &quot; Res2 = ~p~n~n&quot;
<a name="856"/>  856: 	      &quot;XRes3 = ~p~n&quot;
<a name="857"/>  857: 	      &quot; Res3 = ~p~n~n&quot;
<a name="858"/>  858: 	      &quot;XRes4 = ~p~n&quot;
<a name="859"/>  859: 	      &quot; Res4 = ~p~n~n&quot;
<a name="860"/>  860: 	      &quot;XRes5 = ~p~n&quot;
<a name="861"/>  861: 	      &quot; Res5 = ~p~n~n&quot;,
<a name="862"/>  862: 	      [XRes1, Res1,
<a name="863"/>  863: 	       XRes2, Res2,
<a name="864"/>  864: 	       XRes3, Res3,
<a name="865"/>  865: 	       XRes4, Res4,
<a name="866"/>  866: 	       XRes5, Res5]),
<a name="867"/>  867:     XRes1 = Res1,
<a name="868"/>  868:     XRes2 = Res2,
<a name="869"/>  869:     XRes3 = Res3,
<a name="870"/>  870:     XRes4 = Res4,
<a name="871"/>  871:     XRes5 = Res5,
<a name="memory_do-last_expr"/><a name="872"/>  872:     ok.
<a name="873"/>  873: 
<a name="mem_mode-1"/><a name="874"/>  874: <b>mem_mode</b>(T) -&gt;
<a name="mem_mode-last_expr"/><a name="875"/>  875: <b>    {case ets:info</b>(T,compressed) of
<a name="876"/>  876: 	 true -&gt; compressed;
<a name="877"/>  877: 	 false -&gt; normal
<a name="878"/>  878:      end,
<a name="879"/>  879:      erlang:system_info(wordsize)}.
<a name="880"/>  880: 
<a name="chk_normal_tab_struct_size-0"/><a name="881"/>  881: <b>chk_normal_tab_struct_size</b>() -&gt;
<a name="882"/>  882:     System = {os:type(),
<a name="883"/>  883: 	      os:version(),
<a name="884"/>  884: 	      erlang:system_info(wordsize),
<a name="885"/>  885: 	      erlang:system_info(smp_support),
<a name="886"/>  886: 	      erlang:system_info(heap_type)},
<a name="887"/>  887:     io:format(&quot;System = ~p~n&quot;, [System]),
<a name="chk_normal_tab_struct_size-last_expr"/><a name="888"/>  888:     ok.
<a name="889"/>  889: 
<a name="adjust_xmem-3"/><a name="890"/>  890: <b>adjust_xmem</b>([_T1,_T2,_T3,_T4], {A0,B0,C0,D0} = _Mem0, EstCnt) -&gt;
<a name="891"/>  891:     %% Adjust for 64-bit, smp, and os:
<a name="892"/>  892:     %%   Table struct size may differ.
<a name="893"/>  893: 
<a name="894"/>  894:     {TabSz, EstSz} = erts_debug:get_internal_state('DbTable_words'),
<a name="895"/>  895:     HTabSz = TabSz + EstCnt*EstSz,
<a name="896"/>  896:     OrdSetExtra = case erlang:system_info(wordsize) of
<a name="897"/>  897:                       8 -&gt; 40; % larger stack on 64 bit architectures
<a name="898"/>  898:                       _ -&gt; 0
<a name="899"/>  899:                   end,
<a name="adjust_xmem-last_expr"/><a name="900"/>  900:     {A0+TabSz+OrdSetExtra, B0+HTabSz, C0+HTabSz, D0+HTabSz}.
<a name="901"/>  901: 
<a name="902"/>  902: <i>%% Misc. whitebox tests</i>
<a name="t_whitebox-1"/><a name="903"/>  903: <b>t_whitebox</b>(Config) when is_list(Config) -&gt;
<a name="904"/>  904:     EtsMem = etsmem(),
<a name="905"/>  905:     repeat_for_opts(fun whitebox_1/1),
<a name="906"/>  906:     repeat_for_opts(fun whitebox_1/1),
<a name="907"/>  907:     repeat_for_opts(fun whitebox_1/1),
<a name="908"/>  908:     repeat_for_opts(fun whitebox_2/1),
<a name="909"/>  909:     repeat_for_opts(fun whitebox_2/1),
<a name="910"/>  910:     repeat_for_opts(fun whitebox_2/1),
<a name="t_whitebox-last_expr"/><a name="911"/>  911: <b>    verify_etsmem</b>(EtsMem).
<a name="912"/>  912: 
<a name="whitebox_1-1"/><a name="913"/>  913: <b>whitebox_1</b>(Opts) -&gt;
<a name="914"/>  914:     T=ets_new(x,[bag | Opts]),
<a name="915"/>  915:     ets:insert(T,[{du,glade},{ta,en}]),
<a name="916"/>  916:     ets:insert(T,[{hej,hopp2},{du,glade2},{ta,en2}]),
<a name="917"/>  917:     {_,C}=ets:match(T,{ta,'$1'},1),
<a name="918"/>  918:     ets:select(C),
<a name="919"/>  919:     ets:match(C),
<a name="920"/>  920:     ets:delete(T),
<a name="whitebox_1-last_expr"/><a name="921"/>  921:     ok.
<a name="922"/>  922: 
<a name="whitebox_2-1"/><a name="923"/>  923: <b>whitebox_2</b>(OptsIn) -&gt;
<a name="924"/>  924:     run_if_valid_opts(
<a name="925"/>  925:       [ordered_set, {keypos,2} | OptsIn],
<a name="926"/>  926:       fun (Opts) -&gt;
<a name="927"/>  927:               T = ets_new(x, Opts),
<a name="928"/>  928:               0 = ets:select_delete(T,[{{hej},[],[true]}]),
<a name="929"/>  929:               0 = ets:select_delete(T,[{{hej,hopp},[],[true]}]),
<a name="930"/>  930:               ets:delete(T)
<a name="931"/>  931:       end),
<a name="932"/>  932: 
<a name="933"/>  933:     T2 = ets_new(x,[set, {keypos,2}| OptsIn]),
<a name="934"/>  934:     0 = ets:select_delete(T2,[{{hej},[],[true]}]),
<a name="935"/>  935:     0 = ets:select_delete(T2,[{{hej,hopp},[],[true]}]),
<a name="936"/>  936:     ets:delete(T2),
<a name="whitebox_2-last_expr"/><a name="937"/>  937:     ok.
<a name="938"/>  938: 
<a name="select_bound_chunk-1"/><a name="939"/>  939: <b>select_bound_chunk</b>(_Config) -&gt;
<a name="select_bound_chunk-last_expr"/><a name="940"/>  940: <b>    repeat_for_opts</b>(fun select_bound_chunk_do/1, [all_types]).
<a name="941"/>  941: 
<a name="select_bound_chunk_do-1"/><a name="942"/>  942: <b>select_bound_chunk_do</b>(Opts) -&gt;
<a name="943"/>  943:     T = ets_new(x, Opts),
<a name="944"/>  944:     ets:insert(T, [{key, 1}]),
<a name="945"/>  945:     {[{key, 1}], '$end_of_table'} = ets:select(T, [{{key,1},[],['$_']}], 100000),
<a name="select_bound_chunk_do-last_expr"/><a name="946"/>  946:     ok.
<a name="947"/>  947: 
<a name="948"/>  948: 
<a name="949"/>  949: <i>%% Test ets:to/from_dets.</i>
<a name="t_ets_dets-1"/><a name="950"/>  950: <b>t_ets_dets</b>(Config) when is_list(Config) -&gt;
<a name="t_ets_dets-last_expr"/><a name="951"/>  951: <b>    repeat_for_opts</b>(fun(Opts) -&gt; t_ets_dets(Config,Opts) end).
<a name="952"/>  952: 
<a name="t_ets_dets-2"/><a name="953"/>  953: <b>t_ets_dets</b>(Config, Opts) -&gt;
<a name="954"/>  954:     Fname = gen_dets_filename(Config,1),
<a name="955"/>  955:     (catch file:delete(Fname)),
<a name="956"/>  956:     {ok,DTab} = dets:open_file(testdets_1,
<a name="957"/>  957: 			       [{file, Fname}]),
<a name="958"/>  958:     ETab = ets_new(x,Opts),
<a name="959"/>  959:     filltabint(ETab,3000),
<a name="960"/>  960:     DTab = ets:to_dets(ETab,DTab),
<a name="961"/>  961:     ets:delete_all_objects(ETab),
<a name="962"/>  962:     0 = ets:info(ETab,size),
<a name="963"/>  963:     true = ets:from_dets(ETab,DTab),
<a name="964"/>  964:     3000 = ets:info(ETab,size),
<a name="965"/>  965:     ets:delete(ETab),
<a name="966"/>  966:     check_badarg(catch ets:to_dets(ETab,DTab),
<a name="967"/>  967: 		 ets, to_dets, [ETab,DTab]),
<a name="968"/>  968:     check_badarg(catch ets:from_dets(ETab,DTab),
<a name="969"/>  969: 		 ets, from_dets, [ETab,DTab]),
<a name="970"/>  970:     ETab2 = ets_new(x,Opts),
<a name="971"/>  971:     filltabint(ETab2,3000),
<a name="972"/>  972:     dets:close(DTab),
<a name="973"/>  973:     check_badarg(catch ets:to_dets(ETab2,DTab),
<a name="974"/>  974: 		 ets, to_dets, [ETab2,DTab]),
<a name="975"/>  975:     check_badarg(catch ets:from_dets(ETab2,DTab),
<a name="976"/>  976: 		 ets, from_dets, [ETab2,DTab]),
<a name="977"/>  977:     ets:delete(ETab2),
<a name="978"/>  978:     (catch file:delete(Fname)),
<a name="t_ets_dets-last_expr"/><a name="979"/>  979:     ok.
<a name="980"/>  980: 
<a name="check_badarg-4"/><a name="981"/>  981: <b>check_badarg</b>({'EXIT', {badarg, [{M,F,Args,_} | _]}}, M, F, Args) -&gt;
<a name="check_badarg-last_expr"/><a name="982"/>  982:     true.
<a name="983"/>  983: 
<a name="984"/>  984: <i>%% Test ets:delete_all_objects/1.</i>
<a name="t_delete_all_objects-1"/><a name="985"/>  985: <b>t_delete_all_objects</b>(Config) when is_list(Config) -&gt;
<a name="986"/>  986:     EtsMem = etsmem(),
<a name="987"/>  987:     repeat_for_opts_all_set_table_types(fun t_delete_all_objects_do/1),
<a name="t_delete_all_objects-last_expr"/><a name="988"/>  988: <b>    verify_etsmem</b>(EtsMem).
<a name="989"/>  989: 
<a name="get_kept_objects-1"/><a name="990"/>  990: <b>get_kept_objects</b>(T) -&gt;
<a name="get_kept_objects-last_expr"/><a name="991"/>  991: <b>    case ets:info</b>(T,stats) of
<a name="992"/>  992: 	{_,_,_,_,_,_,KO,_}  -&gt;
<a name="993"/>  993: 	    KO;
<a name="994"/>  994:         _ -&gt;
<a name="995"/>  995:             0
<a name="996"/>  996:     end.
<a name="997"/>  997: 
<a name="t_delete_all_objects_do-1"/><a name="998"/>  998: <b>t_delete_all_objects_do</b>(Opts) -&gt;
<a name="999"/>  999:     KeyRange = 40_000,
<a name="1000"/> 1000:     T=ets_new(x, Opts, KeyRange),
<a name="1001"/> 1001:     filltabint(T,KeyRange),
<a name="1002"/> 1002:     O=ets:first(T),
<a name="1003"/> 1003:     ets:next(T,O),
<a name="1004"/> 1004:     ets:safe_fixtable(T,true),
<a name="1005"/> 1005:     true = ets:delete_all_objects(T),
<a name="1006"/> 1006:     '$end_of_table' = ets:next(T,O),
<a name="1007"/> 1007:     0 = ets:info(T,size),
<a name="1008"/> 1008:     case ets:info(T,type) of
<a name="1009"/> 1009:         ordered_set -&gt; ok;
<a name="1010"/> 1010:         _ -&gt; KeyRange = get_kept_objects(T)
<a name="1011"/> 1011:     end,
<a name="1012"/> 1012:     ets:safe_fixtable(T,false),
<a name="1013"/> 1013:     0 = ets:info(T,size),
<a name="1014"/> 1014:     0 = get_kept_objects(T),
<a name="1015"/> 1015:     filltabint(T, KeyRange),
<a name="1016"/> 1016:     KeyRange = ets:info(T,size),
<a name="1017"/> 1017:     true = ets:delete_all_objects(T),
<a name="1018"/> 1018:     0 = ets:info(T,size),
<a name="1019"/> 1019:     ets:delete(T),
<a name="1020"/> 1020: 
<a name="1021"/> 1021:     %% Test delete_all_objects is atomic
<a name="1022"/> 1022:     T2 = ets_new(t_delete_all_objects, [public | Opts]),
<a name="1023"/> 1023:     Self = self(),
<a name="1024"/> 1024:     Inserters = [spawn_link(fun() -&gt; inserter(T2, 1, Self) end) || _ &lt;- [1,2,3,4]],
<a name="1025"/> 1025:     [receive {Ipid, running} -&gt; ok end || Ipid &lt;- Inserters],
<a name="1026"/> 1026: 
<a name="1027"/> 1027:     ets:delete_all_objects(T2),
<a name="1028"/> 1028:     erlang:yield(),
<a name="1029"/> 1029:     [Ipid ! stop || Ipid &lt;- Inserters],
<a name="1030"/> 1030:     Result = [receive {Ipid, stopped, Highest} -&gt; {Ipid,Highest} end || Ipid &lt;- Inserters],
<a name="1031"/> 1031: 
<a name="1032"/> 1032:     %% Verify unbroken sequences of objects inserted _after_ ets:delete_all_objects.
<a name="1033"/> 1033:     Sum = lists:foldl(fun({Ipid, Highest}, AccSum) -&gt;
<a name="1034"/> 1034:                               %% ets:fun2ms(fun({{K,Ipid}}) when K =&lt; Highest -&gt; true end),
<a name="1035"/> 1035:                               AliveMS = [{{{'$1',Ipid}},[{'=&lt;','$1',{const,Highest}}],[true]}],
<a name="1036"/> 1036:                               Alive = ets:select_count(T2, AliveMS),
<a name="1037"/> 1037:                               Lowest = Highest - (Alive-1),
<a name="1038"/> 1038: 
<a name="1039"/> 1039:                               %% ets:fun2ms(fun({{K,Ipid}}) when K &lt; Lowest -&gt; true end)
<a name="1040"/> 1040:                               DeletedMS = [{{{'$1',Ipid}},[{'&lt;','$1',{const,Lowest}}],[true]}],
<a name="1041"/> 1041:                               0 = ets:select_count(T2, DeletedMS),
<a name="1042"/> 1042:                               AccSum + Alive
<a name="1043"/> 1043:                       end,
<a name="1044"/> 1044:                       0,
<a name="1045"/> 1045:                       Result),
<a name="1046"/> 1046:     ok = case ets:info(T2, size) of
<a name="1047"/> 1047:              Sum -&gt; ok;
<a name="1048"/> 1048:              Size -&gt;
<a name="1049"/> 1049:                  io:format(&quot;Sum = ~p\nSize = ~p\n&quot;, [Sum, Size]),
<a name="1050"/> 1050:                  {Sum,Size}
<a name="1051"/> 1051:          end,
<a name="1052"/> 1052: 
<a name="t_delete_all_objects_do-last_expr"/><a name="1053"/> 1053: <b>    ets:delete</b>(T2).
<a name="1054"/> 1054: 
<a name="inserter-3"/><a name="1055"/> 1055: <b>inserter</b>(T, Next, Papa) -&gt;
<a name="1056"/> 1056:     Wait = case Next of
<a name="1057"/> 1057:                10*1000 -&gt;
<a name="1058"/> 1058:                    Papa ! {self(), running},
<a name="1059"/> 1059:                    0;
<a name="1060"/> 1060:                100*1000 -&gt; %% We most often don't reach this far
<a name="1061"/> 1061:                    io:format(&quot;Inserter ~p reached ~p objects\n&quot;,
<a name="1062"/> 1062:                              [self(), Next]),
<a name="1063"/> 1063:                    infinity;
<a name="1064"/> 1064:                _ -&gt;
<a name="1065"/> 1065:                    0
<a name="1066"/> 1066:            end,
<a name="1067"/> 1067: 
<a name="1068"/> 1068:     ets:insert(T, {{Next, self()}}),
<a name="inserter-last_expr"/><a name="1069"/> 1069:     receive
<a name="1070"/> 1070:         stop -&gt;
<a name="1071"/> 1071:             Papa ! {self(), stopped, Next},
<a name="1072"/> 1072:             ok
<a name="1073"/> 1073:     after Wait -&gt;
<a name="1074"/> 1074:             inserter(T, Next+1, Papa)
<a name="1075"/> 1075:     end.
<a name="1076"/> 1076: 
<a name="1077"/> 1077: 
<a name="1078"/> 1078: <i>%% Poke table during delete_all_objects</i>
<a name="t_delete_all_objects_trap-1"/><a name="1079"/> 1079: <b>t_delete_all_objects_trap</b>(Config) when is_list(Config) -&gt;
<a name="1080"/> 1080:     EtsMem = etsmem(),
<a name="1081"/> 1081:     repeat_for_opts_all_set_table_types(
<a name="1082"/> 1082:       fun(Opts) -&gt;
<a name="1083"/> 1083:               delete_all_objects_trap(Opts, unfix),
<a name="1084"/> 1084:               delete_all_objects_trap(Opts, exit),
<a name="1085"/> 1085:               delete_all_objects_trap(Opts, rename)
<a name="1086"/> 1086:       end),
<a name="1087"/> 1087:     verify_etsmem(EtsMem),
<a name="t_delete_all_objects_trap-last_expr"/><a name="1088"/> 1088:     ok.
<a name="1089"/> 1089: 
<a name="delete_all_objects_trap-2"/><a name="1090"/> 1090: <b>delete_all_objects_trap</b>(Opts, Mode) -&gt;
<a name="1091"/> 1091:     io:format(&quot;Opts = ~p\nMode = ~p\n&quot;, [Opts, Mode]),
<a name="1092"/> 1092:     Tester = self(),
<a name="1093"/> 1093:     KeyRange = 50_000,
<a name="1094"/> 1094:     TableName = delete_all_objects_trap,
<a name="1095"/> 1095:     {Tref,T} =
<a name="1096"/> 1096:         case Mode of
<a name="1097"/> 1097:             rename -&gt;
<a name="1098"/> 1098:                 TableName = ets_new(TableName, [named_table,public|Opts], KeyRange),
<a name="1099"/> 1099:                 {ets:whereis(TableName), TableName};
<a name="1100"/> 1100:             _ -&gt;
<a name="1101"/> 1101:                 Tid = ets_new(x, Opts, KeyRange),
<a name="1102"/> 1102:                 {Tid,Tid}
<a name="1103"/> 1103:         end,
<a name="1104"/> 1104:     filltabint(T, KeyRange),
<a name="1105"/> 1105:     KeyRange = ets:info(T,size),
<a name="1106"/> 1106:     FixerFun =
<a name="1107"/> 1107:         fun() -&gt;
<a name="1108"/> 1108:                 erlang:trace(Tester, true, [running]),
<a name="1109"/> 1109:                 case Mode of
<a name="1110"/> 1110:                     rename -&gt; ok;
<a name="1111"/> 1111:                     _ -&gt; ets:safe_fixtable(T, true)
<a name="1112"/> 1112:                 end,
<a name="1113"/> 1113:                 io:format(&quot;Wait for ets:delete_all_objects/1 to yield...\n&quot;, []),
<a name="1114"/> 1114:                 Tester ! {ready, self()},
<a name="1115"/> 1115:                 repeat_while(
<a name="1116"/> 1116:                   fun() -&gt;
<a name="1117"/> 1117:                           case receive_any() of
<a name="1118"/> 1118:                               {trace, Tester, out, {ets,internal_delete_all,2}} -&gt;
<a name="1119"/> 1119:                                   false;
<a name="1120"/> 1120:                               &quot;delete_all_objects done&quot; -&gt;
<a name="1121"/> 1121:                                   ct:fail(&quot;No trap detected&quot;);
<a name="1122"/> 1122:                               _M -&gt;
<a name="1123"/> 1123:                                   %%io:format(&quot;Ignored msg: ~p\n&quot;, [_M]),
<a name="1124"/> 1124:                                   true
<a name="1125"/> 1125:                           end
<a name="1126"/> 1126:                   end),
<a name="1127"/> 1127:                 case Mode of
<a name="1128"/> 1128:                     unfix -&gt;
<a name="1129"/> 1129:                         io:format(&quot;Unfix table and then exit...\n&quot;,[]),
<a name="1130"/> 1130:                         ets:safe_fixtable(T, false);
<a name="1131"/> 1131:                     exit -&gt;
<a name="1132"/> 1132:                         %%io:format(&quot;Exit and do auto-unfix...\n&quot;,[]),
<a name="1133"/> 1133:                         exit;
<a name="1134"/> 1134:                     rename -&gt;
<a name="1135"/> 1135:                         %%io:format(&quot;Rename table...\n&quot;,[]),
<a name="1136"/> 1136:                         renamed = ets:rename(T, renamed)
<a name="1137"/> 1137:                 end
<a name="1138"/> 1138:         end,
<a name="1139"/> 1139:     {Fixer, Mon} = spawn_opt(FixerFun, [link, monitor]),
<a name="1140"/> 1140:     {ready, Fixer} = receive_any(),
<a name="1141"/> 1141:     true = ets:delete_all_objects(T),
<a name="1142"/> 1142:     Fixer ! &quot;delete_all_objects done&quot;,
<a name="1143"/> 1143:     0 = ets:info(Tref,size),
<a name="1144"/> 1144:     {'DOWN', Mon, process, Fixer, normal} = receive_any(),
<a name="1145"/> 1145:     0 = get_kept_objects(Tref),
<a name="1146"/> 1146:     false = ets:info(Tref,safe_fixed),
<a name="1147"/> 1147:     ets:delete(Tref),
<a name="delete_all_objects_trap-last_expr"/><a name="1148"/> 1148:     ok.
<a name="1149"/> 1149: 
<a name="1150"/> 1150: 
<a name="1151"/> 1151: <i>%% Test ets:delete_object/2.</i>
<a name="t_delete_object-1"/><a name="1152"/> 1152: <b>t_delete_object</b>(Config) when is_list(Config) -&gt;
<a name="1153"/> 1153:     EtsMem = etsmem(),
<a name="1154"/> 1154:     repeat_for_opts(fun t_delete_object_do/1),
<a name="t_delete_object-last_expr"/><a name="1155"/> 1155: <b>    verify_etsmem</b>(EtsMem).
<a name="1156"/> 1156: 
<a name="t_delete_object_do-1"/><a name="1157"/> 1157: <b>t_delete_object_do</b>(Opts) -&gt;
<a name="1158"/> 1158:     T = ets_new(x,Opts),
<a name="1159"/> 1159:     filltabint(T,4000),
<a name="1160"/> 1160:     del_one_by_one_set(T,1,4001),
<a name="1161"/> 1161:     filltabint(T,4000),
<a name="1162"/> 1162:     del_one_by_one_set(T,4000,0),
<a name="1163"/> 1163:     filltabint(T,4000),
<a name="1164"/> 1164:     First = ets:first(T),
<a name="1165"/> 1165:     Next = ets:next(T,First),
<a name="1166"/> 1166:     ets:safe_fixtable(T,true),
<a name="1167"/> 1167:     ets:delete_object(T,{First, integer_to_list(First)}),
<a name="1168"/> 1168:     Next = ets:next(T,First),
<a name="1169"/> 1169:     3999 = ets:info(T,size),
<a name="1170"/> 1170:     1 = get_kept_objects(T),
<a name="1171"/> 1171:     ets:safe_fixtable(T,false),
<a name="1172"/> 1172:     3999 = ets:info(T,size),
<a name="1173"/> 1173:     0 = get_kept_objects(T),
<a name="1174"/> 1174:     ets:delete(T),
<a name="1175"/> 1175:     run_if_valid_opts(
<a name="1176"/> 1176:       [ordered_set | Opts],
<a name="1177"/> 1177:       fun (Opts1) -&gt;
<a name="1178"/> 1178:               T1 = ets_new(x, Opts1),
<a name="1179"/> 1179:               filltabint(T1,4000),
<a name="1180"/> 1180:               del_one_by_one_set(T1,1,4001),
<a name="1181"/> 1181:               filltabint(T1,4000),
<a name="1182"/> 1182:               del_one_by_one_set(T1,4000,0),
<a name="1183"/> 1183:               ets:delete(T1)
<a name="1184"/> 1184:       end),
<a name="1185"/> 1185:     T2 = ets_new(x,[bag | Opts]),
<a name="1186"/> 1186:     filltabint2(T2,4000),
<a name="1187"/> 1187:     del_one_by_one_bag(T2,1,4001),
<a name="1188"/> 1188:     filltabint2(T2,4000),
<a name="1189"/> 1189:     del_one_by_one_bag(T2,4000,0),
<a name="1190"/> 1190:     ets:delete(T2),
<a name="1191"/> 1191:     T3 = ets_new(x,[duplicate_bag | Opts]),
<a name="1192"/> 1192:     filltabint3(T3,4000),
<a name="1193"/> 1193:     del_one_by_one_dbag_1(T3,1,4001),
<a name="1194"/> 1194:     filltabint3(T3,4000),
<a name="1195"/> 1195:     del_one_by_one_dbag_1(T3,4000,0),
<a name="1196"/> 1196:     filltabint(T3,4000),
<a name="1197"/> 1197:     filltabint3(T3,4000),
<a name="1198"/> 1198:     del_one_by_one_dbag_2(T3,1,4001),
<a name="1199"/> 1199:     filltabint(T3,4000),
<a name="1200"/> 1200:     filltabint3(T3,4000),
<a name="1201"/> 1201:     del_one_by_one_dbag_2(T3,4000,0),
<a name="1202"/> 1202: 
<a name="1203"/> 1203:     filltabint2(T3,4000),
<a name="1204"/> 1204:     filltabint(T3,4000),
<a name="1205"/> 1205:     del_one_by_one_dbag_3(T3,4000,0),
<a name="1206"/> 1206:     ets:delete(T3),
<a name="t_delete_object_do-last_expr"/><a name="1207"/> 1207:     ok.
<a name="1208"/> 1208: 
<a name="make_init_fun-1"/><a name="1209"/> 1209: <b>make_init_fun</b>(N) when N &gt; 4000-&gt;
<a name="1210"/> 1210:     fun(read) -&gt;
<a name="1211"/> 1211: 	    end_of_input;
<a name="1212"/> 1212:        (close) -&gt;
<a name="1213"/> 1213: 	    exit(close_not_expected)
<a name="1214"/> 1214:     end;
<a name="1215"/> 1215: <b>make_init_fun</b>(N) -&gt;
<a name="make_init_fun-last_expr"/><a name="1216"/> 1216: <b>    fun</b>(read) -&gt;
<a name="1217"/> 1217: 	    case N rem 2 of
<a name="1218"/> 1218: 		0 -&gt;
<a name="1219"/> 1219: 		    {[{N, integer_to_list(N)}, {N, integer_to_list(N)}],
<a name="1220"/> 1220: 		     make_init_fun(N + 1)};
<a name="1221"/> 1221: 		1 -&gt;
<a name="1222"/> 1222: 		    {[], make_init_fun(N + 1)}
<a name="1223"/> 1223: 	    end;
<a name="1224"/> 1224:        (close) -&gt;
<a name="1225"/> 1225: 	    exit(close_not_expected)
<a name="1226"/> 1226:     end.
<a name="1227"/> 1227: 
<a name="1228"/> 1228: <i>%% Test ets:init_table/2.</i>
<a name="t_init_table-1"/><a name="1229"/> 1229: <b>t_init_table</b>(Config) when is_list(Config)-&gt;
<a name="1230"/> 1230:     EtsMem = etsmem(),
<a name="1231"/> 1231:     repeat_for_opts(fun t_init_table_do/1),
<a name="t_init_table-last_expr"/><a name="1232"/> 1232: <b>    verify_etsmem</b>(EtsMem).
<a name="1233"/> 1233: 
<a name="t_init_table_do-1"/><a name="1234"/> 1234: <b>t_init_table_do</b>(Opts) -&gt;
<a name="1235"/> 1235:     T = ets_new(x,[duplicate_bag | Opts]),
<a name="1236"/> 1236:     filltabint(T,4000),
<a name="1237"/> 1237:     ets:init_table(T, make_init_fun(1)),
<a name="1238"/> 1238:     del_one_by_one_dbag_1(T,4000,0),
<a name="1239"/> 1239:     ets:delete(T),
<a name="t_init_table_do-last_expr"/><a name="1240"/> 1240:     ok.
<a name="1241"/> 1241: 
<a name="do_fill_dbag_using_lists-2"/><a name="1242"/> 1242: <b>do_fill_dbag_using_lists</b>(T,0) -&gt;
<a name="1243"/> 1243:     T;
<a name="1244"/> 1244: <b>do_fill_dbag_using_lists</b>(T,N) -&gt;
<a name="1245"/> 1245:     ets:insert(T,[{N,integer_to_list(N)},
<a name="1246"/> 1246: 		  {N + N rem 2,integer_to_list(N + N rem 2)}]),
<a name="do_fill_dbag_using_lists-last_expr"/><a name="1247"/> 1247: <b>    do_fill_dbag_using_lists</b>(T,N - 1).
<a name="1248"/> 1248: 
<a name="1249"/> 1249: 
<a name="1250"/> 1250: <i>%% Test the insert_new function.</i>
<a name="t_insert_new-1"/><a name="1251"/> 1251: <b>t_insert_new</b>(Config) when is_list(Config) -&gt;
<a name="1252"/> 1252:     EtsMem = etsmem(),
<a name="1253"/> 1253:     L = fill_sets_int(1000) ++ fill_sets_int(1000,[{write_concurrency,true}]),
<a name="1254"/> 1254:     lists:foreach(fun(Tab) -&gt;
<a name="1255"/> 1255: 			  false = ets:insert_new(Tab,{2,&quot;2&quot;}),
<a name="1256"/> 1256: 			  true = ets:insert_new(Tab,{2002,&quot;2002&quot;}),
<a name="1257"/> 1257: 			  false = ets:insert_new(Tab,{2002,&quot;2002&quot;}),
<a name="1258"/> 1258: 			  true = ets:insert(Tab,{2002,&quot;2002&quot;}),
<a name="1259"/> 1259: 			  false =  ets:insert_new(Tab,[{2002,&quot;2002&quot;}]),
<a name="1260"/> 1260: 			  false =  ets:insert_new(Tab,[{2002,&quot;2002&quot;},
<a name="1261"/> 1261: 						       {2003,&quot;2003&quot;}]),
<a name="1262"/> 1262: 			  false =  ets:insert_new(Tab,[{2001,&quot;2001&quot;},
<a name="1263"/> 1263: 						       {2002,&quot;2002&quot;},
<a name="1264"/> 1264: 						       {2003,&quot;2003&quot;}]),
<a name="1265"/> 1265: 			  false =  ets:insert_new(Tab,[{2001,&quot;2001&quot;},
<a name="1266"/> 1266: 						       {2002,&quot;2002&quot;}]),
<a name="1267"/> 1267: 			  true =  ets:insert_new(Tab,[{2001,&quot;2001&quot;},
<a name="1268"/> 1268: 						      {2003,&quot;2003&quot;}]),
<a name="1269"/> 1269: 			  false = ets:insert_new(Tab,{2001,&quot;2001&quot;}),
<a name="1270"/> 1270: 			  false = ets:insert_new(Tab,{2002,&quot;2002&quot;}),
<a name="1271"/> 1271: 			  false = ets:insert_new(Tab,{2003,&quot;2003&quot;}),
<a name="1272"/> 1272: 			  true = ets:insert_new(Tab,{2004,&quot;2004&quot;}),
<a name="1273"/> 1273: 			  true = ets:insert_new(Tab,{2000,&quot;2000&quot;}),
<a name="1274"/> 1274: 			  true = ets:insert_new(Tab,[{2005,&quot;2005&quot;},
<a name="1275"/> 1275: 						     {2006,&quot;2006&quot;},
<a name="1276"/> 1276: 						     {2007,&quot;2007&quot;}]),
<a name="1277"/> 1277: 			  Num =
<a name="1278"/> 1278: 			      case ets:info(Tab,type) of
<a name="1279"/> 1279: 				  bag -&gt;
<a name="1280"/> 1280: 				      true =
<a name="1281"/> 1281: 					  ets:insert(Tab,{2004,&quot;2004-2&quot;}),
<a name="1282"/> 1282: 				      false =
<a name="1283"/> 1283: 					  ets:insert_new(Tab,{2004,&quot;2004-3&quot;}),
<a name="1284"/> 1284: 				      1009;
<a name="1285"/> 1285: 				  duplicate_bag -&gt;
<a name="1286"/> 1286: 				      true =
<a name="1287"/> 1287: 					  ets:insert(Tab,{2004,&quot;2004&quot;}),
<a name="1288"/> 1288: 				      false =
<a name="1289"/> 1289: 					  ets:insert_new(Tab,{2004,&quot;2004&quot;}),
<a name="1290"/> 1290: 				      1010;
<a name="1291"/> 1291: 				  _ -&gt;
<a name="1292"/> 1292: 				      1008
<a name="1293"/> 1293: 			      end,
<a name="1294"/> 1294: 			  Num = ets:info(Tab,size),
<a name="1295"/> 1295: 			  List = ets:tab2list(Tab),
<a name="1296"/> 1296: 			  ets:delete_all_objects(Tab),
<a name="1297"/> 1297: 			  true = ets:insert_new(Tab,List),
<a name="1298"/> 1298: 			  false = ets:insert_new(Tab,List),
<a name="1299"/> 1299: 			  ets:delete(Tab)
<a name="1300"/> 1300: 		  end,
<a name="1301"/> 1301: 		  L),
<a name="t_insert_new-last_expr"/><a name="1302"/> 1302: <b>    verify_etsmem</b>(EtsMem).
<a name="1303"/> 1303: 
<a name="1304"/> 1304: <i>%% Test ets:insert/2 with list of objects into duplicate bag table.</i>
<a name="t_insert_list-1"/><a name="1305"/> 1305: <b>t_insert_list</b>(Config) when is_list(Config) -&gt;
<a name="1306"/> 1306:     EtsMem = etsmem(),
<a name="1307"/> 1307:     repeat_for_opts(fun t_insert_list_do/1),
<a name="t_insert_list-last_expr"/><a name="1308"/> 1308: <b>    verify_etsmem</b>(EtsMem).
<a name="1309"/> 1309: 
<a name="t_insert_list_do-1"/><a name="1310"/> 1310: <b>t_insert_list_do</b>(Opts) -&gt;
<a name="1311"/> 1311:     T = ets_new(x,[duplicate_bag | Opts]),
<a name="1312"/> 1312:     do_fill_dbag_using_lists(T,4000),
<a name="1313"/> 1313:     del_one_by_one_dbag_2(T,4000,0),
<a name="t_insert_list_do-last_expr"/><a name="1314"/> 1314: <b>    ets:delete</b>(T).
<a name="1315"/> 1315: 
<a name="1316"/> 1316: <i>% Insert a long list twice in a bag</i>
<a name="t_insert_list_bag-1"/><a name="1317"/> 1317: <b>t_insert_list_bag</b>(Config) when is_list(Config) -&gt;
<a name="1318"/> 1318:     EtsMem = etsmem(),
<a name="1319"/> 1319:     repeat_for_opts(fun t_insert_list_bag_do/1,
<a name="1320"/> 1320:                     [write_concurrency, compressed]),
<a name="t_insert_list_bag-last_expr"/><a name="1321"/> 1321: <b>    verify_etsmem</b>(EtsMem).
<a name="1322"/> 1322: 
<a name="t_insert_list_bag_do-1"/><a name="1323"/> 1323: <b>t_insert_list_bag_do</b>(Opts) -&gt;
<a name="1324"/> 1324:     T = ets:new(t, [bag | Opts]),
<a name="1325"/> 1325:     ListSize = 25000,
<a name="1326"/> 1326:     List = [ {N} || N &lt;- lists:seq(1, ListSize)],
<a name="1327"/> 1327:     ets:insert(T, List),
<a name="1328"/> 1328:     ets:insert(T, List),
<a name="1329"/> 1329:     ListSize = ets:info(T, size),
<a name="1330"/> 1330: 
<a name="1331"/> 1331:     %% Insert different sized objects to better test (compressed) object comparison
<a name="1332"/> 1332:     List2 = [begin Bits=(N rem 71), {N div 7, &lt;&lt;N:Bits&gt;&gt;} end || {N} &lt;- List],
<a name="1333"/> 1333:     ets:insert(T, List2),
<a name="1334"/> 1334:     List2Sz = ListSize * 2,
<a name="1335"/> 1335:     List2Sz = ets:info(T, size),
<a name="1336"/> 1336:     ets:delete(T),
<a name="t_insert_list_bag_do-last_expr"/><a name="1337"/> 1337:     ok.
<a name="1338"/> 1338: 
<a name="1339"/> 1339: <i>% Insert a long list twice in a duplicate_bag</i>
<a name="t_insert_list_duplicate_bag-1"/><a name="1340"/> 1340: <b>t_insert_list_duplicate_bag</b>(Config) when is_list(Config) -&gt;
<a name="1341"/> 1341:     EtsMem = etsmem(),
<a name="1342"/> 1342:     T = ets:new(t, [duplicate_bag]),
<a name="1343"/> 1343:     ListSize = 25000,
<a name="1344"/> 1344:     List = [ {N} || N &lt;- lists:seq(1, ListSize)],
<a name="1345"/> 1345:     ets:insert(T, List),
<a name="1346"/> 1346:     ets:insert(T, List),
<a name="1347"/> 1347:     DoubleListSize = ListSize * 2,
<a name="1348"/> 1348:     DoubleListSize = ets:info(T, size),
<a name="1349"/> 1349:     ets:delete(T),
<a name="t_insert_list_duplicate_bag-last_expr"/><a name="1350"/> 1350: <b>    verify_etsmem</b>(EtsMem).
<a name="1351"/> 1351: 
<a name="1352"/> 1352: <i>%% Test ets:insert/2 with list of objects into set tables.</i>
<a name="t_insert_list_set-1"/><a name="1353"/> 1353: <b>t_insert_list_set</b>(Config) when is_list(Config) -&gt;
<a name="1354"/> 1354:     EtsMem = etsmem(),
<a name="1355"/> 1355:     repeat_for_opts(fun t_insert_list_set_do/1, [set_types]),
<a name="t_insert_list_set-last_expr"/><a name="1356"/> 1356: <b>    verify_etsmem</b>(EtsMem).
<a name="1357"/> 1357: 
<a name="t_insert_list_set_do-1"/><a name="1358"/> 1358: <b>t_insert_list_set_do</b>(Opts) -&gt;
<a name="1359"/> 1359:     Nr = 2,
<a name="1360"/> 1360:     t_insert_list_set_do(Opts, fun ets_insert_with_check/2, Nr, 1, Nr+1),
<a name="1361"/> 1361:     t_insert_list_set_do(Opts, fun ets_insert_with_check/2, Nr*2, 2, Nr*2),
<a name="1362"/> 1362:     InsertNewWithCheck =
<a name="1363"/> 1363:         fun(T,E) -&gt;
<a name="1364"/> 1364:                 Res = ets:insert_new(T,E),
<a name="1365"/> 1365:                 Seq = element(1, lists:nth(1, E)),
<a name="1366"/> 1366:                 case Seq rem 2 =:= 0 of
<a name="1367"/> 1367:                     true -&gt; Res = false;
<a name="1368"/> 1368:                     false -&gt; Res = true
<a name="1369"/> 1369:                 end
<a name="1370"/> 1370:         end,
<a name="1371"/> 1371:     t_insert_list_set_do(Opts, InsertNewWithCheck, Nr, 1, Nr),
<a name="1372"/> 1372:     t_insert_list_set_do(Opts, fun ets:insert_new/2, Nr*2, 2, Nr*2),
<a name="t_insert_list_set_do-last_expr"/><a name="1373"/> 1373:     ok.
<a name="1374"/> 1374: 
<a name="t_insert_list_set_do-5"/><a name="1375"/> 1375: <b>t_insert_list_set_do</b>(Opts, InsertFun, Nr, Step, ExpectedSize) -&gt;
<a name="1376"/> 1376:     T = ets_new(x,Opts),
<a name="1377"/> 1377:     [InsertFun(T,[{X,X}, {X+1,X}]) || X &lt;- lists:seq(1,Nr,Step)],
<a name="1378"/> 1378:     ExpectedSize = ets:info(T,size),
<a name="t_insert_list_set_do-last_expr"/><a name="1379"/> 1379: <b>    ets:delete</b>(T).
<a name="1380"/> 1380: 
<a name="1381"/> 1381: <i>%% Test ets:insert/2 with list of objects into set tables in parallel.</i>
<a name="t_insert_list_parallel-1"/><a name="1382"/> 1382: <b>t_insert_list_parallel</b>(Config) when is_list(Config) -&gt;
<a name="1383"/> 1383:     EtsMem = etsmem(),
<a name="1384"/> 1384:     repeat_for_opts(fun t_insert_list_parallel_do/1, [[public], set_types]),
<a name="t_insert_list_parallel-last_expr"/><a name="1385"/> 1385: <b>    verify_etsmem</b>(EtsMem).
<a name="1386"/> 1386: 
<a name="ets_insert_with_check-2"/><a name="1387"/> 1387: <b>ets_insert_with_check</b>(Table, ToInsert) -&gt;
<a name="1388"/> 1388:     true = ets:insert(Table, ToInsert),
<a name="ets_insert_with_check-last_expr"/><a name="1389"/> 1389:     true.
<a name="1390"/> 1390: 
<a name="ets_insert_new_with_check-2"/><a name="1391"/> 1391: <b>ets_insert_new_with_check</b>(Table, ToInsert) -&gt;
<a name="1392"/> 1392:     ExpectedRes =
<a name="1393"/> 1393:         case put(is_first_insert_for_list, true) of
<a name="1394"/> 1394:             undefined -&gt; true;
<a name="1395"/> 1395:             true -&gt; false
<a name="1396"/> 1396:         end,
<a name="1397"/> 1397:     ExpectedRes = ets:insert_new(Table, ToInsert),
<a name="ets_insert_new_with_check-last_expr"/><a name="1398"/> 1398:     ExpectedRes.
<a name="1399"/> 1399: 
<a name="t_insert_list_parallel_do-1"/><a name="1400"/> 1400: <b>t_insert_list_parallel_do</b>(Opts) -&gt;
<a name="t_insert_list_parallel_do-last_expr"/><a name="1401"/> 1401: <b>    [</b>(fun(I) -&gt;
<a name="1402"/> 1402:              t_insert_list_parallel_do(Opts, I, 2, 100, 500),
<a name="1403"/> 1403:              t_insert_list_parallel_do(Opts, I, 10, 100, 100),
<a name="1404"/> 1404:              t_insert_list_parallel_do(Opts, I, 1000, 100, 10),
<a name="1405"/> 1405:              t_insert_list_parallel_do(Opts, I, 50000, 3, 1)
<a name="1406"/> 1406:       end)(InsertFun) || InsertFun &lt;- [fun ets_insert_with_check/2,
<a name="1407"/> 1407:                                        fun ets_insert_new_with_check/2]].
<a name="1408"/> 1408: 
<a name="t_insert_list_parallel_do-5"/><a name="1409"/> 1409: <b>t_insert_list_parallel_do</b>(Opts, InsertFun, ListLength, NrOfProcesses, NrOfInsertsPerProcess) -&gt;
<a name="1410"/> 1410:     T = ets_new(x,Opts),
<a name="1411"/> 1411:     t_insert_list_parallel_do_helper(self(), T, 0, InsertFun, ListLength, NrOfProcesses, NrOfInsertsPerProcess),
<a name="1412"/> 1412:     receive done -&gt; ok end,
<a name="1413"/> 1413:     ExpectedSize = ListLength * NrOfProcesses,
<a name="1414"/> 1414:     ExpectedSize = length(ets:match_object(T, {'$0', '$1'})),
<a name="1415"/> 1415:     ExpectedSize = ets:info(T, size),
<a name="1416"/> 1416:     ets:delete(T),
<a name="t_insert_list_parallel_do-last_expr"/><a name="1417"/> 1417:     ok.
<a name="1418"/> 1418: 
<a name="t_insert_list_delete_parallel-1"/><a name="1419"/> 1419: <b>t_insert_list_delete_parallel</b>(Config) when is_list(Config) -&gt;
<a name="1420"/> 1420:     EtsMem = etsmem(),
<a name="1421"/> 1421:     repeat_for_opts(fun t_insert_list_delete_parallel_do/1, [[public], set_types]),
<a name="t_insert_list_delete_parallel-last_expr"/><a name="1422"/> 1422: <b>    verify_etsmem</b>(EtsMem).
<a name="1423"/> 1423: 
<a name="t_insert_list_delete_parallel_do-1"/><a name="1424"/> 1424: <b>t_insert_list_delete_parallel_do</b>(Opts) -&gt;
<a name="1425"/> 1425:     [(fun(I) -&gt;
<a name="1426"/> 1426:               t_insert_list_delete_parallel_do(Opts, I, 30, 32, 1000000),
<a name="1427"/> 1427:               t_insert_list_delete_parallel_do(Opts, I, 300, 8, 1000000),
<a name="1428"/> 1428:               t_insert_list_delete_parallel_do(Opts, I, 3000, 4, 1000000),
<a name="1429"/> 1429:               t_insert_list_delete_parallel_do(Opts, I, 9000, 4, 1000000)
<a name="1430"/> 1430:       end)(InsertFun) || InsertFun &lt;- [fun ets_insert_with_check/2,
<a name="1431"/> 1431:                                        fun ets_insert_new_with_check/2]],
<a name="t_insert_list_delete_parallel_do-last_expr"/><a name="1432"/> 1432:     ok.
<a name="1433"/> 1433: 
<a name="t_insert_list_delete_parallel_do-5"/><a name="1434"/> 1434: <b>t_insert_list_delete_parallel_do</b>(Opts, InsertFun, ListLength, NrOfProcesses, NrOfInsertsPerProcess) -&gt;
<a name="1435"/> 1435:     T = ets_new(x,Opts),
<a name="1436"/> 1436:     CompletedInsertsCtr = counters:new(1,[]),
<a name="1437"/> 1437:     NewInsertFun =
<a name="1438"/> 1438:         fun(Table, ToInsert) -&gt;
<a name="1439"/> 1439:                 try
<a name="1440"/> 1440:                     InsertFun(Table, ToInsert),
<a name="1441"/> 1441:                     counters:add(CompletedInsertsCtr, 1, 1)
<a name="1442"/> 1442:                 catch
<a name="1443"/> 1443:                     error:badarg -&gt; put(stop,yes)
<a name="1444"/> 1444:                 end
<a name="1445"/> 1445:         end,
<a name="1446"/> 1446:     Self = self(),
<a name="1447"/> 1447:     spawn(fun()-&gt;
<a name="1448"/> 1448:                   t_insert_list_parallel_do_helper(self(), T, 0, NewInsertFun, ListLength, NrOfProcesses, NrOfInsertsPerProcess),
<a name="1449"/> 1449:                   receive done -&gt; Self ! done_parallel_insert end
<a name="1450"/> 1450:           end),
<a name="1451"/> 1451:     receive after 3 -&gt; ok end,
<a name="1452"/> 1452:     spawn(fun()-&gt;
<a name="1453"/> 1453:                   spawn(fun()-&gt;
<a name="1454"/> 1454:                                 receive after 7 -&gt; ok end,
<a name="1455"/> 1455:                                 ets:delete(T),
<a name="1456"/> 1456:                                 Self ! done_delete
<a name="1457"/> 1457:                         end)
<a name="1458"/> 1458:           end),
<a name="1459"/> 1459:     receive done_delete -&gt; ok end,
<a name="1460"/> 1460:     receive done_parallel_insert -&gt; ok end,
<a name="t_insert_list_delete_parallel_do-last_expr"/><a name="1461"/> 1461: <b>    io:format</b>(&quot;~p/~p completed&quot;,
<a name="1462"/> 1462:               [counters:get(CompletedInsertsCtr, 1),
<a name="1463"/> 1463:                NrOfProcesses * NrOfInsertsPerProcess]).
<a name="1464"/> 1464: 
<a name="1465"/> 1465: 
<a name="t_insert_list_parallel_do_helper-7"/><a name="1466"/> 1466: <b>t_insert_list_parallel_do_helper</b>(Parent, T, StartKey, InsertFun, ListLength, 1, NrOfInsertsPerProcess) -&gt;
<a name="1467"/> 1467:     try
<a name="1468"/> 1468:         repeat(fun()-&gt;
<a name="1469"/> 1469:                        case get(stop) of
<a name="1470"/> 1470:                            yes -&gt; throw(end_repeat);
<a name="1471"/> 1471:                            _ -&gt; ok
<a name="1472"/> 1472:                        end,
<a name="1473"/> 1473:                        InsertFun(T,[{X,X} || X &lt;- lists:seq(StartKey,StartKey+ListLength-1,1)])
<a name="1474"/> 1474:                end, NrOfInsertsPerProcess)
<a name="1475"/> 1475:     catch
<a name="1476"/> 1476:         throw:end_repeat -&gt; ok
<a name="1477"/> 1477:     end,
<a name="1478"/> 1478:     Parent ! done;
<a name="1479"/> 1479: <b>t_insert_list_parallel_do_helper</b>(Parent, T, StartKey, InsertFun, ListLength, NrOfProcesses, NrOfInsertsPerProcess) -&gt;
<a name="1480"/> 1480:     Self = self(),
<a name="1481"/> 1481:     spawn(fun() -&gt;
<a name="1482"/> 1482:                   t_insert_list_parallel_do_helper(Self,
<a name="1483"/> 1483:                                                    T,
<a name="1484"/> 1484:                                                    StartKey,
<a name="1485"/> 1485:                                                    InsertFun,
<a name="1486"/> 1486:                                                    ListLength,
<a name="1487"/> 1487:                                                    NrOfProcesses div 2,
<a name="1488"/> 1488:                                                    NrOfInsertsPerProcess) end),
<a name="1489"/> 1489:     spawn(fun() -&gt;
<a name="1490"/> 1490:                   t_insert_list_parallel_do_helper(Self,
<a name="1491"/> 1491:                                                    T,
<a name="1492"/> 1492:                                                    StartKey + ListLength*(NrOfProcesses div 2),
<a name="1493"/> 1493:                                                    InsertFun,
<a name="1494"/> 1494:                                                    ListLength,
<a name="1495"/> 1495:                                                    (NrOfProcesses div 2) + (NrOfProcesses rem 2),
<a name="1496"/> 1496:                                                    NrOfInsertsPerProcess)
<a name="1497"/> 1497:           end),
<a name="1498"/> 1498:     receive done -&gt; ok end,
<a name="1499"/> 1499:     receive done -&gt; ok end,
<a name="t_insert_list_parallel_do_helper-last_expr"/><a name="1500"/> 1500:     Parent ! done.
<a name="1501"/> 1501: 
<a name="t_insert_list_delete_set-1"/><a name="1502"/> 1502: <b>t_insert_list_delete_set</b>(Config) when is_list(Config) -&gt;
<a name="1503"/> 1503:     EtsMem = etsmem(),
<a name="1504"/> 1504:     repeat_for_opts(fun t_insert_list_delete_set_do/1, [[public],set_types]),
<a name="t_insert_list_delete_set-last_expr"/><a name="1505"/> 1505: <b>    verify_etsmem</b>(EtsMem).
<a name="1506"/> 1506: 
<a name="t_insert_list_delete_set_do-1"/><a name="1507"/> 1507: <b>t_insert_list_delete_set_do</b>(Opts) -&gt;
<a name="1508"/> 1508:     [(fun(I) -&gt;
<a name="1509"/> 1509:               t_insert_list_delete_set_do(Opts, I, 1000000, 1, 1),
<a name="1510"/> 1510:               t_insert_list_delete_set_do(Opts, I, 100000, 10, 5),
<a name="1511"/> 1511:               t_insert_list_delete_set_do(Opts, I, 10000, 100, 50),
<a name="1512"/> 1512:               t_insert_list_delete_set_do(Opts, I, 1000, 1000, 500)
<a name="1513"/> 1513:       end)(InsertFun) || InsertFun &lt;- [fun ets_insert_with_check/2,
<a name="1514"/> 1514:                                        fun ets_insert_new_with_check/2]],
<a name="t_insert_list_delete_set_do-last_expr"/><a name="1515"/> 1515:     ok.
<a name="1516"/> 1516: 
<a name="1517"/> 1517: 
<a name="t_insert_list_delete_set_do-5"/><a name="1518"/> 1518: <b>t_insert_list_delete_set_do</b>(Opts, InsertFun, ListLength, NrOfTables, NrOfInserts) -&gt;
<a name="1519"/> 1519:     CompletedInsertsCtr = counters:new(1,[]),
<a name="1520"/> 1520:     Parent = self(),
<a name="1521"/> 1521:     [(fun() -&gt;
<a name="1522"/> 1522:               T = ets_new(x,Opts),
<a name="1523"/> 1523:               spawn(
<a name="1524"/> 1524:                 fun() -&gt;
<a name="1525"/> 1525:                         try
<a name="1526"/> 1526:                             repeat(
<a name="1527"/> 1527:                               fun() -&gt;
<a name="1528"/> 1528:                                       InsertFun(T,[{Z,Z} ||
<a name="1529"/> 1529:                                                       Z &lt;- lists:seq(1,ListLength)]),
<a name="1530"/> 1530:                                       counters:add(CompletedInsertsCtr, 1, 1)%,
<a name="1531"/> 1531:                               end, NrOfInserts)
<a name="1532"/> 1532:                         catch
<a name="1533"/> 1533:                             error:badarg -&gt; ok
<a name="1534"/> 1534:                         end,
<a name="1535"/> 1535:                         Parent ! done
<a name="1536"/> 1536:                 end),
<a name="1537"/> 1537:               receive after 1 -&gt; ok end,
<a name="1538"/> 1538:               ets:delete(T)
<a name="1539"/> 1539:       end)() || _ &lt;- lists:seq(1,NrOfTables)],
<a name="1540"/> 1540:     [receive done -&gt; ok end || _ &lt;- lists:seq(1,NrOfTables)],
<a name="t_insert_list_delete_set_do-last_expr"/><a name="1541"/> 1541: <b>    io:format</b>(&quot;~p/~p completed&quot;,
<a name="1542"/> 1542:               [counters:get(CompletedInsertsCtr, 1),
<a name="1543"/> 1543:                NrOfTables * NrOfInserts]).
<a name="1544"/> 1544: 
<a name="1545"/> 1545: 
<a name="t_insert_list_kill_process-1"/><a name="1546"/> 1546: <b>t_insert_list_kill_process</b>(Config) when is_list(Config) -&gt;
<a name="1547"/> 1547:     EtsMem = etsmem(),
<a name="1548"/> 1548:     repeat_for_opts(fun t_insert_list_kill_process_do/1, [[public], set_types]),
<a name="t_insert_list_kill_process-last_expr"/><a name="1549"/> 1549: <b>    verify_etsmem</b>(EtsMem).
<a name="1550"/> 1550: 
<a name="1551"/> 1551: 
<a name="t_insert_list_kill_process_do-1"/><a name="1552"/> 1552: <b>t_insert_list_kill_process_do</b>(Opts) -&gt;
<a name="1553"/> 1553:     [(fun(I) -&gt;
<a name="1554"/> 1554:               [(fun(Time) -&gt;
<a name="1555"/> 1555:                         T = ets_new(x,Opts),
<a name="1556"/> 1556:                         List = lists:seq(1,600000),
<a name="1557"/> 1557:                         TupleList = [{E,E} || E &lt;- List],
<a name="1558"/> 1558:                         Pid = spawn(fun() -&gt; I(T, TupleList) end),
<a name="1559"/> 1559:                         receive after Time -&gt; ok end,
<a name="1560"/> 1560:                         exit(Pid, kill),
<a name="1561"/> 1561:                         ets:delete(T)
<a name="1562"/> 1562:                 end)(TheTime) || TheTime &lt;- [1,3,5] ++ lists:seq(7,29,7)]
<a name="1563"/> 1563:       end)(InsertFun) || InsertFun &lt;- [fun ets:insert/2,
<a name="1564"/> 1564:                                        fun ets:insert_new/2]],
<a name="t_insert_list_kill_process_do-last_expr"/><a name="1565"/> 1565:     ok.
<a name="1566"/> 1566: 
<a name="t_insert_list_insert_order_preserved-1"/><a name="1567"/> 1567: <b>t_insert_list_insert_order_preserved</b>(Config) when is_list(Config) -&gt;
<a name="1568"/> 1568:     insert_list_insert_order_preserved(bag),
<a name="1569"/> 1569:     insert_list_insert_order_preserved(duplicate_bag),
<a name="t_insert_list_insert_order_preserved-last_expr"/><a name="1570"/> 1570:     ok.
<a name="1571"/> 1571: 
<a name="insert_list_insert_order_preserved-1"/><a name="1572"/> 1572: <b>insert_list_insert_order_preserved</b>(Type) -&gt;
<a name="1573"/> 1573:     Tab = ets:new(?FUNCTION_NAME, [Type]),
<a name="1574"/> 1574:     K = a,
<a name="1575"/> 1575:     Values1 = [{K, 1}, {K, 2}, {K, 3}],
<a name="1576"/> 1576:     Values2 = [{K, 4}, {K, 5}, {K, 6}],
<a name="1577"/> 1577:     ets:insert(Tab, Values1),
<a name="1578"/> 1578:     ets:insert(Tab, Values2),
<a name="1579"/> 1579:     [{K, 1}, {K, 2}, {K, 3}, {K, 4}, {K, 5}, {K, 6}] = ets:lookup(Tab, K),
<a name="1580"/> 1580: 
<a name="1581"/> 1581:     ets:delete(Tab, K),
<a name="1582"/> 1582:     [] = ets:lookup(Tab, K),
<a name="1583"/> 1583: 
<a name="1584"/> 1584:     %% Insert order in duplicate_bag depended on reductions left
<a name="1585"/> 1585:     ITERATIONS_PER_RED = 8,
<a name="1586"/> 1586:     NTuples = 4000 * ITERATIONS_PER_RED + 10,
<a name="1587"/> 1587:     LongList = [{K, V} || V &lt;- lists:seq(1, NTuples)],
<a name="1588"/> 1588:     ets:insert(Tab, LongList),
<a name="1589"/> 1589:     LongList = ets:lookup(Tab, K),
<a name="1590"/> 1590: 
<a name="insert_list_insert_order_preserved-last_expr"/><a name="1591"/> 1591: <b>    ets:delete</b>(Tab).
<a name="1592"/> 1592: 
<a name="1593"/> 1593: <i>%% Test interface of ets:test_ms/2.</i>
<a name="t_test_ms-1"/><a name="1594"/> 1594: <b>t_test_ms</b>(Config) when is_list(Config) -&gt;
<a name="1595"/> 1595:     EtsMem = etsmem(),
<a name="1596"/> 1596:     {ok,[a,b]} = ets:test_ms({a,b},
<a name="1597"/> 1597: 			     [{{'$1','$2'},[{'&lt;','$1','$2'}],['$$']}]),
<a name="1598"/> 1598:     {ok,false} = ets:test_ms({a,b},
<a name="1599"/> 1599: 			     [{{'$1','$2'},[{'&gt;','$1','$2'}],['$$']}]),
<a name="1600"/> 1600:     Tpl = {a,gb_sets:new()},
<a name="1601"/> 1601:     {ok,Tpl} = ets:test_ms(Tpl, [{{'_','_'},  [], ['$_']}]), % OTP-10190
<a name="1602"/> 1602:     {error,[{error,String}]} = ets:test_ms({a,b},
<a name="1603"/> 1603: 					   [{{'$1','$2'},
<a name="1604"/> 1604: 					     [{'flurp','$1','$2'}],
<a name="1605"/> 1605: 					     ['$$']}]),
<a name="1606"/> 1606:     true = (if is_list(String) -&gt; true; true -&gt; false end),
<a name="t_test_ms-last_expr"/><a name="1607"/> 1607: <b>    verify_etsmem</b>(EtsMem).
<a name="1608"/> 1608: 
<a name="1609"/> 1609: <i>%% Test the select reverse BIFs.</i>
<a name="t_select_reverse-1"/><a name="1610"/> 1610: <b>t_select_reverse</b>(Config) when is_list(Config) -&gt;
<a name="1611"/> 1611:     Table = ets_new(xxx, [ordered_set]),
<a name="1612"/> 1612:     filltabint(Table,1000),
<a name="1613"/> 1613:     A = lists:reverse(ets:select(Table,[{{'$1', '_'},
<a name="1614"/> 1614: 					 [{'&gt;',
<a name="1615"/> 1615: 					   {'rem',
<a name="1616"/> 1616: 					    '$1', 5},
<a name="1617"/> 1617: 					   2}],
<a name="1618"/> 1618: 					 ['$_']}])),
<a name="1619"/> 1619:     A = ets:select_reverse(Table,[{{'$1', '_'},
<a name="1620"/> 1620: 				   [{'&gt;',
<a name="1621"/> 1621: 				     {'rem',
<a name="1622"/> 1622: 				      '$1', 5},
<a name="1623"/> 1623: 				     2}],
<a name="1624"/> 1624: 				   ['$_']}]),
<a name="1625"/> 1625:     A = reverse_chunked(Table,[{{'$1', '_'},
<a name="1626"/> 1626: 				[{'&gt;',
<a name="1627"/> 1627: 				  {'rem',
<a name="1628"/> 1628: 				   '$1', 5},
<a name="1629"/> 1629: 				  2}],
<a name="1630"/> 1630: 				['$_']}],3),
<a name="1631"/> 1631:     %% A set/bag/duplicate_bag should get the same result regardless
<a name="1632"/> 1632:     %% of select or select_reverse
<a name="1633"/> 1633:     Table2 = ets_new(xxx, [set]),
<a name="1634"/> 1634:     filltabint(Table2,1000),
<a name="1635"/> 1635:     Table3 = ets_new(xxx, [bag]),
<a name="1636"/> 1636:     filltabint(Table3,1000),
<a name="1637"/> 1637:     Table4 = ets_new(xxx, [duplicate_bag]),
<a name="1638"/> 1638:     filltabint(Table4,1000),
<a name="1639"/> 1639:     lists:map(fun(Tab) -&gt;
<a name="1640"/> 1640: 		      B = ets:select(Tab,[{{'$1', '_'},
<a name="1641"/> 1641: 					   [{'&gt;',
<a name="1642"/> 1642: 					     {'rem',
<a name="1643"/> 1643: 					      '$1', 5},
<a name="1644"/> 1644: 					     2}],
<a name="1645"/> 1645: 					   ['$_']}]),
<a name="1646"/> 1646: 		      B = ets:select_reverse(Tab,[{{'$1', '_'},
<a name="1647"/> 1647: 						   [{'&gt;',
<a name="1648"/> 1648: 						     {'rem',
<a name="1649"/> 1649: 						      '$1', 5},
<a name="1650"/> 1650: 						     2}],
<a name="1651"/> 1651: 						   ['$_']}])
<a name="1652"/> 1652: 	      end,[Table2, Table3, Table4]),
<a name="t_select_reverse-last_expr"/><a name="1653"/> 1653:     ok.
<a name="1654"/> 1654: 
<a name="1655"/> 1655: 
<a name="1656"/> 1656: 
<a name="reverse_chunked-3"/><a name="1657"/> 1657: <b>reverse_chunked</b>(T,MS,N) -&gt;
<a name="reverse_chunked-last_expr"/><a name="1658"/> 1658: <b>    do_reverse_chunked</b>(ets:select_reverse(T,MS,N),[]).
<a name="1659"/> 1659: 
<a name="do_reverse_chunked-2"/><a name="1660"/> 1660: <b>do_reverse_chunked</b>('$end_of_table',Acc) -&gt;
<a name="1661"/> 1661:     lists:reverse(Acc);
<a name="1662"/> 1662: <b>do_reverse_chunked</b>({L,C},Acc) -&gt;
<a name="1663"/> 1663:     NewAcc = lists:reverse(L)++Acc,
<a name="do_reverse_chunked-last_expr"/><a name="1664"/> 1664: <b>    do_reverse_chunked</b>(ets:select_reverse(C), NewAcc).
<a name="1665"/> 1665: 
<a name="1666"/> 1666: 
<a name="1667"/> 1667: <i>%% Test the ets:select_delete/2 and ets:select_count/2 BIFs.</i>
<a name="t_select_delete-1"/><a name="1668"/> 1668: <b>t_select_delete</b>(Config) when is_list(Config) -&gt;
<a name="1669"/> 1669:     ct:timetrap({minutes,30}), %% valgrind needs a lot
<a name="1670"/> 1670:     EtsMem = etsmem(),
<a name="1671"/> 1671:     Tables = fill_sets_int(10000) ++ fill_sets_int(10000,[{write_concurrency,true}]),
<a name="1672"/> 1672:     lists:foreach
<a name="1673"/> 1673:       (fun(Table) -&gt;
<a name="1674"/> 1674: 	       4000 = ets:select_count(Table,[{{'$1', '_'},
<a name="1675"/> 1675: 					       [{'&gt;',
<a name="1676"/> 1676: 						 {'rem',
<a name="1677"/> 1677: 						  '$1', 5},
<a name="1678"/> 1678: 						 2}],
<a name="1679"/> 1679: 					       [true]}]),
<a name="1680"/> 1680: 	       4000 = ets:select_delete(Table,[{{'$1', '_'},
<a name="1681"/> 1681: 						[{'&gt;',
<a name="1682"/> 1682: 						  {'rem',
<a name="1683"/> 1683: 						   '$1', 5},
<a name="1684"/> 1684: 						  2}],
<a name="1685"/> 1685: 						[true]}]),
<a name="1686"/> 1686: 	       check(Table,
<a name="1687"/> 1687: 		     fun({N,_}) when (N rem 5) =&lt; 2 -&gt;
<a name="1688"/> 1688: 			     true;
<a name="1689"/> 1689: 			(_) -&gt;
<a name="1690"/> 1690: 			     false
<a name="1691"/> 1691: 		     end,
<a name="1692"/> 1692: 		     6000)
<a name="1693"/> 1693: 
<a name="1694"/> 1694:        end,
<a name="1695"/> 1695:        Tables),
<a name="1696"/> 1696:     lists:foreach
<a name="1697"/> 1697:       (fun(Table) -&gt;
<a name="1698"/> 1698: 	       ets:select_delete(Table,[{'_',[],[true]}]),
<a name="1699"/> 1699: 	       xfilltabint(Table,4000),
<a name="1700"/> 1700: 	       successive_delete(Table,1,4001,bound),
<a name="1701"/> 1701: 	       0 = ets:info(Table,size),
<a name="1702"/> 1702: 	       xfilltabint(Table,4000),
<a name="1703"/> 1703: 	       successive_delete(Table,4000,0, bound),
<a name="1704"/> 1704: 	       0 = ets:info(Table,size),
<a name="1705"/> 1705: 	       xfilltabint(Table,4000),
<a name="1706"/> 1706: 	       successive_delete(Table,1,4001,unbound),
<a name="1707"/> 1707: 	       0 = ets:info(Table,size),
<a name="1708"/> 1708: 	       xfilltabint(Table,4000),
<a name="1709"/> 1709: 	       successive_delete(Table,4000,0, unbound),
<a name="1710"/> 1710: 	       0 = ets:info(Table,size)
<a name="1711"/> 1711: 
<a name="1712"/> 1712:        end,
<a name="1713"/> 1713:        Tables),
<a name="1714"/> 1714:     lists:foreach
<a name="1715"/> 1715:       (fun(Table) -&gt;
<a name="1716"/> 1716: 	       F = case ets:info(Table,type) of
<a name="1717"/> 1717: 		       X when X == bag; X == duplicate_bag -&gt;
<a name="1718"/> 1718: 			   2;
<a name="1719"/> 1719: 		       _ -&gt;
<a name="1720"/> 1720: 			   1
<a name="1721"/> 1721: 		   end,
<a name="1722"/> 1722: 	       xfilltabstr(Table, 4000),
<a name="1723"/> 1723: 	       1000 = ets:select_count(Table,
<a name="1724"/> 1724: 				       [{{[$3 | '$1'], '_'},
<a name="1725"/> 1725: 					 [{'==',
<a name="1726"/> 1726: 					   {'length', '$1'},
<a name="1727"/> 1727: 					   3}],[true]}]) div F,
<a name="1728"/> 1728: 	       1000 = ets:select_delete(Table,
<a name="1729"/> 1729: 					[{{[$3 | '$1'], '_'},
<a name="1730"/> 1730: 					  [{'==',
<a name="1731"/> 1731: 					    {'length', '$1'},
<a name="1732"/> 1732: 					    3}],[true]}]) div F,
<a name="1733"/> 1733: 	       check(Table, fun({[3,_,_,_],_}) -&gt; false;
<a name="1734"/> 1734: 			       (_) -&gt; true
<a name="1735"/> 1735: 			    end, 3000*F),
<a name="1736"/> 1736: 	       8 = ets:select_count(Table,
<a name="1737"/> 1737: 				    [{{&quot;7&quot;,'_'},[],[false]},
<a name="1738"/> 1738: 				     {{['_'], '_'},
<a name="1739"/> 1739: 				      [],[true]}]) div F,
<a name="1740"/> 1740: 	       8 = ets:select_delete(Table,
<a name="1741"/> 1741: 				     [{{&quot;7&quot;,'_'},[],[false]},
<a name="1742"/> 1742: 				      {{['_'], '_'},
<a name="1743"/> 1743: 				       [],[true]}]) div F,
<a name="1744"/> 1744: 	       check(Table, fun({&quot;7&quot;,_}) -&gt; true;
<a name="1745"/> 1745: 			       ({[_],_}) -&gt; false;
<a name="1746"/> 1746: 			       (_) -&gt; true
<a name="1747"/> 1747: 			    end, 2992*F),
<a name="1748"/> 1748: 	       xfilltabstr(Table, 4000),
<a name="1749"/> 1749: 	       %% This happens to be interesting for other select types too
<a name="1750"/> 1750: 	       200 = length(ets:select(Table,
<a name="1751"/> 1751: 				       [{{[$3,'_','_'],'_'},
<a name="1752"/> 1752: 					 [],[true]},
<a name="1753"/> 1753: 					{{[$1,'_','_'],'_'},
<a name="1754"/> 1754: 					 [],[true]}])) div F,
<a name="1755"/> 1755: 	       200 = ets:select_count(Table,
<a name="1756"/> 1756: 				      [{{[$3,'_','_'],'_'},
<a name="1757"/> 1757: 					[],[true]},
<a name="1758"/> 1758: 				       {{[$1,'_','_'],'_'},
<a name="1759"/> 1759: 					[],[true]}]) div F,
<a name="1760"/> 1760: 	       200 = length(element(1,ets:select(Table,
<a name="1761"/> 1761: 						 [{{[$3,'_','_'],'_'},
<a name="1762"/> 1762: 						   [],[true]},
<a name="1763"/> 1763: 						  {{[$1,'_','_'],'_'},
<a name="1764"/> 1764: 						   [],[true]}],
<a name="1765"/> 1765: 						 1000))) div F,
<a name="1766"/> 1766: 	       200 = length(
<a name="1767"/> 1767: 		       ets:select_reverse(Table,
<a name="1768"/> 1768: 					  [{{[$3,'_','_'],'_'},
<a name="1769"/> 1769: 					    [],[true]},
<a name="1770"/> 1770: 					   {{[$1,'_','_'],'_'},
<a name="1771"/> 1771: 					    [],[true]}])) div F,
<a name="1772"/> 1772: 	       200 = length(
<a name="1773"/> 1773: 		       element(1,
<a name="1774"/> 1774: 			       ets:select_reverse
<a name="1775"/> 1775: 				 (Table,
<a name="1776"/> 1776: 				  [{{[$3,'_','_'],'_'},
<a name="1777"/> 1777: 				    [],[true]},
<a name="1778"/> 1778: 				   {{[$1,'_','_'],'_'},
<a name="1779"/> 1779: 				    [],[true]}],
<a name="1780"/> 1780: 				  1000))) div F,
<a name="1781"/> 1781: 	       200 = ets:select_delete(Table,
<a name="1782"/> 1782: 				       [{{[$3,'_','_'],'_'},
<a name="1783"/> 1783: 					 [],[true]},
<a name="1784"/> 1784: 					{{[$1,'_','_'],'_'},
<a name="1785"/> 1785: 					 [],[true]}]) div F,
<a name="1786"/> 1786: 	       0 = ets:select_count(Table,
<a name="1787"/> 1787: 				    [{{[$3,'_','_'],'_'},
<a name="1788"/> 1788: 				      [],[true]},
<a name="1789"/> 1789: 				     {{[$1,'_','_'],'_'},
<a name="1790"/> 1790: 				      [],[true]}]) div F,
<a name="1791"/> 1791: 	       check(Table, fun({[$3,_,_],_}) -&gt; false;
<a name="1792"/> 1792: 			       ({[$1,_,_],_}) -&gt; false;
<a name="1793"/> 1793: 			       (_) -&gt; true
<a name="1794"/> 1794: 			    end, 3800*F)
<a name="1795"/> 1795:        end,
<a name="1796"/> 1796:        Tables),
<a name="1797"/> 1797:     lists:foreach(fun(Tab) -&gt; ets:delete(Tab) end,Tables),
<a name="t_select_delete-last_expr"/><a name="1798"/> 1798: <b>    verify_etsmem</b>(EtsMem).
<a name="1799"/> 1799: 
<a name="1800"/> 1800: <i>%% Tests the ets:select_replace/2 BIF</i>
<a name="t_select_replace-1"/><a name="1801"/> 1801: <b>t_select_replace</b>(Config) when is_list(Config) -&gt;
<a name="1802"/> 1802:     EtsMem = etsmem(),
<a name="1803"/> 1803:     repeat_for_opts(fun do_select_replace/1),
<a name="t_select_replace-last_expr"/><a name="1804"/> 1804: <b>    verify_etsmem</b>(EtsMem).
<a name="1805"/> 1805: 
<a name="do_select_replace-1"/><a name="1806"/> 1806: <b>do_select_replace</b>(Opts) -&gt;
<a name="1807"/> 1807:     Tables = fill_sets_intup(10000, Opts),
<a name="1808"/> 1808: 
<a name="1809"/> 1809:     TestFun = fun (Table, TableType) when TableType =:= bag -&gt;
<a name="1810"/> 1810:                       % Operation not supported; bag implementation
<a name="1811"/> 1811:                       % presented both semantic consistency and performance issues.
<a name="1812"/> 1812:                       10000 = ets:select_delete(Table, [{'_',[],[true]}]);
<a name="1813"/> 1813: 
<a name="1814"/> 1814:                   (Table, TableType) -&gt;
<a name="1815"/> 1815:                       % Invalid replacement doesn't keep the key
<a name="1816"/> 1816:                       MatchSpec1 = [{{{'$1','$3'}, '$2'},
<a name="1817"/> 1817:                                      [{'=:=', {'band', '$1', 2#11}, 2#11},
<a name="1818"/> 1818:                                       {'=/=', {'hd', '$2'}, $x}],
<a name="1819"/> 1819:                                      [{{{{'$2','$3'}}, '$1'}}]}],
<a name="1820"/> 1820:                       {'EXIT',{badarg,_}} = (catch ets:select_replace(Table, MatchSpec1)),
<a name="1821"/> 1821: 
<a name="1822"/> 1822:                       % Invalid replacement doesn't keep the key (even though it would be the same value)
<a name="1823"/> 1823:                       MatchSpec2 = [{{{'$1','$3'}, '$2'},
<a name="1824"/> 1824:                                      [{'=:=', {'band', '$1', 2#11}, 2#11}],
<a name="1825"/> 1825:                                      [{{{{{'+', '$1', 0},'$3'}}, '$2'}}]},
<a name="1826"/> 1826:                                     {{{'$1','$3'}, '$2'},
<a name="1827"/> 1827:                                      [{'=/=', {'band', '$1', 2#11}, 2#11}],
<a name="1828"/> 1828:                                      [{{{{{'-', '$1', 0},'$3'}}, '$2'}}]}],
<a name="1829"/> 1829:                       {'EXIT',{badarg,_}} = (catch ets:select_replace(Table, MatchSpec2)),
<a name="1830"/> 1830: 
<a name="1831"/> 1831:                       % Invalid replacement changes key to float equivalent
<a name="1832"/> 1832:                       MatchSpec3 = [{{{'$1','$3'}, '$2'},
<a name="1833"/> 1833:                                      [{'=:=', {'band', '$1', 2#11}, 2#11},
<a name="1834"/> 1834:                                       {'=/=', {'hd', '$2'}, $x}],
<a name="1835"/> 1835:                                      [{{{{{'*', '$1', 1.0},'$3'}}, '$2'}}]}],
<a name="1836"/> 1836:                       {'EXIT',{badarg,_}} = (catch ets:select_replace(Table, MatchSpec3)),
<a name="1837"/> 1837: 
<a name="1838"/> 1838:                       % Replacements are differently-sized tuples
<a name="1839"/> 1839:                       MatchSpec4_A = [{{{'$1','$3'},'$2'},
<a name="1840"/> 1840:                                        [{'&lt;', {'rem', '$1', 5}, 2}],
<a name="1841"/> 1841:                                        [{{{{'$1','$3'}}, [$x | '$2'], stuff}}]}],
<a name="1842"/> 1842:                       MatchSpec4_B = [{{{'$1','$3'},'$2','_'},
<a name="1843"/> 1843:                                        [],
<a name="1844"/> 1844:                                        [{{{{'$1','$3'}},'$2'}}]}],
<a name="1845"/> 1845:                       4000 = ets:select_replace(Table, MatchSpec4_A),
<a name="1846"/> 1846:                       4000 = ets:select_replace(Table, MatchSpec4_B),
<a name="1847"/> 1847: 
<a name="1848"/> 1848:                       % Replacement is the same tuple
<a name="1849"/> 1849:                       MatchSpec5 = [{{{'$1','$3'}, '$2'},
<a name="1850"/> 1850:                                      [{'&gt;', {'rem', '$1', 5}, 3}],
<a name="1851"/> 1851:                                      ['$_']}],
<a name="1852"/> 1852:                       2000 = ets:select_replace(Table, MatchSpec5),
<a name="1853"/> 1853: 
<a name="1854"/> 1854:                       % Replacement reconstructs an equal tuple
<a name="1855"/> 1855:                       MatchSpec6 = [{{{'$1','$3'}, '$2'},
<a name="1856"/> 1856:                                      [{'&gt;', {'rem', '$1', 5}, 3}],
<a name="1857"/> 1857:                                      [{{{{'$1','$3'}}, '$2'}}]}],
<a name="1858"/> 1858:                       2000 = ets:select_replace(Table, MatchSpec6),
<a name="1859"/> 1859: 
<a name="1860"/> 1860:                       % Replacement uses {element,KeyPos,T} for key
<a name="1861"/> 1861:                       2000 = ets:select_replace(Table,
<a name="1862"/> 1862:                                                 [{{{'$1','$3'}, '$2'},
<a name="1863"/> 1863:                                                   [{'&gt;', {'rem', '$1', 5}, 3}],
<a name="1864"/> 1864:                                                   [{{{element, 1, '$_'}, '$2'}}]}]),
<a name="1865"/> 1865: 
<a name="1866"/> 1866:                       % Replacement uses wrong {element,KeyPos,T} for key
<a name="1867"/> 1867:                       {'EXIT',{badarg,_}} = (catch ets:select_replace(Table,
<a name="1868"/> 1868:                                                                      [{{{'$1','$3'}, '$2'},
<a name="1869"/> 1869:                                                                        [],
<a name="1870"/> 1870:                                                                        [{{{element, 2, '$_'}, '$2'}}]}])),
<a name="1871"/> 1871: 
<a name="1872"/> 1872:                       check(Table,
<a name="1873"/> 1873:                             fun ({{N,_}, [$x, C | _]}) when ((N rem 5) &lt; 2) -&gt; (C &gt;= $0) andalso (C =&lt; $9);
<a name="1874"/> 1874:                                 ({{N,_}, [C | _]}) when is_float(N) -&gt; (C &gt;= $0) andalso (C =&lt; $9);
<a name="1875"/> 1875:                                 ({{N,_}, [C | _]}) when ((N rem 5) &gt; 3) -&gt; (C &gt;= $0) andalso (C =&lt; $9);
<a name="1876"/> 1876:                                 ({_, [C | _]}) -&gt; (C &gt;= $0) andalso (C =&lt; $9)
<a name="1877"/> 1877:                             end,
<a name="1878"/> 1878:                             10000),
<a name="1879"/> 1879: 
<a name="1880"/> 1880:                       % Replace unbound range (&gt;)
<a name="1881"/> 1881:                       MatchSpec7 = [{{{'$1','$3'}, '$2'},
<a name="1882"/> 1882:                                      [{'&gt;', '$1', 7000}],
<a name="1883"/> 1883:                                      [{{{{'$1','$3'}}, {{gt_range, '$2'}}}}]}],
<a name="1884"/> 1884:                       3000 = ets:select_replace(Table, MatchSpec7),
<a name="1885"/> 1885: 
<a name="1886"/> 1886:                       % Replace unbound range (&lt;)
<a name="1887"/> 1887:                       MatchSpec8 = [{{{'$1','$3'}, '$2'},
<a name="1888"/> 1888:                                      [{'&lt;', '$1', 3000}],
<a name="1889"/> 1889:                                      [{{{{'$1','$3'}}, {{le_range, '$2'}}}}]}],
<a name="1890"/> 1890:                       case TableType of
<a name="1891"/> 1891:                           ordered_set -&gt;   2999 = ets:select_replace(Table, MatchSpec8);
<a name="1892"/> 1892:                           set -&gt;           2999 = ets:select_replace(Table, MatchSpec8);
<a name="1893"/> 1893:                           duplicate_bag -&gt; 2998 = ets:select_replace(Table, MatchSpec8)
<a name="1894"/> 1894:                       end,
<a name="1895"/> 1895: 
<a name="1896"/> 1896:                       % Replace bound range
<a name="1897"/> 1897:                       MatchSpec9 = [{{{'$1','$3'}, '$2'},
<a name="1898"/> 1898:                                      [{'&gt;=', '$1', 3001},
<a name="1899"/> 1899:                                       {'&lt;', '$1', 7000}],
<a name="1900"/> 1900:                                      [{{{{'$1','$3'}}, {{range, '$2'}}}}]}],
<a name="1901"/> 1901:                       case TableType of
<a name="1902"/> 1902:                           ordered_set -&gt;   3999 = ets:select_replace(Table, MatchSpec9);
<a name="1903"/> 1903:                           set -&gt;           3999 = ets:select_replace(Table, MatchSpec9);
<a name="1904"/> 1904:                           duplicate_bag -&gt; 3998 = ets:select_replace(Table, MatchSpec9)
<a name="1905"/> 1905:                       end,
<a name="1906"/> 1906: 
<a name="1907"/> 1907:                       % Replace particular keys
<a name="1908"/> 1908:                       MatchSpec10 = [{{{'$1','$3'}, '$2'},
<a name="1909"/> 1909:                                      [{'==', '$1', 3000}],
<a name="1910"/> 1910:                                      [{{{{'$1','$3'}}, {{specific1, '$2'}}}}]},
<a name="1911"/> 1911:                                     {{{'$1','$3'}, '$2'},
<a name="1912"/> 1912:                                      [{'==', '$1', 7000}],
<a name="1913"/> 1913:                                      [{{{{'$1','$3'}}, {{specific2, '$2'}}}}]}],
<a name="1914"/> 1914:                       case TableType of
<a name="1915"/> 1915:                           ordered_set -&gt;   2 = ets:select_replace(Table, MatchSpec10);
<a name="1916"/> 1916:                           set -&gt;           2 = ets:select_replace(Table, MatchSpec10);
<a name="1917"/> 1917:                           duplicate_bag -&gt; 4 = ets:select_replace(Table, MatchSpec10)
<a name="1918"/> 1918:                       end,
<a name="1919"/> 1919: 
<a name="1920"/> 1920:                       check(Table,
<a name="1921"/> 1921:                             fun ({{N,_}, {gt_range, _}}) -&gt; N &gt; 7000;
<a name="1922"/> 1922:                                 ({{N,_}, {le_range, _}}) -&gt; N &lt; 3000;
<a name="1923"/> 1923:                                 ({{N,_}, {range, _}}) -&gt; (N &gt;= 3001) andalso (N &lt; 7000);
<a name="1924"/> 1924:                                 ({{N,_}, {specific1, _}}) -&gt; N == 3000;
<a name="1925"/> 1925:                                 ({{N,_}, {specific2, _}}) -&gt; N == 7000
<a name="1926"/> 1926:                             end,
<a name="1927"/> 1927:                             10000),
<a name="1928"/> 1928: 
<a name="1929"/> 1929:                       10000 = ets:select_delete(Table, [{'_',[],[true]}]),
<a name="1930"/> 1930:                       check(Table, fun (_) -&gt; false end, 0)
<a name="1931"/> 1931:               end,
<a name="1932"/> 1932: 
<a name="1933"/> 1933:     lists:foreach(
<a name="1934"/> 1934:       fun(Table) -&gt;
<a name="1935"/> 1935:               TestFun(Table, ets:info(Table, type)),
<a name="1936"/> 1936:               ets:delete(Table)
<a name="1937"/> 1937:       end,
<a name="1938"/> 1938:       Tables),
<a name="1939"/> 1939: 
<a name="1940"/> 1940:     %% Test key-safe match-specs are accepted
<a name="1941"/> 1941:     BigNum = (123 bsl 123),
<a name="1942"/> 1942:     RefcBin = list_to_binary(lists:seq(1,?heap_binary_size+1)),
<a name="1943"/> 1943:     Terms = [a, &quot;hej&quot;, 123, 1.23, BigNum , &lt;&lt;&quot;123&quot;&gt;&gt;, RefcBin, TestFun, self()],
<a name="1944"/> 1944:     EqPairs = fun(X,Y) -&gt;
<a name="1945"/> 1945:                       [{ '$1', '$1'},
<a name="1946"/> 1946:                        { {X, Y}, {{X, Y}}},
<a name="1947"/> 1947:                        { {'$1', Y}, {{'$1', Y}}},
<a name="1948"/> 1948:                        { {{X, Y}}, {{{{X, Y}}}}},
<a name="1949"/> 1949:                        { {X}, {{X}}},
<a name="1950"/> 1950:                        { X, {const, X}},
<a name="1951"/> 1951:                        { {X,Y}, {const, {X,Y}}},
<a name="1952"/> 1952:                        { {X}, {const, {X}}},
<a name="1953"/> 1953:                        { {X, Y}, {{X, {const, Y}}}},
<a name="1954"/> 1954:                        { {X, {Y,'$1'}}, {{{const, X}, {{Y,'$1'}}}}},
<a name="1955"/> 1955:                        { [X, Y | '$1'], [X, Y | '$1']},
<a name="1956"/> 1956:                        { [{X, '$1'}, Y], [{{X, '$1'}}, Y]},
<a name="1957"/> 1957:                        { [{X, Y} | '$1'], [{const, {X, Y}} | '$1']},
<a name="1958"/> 1958:                        { [$p,$r,$e,$f,$i,$x | '$1'], [$p,$r,$e,$f,$i,$x | '$1']},
<a name="1959"/> 1959:                        { {[{X,Y}]}, {{[{{X,Y}}]}}},
<a name="1960"/> 1960:                        { {[{X,Y}]}, {{{const, [{X,Y}]}}}},
<a name="1961"/> 1961:                        { {[{X,Y}]}, {{[{const,{X,Y}}]}}}
<a name="1962"/> 1962:                       ]
<a name="1963"/> 1963:               end,
<a name="1964"/> 1964: 
<a name="1965"/> 1965:     T2 = ets:new(x, Opts),
<a name="1966"/> 1966:     [lists:foreach(fun({A, B}) -&gt;
<a name="1967"/> 1967:                            %% just check that matchspec is accepted
<a name="1968"/> 1968:                            0 = ets:select_replace(T2, [{{A, '$2', '$3'}, [], [{{B, '$3', '$2'}}]}])
<a name="1969"/> 1969:                    end,
<a name="1970"/> 1970:                    EqPairs(X,Y)) || X &lt;- Terms, Y &lt;- Terms],
<a name="1971"/> 1971: 
<a name="1972"/> 1972:     %% Test key-unsafe matchspecs are rejected
<a name="1973"/> 1973:     NeqPairs = fun(X, Y) -&gt;
<a name="1974"/> 1974:                       [{'$1', '$2'},
<a name="1975"/> 1975:                        {{X, Y}, {X, Y}},
<a name="1976"/> 1976:                        {{{X, Y}}, {{{X, Y}}}},
<a name="1977"/> 1977:                        {{X}, {{{X}}}},
<a name="1978"/> 1978:                        {{const, X}, {const, X}},
<a name="1979"/> 1979:                        {{const, {X,Y}}, {const, {X,Y}}},
<a name="1980"/> 1980:                        {'$1', {const, '$1'}},
<a name="1981"/> 1981:                        {{X}, {const, {{X}}}},
<a name="1982"/> 1982:                        {{X, {Y,'$1'}}, {{{const, X}, {Y,'$1'}}}},
<a name="1983"/> 1983:                        {[X, Y | '$1'], [X, Y]},
<a name="1984"/> 1984:                        {[X, Y], [X, Y | '$1']},
<a name="1985"/> 1985:                        {[{X, '$1'}, Y], [{X, '$1'}, Y]},
<a name="1986"/> 1986:                        {[$p,$r,$e,$f,$i,$x | '$1'], [$p,$r,$e,$f,$I,$x | '$1']},
<a name="1987"/> 1987:                        { {[{X,Y}]}, {{[{X,Y}]}}},
<a name="1988"/> 1988:                        { {[{X,Y}]}, {{{const, [{{X,Y}}]}}}},
<a name="1989"/> 1989:                        { {[{X,Y}]}, {{[{const,{{X,Y}}}]}}},
<a name="1990"/> 1990:                        {'_', '_'},
<a name="1991"/> 1991:                        {'$_', '$_'},
<a name="1992"/> 1992:                        {'$$', '$$'},
<a name="1993"/> 1993:                        {#{}, #{}},
<a name="1994"/> 1994:                        {#{X =&gt; '$1'}, #{X =&gt; '$1'}}
<a name="1995"/> 1995:                       ]
<a name="1996"/> 1996:               end,
<a name="1997"/> 1997: 
<a name="1998"/> 1998:     [lists:foreach(fun({A, B}) -&gt;
<a name="1999"/> 1999:                            %% just check that matchspec is rejected
<a name="2000"/> 2000:                            {'EXIT',{badarg,_}} = (catch ets:select_replace(T2, [{{A, '$2', '$3'}, [], [{{B, '$3', '$2'}}]}]))
<a name="2001"/> 2001:                    end,
<a name="2002"/> 2002:                    NeqPairs(X,Y)) || X &lt;- Terms, Y &lt;- Terms],
<a name="2003"/> 2003: 
<a name="2004"/> 2004: 
<a name="2005"/> 2005:     %% Wrap entire tuple with 'const'
<a name="2006"/> 2006:     [[begin
<a name="2007"/> 2007:           Old = {Key, 1, 2},
<a name="2008"/> 2008:           ets:insert(T2, Old),
<a name="2009"/> 2009:           1 = ets:select_replace(T2, [{Old, [], [{const, New}]}]),
<a name="2010"/> 2010:           [New] = ets:lookup(T2, Key),
<a name="2011"/> 2011:           ets:delete(T2, Key)
<a name="2012"/> 2012:       end || New &lt;- [{Key, 1, 2}, {Key, 3, 4}, {Key, 1}, {Key, 1, 2, 3}, {Key}]
<a name="2013"/> 2013:      ]
<a name="2014"/> 2014:      || Key &lt;- [{1, tuple}, {nested, {tuple, {a,b}}} | Terms]],
<a name="2015"/> 2015: 
<a name="2016"/> 2016:     %% 'const' wrap does not work with maps or variables in keys
<a name="2017"/> 2017:     [[begin
<a name="2018"/> 2018:           Old = {Key, 1, 2},
<a name="2019"/> 2019:           {'EXIT',{badarg,_}} = (catch ets:select_replace(T2, [{Old, [], [{const, New}]}]))
<a name="2020"/> 2020:       end || New &lt;- [{Key, 1, 2}, {Key, 3, 4}, {Key, 1}, {Key, 1, 2, 3}, {Key}]
<a name="2021"/> 2021:      ]
<a name="2022"/> 2022:      || Key &lt;- [#{a =&gt; 1}, {nested, #{a =&gt; 1}}, '$1']],
<a name="2023"/> 2023: 
<a name="2024"/> 2024: 
<a name="2025"/> 2025:     ets:delete(T2),
<a name="do_select_replace-last_expr"/><a name="2026"/> 2026:     ok.
<a name="2027"/> 2027: 
<a name="2028"/> 2028: <i>%% OTP-15346: Bug caused select_replace of bound key to corrupt static stack</i>
<a name="2029"/> 2029: <i>%% used by ets:next and ets:prev.</i>
<a name="t_select_replace_next_bug-1"/><a name="2030"/> 2030: <b>t_select_replace_next_bug</b>(Config) when is_list(Config) -&gt;
<a name="2031"/> 2031:     T = ets:new(k, [ordered_set]),
<a name="2032"/> 2032:     [ets:insert(T, {I, value}) || I &lt;- lists:seq(1,10)],
<a name="2033"/> 2033:     1 = ets:first(T),
<a name="2034"/> 2034: 
<a name="2035"/> 2035:     %% Make sure select_replace does not leave pointer
<a name="2036"/> 2036:     %% to deallocated {2,value} in static stack.
<a name="2037"/> 2037:     MS = [{{2,value}, [], [{{2,&quot;new_value&quot;}}]}],
<a name="2038"/> 2038:     1 = ets:select_replace(T, MS),
<a name="2039"/> 2039: 
<a name="2040"/> 2040:     %% This would crash or give wrong result at least on DEBUG emulator
<a name="2041"/> 2041:     %% where deallocated memory is overwritten.
<a name="2042"/> 2042:     2 = ets:next(T, 1),
<a name="2043"/> 2043: 
<a name="t_select_replace_next_bug-last_expr"/><a name="2044"/> 2044: <b>    ets:delete</b>(T).
<a name="2045"/> 2045: 
<a name="2046"/> 2046: 
<a name="2047"/> 2047: <i>%% OTP-17379</i>
<a name="t_select_pam_stack_overflow_bug-1"/><a name="2048"/> 2048: <b>t_select_pam_stack_overflow_bug</b>(_Config) -&gt;
<a name="2049"/> 2049:     T = ets:new(k, []),
<a name="2050"/> 2050:     ets:insert(T,[{x,17}]),
<a name="2051"/> 2051:     [{x,18}] = ets:select(T,[{{x,17}, [], [{{{element,1,'$_'},{const,18}}}]}]),
<a name="2052"/> 2052:     ets:delete(T),
<a name="t_select_pam_stack_overflow_bug-last_expr"/><a name="2053"/> 2053:     ok.
<a name="2054"/> 2054: 
<a name="2055"/> 2055: <i>%% When a variable was used as key in ms body, the matched value would</i>
<a name="2056"/> 2056: <i>%% not be copied to the heap of the calling process.</i>
<a name="t_select_flatmap_term_copy_bug-1"/><a name="2057"/> 2057: <b>t_select_flatmap_term_copy_bug</b>(_Config) -&gt;
<a name="2058"/> 2058:     T = ets:new(a,[]),
<a name="2059"/> 2059:     ets:insert(T, {list_to_binary(lists:duplicate(36,$a))}),
<a name="2060"/> 2060:     V1 = ets:select(T, [{{'$1'},[],[#{ '$1' =&gt; a }]}]),
<a name="2061"/> 2061:     erlang:garbage_collect(),
<a name="2062"/> 2062:     V1 = ets:select(T, [{{'$1'},[],[#{ '$1' =&gt; a }]}]),
<a name="2063"/> 2063:     erlang:garbage_collect(),
<a name="2064"/> 2064:     V2 = ets:select(T, [{{'$1'},[],[#{ a =&gt; '$1' }]}]),
<a name="2065"/> 2065:     erlang:garbage_collect(),
<a name="2066"/> 2066:     V2 = ets:select(T, [{{'$1'},[],[#{ a =&gt; '$1' }]}]),
<a name="2067"/> 2067:     erlang:garbage_collect(),
<a name="2068"/> 2068:     V3 = ets:select(T, [{{'$1'},[],[#{ '$1' =&gt; '$1' }]}]),
<a name="2069"/> 2069:     erlang:garbage_collect(),
<a name="2070"/> 2070:     V3 = ets:select(T, [{{'$1'},[],[#{ '$1' =&gt; '$1' }]}]),
<a name="2071"/> 2071:     erlang:garbage_collect(),
<a name="2072"/> 2072:     V4 = ets:select(T, [{{'$1'},[],[#{ a =&gt; a }]}]),
<a name="2073"/> 2073:     erlang:garbage_collect(),
<a name="2074"/> 2074:     V4 = ets:select(T, [{{'$1'},[],[#{ a =&gt; a }]}]),
<a name="2075"/> 2075:     erlang:garbage_collect(),
<a name="2076"/> 2076:     ets:delete(T),
<a name="t_select_flatmap_term_copy_bug-last_expr"/><a name="2077"/> 2077:     ok.
<a name="2078"/> 2078: 
<a name="2079"/> 2079: <i>%% When a variable was used as key or value in ms body,</i>
<a name="2080"/> 2080: <i>%% the matched value would not be copied to the heap of</i>
<a name="2081"/> 2081: <i>%% the calling process.</i>
<a name="t_select_hashmap_term_copy_bug-1"/><a name="2082"/> 2082: <b>t_select_hashmap_term_copy_bug</b>(_Config) -&gt;
<a name="2083"/> 2083: 
<a name="2084"/> 2084:     T = ets:new(a,[]),
<a name="2085"/> 2085:     Dollar1 = list_to_binary(lists:duplicate(36,$a)),
<a name="2086"/> 2086:     ets:insert(T, {Dollar1}),
<a name="2087"/> 2087: 
<a name="2088"/> 2088:     {LargeMapSize, FlatmapSize} =
<a name="2089"/> 2089:         case erlang:system_info(emu_type) of
<a name="2090"/> 2090:             debug -&gt; {40, 3};
<a name="2091"/> 2091:             _ -&gt; {250, 32}
<a name="2092"/> 2092:         end,
<a name="2093"/> 2093: 
<a name="2094"/> 2094:     LM = maps:from_keys(lists:seq(1,LargeMapSize), 1),
<a name="2095"/> 2095: 
<a name="2096"/> 2096:     lists:foreach(
<a name="2097"/> 2097:       fun(Key) -&gt;
<a name="2098"/> 2098:               V = ets:select(T, [{{'$1'},[], [LM#{ Key =&gt; '$1' }]}]),
<a name="2099"/> 2099:               erlang:garbage_collect(),
<a name="2100"/> 2100:               V = ets:select(T, [{{'$1'},[], [LM#{ Key =&gt; '$1' }]}]),
<a name="2101"/> 2101:               erlang:garbage_collect(),
<a name="2102"/> 2102: 
<a name="2103"/> 2103:               V = [LM#{ Key =&gt; Dollar1 }]
<a name="2104"/> 2104:       end, maps:keys(LM)),
<a name="2105"/> 2105: 
<a name="2106"/> 2106:     %% Create a hashmap with enough keys before and after the '$1' for it to
<a name="2107"/> 2107:     %% remain a hashmap when we remove those keys.
<a name="2108"/> 2108:     LMWithDollar = make_lm_with_dollar(LM#{ '$1' =&gt; a }, LargeMapSize, FlatmapSize),
<a name="2109"/> 2109: 
<a name="2110"/> 2110:     %% Test that hashmap with '$1' in first position works
<a name="2111"/> 2111:     %% We rely on that fact that maps:keys return the keys
<a name="2112"/> 2112:     %% in iteration order.
<a name="2113"/> 2113:     lists:foldl(
<a name="2114"/> 2114:       fun
<a name="2115"/> 2115:           (Key, M = #{ '$1' := A }) when map_size(M) &gt; FlatmapSize -&gt;
<a name="2116"/> 2116: 
<a name="2117"/> 2117:               V = ets:select(T, [{{'$1'},[], [M]}]),
<a name="2118"/> 2118:               erlang:garbage_collect(),
<a name="2119"/> 2119:               V = ets:select(T, [{{'$1'},[], [M]}]),
<a name="2120"/> 2120:               erlang:garbage_collect(),
<a name="2121"/> 2121: 
<a name="2122"/> 2122:               V = [(maps:remove('$1',M))#{ Dollar1 =&gt; A }],
<a name="2123"/> 2123: 
<a name="2124"/> 2124:               maps:remove(Key, M);
<a name="2125"/> 2125:           (_, M) when map_size(M) &gt; FlatmapSize -&gt;
<a name="2126"/> 2126:               M
<a name="2127"/> 2127:       end, LMWithDollar, maps:keys(LMWithDollar)),
<a name="2128"/> 2128: 
<a name="2129"/> 2129:     %% Test that hashmap with '$1' in last position works
<a name="2130"/> 2130:     %% We rely on that fact that maps:keys return the keys
<a name="2131"/> 2131:     %% in iteration order.
<a name="2132"/> 2132:     lists:foldl(
<a name="2133"/> 2133:       fun
<a name="2134"/> 2134:           (Key, M = #{ '$1' := A }) -&gt;
<a name="2135"/> 2135: 
<a name="2136"/> 2136:               V = ets:select(T, [{{'$1'},[], [M]}]),
<a name="2137"/> 2137:               erlang:garbage_collect(),
<a name="2138"/> 2138:               V = ets:select(T, [{{'$1'},[], [M]}]),
<a name="2139"/> 2139:               erlang:garbage_collect(),
<a name="2140"/> 2140: 
<a name="2141"/> 2141:               V = [(maps:remove('$1',M))#{ Dollar1 =&gt; A }],
<a name="2142"/> 2142: 
<a name="2143"/> 2143:               maps:remove(Key, M);
<a name="2144"/> 2144:           (_, M) when map_size(M) &gt; FlatmapSize -&gt;
<a name="2145"/> 2145:               M
<a name="2146"/> 2146:       end, LMWithDollar, lists:reverse(maps:keys(LMWithDollar))),
<a name="2147"/> 2147: 
<a name="2148"/> 2148:     %% Test hashmap with a key-value pair that are variable
<a name="2149"/> 2149:     V3 = ets:select(T, [{{'$1'},[], [LM#{ '$1' =&gt; '$1' }]}]),
<a name="2150"/> 2150:     erlang:garbage_collect(),
<a name="2151"/> 2151:     V3 = ets:select(T, [{{'$1'},[], [LM#{ '$1' =&gt; '$1' }]}]),
<a name="2152"/> 2152:     erlang:garbage_collect(),
<a name="2153"/> 2153: 
<a name="2154"/> 2154:     V3 = [LM#{ Dollar1 =&gt; Dollar1 }],
<a name="2155"/> 2155: 
<a name="2156"/> 2156:     %% Test hashmap with all constant keys and values
<a name="2157"/> 2157:     V4 = ets:select(T, [{{'$1'},[], [LM#{ a =&gt; a }]}]),
<a name="2158"/> 2158:     erlang:garbage_collect(),
<a name="2159"/> 2159:     V4 = ets:select(T, [{{'$1'},[], [LM#{ a =&gt; a }]}]),
<a name="2160"/> 2160:     erlang:garbage_collect(),
<a name="2161"/> 2161: 
<a name="2162"/> 2162:     V4 = [LM#{ a =&gt; a }],
<a name="2163"/> 2163: 
<a name="2164"/> 2164:     ets:delete(T),
<a name="t_select_hashmap_term_copy_bug-last_expr"/><a name="2165"/> 2165:     ok.
<a name="2166"/> 2166: 
<a name="2167"/> 2167: <i>%% Create a hashmap that always has FlatmapSize keys before and after '$1'.</i>
<a name="2168"/> 2168: <i>%% Since the atom index of '$1' is used as hash, we cannot know before the</i>
<a name="2169"/> 2169: <i>%% code is run where exactly it will be placed, so in the rare cases when</i>
<a name="2170"/> 2170: <i>%% there isn't enough keys in the map, we insert more until there are enough.</i>
<a name="make_lm_with_dollar-3"/><a name="2171"/> 2171: <b>make_lm_with_dollar</b>(Map, LargeMapSize, FlatmapSize) -&gt;
<a name="2172"/> 2172:     {KeysBefore, KeysAfter} = lists:splitwith(fun erlang:is_integer/1, maps:keys(Map)),
<a name="make_lm_with_dollar-last_expr"/><a name="2173"/> 2173: <b>    if length</b>(KeysBefore) =&lt; FlatmapSize;
<a name="2174"/> 2174:        length(KeysAfter) - 1 =&lt; FlatmapSize -&gt;
<a name="2175"/> 2175:             NewMap = maps:from_keys(lists:seq(LargeMapSize, LargeMapSize*2), 1),
<a name="2176"/> 2176:             make_lm_with_dollar(maps:merge(Map, NewMap), LargeMapSize*2, FlatmapSize);
<a name="2177"/> 2177:        true -&gt;
<a name="2178"/> 2178:             Map
<a name="2179"/> 2179:     end.
<a name="2180"/> 2180: 
<a name="2181"/> 2181: <i>%% Test that partly bound keys gives faster matches.</i>
<a name="partly_bound-1"/><a name="2182"/> 2182: <b>partly_bound</b>(Config) when is_list(Config) -&gt;
<a name="partly_bound-last_expr"/><a name="2183"/> 2183: <b>    case os:type</b>() of
<a name="2184"/> 2184: 	{win32,_} -&gt;
<a name="2185"/> 2185: 	    {skip,&quot;Inaccurate measurements on Windows&quot;};
<a name="2186"/> 2186: 	_ -&gt;
<a name="2187"/> 2187: 	    EtsMem = etsmem(),
<a name="2188"/> 2188: 	    dont_make_worse(),
<a name="2189"/> 2189: 	    make_better(),
<a name="2190"/> 2190: 	    verify_etsmem(EtsMem)
<a name="2191"/> 2191:     end.
<a name="2192"/> 2192: 
<a name="dont_make_worse-0"/><a name="2193"/> 2193: <b>dont_make_worse</b>() -&gt;
<a name="dont_make_worse-last_expr"/><a name="2194"/> 2194: <b>    seventyfive_percent_success</b>(fun dont_make_worse_sub/0, 0, 0, 10).
<a name="2195"/> 2195: 
<a name="dont_make_worse_sub-0"/><a name="2196"/> 2196: <b>dont_make_worse_sub</b>() -&gt;
<a name="2197"/> 2197:     T = build_table([a,b],[a,b],15000),
<a name="2198"/> 2198:     T1 = time_match_object(T,{'_',a,a,1500}, [{{a,a,1500},a,a,1500}]),
<a name="2199"/> 2199:     T2 = time_match_object(T,{{a,a,'_'},a,a,1500},
<a name="2200"/> 2200: 			   [{{a,a,1500},a,a,1500}]),
<a name="2201"/> 2201:     ets:delete(T),
<a name="2202"/> 2202:     true = (T1 &gt; T2),
<a name="dont_make_worse_sub-last_expr"/><a name="2203"/> 2203:     ok.
<a name="2204"/> 2204: 
<a name="make_better-0"/><a name="2205"/> 2205: <b>make_better</b>() -&gt;
<a name="2206"/> 2206:     fifty_percent_success(fun make_better_sub2/0, 0, 0, 10),
<a name="make_better-last_expr"/><a name="2207"/> 2207: <b>    fifty_percent_success</b>(fun make_better_sub1/0, 0, 0, 10).
<a name="2208"/> 2208: 
<a name="make_better_sub1-0"/><a name="2209"/> 2209: <b>make_better_sub1</b>() -&gt;
<a name="2210"/> 2210:     T = build_table2([a,b],[a,b],15000),
<a name="2211"/> 2211:     T1 = time_match_object(T,{'_',1500,a,a}, [{{1500,a,a},1500,a,a}]),
<a name="2212"/> 2212:     T2 = time_match_object(T,{{1500,a,'_'},1500,a,a},
<a name="2213"/> 2213: 			   [{{1500,a,a},1500,a,a}]),
<a name="2214"/> 2214:     ets:delete(T),
<a name="2215"/> 2215:     io:format(&quot;~p&gt;~p~n&quot;,[(T1 / 100),T2]),
<a name="2216"/> 2216:     true = ((T1 / 100) &gt; T2), % More marginal than needed.
<a name="make_better_sub1-last_expr"/><a name="2217"/> 2217:     ok.
<a name="2218"/> 2218: 
<a name="make_better_sub2-0"/><a name="2219"/> 2219: <b>make_better_sub2</b>() -&gt;
<a name="2220"/> 2220:     T = build_table2([a,b],[a,b],15000),
<a name="2221"/> 2221:     T1 = time_match(T,{'$1',1500,a,a}),
<a name="2222"/> 2222:     T2 = time_match(T,{{1500,a,'$1'},1500,a,a}),
<a name="2223"/> 2223:     ets:delete(T),
<a name="2224"/> 2224:     io:format(&quot;~p&gt;~p~n&quot;,[(T1 / 100),T2]),
<a name="2225"/> 2225:     true = ((T1 / 100) &gt; T2), % More marginal than needed.
<a name="make_better_sub2-last_expr"/><a name="2226"/> 2226:     ok.
<a name="2227"/> 2227: 
<a name="2228"/> 2228: 
<a name="2229"/> 2229: <i>%% Heavy random matching, comparing set with ordered_set.</i>
<a name="match_heavy-1"/><a name="2230"/> 2230: <b>match_heavy</b>(Config) when is_list(Config) -&gt;
<a name="2231"/> 2231:     PrivDir = proplists:get_value(priv_dir,Config),
<a name="2232"/> 2232:     DataDir = proplists:get_value(data_dir, Config),
<a name="2233"/> 2233:     %% Easier to have in process dictionary when manually
<a name="2234"/> 2234:     %% running the test function.
<a name="2235"/> 2235:     put(where_to_read,DataDir),
<a name="2236"/> 2236:     put(where_to_write,PrivDir),
<a name="2237"/> 2237:     random_test(),
<a name="2238"/> 2238:     drop_match(),
<a name="match_heavy-last_expr"/><a name="2239"/> 2239:     ok.
<a name="2240"/> 2240: 
<a name="2241"/> 2241: <i>%%% Extra safety for the very low probability that this is not</i>
<a name="2242"/> 2242: <i>%%% caught by the random test (Statistically impossible???)</i>
<a name="drop_match-0"/><a name="2243"/> 2243: <b>drop_match</b>() -&gt;
<a name="2244"/> 2244:     EtsMem = etsmem(),
<a name="2245"/> 2245:     T = build_table([a,b],[a],1500),
<a name="2246"/> 2246:     [{{a,a,1},a,a,1},{{b,a,1},b,a,1}] =
<a name="2247"/> 2247: 	ets:match_object(T, {'_','_','_',1}),
<a name="2248"/> 2248:     true = ets:delete(T),
<a name="drop_match-last_expr"/><a name="2249"/> 2249: <b>    verify_etsmem</b>(EtsMem).
<a name="2250"/> 2250: 
<a name="2251"/> 2251: 
<a name="2252"/> 2252: 
<a name="ets_match-2"/><a name="2253"/> 2253: <b>ets_match</b>(Tab,Expr) -&gt;
<a name="ets_match-last_expr"/><a name="2254"/> 2254: <b>    case rand:uniform</b>(2) of
<a name="2255"/> 2255: 	1 -&gt;
<a name="2256"/> 2256: 	    ets:match(Tab,Expr);
<a name="2257"/> 2257: 	_ -&gt;
<a name="2258"/> 2258: 	    match_chunked(Tab,Expr)
<a name="2259"/> 2259:     end.
<a name="2260"/> 2260: 
<a name="match_chunked-2"/><a name="2261"/> 2261: <b>match_chunked</b>(Tab,Expr) -&gt;
<a name="match_chunked-last_expr"/><a name="2262"/> 2262: <b>    match_chunked_collect</b>(ets:match(Tab,Expr,
<a name="2263"/> 2263: 				    rand:uniform(1999) + 1)).
<a name="match_chunked_collect-1"/><a name="2264"/> 2264: <b>match_chunked_collect</b>('$end_of_table') -&gt;
<a name="2265"/> 2265:     [];
<a name="2266"/> 2266: <b>match_chunked_collect</b>({Results, Continuation}) -&gt;
<a name="match_chunked_collect-last_expr"/><a name="2267"/> 2267: <b>    Results ++ match_chunked_collect</b>(ets:match(Continuation)).
<a name="2268"/> 2268: 
<a name="ets_match_object-2"/><a name="2269"/> 2269: <b>ets_match_object</b>(Tab,Expr) -&gt;
<a name="ets_match_object-last_expr"/><a name="2270"/> 2270: <b>    case rand:uniform</b>(2) of
<a name="2271"/> 2271: 	1 -&gt;
<a name="2272"/> 2272: 	    ets:match_object(Tab,Expr);
<a name="2273"/> 2273: 	_ -&gt;
<a name="2274"/> 2274: 	    match_object_chunked(Tab,Expr)
<a name="2275"/> 2275:     end.
<a name="2276"/> 2276: 
<a name="match_object_chunked-2"/><a name="2277"/> 2277: <b>match_object_chunked</b>(Tab,Expr) -&gt;
<a name="match_object_chunked-last_expr"/><a name="2278"/> 2278: <b>    match_object_chunked_collect</b>(ets:match_object(Tab,Expr,
<a name="2279"/> 2279: 						  rand:uniform(1999) + 1)).
<a name="match_object_chunked_collect-1"/><a name="2280"/> 2280: <b>match_object_chunked_collect</b>('$end_of_table') -&gt;
<a name="2281"/> 2281:     [];
<a name="2282"/> 2282: <b>match_object_chunked_collect</b>({Results, Continuation}) -&gt;
<a name="match_object_chunked_collect-last_expr"/><a name="2283"/> 2283: <b>    Results ++ match_object_chunked_collect</b>(ets:match_object(Continuation)).
<a name="2284"/> 2284: 
<a name="2285"/> 2285: 
<a name="2286"/> 2286: 
<a name="random_test-0"/><a name="2287"/> 2287: <b>random_test</b>() -&gt;
<a name="2288"/> 2288:     ReadDir = get(where_to_read),
<a name="2289"/> 2289:     WriteDir = get(where_to_write),
<a name="2290"/> 2290:     (catch file:make_dir(WriteDir)),
<a name="2291"/> 2291:     case file:consult(filename:join([ReadDir,&quot;preset_random_seed.txt&quot;])) of
<a name="2292"/> 2292: 	{ok,[X]} -&gt;
<a name="2293"/> 2293: 	    rand:seed(X);
<a name="2294"/> 2294: 	_ -&gt;
<a name="2295"/> 2295: 	    rand:seed(default)
<a name="2296"/> 2296:     end,
<a name="2297"/> 2297:     Seed = rand:export_seed(),
<a name="2298"/> 2298:     {ok,F} = file:open(filename:join([WriteDir,&quot;last_random_seed.txt&quot;]),
<a name="2299"/> 2299: 		       [write]),
<a name="2300"/> 2300:     io:format(F,&quot;~p. ~n&quot;,[Seed]),
<a name="2301"/> 2301:     file:close(F),
<a name="2302"/> 2302:     io:format(&quot;Random seed ~p written to ~s, copy to ~s to rerun with &quot;
<a name="2303"/> 2303: 	      &quot;same seed.&quot;,[Seed,
<a name="2304"/> 2304: 			    filename:join([WriteDir, &quot;last_random_seed.txt&quot;]),
<a name="2305"/> 2305: 			    filename:join([ReadDir,
<a name="2306"/> 2306: 					   &quot;preset_random_seed.txt&quot;])]),
<a name="random_test-last_expr"/><a name="2307"/> 2307: <b>    do_random_test</b>().
<a name="2308"/> 2308: 
<a name="do_random_test-0"/><a name="2309"/> 2309: <b>do_random_test</b>() -&gt;
<a name="2310"/> 2310:     EtsMem = etsmem(),
<a name="2311"/> 2311:     OrdSet = ets_new(xxx,[ordered_set]),
<a name="2312"/> 2312:     Set = ets_new(xxx,[]),
<a name="2313"/> 2313:     do_n_times(fun() -&gt;
<a name="2314"/> 2314: 		       Key = create_random_string(25),
<a name="2315"/> 2315: 		       Value = create_random_tuple(25),
<a name="2316"/> 2316: 		       ets:insert(OrdSet,{Key,Value}),
<a name="2317"/> 2317: 		       ets:insert(Set,{Key,Value})
<a name="2318"/> 2318: 	       end, 5000),
<a name="2319"/> 2319:     io:format(&quot;~nData inserted~n&quot;),
<a name="2320"/> 2320:     do_n_times(fun() -&gt;
<a name="2321"/> 2321: 		       I = rand:uniform(25),
<a name="2322"/> 2322: 		       Key = create_random_string(I) ++ '_',
<a name="2323"/> 2323: 		       L1 = ets_match_object(OrdSet,{Key,'_'}),
<a name="2324"/> 2324: 		       L2 = lists:sort(ets_match_object(Set,{Key,'_'})),
<a name="2325"/> 2325: 		       case L1 == L2 of
<a name="2326"/> 2326: 			   false -&gt;
<a name="2327"/> 2327: 			       io:format(&quot;~p != ~p~n&quot;,
<a name="2328"/> 2328: 					 [L1,L2]),
<a name="2329"/> 2329: 			       exit({not_eq, L1, L2});
<a name="2330"/> 2330: 			   true -&gt;
<a name="2331"/> 2331: 			       ok
<a name="2332"/> 2332: 		       end
<a name="2333"/> 2333: 	       end,
<a name="2334"/> 2334: 	       2000),
<a name="2335"/> 2335:     io:format(&quot;~nData matched~n&quot;),
<a name="2336"/> 2336:     ets:match_delete(OrdSet,'_'),
<a name="2337"/> 2337:     ets:match_delete(Set,'_'),
<a name="2338"/> 2338:     do_n_times(fun() -&gt;
<a name="2339"/> 2339: 		       Value = create_random_string(25),
<a name="2340"/> 2340: 		       Key = create_random_tuple(25),
<a name="2341"/> 2341: 		       ets:insert(OrdSet,{Key,Value}),
<a name="2342"/> 2342: 		       ets:insert(Set,{Key,Value})
<a name="2343"/> 2343: 	       end, 2000),
<a name="2344"/> 2344:     io:format(&quot;~nData inserted~n&quot;),
<a name="2345"/> 2345:     (fun() -&gt;
<a name="2346"/> 2346: 	     Key = list_to_tuple(lists:duplicate(25,'_')),
<a name="2347"/> 2347: 	     L1 = ets_match_object(OrdSet,{Key,'_'}),
<a name="2348"/> 2348: 	     L2 = lists:sort(ets_match_object(Set,{Key,'_'})),
<a name="2349"/> 2349: 	     2000 = length(L1),
<a name="2350"/> 2350: 	     case L1 == L2 of
<a name="2351"/> 2351: 		 false -&gt;
<a name="2352"/> 2352: 		     io:format(&quot;~p != ~p~n&quot;,
<a name="2353"/> 2353: 			       [L1,L2]),
<a name="2354"/> 2354: 		     exit({not_eq, L1, L2});
<a name="2355"/> 2355: 		 true -&gt;
<a name="2356"/> 2356: 		     ok
<a name="2357"/> 2357: 	     end
<a name="2358"/> 2358:      end)(),
<a name="2359"/> 2359:     (fun() -&gt;
<a name="2360"/> 2360: 	     Key = {'$1','$2','$3','$4',
<a name="2361"/> 2361: 		    '$5','$6','$7','$8',
<a name="2362"/> 2362: 		    '$9','$10','$11','$12',
<a name="2363"/> 2363: 		    '$13','$14','$15','$16',
<a name="2364"/> 2364: 		    '$17','$18','$19','$20',
<a name="2365"/> 2365: 		    '$21','$22','$23','$24',
<a name="2366"/> 2366: 		    '$25'},
<a name="2367"/> 2367: 	     L1 = ets_match_object(OrdSet,{Key,'_'}),
<a name="2368"/> 2368: 	     L2 = lists:sort(ets_match_object(Set,{Key,'_'})),
<a name="2369"/> 2369: 	     2000 = length(L1),
<a name="2370"/> 2370: 	     case L1 == L2 of
<a name="2371"/> 2371: 		 false -&gt;
<a name="2372"/> 2372: 		     io:format(&quot;~p != ~p~n&quot;,
<a name="2373"/> 2373: 			       [L1,L2]),
<a name="2374"/> 2374: 		     exit({not_eq, L1, L2});
<a name="2375"/> 2375: 		 true -&gt;
<a name="2376"/> 2376: 		     ok
<a name="2377"/> 2377: 	     end
<a name="2378"/> 2378:      end)(),
<a name="2379"/> 2379:     (fun() -&gt;
<a name="2380"/> 2380: 	     Key = {'$1','$2','$3','$4',
<a name="2381"/> 2381: 		    '$5','$6','$7','$8',
<a name="2382"/> 2382: 		    '$9','$10','$11','$12',
<a name="2383"/> 2383: 		    '$13','$14','$15','$16',
<a name="2384"/> 2384: 		    '$17','$18','$19','$20',
<a name="2385"/> 2385: 		    '$21','$22','$23','$24',
<a name="2386"/> 2386: 		    '$25'},
<a name="2387"/> 2387: 	     L1 = ets_match(OrdSet,{Key,'_'}),
<a name="2388"/> 2388: 	     L2 = lists:sort(ets_match(Set,{Key,'_'})),
<a name="2389"/> 2389: 	     2000 = length(L1),
<a name="2390"/> 2390: 	     case L1 == L2 of
<a name="2391"/> 2391: 		 false -&gt;
<a name="2392"/> 2392: 		     io:format(&quot;~p != ~p~n&quot;,
<a name="2393"/> 2393: 			       [L1,L2]),
<a name="2394"/> 2394: 		     exit({not_eq, L1, L2});
<a name="2395"/> 2395: 		 true -&gt;
<a name="2396"/> 2396: 		     ok
<a name="2397"/> 2397: 	     end
<a name="2398"/> 2398:      end)(),
<a name="2399"/> 2399:     ets:match_delete(OrdSet,'_'),
<a name="2400"/> 2400:     ets:match_delete(Set,'_'),
<a name="2401"/> 2401:     do_n_times(fun() -&gt;
<a name="2402"/> 2402: 		       Value = create_random_string(25),
<a name="2403"/> 2403: 		       Key = create_random_tuple(25),
<a name="2404"/> 2404: 		       ets:insert(OrdSet,{Key,Value}),
<a name="2405"/> 2405: 		       ets:insert(Set,{Key,Value})
<a name="2406"/> 2406: 	       end, 2000),
<a name="2407"/> 2407:     io:format(&quot;~nData inserted~n&quot;),
<a name="2408"/> 2408:     do_n_times(fun() -&gt;
<a name="2409"/> 2409: 		       Key = create_partly_bound_tuple(25),
<a name="2410"/> 2410: 		       L1 = ets_match_object(OrdSet,{Key,'_'}),
<a name="2411"/> 2411: 		       L2 = lists:sort(ets_match_object(Set,{Key,'_'})),
<a name="2412"/> 2412: 		       case L1 == L2 of
<a name="2413"/> 2413: 			   false -&gt;
<a name="2414"/> 2414: 			       io:format(&quot;~p != ~p~n&quot;,
<a name="2415"/> 2415: 					 [L1,L2]),
<a name="2416"/> 2416: 			       exit({not_eq, L1, L2});
<a name="2417"/> 2417: 			   true -&gt;
<a name="2418"/> 2418: 			       ok
<a name="2419"/> 2419: 		       end
<a name="2420"/> 2420: 	       end,
<a name="2421"/> 2421: 	       2000),
<a name="2422"/> 2422:     do_n_times(fun() -&gt;
<a name="2423"/> 2423: 		       Key = create_partly_bound_tuple2(25),
<a name="2424"/> 2424: 		       L1 = ets_match_object(OrdSet,{Key,'_'}),
<a name="2425"/> 2425: 		       L2 = lists:sort(ets_match_object(Set,{Key,'_'})),
<a name="2426"/> 2426: 		       case L1 == L2 of
<a name="2427"/> 2427: 			   false -&gt;
<a name="2428"/> 2428: 			       io:format(&quot;~p != ~p~n&quot;,
<a name="2429"/> 2429: 					 [L1,L2]),
<a name="2430"/> 2430: 			       exit({not_eq, L1, L2});
<a name="2431"/> 2431: 			   true -&gt;
<a name="2432"/> 2432: 			       ok
<a name="2433"/> 2433: 		       end
<a name="2434"/> 2434: 	       end,
<a name="2435"/> 2435: 	       2000),
<a name="2436"/> 2436:     do_n_times(fun() -&gt;
<a name="2437"/> 2437: 		       Key = create_partly_bound_tuple2(25),
<a name="2438"/> 2438: 		       L1 = ets_match(OrdSet,{Key,'_'}),
<a name="2439"/> 2439: 		       L2 = lists:sort(ets_match(Set,{Key,'_'})),
<a name="2440"/> 2440: 		       case L1 == L2 of
<a name="2441"/> 2441: 			   false -&gt;
<a name="2442"/> 2442: 			       io:format(&quot;~p != ~p~n&quot;,
<a name="2443"/> 2443: 					 [L1,L2]),
<a name="2444"/> 2444: 			       exit({not_eq, L1, L2});
<a name="2445"/> 2445: 			   true -&gt;
<a name="2446"/> 2446: 			       ok
<a name="2447"/> 2447: 		       end
<a name="2448"/> 2448: 	       end,
<a name="2449"/> 2449: 	       2000),
<a name="2450"/> 2450:     io:format(&quot;~nData matched~n&quot;),
<a name="2451"/> 2451:     ets:match_delete(OrdSet,'_'),
<a name="2452"/> 2452:     ets:match_delete(Set,'_'),
<a name="2453"/> 2453:     do_n_times(fun() -&gt;
<a name="2454"/> 2454: 		       do_n_times(fun() -&gt;
<a name="2455"/> 2455: 					  Value =
<a name="2456"/> 2456: 					      create_random_string(25),
<a name="2457"/> 2457: 					  Key = create_random_tuple(25),
<a name="2458"/> 2458: 					  ets:insert(OrdSet,{Key,Value}),
<a name="2459"/> 2459: 					  ets:insert(Set,{Key,Value})
<a name="2460"/> 2460: 				  end, 500),
<a name="2461"/> 2461: 		       io:format(&quot;~nData inserted~n&quot;),
<a name="2462"/> 2462: 		       do_n_times(fun() -&gt;
<a name="2463"/> 2463: 					  Key =
<a name="2464"/> 2464: 					      create_partly_bound_tuple(25),
<a name="2465"/> 2465: 					  ets:match_delete(OrdSet,{Key,'_'}),
<a name="2466"/> 2466: 					  ets:match_delete(Set,{Key,'_'}),
<a name="2467"/> 2467: 					  L1 = ets:info(OrdSet,size),
<a name="2468"/> 2468: 					  L2 = ets:info(Set,size),
<a name="2469"/> 2469: 					  [] = ets_match_object(OrdSet,
<a name="2470"/> 2470: 								{Key,'_'}),
<a name="2471"/> 2471: 					  case L1 == L2 of
<a name="2472"/> 2472: 					      false -&gt;
<a name="2473"/> 2473: 						  io:format(&quot;~p != ~p &quot;
<a name="2474"/> 2474: 							    &quot;(deleted ~p)~n&quot;,
<a name="2475"/> 2475: 							    [L1,L2,Key]),
<a name="2476"/> 2476: 						  exit({not_eq, L1, L2,
<a name="2477"/> 2477: 							{deleted,Key}});
<a name="2478"/> 2478: 					      true -&gt;
<a name="2479"/> 2479: 						  ok
<a name="2480"/> 2480: 					  end
<a name="2481"/> 2481: 				  end,
<a name="2482"/> 2482: 				  50),
<a name="2483"/> 2483: 		       io:format(&quot;~nData deleted~n&quot;)
<a name="2484"/> 2484: 	       end,
<a name="2485"/> 2485: 	       10),
<a name="2486"/> 2486:     ets:delete(OrdSet),
<a name="2487"/> 2487:     ets:delete(Set),
<a name="do_random_test-last_expr"/><a name="2488"/> 2488: <b>    verify_etsmem</b>(EtsMem).
<a name="2489"/> 2489: 
<a name="2490"/> 2490: <i>%% Test various variants of update_element.</i>
<a name="update_element-1"/><a name="2491"/> 2491: <b>update_element</b>(Config) when is_list(Config) -&gt;
<a name="2492"/> 2492:     EtsMem = etsmem(),
<a name="2493"/> 2493:     repeat_for_opts(fun update_element_opts/1),
<a name="update_element-last_expr"/><a name="2494"/> 2494: <b>    verify_etsmem</b>(EtsMem).
<a name="2495"/> 2495: 
<a name="update_element_opts-1"/><a name="2496"/> 2496: <b>update_element_opts</b>(Opts) -&gt;
<a name="2497"/> 2497:     TupleCases = [{{key,val}, 1 ,2},
<a name="2498"/> 2498: 		  {{val,key}, 2, 1},
<a name="2499"/> 2499: 		  {{key,val}, 1 ,[2]},
<a name="2500"/> 2500: 		  {{key,val,val}, 1, [2,3]},
<a name="2501"/> 2501: 		  {{val,key,val,val}, 2, [3,4,1]},
<a name="2502"/> 2502: 		  {{val,val,key,val}, 3, [1,4,1,2]}, % update pos1 twice
<a name="2503"/> 2503: 		  {{val,val,val,key}, 4, [2,1,2,3]}],% update pos2 twice
<a name="2504"/> 2504: 
<a name="2505"/> 2505:     lists:foreach(fun({Tuple,KeyPos,UpdPos}) -&gt; update_element_opts(Tuple,KeyPos,UpdPos,Opts) end,
<a name="2506"/> 2506: 		  TupleCases),
<a name="2507"/> 2507: 
<a name="update_element_opts-last_expr"/><a name="2508"/> 2508: <b>    update_element_neg</b>(Opts).
<a name="2509"/> 2509: 
<a name="2510"/> 2510: 
<a name="2511"/> 2511: 
<a name="update_element_opts-4"/><a name="2512"/> 2512: <b>update_element_opts</b>(Tuple,KeyPos,UpdPos,Opts) -&gt;
<a name="2513"/> 2513:     Set = ets_new(set,[{keypos,KeyPos} | Opts]),
<a name="2514"/> 2514:     update_element(Set,Tuple,KeyPos,UpdPos),
<a name="2515"/> 2515:     true = ets:delete(Set),
<a name="2516"/> 2516: 
<a name="2517"/> 2517:     run_if_valid_opts(
<a name="2518"/> 2518:       [ordered_set,{keypos,KeyPos} | Opts],
<a name="2519"/> 2519:       fun (OptsOrdSet) -&gt;
<a name="2520"/> 2520:               OrdSet = ets_new(ordered_set, OptsOrdSet),
<a name="2521"/> 2521:               update_element(OrdSet,Tuple,KeyPos,UpdPos),
<a name="2522"/> 2522:               true = ets:delete(OrdSet)
<a name="2523"/> 2523:       end),
<a name="update_element_opts-last_expr"/><a name="2524"/> 2524:     ok.
<a name="2525"/> 2525: 
<a name="update_element-4"/><a name="2526"/> 2526: <b>update_element</b>(T,Tuple,KeyPos,UpdPos) -&gt;
<a name="2527"/> 2527:     KeyList = [17,&quot;seventeen&quot;,&lt;&lt;&quot;seventeen&quot;&gt;&gt;,{17},list_to_binary(lists:seq(1,100)),make_ref(), self()],
<a name="update_element-last_expr"/><a name="2528"/> 2528: <b>    lists:foreach</b>(fun(Key) -&gt;
<a name="2529"/> 2529: 			  TupleWithKey = setelement(KeyPos,Tuple,Key),
<a name="2530"/> 2530: 			  update_element_do(T,TupleWithKey,Key,UpdPos)
<a name="2531"/> 2531: 		  end,
<a name="2532"/> 2532: 		  KeyList).
<a name="2533"/> 2533: 
<a name="update_element_do-4"/><a name="2534"/> 2534: <b>update_element_do</b>(Tab,Tuple,Key,UpdPos) -&gt;
<a name="2535"/> 2535: 
<a name="2536"/> 2536:     %% Strategy: Step around in Values array and call ets:update_element for the values.
<a name="2537"/> 2537:     %% Take Length number of steps of size 1, then of size 2, ..., Length-1.
<a name="2538"/> 2538:     %% This will try all combinations of {fromValue,toValue}
<a name="2539"/> 2539:     %%
<a name="2540"/> 2540:     %% IMPORTANT: size(Values) must be a prime number for this to work!!!
<a name="2541"/> 2541: 
<a name="2542"/> 2542:     Big32 = 16#12345678,
<a name="2543"/> 2543:     Big64 = 16#123456789abcdef0,
<a name="2544"/> 2544:     RefcBin = list_to_binary(lists:seq(1,100)),
<a name="2545"/> 2545:     BigMap1 = maps:from_list([{N,N} || N &lt;- lists:seq(1,33)]),
<a name="2546"/> 2546:     BigMap2 = BigMap1#{key =&gt; RefcBin, RefcBin =&gt; value},
<a name="2547"/> 2547:     Values = { 623, -27, Big32, -Big32, Big64, -Big64, Big32*Big32,
<a name="2548"/> 2548: 	       -Big32*Big32, Big32*Big64, -Big32*Big64, Big64*Big64, -Big64*Big64,
<a name="2549"/> 2549: 	       &quot;A&quot;, &quot;Sverker&quot;, [], {12,-132}, {},
<a name="2550"/> 2550: 	       &lt;&lt;45,232,0,12,133&gt;&gt;, &lt;&lt;234,12,23&gt;&gt;, RefcBin,
<a name="2551"/> 2551: 	       (fun(X) -&gt; X*Big32 end),
<a name="2552"/> 2552: 	       make_ref(), make_ref(), self(), ok, update_element,
<a name="2553"/> 2553:                #{a =&gt; value, &quot;hello&quot; =&gt; &quot;world&quot;, 1.0 =&gt; RefcBin },
<a name="2554"/> 2554:                BigMap1, BigMap2},
<a name="2555"/> 2555:     Length = tuple_size(Values),
<a name="2556"/> 2556:     29 = Length,
<a name="2557"/> 2557: 
<a name="2558"/> 2558:     PosValArgF = fun MeF(ToIx, ResList, [Pos | PosTail], Rand) -&gt;
<a name="2559"/> 2559: 			 NextIx = (ToIx+Rand) rem Length,
<a name="2560"/> 2560: 			 MeF(NextIx, [{Pos,element(ToIx+1,Values)} | ResList], PosTail, Rand);
<a name="2561"/> 2561: 
<a name="2562"/> 2562: 		     MeF(_ToIx, ResList, [], _Rand) -&gt;
<a name="2563"/> 2563: 			 ResList;
<a name="2564"/> 2564: 
<a name="2565"/> 2565: 		     MeF(ToIx, [], Pos, _Rand) -&gt;
<a name="2566"/> 2566: 			 {Pos, element(ToIx+1,Values)}   % single {pos,value} arg
<a name="2567"/> 2567: 		 end,
<a name="2568"/> 2568: 
<a name="2569"/> 2569:     UpdateF = fun(ToIx,Rand) -&gt;
<a name="2570"/> 2570:                       PosValArg = PosValArgF(ToIx,[],UpdPos,Rand),
<a name="2571"/> 2571:                       %%io:format(&quot;update_element(~p)~n&quot;,[PosValArg]),
<a name="2572"/> 2572:                       ArgHash = erlang:phash2({Tab,Key,PosValArg}),
<a name="2573"/> 2573:                       true = ets:update_element(Tab, Key, PosValArg),
<a name="2574"/> 2574:                       [DefaultObj] = ets:lookup(Tab, Key),
<a name="2575"/> 2575:                       NewKey = make_ref(),
<a name="2576"/> 2576:                       true = ets:update_element(Tab, NewKey, PosValArg, DefaultObj),
<a name="2577"/> 2577:                       true = [update_tuple({ets:info(Tab, keypos), NewKey}, DefaultObj)] =:= ets:lookup(Tab, NewKey),
<a name="2578"/> 2578:                       ArgHash = erlang:phash2({Tab,Key,PosValArg}),
<a name="2579"/> 2579:                       NewTuple = update_tuple(PosValArg,Tuple),
<a name="2580"/> 2580:                       [NewTuple] = ets:lookup(Tab,Key),
<a name="2581"/> 2581:                       [begin
<a name="2582"/> 2582:                            Elem = element(I, NewTuple),
<a name="2583"/> 2583:                            Elem = ets:lookup_element(Tab, Key, I)
<a name="2584"/> 2584:                        end
<a name="2585"/> 2585:                        || I &lt;- lists:seq(1, tuple_size(NewTuple))]
<a name="2586"/> 2586: 	      end,
<a name="2587"/> 2587: 
<a name="2588"/> 2588:     LoopF = fun MeF(_FromIx, Incr, _Times, Checksum) when Incr &gt;= Length -&gt;
<a name="2589"/> 2589: 		    Checksum; % done
<a name="2590"/> 2590: 
<a name="2591"/> 2591: 		MeF(FromIx, Incr, 0, Checksum) -&gt;
<a name="2592"/> 2592: 		    MeF(FromIx, Incr+1, Length, Checksum);
<a name="2593"/> 2593: 
<a name="2594"/> 2594: 		MeF(FromIx, Incr, Times, Checksum) -&gt;
<a name="2595"/> 2595: 		    ToIx = (FromIx + Incr) rem Length,
<a name="2596"/> 2596: 		    UpdateF(ToIx,Checksum),
<a name="2597"/> 2597: 		    if
<a name="2598"/> 2598: 			Incr =:= 0 -&gt; UpdateF(ToIx,Checksum);  % extra update to same value
<a name="2599"/> 2599: 			true -&gt; true
<a name="2600"/> 2600: 		    end,
<a name="2601"/> 2601: 		    MeF(ToIx, Incr, Times-1, Checksum+ToIx+1)
<a name="2602"/> 2602: 	    end,
<a name="2603"/> 2603: 
<a name="2604"/> 2604:     FirstTuple = Tuple,
<a name="2605"/> 2605:     true = ets:insert(Tab,FirstTuple),
<a name="2606"/> 2606:     [FirstTuple] = ets:lookup(Tab,Key),
<a name="2607"/> 2607: 
<a name="2608"/> 2608:     Checksum = LoopF(0, 1, Length, 0),
<a name="2609"/> 2609:     Checksum = (Length-1)*Length*(Length+1) div 2,  % if Length is a prime
<a name="update_element_do-last_expr"/><a name="2610"/> 2610:     ok.
<a name="2611"/> 2611: 
<a name="update_tuple-2"/><a name="2612"/> 2612: <b>update_tuple</b>({Pos,Val}, Tpl) -&gt;
<a name="2613"/> 2613:     setelement(Pos, Tpl, Val);
<a name="2614"/> 2614: <b>update_tuple</b>([{Pos,Val} | Tail], Tpl) -&gt;
<a name="2615"/> 2615:     update_tuple(Tail,setelement(Pos, Tpl, Val));
<a name="2616"/> 2616: <b>update_tuple</b>([], Tpl) -&gt;
<a name="update_tuple-last_expr"/><a name="2617"/> 2617:     Tpl.
<a name="2618"/> 2618: 
<a name="2619"/> 2619: 
<a name="2620"/> 2620: 
<a name="update_element_neg-1"/><a name="2621"/> 2621: <b>update_element_neg</b>(Opts) -&gt;
<a name="2622"/> 2622:     Set = ets_new(set,Opts),
<a name="2623"/> 2623:     update_element_neg_do(Set),
<a name="2624"/> 2624:     ets:delete(Set),
<a name="2625"/> 2625:     {'EXIT',{badarg,_}} = (catch ets:update_element(Set,key,{2,1})),
<a name="2626"/> 2626:     {'EXIT',{badarg,_}} = (catch ets:update_element(Set,key,{2,1},{a,b})),
<a name="2627"/> 2627: 
<a name="2628"/> 2628:     run_if_valid_opts(
<a name="2629"/> 2629:       [ordered_set | Opts],
<a name="2630"/> 2630:       fun(OptsOrdSet) -&gt;
<a name="2631"/> 2631:               OrdSet = ets_new(ordered_set, OptsOrdSet),
<a name="2632"/> 2632:               update_element_neg_do(OrdSet),
<a name="2633"/> 2633:               ets:delete(OrdSet),
<a name="2634"/> 2634:               {'EXIT',{badarg,_}} = (catch ets:update_element(OrdSet,key,{2,1})),
<a name="2635"/> 2635:               {'EXIT',{badarg,_}} = (catch ets:update_element(OrdSet,key2,{2,1},{a,b}))
<a name="2636"/> 2636:       end),
<a name="2637"/> 2637: 
<a name="2638"/> 2638:     Bag = ets_new(bag,[bag | Opts]),
<a name="2639"/> 2639:     DBag = ets_new(duplicate_bag,[duplicate_bag | Opts]),
<a name="2640"/> 2640:     {'EXIT',{badarg,_}} = (catch ets:update_element(Bag,key,{2,1})),
<a name="2641"/> 2641:     {'EXIT',{badarg,_}} = (catch ets:update_element(Bag,key,{2,1},{key,0})),
<a name="2642"/> 2642:     {'EXIT',{badarg,_}} = (catch ets:update_element(DBag,key,{2,1})),
<a name="2643"/> 2643:     {'EXIT',{badarg,_}} = (catch ets:update_element(DBag,key,{2,1},{key,0})),
<a name="2644"/> 2644:     true = ets:delete(Bag),
<a name="2645"/> 2645:     true = ets:delete(DBag),
<a name="update_element_neg-last_expr"/><a name="2646"/> 2646:     ok.
<a name="2647"/> 2647: 
<a name="2648"/> 2648: 
<a name="update_element_neg_do-1"/><a name="2649"/> 2649: <b>update_element_neg_do</b>(T) -&gt;
<a name="2650"/> 2650:     Object = {key, 0, &quot;Hej&quot;},
<a name="2651"/> 2651:     true = ets:insert(T,Object),
<a name="2652"/> 2652: 
<a name="2653"/> 2653:     UpdateF = fun(Arg3) -&gt;
<a name="2654"/> 2654: 		      ArgHash = erlang:phash2({T,key,Arg3}),
<a name="2655"/> 2655: 		      {'EXIT',{badarg,_}} = (catch ets:update_element(T,key,Arg3)),
<a name="2656"/> 2656: 		      ArgHash = erlang:phash2({T,key,Arg3}),
<a name="2657"/> 2657: 		      {'EXIT',{badarg,_}} = (catch ets:update_element(T,key2,Arg3,Object)),
<a name="2658"/> 2658: 		      ArgHash = erlang:phash2({T,key,Arg3}),
<a name="2659"/> 2659: 		      [Object] = ets:lookup(T,key)
<a name="2660"/> 2660: 	      end,
<a name="2661"/> 2661: 
<a name="2662"/> 2662:     %% List of invalid {Pos,Value} tuples
<a name="2663"/> 2663:     InvList = [false, {2}, {2,1,false}, {false,1}, {0,1}, {1,1}, {-1,1}, {4,1}],
<a name="2664"/> 2664: 
<a name="2665"/> 2665:     lists:foreach(UpdateF, InvList),
<a name="2666"/> 2666:     lists:foreach(fun(InvTpl) -&gt; UpdateF([{2,1},InvTpl]) end, InvList),
<a name="2667"/> 2667:     lists:foreach(fun(InvTpl) -&gt; UpdateF([InvTpl,{2,1}]) end, InvList),
<a name="2668"/> 2668:     lists:foreach(fun(InvTpl) -&gt; UpdateF([{2,1},{3,&quot;Hello&quot;},InvTpl]) end, InvList),
<a name="2669"/> 2669:     lists:foreach(fun(InvTpl) -&gt; UpdateF([{3,&quot;Hello&quot;},{2,1},InvTpl]) end, InvList),
<a name="2670"/> 2670:     lists:foreach(fun(InvTpl) -&gt; UpdateF([{2,1},InvTpl,{3,&quot;Hello&quot;}]) end, InvList),
<a name="2671"/> 2671:     lists:foreach(fun(InvTpl) -&gt; UpdateF([InvTpl,{3,&quot;Hello&quot;},{2,1}]) end, InvList),
<a name="2672"/> 2672:     UpdateF([{2,1} | {3,1}]),
<a name="2673"/> 2673:     lists:foreach(fun(InvTpl) -&gt; UpdateF([{2,1} | InvTpl]) end, InvList),
<a name="2674"/> 2674: 
<a name="2675"/> 2675:     true = ets:update_element(T,key,[]),
<a name="2676"/> 2676:     false = ets:update_element(T,false,[]),
<a name="2677"/> 2677:     false = ets:update_element(T,false,{2,1}),
<a name="2678"/> 2678:     ets:delete(T,key),
<a name="2679"/> 2679:     false = ets:update_element(T,key,{2,1}),
<a name="update_element_neg_do-last_expr"/><a name="2680"/> 2680:     ok.
<a name="2681"/> 2681: 
<a name="2682"/> 2682: 
<a name="update_element_default-1"/><a name="2683"/> 2683: <b>update_element_default</b>(Config) when is_list(Config) -&gt;
<a name="2684"/> 2684:     EtsMem = etsmem(),
<a name="2685"/> 2685:     repeat_for_opts(fun update_element_default_opts/1),
<a name="update_element_default-last_expr"/><a name="2686"/> 2686: <b>    verify_etsmem</b>(EtsMem).
<a name="2687"/> 2687: 
<a name="2688"/> 2688: 
<a name="update_element_default_opts-1"/><a name="2689"/> 2689: <b>update_element_default_opts</b>(Opts) -&gt;
<a name="2690"/> 2690:     lists:foreach(
<a name="2691"/> 2691:         fun({Type, {Key, Pos}}) -&gt;
<a name="2692"/> 2692:             run_if_valid_opts(
<a name="2693"/> 2693:                 [Type, {keypos, Pos} | Opts],
<a name="2694"/> 2694: 		fun(TabOpts) -&gt;
<a name="2695"/> 2695:                     Tab = ets_new(Type, TabOpts),
<a name="2696"/> 2696: 		    true = ets:update_element(Tab, Key, {3, b}, {key1, key2, a, x}),
<a name="2697"/> 2697: 		    [{key1, key2, b, x}] = ets:lookup(Tab, Key),
<a name="2698"/> 2698: 		    true = ets:update_element(Tab, Key, {3, c}, {key1, key2, a, y}),
<a name="2699"/> 2699: 		    [{key1, key2, c, x}] = ets:lookup(Tab, Key),
<a name="2700"/> 2700: 		    ets:delete(Tab)
<a name="2701"/> 2701:                 end
<a name="2702"/> 2702: 	    )
<a name="2703"/> 2703: 	end,
<a name="2704"/> 2704: 	[{Type, KeyPos} || Type &lt;- [set, ordered_set], KeyPos &lt;- [{key1, 1}, {key2, 2}]]
<a name="2705"/> 2705:     ),
<a name="update_element_default_opts-last_expr"/><a name="2706"/> 2706:     ok.
<a name="2707"/> 2707: 
<a name="2708"/> 2708: 
<a name="2709"/> 2709: <i>%% test various variants of update_counter.</i>
<a name="update_counter-1"/><a name="2710"/> 2710: <b>update_counter</b>(Config) when is_list(Config) -&gt;
<a name="2711"/> 2711:     EtsMem = etsmem(),
<a name="2712"/> 2712:     repeat_for_opts(fun update_counter_do/1),
<a name="update_counter-last_expr"/><a name="2713"/> 2713: <b>    verify_etsmem</b>(EtsMem).
<a name="2714"/> 2714: 
<a name="update_counter_do-1"/><a name="2715"/> 2715: <b>update_counter_do</b>(Opts) -&gt;
<a name="2716"/> 2716:     Set = ets_new(set,Opts),
<a name="2717"/> 2717:     update_counter_for(Set),
<a name="2718"/> 2718:     ets:delete_all_objects(Set),
<a name="2719"/> 2719:     ets:safe_fixtable(Set, true),
<a name="2720"/> 2720:     update_counter_for(Set),
<a name="2721"/> 2721:     ets:safe_fixtable(Set, false),
<a name="2722"/> 2722:     ets:delete(Set),
<a name="2723"/> 2723: 
<a name="2724"/> 2724:     run_if_valid_opts(
<a name="2725"/> 2725:       [ordered_set | Opts],
<a name="2726"/> 2726:       fun (OptsOrdSet) -&gt;
<a name="2727"/> 2727:               OrdSet = ets_new(ordered_set, OptsOrdSet),
<a name="2728"/> 2728:               update_counter_for(OrdSet),
<a name="2729"/> 2729:               ets:delete_all_objects(OrdSet),
<a name="2730"/> 2730:               ets:safe_fixtable(OrdSet, true),
<a name="2731"/> 2731:               update_counter_for(OrdSet),
<a name="2732"/> 2732:               ets:safe_fixtable(OrdSet, false),
<a name="2733"/> 2733:               ets:delete(OrdSet)
<a name="2734"/> 2734:       end),
<a name="2735"/> 2735: 
<a name="update_counter_do-last_expr"/><a name="2736"/> 2736: <b>    update_counter_neg</b>(Opts).
<a name="2737"/> 2737: 
<a name="update_counter_for-1"/><a name="2738"/> 2738: <b>update_counter_for</b>(T) -&gt;
<a name="2739"/> 2739:     ets:insert(T,{a,1,1}),
<a name="2740"/> 2740:     101 = ets:update_counter(T,a,100),
<a name="2741"/> 2741:     [{a,101,1}] = ets:lookup(T,a),
<a name="2742"/> 2742:     101 = ets:update_counter(T,a,{3,100}),
<a name="2743"/> 2743:     [{a,101,101}] = ets:lookup(T,a),
<a name="2744"/> 2744: 
<a name="2745"/> 2745: 
<a name="2746"/> 2746:     LooperF = fun(Obj, 0, _, _) -&gt;
<a name="2747"/> 2747: 		      Obj;
<a name="2748"/> 2748: 
<a name="2749"/> 2749: 		 (Obj, Times, Arg3, Myself) -&gt;
<a name="2750"/> 2750: 		      {NewObj, Ret} = uc_mimic(Obj,Arg3),
<a name="2751"/> 2751: 		      ArgHash = erlang:phash2({T,a,Arg3}),
<a name="2752"/> 2752: 		      %%io:format(&quot;update_counter(~p, ~p, ~p) expecting ~p\n&quot;,[T,a,Arg3,Ret]),
<a name="2753"/> 2753:                       [DefaultObj] = ets:lookup(T, a),
<a name="2754"/> 2754: 		      Ret = ets:update_counter(T,a,Arg3),
<a name="2755"/> 2755:                       Ret = ets:update_counter(T, b, Arg3, DefaultObj),   % Use other key
<a name="2756"/> 2756: 		      ArgHash = erlang:phash2({T,a,Arg3}),
<a name="2757"/> 2757: 		      %%io:format(&quot;NewObj=~p~n &quot;,[NewObj]),
<a name="2758"/> 2758: 		      [NewObj] = ets:lookup(T,a),
<a name="2759"/> 2759:                       true = ets:lookup(T, b) =:= [setelement(1, NewObj, b)],
<a name="2760"/> 2760:                       ets:delete(T, b),
<a name="2761"/> 2761: 		      Myself(NewObj,Times-1,Arg3,Myself)
<a name="2762"/> 2762: 	      end,
<a name="2763"/> 2763: 
<a name="2764"/> 2764:     LoopF = fun(Obj, Times, Arg3) -&gt;
<a name="2765"/> 2765: 		    %%io:format(&quot;Loop start:\nObj = ~p\nArg3=~p\n&quot;,[Obj,Arg3]),
<a name="2766"/> 2766: 		    LooperF(Obj,Times,Arg3,LooperF)
<a name="2767"/> 2767: 	    end,
<a name="2768"/> 2768: 
<a name="2769"/> 2769:     SmallMax32 = (1 bsl 27) - 1,
<a name="2770"/> 2770:     SmallMax64 = (1 bsl (27+32)) - 1,
<a name="2771"/> 2771:     Big1Max32 = (1 bsl 32) - 1,
<a name="2772"/> 2772:     Big1Max64 = (1 bsl 64) - 1,
<a name="2773"/> 2773: 
<a name="2774"/> 2774:     Steps = 100,
<a name="2775"/> 2775:     Obj0 = {a,0,0,0,0},
<a name="2776"/> 2776:     ets:insert(T,Obj0),
<a name="2777"/> 2777:     Obj1 = LoopF(Obj0, Steps, {2,(SmallMax32 div Steps)*2}),
<a name="2778"/> 2778:     Obj2 = LoopF(Obj1, Steps, {3,(SmallMax64 div Steps)*2}),
<a name="2779"/> 2779:     Obj3 = LoopF(Obj2, Steps, {4,(Big1Max32 div Steps)*2}),
<a name="2780"/> 2780:     Obj4 = LoopF(Obj3, Steps, {5,(Big1Max64 div Steps)*2}),
<a name="2781"/> 2781: 
<a name="2782"/> 2782:     Obj5 = LoopF(Obj4, Steps, {2,-(SmallMax32 div Steps)*4}),
<a name="2783"/> 2783:     Obj6 = LoopF(Obj5, Steps, {3,-(SmallMax64 div Steps)*4}),
<a name="2784"/> 2784:     Obj7 = LoopF(Obj6, Steps, {4,-(Big1Max32 div Steps)*4}),
<a name="2785"/> 2785:     Obj8 = LoopF(Obj7, Steps, {5,-(Big1Max64 div Steps)*4}),
<a name="2786"/> 2786: 
<a name="2787"/> 2787:     Obj9 = LoopF(Obj8, Steps, {2,(SmallMax32 div Steps)*2}),
<a name="2788"/> 2788:     ObjA = LoopF(Obj9, Steps, {3,(SmallMax64 div Steps)*2}),
<a name="2789"/> 2789:     ObjB = LoopF(ObjA, Steps, {4,(Big1Max32 div Steps)*2}),
<a name="2790"/> 2790:     Obj0 = LoopF(ObjB, Steps, {5,(Big1Max64 div Steps)*2}),
<a name="2791"/> 2791: 
<a name="2792"/> 2792:     %% back at zero, same trip again with lists
<a name="2793"/> 2793: 
<a name="2794"/> 2794:     Obj4 = LoopF(Obj0,Steps,[{2, (SmallMax32 div Steps)*2},
<a name="2795"/> 2795: 			     {3, (SmallMax64 div Steps)*2},
<a name="2796"/> 2796: 			     {4, (Big1Max32 div Steps)*2},
<a name="2797"/> 2797: 			     {5, (Big1Max64 div Steps)*2}]),
<a name="2798"/> 2798: 
<a name="2799"/> 2799:     Obj8 = LoopF(Obj4,Steps,[{4, -(Big1Max32 div Steps)*4},
<a name="2800"/> 2800: 			     {2, -(SmallMax32 div Steps)*4},
<a name="2801"/> 2801: 			     {5, -(Big1Max64 div Steps)*4},
<a name="2802"/> 2802: 			     {3, -(SmallMax64 div Steps)*4}]),
<a name="2803"/> 2803: 
<a name="2804"/> 2804:     Obj0 = LoopF(Obj8,Steps,[{5, (Big1Max64 div Steps)*2},
<a name="2805"/> 2805: 			     {2, (SmallMax32 div Steps)*2},
<a name="2806"/> 2806: 			     {4, (Big1Max32 div Steps)*2},
<a name="2807"/> 2807: 			     {3, (SmallMax64 div Steps)*2}]),
<a name="2808"/> 2808: 
<a name="2809"/> 2809:     %% make them shift size at the same time
<a name="2810"/> 2810:     ObjC = LoopF(Obj0,Steps,[{5, (Big1Max64 div Steps)*2},
<a name="2811"/> 2811: 			     {3, (Big1Max64 div Steps)*2 + 1},
<a name="2812"/> 2812: 			     {2, -(Big1Max64 div Steps)*2},
<a name="2813"/> 2813: 			     {4, -(Big1Max64 div Steps)*2 + 1}]),
<a name="2814"/> 2814: 
<a name="2815"/> 2815:     %% update twice in same list
<a name="2816"/> 2816:     ObjD = LoopF(ObjC,Steps,[{5, -(Big1Max64 div Steps) + 1},
<a name="2817"/> 2817: 			     {3, -(Big1Max64 div Steps)*2 - 1},
<a name="2818"/> 2818: 			     {5, -(Big1Max64 div Steps) - 1},
<a name="2819"/> 2819: 			     {4, (Big1Max64 div Steps)*2 - 1}]),
<a name="2820"/> 2820: 
<a name="2821"/> 2821:     Obj0 = LoopF(ObjD,Steps,[{2, (Big1Max64 div Steps) - 1},
<a name="2822"/> 2822: 			     {4, Big1Max64*2},
<a name="2823"/> 2823: 			     {2, (Big1Max64 div Steps) + 1},
<a name="2824"/> 2824: 			     {4, -Big1Max64*2}]),
<a name="2825"/> 2825: 
<a name="2826"/> 2826:     %% warping with list
<a name="2827"/> 2827:     ObjE = LoopF(Obj0,1000,
<a name="2828"/> 2828: 		 [{3,SmallMax32*4 div 5,SmallMax32*2,-SmallMax32*2},
<a name="2829"/> 2829: 		  {5,-SmallMax64*4 div 7,-SmallMax64*2,SmallMax64*2},
<a name="2830"/> 2830: 		  {4,-Big1Max32*4 div 11,-Big1Max32*2,Big1Max32*2},
<a name="2831"/> 2831: 		  {2,Big1Max64*4 div 13,Big1Max64*2,-Big1Max64*2}]),
<a name="2832"/> 2832: 
<a name="2833"/> 2833:     %% warping without list
<a name="2834"/> 2834:     ObjF = LoopF(ObjE,1000,{3,SmallMax32*4 div 5,SmallMax32*2,-SmallMax32*2}),
<a name="2835"/> 2835:     ObjG = LoopF(ObjF,1000,{5,-SmallMax64*4 div 7,-SmallMax64*2,SmallMax64*2}),
<a name="2836"/> 2836:     ObjH = LoopF(ObjG,1000,{4,-Big1Max32*4 div 11,-Big1Max32*2,Big1Max32*2}),
<a name="2837"/> 2837:     ObjI = LoopF(ObjH,1000,{2,Big1Max64*4 div 13,Big1Max64*2,-Big1Max64*2}),
<a name="2838"/> 2838: 
<a name="2839"/> 2839:     %% mixing it up
<a name="2840"/> 2840:     LoopF(ObjI,1000,
<a name="2841"/> 2841: 	  [{3,SmallMax32*4 div 5,SmallMax32*2,-SmallMax32*2},
<a name="2842"/> 2842: 	   {5,-SmallMax64*4 div 3},
<a name="2843"/> 2843: 	   {3,-SmallMax32*4 div 11},
<a name="2844"/> 2844: 	   {5,0},
<a name="2845"/> 2845: 	   {4,1},
<a name="2846"/> 2846: 	   {5,-SmallMax64*4 div 7,-SmallMax64*2,SmallMax64*2},
<a name="2847"/> 2847: 	   {2,Big1Max64*4 div 13,Big1Max64*2,-Big1Max64*2}]),
<a name="update_counter_for-last_expr"/><a name="2848"/> 2848:     ok.
<a name="2849"/> 2849: 
<a name="2850"/> 2850: <i>%% uc_mimic works kind of like the real ets:update_counter</i>
<a name="2851"/> 2851: <i>%% Obj = Tuple in ets</i>
<a name="2852"/> 2852: <i>%% Pits = {Pos,Incr} | {Pos,Incr,Thres,Warp}</i>
<a name="2853"/> 2853: <i>%% Returns {Updated tuple in ets, Return value from update_counter}</i>
<a name="uc_mimic-2"/><a name="2854"/> 2854: <b>uc_mimic</b>(Obj, Pits) when is_tuple(Pits) -&gt;
<a name="2855"/> 2855:     Pos = element(1,Pits),
<a name="2856"/> 2856:     NewObj = setelement(Pos, Obj, uc_adder(element(Pos,Obj),Pits)),
<a name="2857"/> 2857:     {NewObj, element(Pos,NewObj)};
<a name="2858"/> 2858: 
<a name="2859"/> 2859: <b>uc_mimic</b>(Obj, PitsList) when is_list(PitsList) -&gt;
<a name="2860"/> 2860:     {NewObj,ValList} = uc_mimic(Obj,PitsList,[]),
<a name="uc_mimic-last_expr"/><a name="2861"/> 2861: <b>    {NewObj,lists:reverse</b>(ValList)}.
<a name="2862"/> 2862: 
<a name="uc_mimic-3"/><a name="2863"/> 2863: <b>uc_mimic</b>(Obj, [], Acc) -&gt;
<a name="2864"/> 2864:     {Obj,Acc};
<a name="2865"/> 2865: <b>uc_mimic</b>(Obj, [Pits|Tail], Acc) -&gt;
<a name="2866"/> 2866:     {NewObj,NewVal} = uc_mimic(Obj,Pits),
<a name="uc_mimic-last_expr"/><a name="2867"/> 2867: <b>    uc_mimic</b>(NewObj,Tail,[NewVal|Acc]).
<a name="2868"/> 2868: 
<a name="uc_adder-2"/><a name="2869"/> 2869: <b>uc_adder</b>(Init, {_Pos, Add}) -&gt;
<a name="2870"/> 2870:     Init + Add;
<a name="2871"/> 2871: <b>uc_adder</b>(Init, {_Pos, Add, Thres, Warp}) -&gt;
<a name="uc_adder-last_expr"/><a name="2872"/> 2872:     case Init + Add of
<a name="2873"/> 2873: 	X when X &gt; Thres, Add &gt; 0 -&gt;
<a name="2874"/> 2874: 	    Warp;
<a name="2875"/> 2875: 	Y when Y &lt; Thres, Add &lt; 0 -&gt;
<a name="2876"/> 2876: 	    Warp;
<a name="2877"/> 2877: 	Z -&gt;
<a name="2878"/> 2878: 	    Z
<a name="2879"/> 2879:     end.
<a name="2880"/> 2880: 
<a name="update_counter_neg-1"/><a name="2881"/> 2881: <b>update_counter_neg</b>(Opts) -&gt;
<a name="2882"/> 2882:     Set = ets_new(set,Opts),
<a name="2883"/> 2883:     update_counter_neg_for(Set),
<a name="2884"/> 2884:     ets:delete(Set),
<a name="2885"/> 2885:     {'EXIT',{badarg,_}} = (catch ets:update_counter(Set,key,1)),
<a name="2886"/> 2886: 
<a name="2887"/> 2887:     run_if_valid_opts(
<a name="2888"/> 2888:       [ordered_set | Opts],
<a name="2889"/> 2889:       fun (OptsOrdSet) -&gt;
<a name="2890"/> 2890:               OrdSet = ets_new(ordered_set, OptsOrdSet),
<a name="2891"/> 2891:               update_counter_neg_for(OrdSet),
<a name="2892"/> 2892:               ets:delete(OrdSet),
<a name="2893"/> 2893:               {'EXIT',{badarg,_}} = (catch ets:update_counter(OrdSet,key,1))
<a name="2894"/> 2894:       end),
<a name="2895"/> 2895: 
<a name="2896"/> 2896:     Bag = ets_new(bag,[bag | Opts]),
<a name="2897"/> 2897:     DBag = ets_new(duplicate_bag,[duplicate_bag | Opts]),
<a name="2898"/> 2898:     {'EXIT',{badarg,_}} = (catch ets:update_counter(Bag,key,1)),
<a name="2899"/> 2899:     {'EXIT',{badarg,_}} = (catch ets:update_counter(DBag,key,1)),
<a name="2900"/> 2900:     true = ets:delete(Bag),
<a name="2901"/> 2901:     true = ets:delete(DBag),
<a name="update_counter_neg-last_expr"/><a name="2902"/> 2902:     ok.
<a name="2903"/> 2903: 
<a name="update_counter_neg_for-1"/><a name="2904"/> 2904: <b>update_counter_neg_for</b>(T) -&gt;
<a name="2905"/> 2905:     Object = {key,0,false,1},
<a name="2906"/> 2906:     true = ets:insert(T,Object),
<a name="2907"/> 2907: 
<a name="2908"/> 2908:     UpdateF = fun(Arg3) -&gt;
<a name="2909"/> 2909: 		      ArgHash = erlang:phash2({T,key,Arg3}),
<a name="2910"/> 2910: 		      {'EXIT',{badarg,_}} = (catch ets:update_counter(T,key,Arg3)),
<a name="2911"/> 2911: 		      ArgHash = erlang:phash2({T,key,Arg3}),
<a name="2912"/> 2912: 		      [Object] = ets:lookup(T,key)
<a name="2913"/> 2913: 	      end,
<a name="2914"/> 2914: 
<a name="2915"/> 2915:     %% List of invalid arg3-tuples
<a name="2916"/> 2916:     InvList = [false, {2}, {2,false}, {false,1},
<a name="2917"/> 2917: 	       {0,1}, {-1,1}, % BUG &lt; R12B-2
<a name="2918"/> 2918: 	       {1,1}, {3,1}, {5,1}, {2,1,100}, {2,1,100,0,false}, {2,1,false,0}, {2,1,0,false}],
<a name="2919"/> 2919: 
<a name="2920"/> 2920:     lists:foreach(UpdateF, InvList),
<a name="2921"/> 2921:     lists:foreach(fun(Inv) -&gt; UpdateF([{2,1},Inv]) end, InvList),
<a name="2922"/> 2922:     lists:foreach(fun(Inv) -&gt; UpdateF([Inv,{2,1}]) end, InvList),
<a name="2923"/> 2923:     lists:foreach(fun(Inv) -&gt; UpdateF([{2,1},{4,-100},Inv]) end, InvList),
<a name="2924"/> 2924:     lists:foreach(fun(Inv) -&gt; UpdateF([{4,100,50,0},{2,1},Inv]) end, InvList),
<a name="2925"/> 2925:     lists:foreach(fun(Inv) -&gt; UpdateF([{2,1},Inv,{4,100,50,0}]) end, InvList),
<a name="2926"/> 2926:     lists:foreach(fun(Inv) -&gt; UpdateF([Inv,{4,100,50,0},{2,1}]) end, InvList),
<a name="2927"/> 2927:     UpdateF([{2,1} | {4,1}]),
<a name="2928"/> 2928:     lists:foreach(fun(Inv) -&gt; UpdateF([{2,1} | Inv]) end, InvList),
<a name="2929"/> 2929: 
<a name="2930"/> 2930:     {'EXIT',{badarg,_}} = (catch ets:update_counter(T,false,1)),
<a name="2931"/> 2931:     ets:delete(T,key),
<a name="2932"/> 2932:     {'EXIT',{badarg,_}} = (catch ets:update_counter(T,key,1)),
<a name="update_counter_neg_for-last_expr"/><a name="2933"/> 2933:     ok.
<a name="2934"/> 2934: 
<a name="2935"/> 2935: 
<a name="evil_update_counter-1"/><a name="2936"/> 2936: <b>evil_update_counter</b>(Config) when is_list(Config) -&gt;
<a name="2937"/> 2937:     %% The code server uses ets table. Pre-load modules that might not be
<a name="2938"/> 2938:     %% already loaded.
<a name="2939"/> 2939:     gb_sets:module_info(),
<a name="2940"/> 2940:     math:module_info(),
<a name="2941"/> 2941:     ordsets:module_info(),
<a name="2942"/> 2942:     rand:module_info(),
<a name="2943"/> 2943: 
<a name="evil_update_counter-last_expr"/><a name="2944"/> 2944: <b>    repeat_for_opts</b>(fun evil_update_counter_do/1).
<a name="2945"/> 2945: 
<a name="evil_update_counter_do-1"/><a name="2946"/> 2946: <b>evil_update_counter_do</b>(Opts) -&gt;
<a name="2947"/> 2947:     EtsMem = etsmem(),
<a name="2948"/> 2948:     process_flag(trap_exit, true),
<a name="2949"/> 2949:     Pids = [my_spawn_link(fun() -&gt; evil_counter(I,Opts) end)  || I &lt;- lists:seq(1, 40)],
<a name="2950"/> 2950:     wait_for_all(gb_sets:from_list(Pids)),
<a name="2951"/> 2951:     verify_etsmem(EtsMem),
<a name="evil_update_counter_do-last_expr"/><a name="2952"/> 2952:     ok.
<a name="2953"/> 2953: 
<a name="wait_for_all-1"/><a name="2954"/> 2954: <b>wait_for_all</b>(Pids0) -&gt;
<a name="wait_for_all-last_expr"/><a name="2955"/> 2955: <b>    case gb_sets:is_empty</b>(Pids0) of
<a name="2956"/> 2956: 	true -&gt;
<a name="2957"/> 2957: 	    ok;
<a name="2958"/> 2958: 	false -&gt;
<a name="2959"/> 2959: 	    receive
<a name="2960"/> 2960: 		{'EXIT',Pid,normal} -&gt;
<a name="2961"/> 2961: 		    Pids = gb_sets:delete(Pid, Pids0),
<a name="2962"/> 2962: 		    wait_for_all(Pids);
<a name="2963"/> 2963: 		Other -&gt;
<a name="2964"/> 2964: 		    io:format(&quot;unexpected: ~p\n&quot;, [Other]),
<a name="2965"/> 2965: 		    ct:fail(failed)
<a name="2966"/> 2966: 	    end
<a name="2967"/> 2967:     end.
<a name="2968"/> 2968: 
<a name="evil_counter-2"/><a name="2969"/> 2969: <b>evil_counter</b>(I,Opts) -&gt;
<a name="2970"/> 2970:     T = ets_new(a, Opts),
<a name="2971"/> 2971:     Start0 = case I rem 3 of
<a name="2972"/> 2972: 		 0 -&gt; 16#12345678;
<a name="2973"/> 2973: 		 1 -&gt; 16#12345678FFFFFFFF;
<a name="2974"/> 2974: 		 2 -&gt; 16#7777777777FFFFFFFF863648726743
<a name="2975"/> 2975: 	     end,
<a name="2976"/> 2976:     Start = Start0 + rand:uniform(100000),
<a name="2977"/> 2977:     ets:insert(T, {dracula,Start}),
<a name="2978"/> 2978:     Iter = 40000 div syrup_factor(),
<a name="2979"/> 2979:     End = Start + Iter,
<a name="2980"/> 2980:     End = evil_counter_1(Iter, T),
<a name="evil_counter-last_expr"/><a name="2981"/> 2981: <b>    ets:delete</b>(T).
<a name="2982"/> 2982: 
<a name="evil_counter_1-2"/><a name="2983"/> 2983: <b>evil_counter_1</b>(0, T) -&gt;
<a name="2984"/> 2984:     [{dracula,Count}] = ets:lookup(T, dracula),
<a name="2985"/> 2985:     Count;
<a name="2986"/> 2986: <b>evil_counter_1</b>(Iter, T) -&gt;
<a name="2987"/> 2987:     ets:update_counter(T, dracula, 1),
<a name="evil_counter_1-last_expr"/><a name="2988"/> 2988: <b>    evil_counter_1</b>(Iter-1, T).
<a name="2989"/> 2989: 
<a name="update_counter_with_default-1"/><a name="2990"/> 2990: <b>update_counter_with_default</b>(Config) when is_list(Config) -&gt;
<a name="update_counter_with_default-last_expr"/><a name="2991"/> 2991: <b>    repeat_for_opts</b>(fun update_counter_with_default_do/1).
<a name="2992"/> 2992: 
<a name="update_counter_with_default_do-1"/><a name="2993"/> 2993: <b>update_counter_with_default_do</b>(Opts) -&gt;
<a name="2994"/> 2994:     T1 = ets_new(a, [set | Opts]),
<a name="2995"/> 2995:     %% Insert default object.
<a name="2996"/> 2996:     3 = ets:update_counter(T1, foo, 2, {beaufort,1}),
<a name="2997"/> 2997:     1 = ets:info(T1, size),
<a name="2998"/> 2998:     %% Increment.
<a name="2999"/> 2999:     5 = ets:update_counter(T1, foo, 2, {cabecou,1}),
<a name="3000"/> 3000:     1 = ets:info(T1, size),
<a name="3001"/> 3001:     %% Increment with list.
<a name="3002"/> 3002:     [9] = ets:update_counter(T1, foo, [{2,4}], {camembert,1}),
<a name="3003"/> 3003:     1 = ets:info(T1, size),
<a name="3004"/> 3004:     %% Same with non-immediate key.
<a name="3005"/> 3005:     3 = ets:update_counter(T1, {foo,bar}, 2, {{chaource,chevrotin},1}),
<a name="3006"/> 3006:     2 = ets:info(T1, size),
<a name="3007"/> 3007:     5 = ets:update_counter(T1, {foo,bar}, 2, {{cantal,comté},1}),
<a name="3008"/> 3008:     2 = ets:info(T1, size),
<a name="3009"/> 3009:     [9] = ets:update_counter(T1, {foo,bar}, [{2,4}], {{emmental,de,savoie},1}),
<a name="3010"/> 3010:     2 = ets:info(T1, size),
<a name="3011"/> 3011:     %% default counter is not an integer.
<a name="3012"/> 3012:     {'EXIT',{badarg,_}} = (catch ets:update_counter(T1, qux, 3, {saint,félicien})),
<a name="3013"/> 3013:     2 = ets:info(T1, size),
<a name="3014"/> 3014:     %% No third element in default value.
<a name="3015"/> 3015:     {'EXIT',{badarg,_}} = (catch ets:update_counter(T1, qux, [{3,1}], {roquefort,1})),
<a name="3016"/> 3016:     2 = ets:info(T1, size),
<a name="3017"/> 3017: 
<a name="3018"/> 3018:     %% Same with ordered set.
<a name="3019"/> 3019:     run_if_valid_opts(
<a name="3020"/> 3020:       [ordered_set | Opts],
<a name="3021"/> 3021:       fun (Opts2) -&gt;
<a name="3022"/> 3022:               T2 = ets_new(b, Opts2),
<a name="3023"/> 3023:               3 = ets:update_counter(T2, foo, 2, {maroilles,1}),
<a name="3024"/> 3024:               1 = ets:info(T2, size),
<a name="3025"/> 3025:               5 = ets:update_counter(T2, foo, 2, {mimolette,1}),
<a name="3026"/> 3026:               1 = ets:info(T2, size),
<a name="3027"/> 3027:               [9] = ets:update_counter(T2, foo, [{2,4}], {morbier,1}),
<a name="3028"/> 3028:               1 = ets:info(T2, size),
<a name="3029"/> 3029:               3 = ets:update_counter(T2, {foo,bar}, 2, {{laguiole},1}),
<a name="3030"/> 3030:               2 = ets:info(T2, size),
<a name="3031"/> 3031:               5 = ets:update_counter(T2, {foo,bar}, 2, {{saint,nectaire},1}),
<a name="3032"/> 3032:               2 = ets:info(T2, size),
<a name="3033"/> 3033:               [9] = ets:update_counter(T2, {foo,bar}, [{2,4}], {{rocamadour},1}),
<a name="3034"/> 3034:               2 = ets:info(T2, size),
<a name="3035"/> 3035:               %% Arithmetically-equal keys.
<a name="3036"/> 3036:               3 = ets:update_counter(T2, 1.0, 2, {1,1}),
<a name="3037"/> 3037:               3 = ets:info(T2, size),
<a name="3038"/> 3038:               5 = ets:update_counter(T2, 1, 2, {1,1}),
<a name="3039"/> 3039:               3 = ets:info(T2, size),
<a name="3040"/> 3040:               7 = ets:update_counter(T2, 1, 2, {1.0,1}),
<a name="3041"/> 3041:               3 = ets:info(T2, size),
<a name="3042"/> 3042:               %% Same with reversed type difference.
<a name="3043"/> 3043:               3 = ets:update_counter(T2, 2, 2, {2.0,1}),
<a name="3044"/> 3044:               4 = ets:info(T2, size),
<a name="3045"/> 3045:               5 = ets:update_counter(T2, 2.0, 2, {2.0,1}),
<a name="3046"/> 3046:               4 = ets:info(T2, size),
<a name="3047"/> 3047:               7 = ets:update_counter(T2, 2.0, 2, {2,1}),
<a name="3048"/> 3048:               4 = ets:info(T2, size),
<a name="3049"/> 3049:               %% default counter is not an integer.
<a name="3050"/> 3050:               {'EXIT',{badarg,_}} = (catch ets:update_counter(T2, qux, 3, {saint,félicien})),
<a name="3051"/> 3051:               4 = ets:info(T2, size),
<a name="3052"/> 3052:               %% No third element in default value.
<a name="3053"/> 3053:               {'EXIT',{badarg,_}} = (catch ets:update_counter(T2, qux, [{3,1}], {roquefort,1})),
<a name="3054"/> 3054:               4 = ets:info(T2, size)
<a name="3055"/> 3055:       end),
<a name="update_counter_with_default_do-last_expr"/><a name="3056"/> 3056:     ok.
<a name="3057"/> 3057: 
<a name="3058"/> 3058: <i>%% ERL-1125</i>
<a name="update_counter_with_default_bad_pos-1"/><a name="3059"/> 3059: <b>update_counter_with_default_bad_pos</b>(Config) when is_list(Config) -&gt;
<a name="update_counter_with_default_bad_pos-last_expr"/><a name="3060"/> 3060: <b>    repeat_for_all_ord_set_table_types</b>(fun update_counter_with_default_bad_pos_do/1).
<a name="3061"/> 3061: 
<a name="update_counter_with_default_bad_pos_do-1"/><a name="3062"/> 3062: <b>update_counter_with_default_bad_pos_do</b>(Opts) -&gt;
<a name="3063"/> 3063:     T = ets_new(a, Opts),
<a name="3064"/> 3064:     0 = ets:info(T, size),
<a name="3065"/> 3065:     ok = try ets:update_counter(T, 101065, {1, 1}, {101065, 0})
<a name="3066"/> 3066:          catch
<a name="3067"/> 3067:              error:badarg -&gt; ok;
<a name="3068"/> 3068:              Class:Reason -&gt; {Class, Reason}
<a name="3069"/> 3069:          end,
<a name="3070"/> 3070:     0 = ets:info(T, size),
<a name="update_counter_with_default_bad_pos_do-last_expr"/><a name="3071"/> 3071:     ok.
<a name="3072"/> 3072: 
<a name="update_counter_table_growth-1"/><a name="3073"/> 3073: <b>update_counter_table_growth</b>(_Config) -&gt;
<a name="update_counter_table_growth-last_expr"/><a name="3074"/> 3074: <b>    repeat_for_opts</b>(fun update_counter_table_growth_do/1).
<a name="3075"/> 3075: 
<a name="update_counter_table_growth_do-1"/><a name="3076"/> 3076: <b>update_counter_table_growth_do</b>(Opts) -&gt;
<a name="3077"/> 3077:     Set = ets_new(b, [set | Opts]),
<a name="3078"/> 3078:     [ets:update_counter(Set, N, {2, 1}, {N, 1}) || N &lt;- lists:seq(1,10000)],
<a name="3079"/> 3079: 
<a name="3080"/> 3080:     run_if_valid_opts(
<a name="3081"/> 3081:       [ordered_set | Opts],
<a name="3082"/> 3082:       fun(OptsOrdSet) -&gt;
<a name="3083"/> 3083:               OrdSet = ets_new(b, OptsOrdSet),
<a name="3084"/> 3084:               [ets:update_counter(OrdSet, N, {2, 1}, {N, 1})
<a name="3085"/> 3085:                || N &lt;- lists:seq(1,10000)]
<a name="3086"/> 3086:       end),
<a name="update_counter_table_growth_do-last_expr"/><a name="3087"/> 3087:     ok.
<a name="3088"/> 3088: 
<a name="3089"/> 3089: <i>%% Check that a first-next sequence always works on a fixed table.</i>
<a name="fixtable_next-1"/><a name="3090"/> 3090: <b>fixtable_next</b>(Config) when is_list(Config) -&gt;
<a name="fixtable_next-last_expr"/><a name="3091"/> 3091: <b>    repeat_for_opts</b>(fun fixtable_next_do/1,
<a name="3092"/> 3092:                     [write_concurrency,all_types]).
<a name="3093"/> 3093: 
<a name="fixtable_next_do-1"/><a name="3094"/> 3094: <b>fixtable_next_do</b>(Opts) -&gt;
<a name="3095"/> 3095:     EtsMem = etsmem(),
<a name="3096"/> 3096:     do_fixtable_next(ets_new(set,[public | Opts])),
<a name="fixtable_next_do-last_expr"/><a name="3097"/> 3097: <b>    verify_etsmem</b>(EtsMem).
<a name="3098"/> 3098: 
<a name="do_fixtable_next-1"/><a name="3099"/> 3099: <b>do_fixtable_next</b>(Tab) -&gt;
<a name="3100"/> 3100:     F = fun(X,T,FF) -&gt;
<a name="3101"/> 3101:                 case X of
<a name="3102"/> 3102:                     0 -&gt; true;
<a name="3103"/> 3103:                     _ -&gt;
<a name="3104"/> 3104:                         ets:insert(T, {X,
<a name="3105"/> 3105:                                        integer_to_list(X),
<a name="3106"/> 3106:                                        X rem 10}),
<a name="3107"/> 3107:                         FF(X-1,T,FF)
<a name="3108"/> 3108:                 end
<a name="3109"/> 3109:         end,
<a name="3110"/> 3110:     F(100,Tab,F),
<a name="3111"/> 3111:     ets:safe_fixtable(Tab,true),
<a name="3112"/> 3112:     First = ets:first(Tab),
<a name="3113"/> 3113:     ets:delete(Tab, First),
<a name="3114"/> 3114:     ets:next(Tab, First),
<a name="3115"/> 3115:     ets:match_delete(Tab,{'_','_','_'}),
<a name="3116"/> 3116:     '$end_of_table' = ets:next(Tab, First),
<a name="3117"/> 3117:     true = ets:info(Tab, fixed),
<a name="3118"/> 3118:     ets:safe_fixtable(Tab, false),
<a name="3119"/> 3119:     false = ets:info(Tab, fixed),
<a name="do_fixtable_next-last_expr"/><a name="3120"/> 3120: <b>    ets:delete</b>(Tab).
<a name="3121"/> 3121: 
<a name="3122"/> 3122: <i>%% Check that iteration of bags find all live objects and nothing else.</i>
<a name="fixtable_iter_bag-1"/><a name="3123"/> 3123: <b>fixtable_iter_bag</b>(Config) when is_list(Config) -&gt;
<a name="fixtable_iter_bag-last_expr"/><a name="3124"/> 3124: <b>    repeat_for_opts</b>(fun fixtable_iter_do/1,
<a name="3125"/> 3125:                     [write_concurrency,[bag,duplicate_bag]]).
<a name="3126"/> 3126: 
<a name="fixtable_iter_do-1"/><a name="3127"/> 3127: <b>fixtable_iter_do</b>(Opts) -&gt;
<a name="3128"/> 3128:     EtsMem = etsmem(),
<a name="3129"/> 3129:     do_fixtable_iter_bag(ets_new(fixtable_iter_bag,Opts)),
<a name="fixtable_iter_do-last_expr"/><a name="3130"/> 3130: <b>    verify_etsmem</b>(EtsMem).
<a name="3131"/> 3131: 
<a name="do_fixtable_iter_bag-1"/><a name="3132"/> 3132: <b>do_fixtable_iter_bag</b>(T) -&gt;
<a name="3133"/> 3133:     MaxValues = 4,
<a name="3134"/> 3134:     %% Create 1 to MaxValues objects for each key
<a name="3135"/> 3135:     %% and then delete every possible combination of those objects
<a name="3136"/> 3136:     %% in every possible order.
<a name="3137"/> 3137:     %% Then test iteration returns all live objects and nothing else.
<a name="3138"/> 3138: 
<a name="3139"/> 3139:     CrDelOps = [begin
<a name="3140"/> 3140:                     Values = lists:seq(1,N),
<a name="3141"/> 3141:                     %% All ways of deleting any number of the Values in any order
<a name="3142"/> 3142:                     Combos = combs(Values),
<a name="3143"/> 3143:                     DeleteOps = concat_lists([perms(C) || C &lt;- Combos]),
<a name="3144"/> 3144:                     {N, DeleteOps}
<a name="3145"/> 3145:                 end
<a name="3146"/> 3146:                 || N &lt;- lists:seq(1,MaxValues)],
<a name="3147"/> 3147: 
<a name="3148"/> 3148:     %%io:format(&quot;~p\n&quot;, [CrDelOps]),
<a name="3149"/> 3149: 
<a name="3150"/> 3150:     NKeys = lists:foldl(fun({_, DeleteOps}, Cnt) -&gt;
<a name="3151"/> 3151:                                Cnt + length(DeleteOps)
<a name="3152"/> 3152:                        end,
<a name="3153"/> 3153:                        0,
<a name="3154"/> 3154:                        CrDelOps),
<a name="3155"/> 3155: 
<a name="3156"/> 3156:     io:format(&quot;Create ~p keys\n&quot;, [NKeys]),
<a name="3157"/> 3157: 
<a name="3158"/> 3158:     %% Fixate even before inserts just to maintain small table size
<a name="3159"/> 3159:     %% and increase likelyhood of different keys in same bucket.
<a name="3160"/> 3160:     ets:safe_fixtable(T,true),
<a name="3161"/> 3161:     InsRes = [begin
<a name="3162"/> 3162:                   [begin
<a name="3163"/> 3163:                        Key = {NValues,ValueList},
<a name="3164"/> 3164:                        [begin
<a name="3165"/> 3165:                             Tpl = {Key, V},
<a name="3166"/> 3166:                             %%io:format(&quot;Insert object ~p&quot;, [Tpl]),
<a name="3167"/> 3167:                             ets:insert(T, Tpl),
<a name="3168"/> 3168:                             Tpl
<a name="3169"/> 3169:                         end
<a name="3170"/> 3170:                         || V &lt;- lists:seq(1,NValues)]
<a name="3171"/> 3171:                    end
<a name="3172"/> 3172:                    || ValueList &lt;- DeleteOps]
<a name="3173"/> 3173:               end
<a name="3174"/> 3174:               || {NValues, DeleteOps} &lt;- CrDelOps],
<a name="3175"/> 3175: 
<a name="3176"/> 3176:     Inserted = lists:flatten(InsRes),
<a name="3177"/> 3177:     InSorted = lists:sort(Inserted),
<a name="3178"/> 3178:     InSorted = lists:usort(Inserted),  %% No duplicates
<a name="3179"/> 3179:     NObjs = length(Inserted),
<a name="3180"/> 3180: 
<a name="3181"/> 3181:     DelRes = [begin
<a name="3182"/> 3182:                   [begin
<a name="3183"/> 3183:                        Key = {NValues,ValueList},
<a name="3184"/> 3184:                        [begin
<a name="3185"/> 3185:                             Tpl = {Key, V},
<a name="3186"/> 3186:                             %%io:format(&quot;Delete object ~p&quot;, [Tpl]),
<a name="3187"/> 3187:                             ets:delete_object(T, Tpl),
<a name="3188"/> 3188:                             Tpl
<a name="3189"/> 3189:                         end
<a name="3190"/> 3190:                         || V &lt;- ValueList]
<a name="3191"/> 3191:                    end
<a name="3192"/> 3192:                    || ValueList &lt;- DeleteOps]
<a name="3193"/> 3193:               end
<a name="3194"/> 3194:               || {NValues, DeleteOps} &lt;- CrDelOps],
<a name="3195"/> 3195: 
<a name="3196"/> 3196:     Deleted = lists:flatten(DelRes),
<a name="3197"/> 3197:     DelSorted = lists:sort(Deleted),
<a name="3198"/> 3198:     DelSorted = lists:usort(Deleted),  %% No duplicates
<a name="3199"/> 3199:     NDels = length(Deleted),
<a name="3200"/> 3200: 
<a name="3201"/> 3201:     %% Nr of keys where all values were deleted.
<a name="3202"/> 3202:     NDeletedKeys = lists:sum([factorial(N) || N &lt;- lists:seq(1,MaxValues)]),
<a name="3203"/> 3203: 
<a name="3204"/> 3204:     CountKeysFun = fun Me(K1, Cnt) -&gt;
<a name="3205"/> 3205:                            case ets:next(T, K1) of
<a name="3206"/> 3206:                                '$end_of_table' -&gt;
<a name="3207"/> 3207:                                    Cnt;
<a name="3208"/> 3208:                                K2 -&gt;
<a name="3209"/> 3209:                                    Objs = ets:lookup(T, K2),
<a name="3210"/> 3210:                                    [{{NValues, ValueList}, _V} | _] = Objs,
<a name="3211"/> 3211:                                    ExpectedLive = NValues - length(ValueList),
<a name="3212"/> 3212:                                    ExpectedLive = length(Objs),
<a name="3213"/> 3213:                                    Me(K2, Cnt+1)
<a name="3214"/> 3214:                            end
<a name="3215"/> 3215:                    end,
<a name="3216"/> 3216: 
<a name="3217"/> 3217:     ExpectedKeys = NKeys - NDeletedKeys,
<a name="3218"/> 3218:     io:format(&quot;Expected keys: ~p\n&quot;, [ExpectedKeys]),
<a name="3219"/> 3219:     FoundKeys = CountKeysFun(ets:first(T), 1),
<a name="3220"/> 3220:     io:format(&quot;Found keys: ~p\n&quot;, [FoundKeys]),
<a name="3221"/> 3221:     ExpectedKeys = FoundKeys,
<a name="3222"/> 3222: 
<a name="3223"/> 3223:     ExpectedObjs = NObjs - NDels,
<a name="3224"/> 3224:     io:format(&quot;Expected objects: ~p\n&quot;, [ExpectedObjs]),
<a name="3225"/> 3225:     FoundObjs = ets:select_count(T, [{{'_','_'}, [], [true]}]),
<a name="3226"/> 3226:     io:format(&quot;Found objects: ~p\n&quot;, [FoundObjs]),
<a name="3227"/> 3227:     ExpectedObjs = FoundObjs,
<a name="3228"/> 3228: 
<a name="do_fixtable_iter_bag-last_expr"/><a name="3229"/> 3229: <b>    ets:delete</b>(T).
<a name="3230"/> 3230: 
<a name="3231"/> 3231: <i>%% All permutations of list</i>
<a name="perms-1"/><a name="3232"/> 3232: <b>perms</b>([]) -&gt; [[]];
<a name="perms-last_expr"/><a name="3233"/> 3233: <b>perms</b>(L)  -&gt; [[H|T] || H &lt;- L, T &lt;- perms(L--[H])].
<a name="3234"/> 3234: 
<a name="3235"/> 3235: <i>%% All combinations of picking the element (or not) from list</i>
<a name="combs-1"/><a name="3236"/> 3236: <b>combs</b>([]) -&gt; [[]];
<a name="3237"/> 3237: <b>combs</b>([H|T]) -&gt;
<a name="3238"/> 3238:     Tcombs = combs(T),
<a name="combs-last_expr"/><a name="3239"/> 3239:     Tcombs ++ [[H | C] || C &lt;- Tcombs].
<a name="3240"/> 3240: 
<a name="factorial-1"/><a name="3241"/> 3241: <b>factorial</b>(0) -&gt; 1;
<a name="3242"/> 3242: <b>factorial</b>(N) when N &gt; 0 -&gt;
<a name="factorial-last_expr"/><a name="3243"/> 3243: <b>    N * factorial</b>(N - 1).
<a name="3244"/> 3244: 
<a name="concat_lists-1"/><a name="3245"/> 3245: <b>concat_lists</b>([]) -&gt;
<a name="3246"/> 3246:     [];
<a name="3247"/> 3247: <b>concat_lists</b>([H|T]) -&gt;
<a name="concat_lists-last_expr"/><a name="3248"/> 3248: <b>    H ++ concat_lists</b>(T).
<a name="3249"/> 3249: 
<a name="3250"/> 3250: 
<a name="3251"/> 3251: <i>%% Check inserts of deleted keys in fixed bags.</i>
<a name="fixtable_insert-1"/><a name="3252"/> 3252: <b>fixtable_insert</b>(Config) when is_list(Config) -&gt;
<a name="3253"/> 3253:     Combos = [[Type,{write_concurrency,WC}] || Type&lt;- [bag,duplicate_bag],
<a name="3254"/> 3254: 					       WC &lt;- [false,true]],
<a name="3255"/> 3255:     lists:foreach(fun(Opts) -&gt; fixtable_insert_do(Opts) end,
<a name="3256"/> 3256: 		  Combos),
<a name="fixtable_insert-last_expr"/><a name="3257"/> 3257:     ok.
<a name="3258"/> 3258: 
<a name="fixtable_insert_do-1"/><a name="3259"/> 3259: <b>fixtable_insert_do</b>(Opts) -&gt;
<a name="3260"/> 3260:     io:format(&quot;Opts = ~p\n&quot;,[Opts]),
<a name="3261"/> 3261:     Ets = make_table(ets, Opts, [{a,1}, {a,2}, {b,1}, {b,2}]),
<a name="3262"/> 3262:     ets:safe_fixtable(Ets,true),
<a name="3263"/> 3263:     ets:match_delete(Ets,{b,1}),
<a name="3264"/> 3264:     First = ets:first(Ets),
<a name="3265"/> 3265:     Next = case First of
<a name="3266"/> 3266: 	       a -&gt; b;
<a name="3267"/> 3267: 	       b -&gt; a
<a name="3268"/> 3268: 	   end,
<a name="3269"/> 3269:     Next = ets:next(Ets,First),
<a name="3270"/> 3270:     ets:delete(Ets,Next),
<a name="3271"/> 3271:     '$end_of_table' = ets:next(Ets,First),
<a name="3272"/> 3272:     ets:insert(Ets, {Next,1}),
<a name="3273"/> 3273:     false = ets:insert_new(Ets, {Next,1}),
<a name="3274"/> 3274:     Next = ets:next(Ets,First),
<a name="3275"/> 3275:     '$end_of_table' = ets:next(Ets,Next),
<a name="3276"/> 3276:     ets:delete(Ets,Next),
<a name="3277"/> 3277:     '$end_of_table' = ets:next(Ets,First),
<a name="3278"/> 3278:     ets:insert(Ets, {Next,2}),
<a name="3279"/> 3279:     false = ets:insert_new(Ets, {Next,1}),
<a name="3280"/> 3280:     Next = ets:next(Ets,First),
<a name="3281"/> 3281:     '$end_of_table' = ets:next(Ets,Next),
<a name="3282"/> 3282:     ets:delete(Ets,First),
<a name="3283"/> 3283:     Next = ets:first(Ets),
<a name="3284"/> 3284:     '$end_of_table' = ets:next(Ets,Next),
<a name="3285"/> 3285:     ets:delete(Ets,Next),
<a name="3286"/> 3286:     '$end_of_table' = ets:next(Ets,First),
<a name="3287"/> 3287:     true = ets:insert_new(Ets,{Next,1}),
<a name="3288"/> 3288:     false = ets:insert_new(Ets,{Next,2}),
<a name="3289"/> 3289:     Next = ets:next(Ets,First),
<a name="3290"/> 3290:     ets:delete_object(Ets,{Next,1}),
<a name="3291"/> 3291:     '$end_of_table' = ets:next(Ets,First),
<a name="3292"/> 3292:     true = ets:insert_new(Ets,{Next,2}),
<a name="3293"/> 3293:     false = ets:insert_new(Ets,{Next,1}),
<a name="3294"/> 3294:     Next = ets:next(Ets,First),
<a name="3295"/> 3295:     ets:delete(Ets,First),
<a name="3296"/> 3296:     ets:safe_fixtable(Ets,false),
<a name="3297"/> 3297:     {'EXIT',{badarg,_}} = (catch ets:next(Ets,First)),
<a name="fixtable_insert_do-last_expr"/><a name="3298"/> 3298:     ok.
<a name="3299"/> 3299: 
<a name="3300"/> 3300: <i>%% Test the 'write_concurrency' option.</i>
<a name="write_concurrency-1"/><a name="3301"/> 3301: <b>write_concurrency</b>(Config) when is_list(Config) -&gt;
<a name="3302"/> 3302:     EtsMem = etsmem(),
<a name="3303"/> 3303:     Yes1 = ets_new(foo,[public,{write_concurrency,true}]),
<a name="3304"/> 3304:     Yes2 = ets_new(foo,[protected,{write_concurrency,true}]),
<a name="3305"/> 3305:     No1 = ets_new(foo,[private,{write_concurrency,true}]),
<a name="3306"/> 3306: 
<a name="3307"/> 3307:     Yes3 = ets_new(foo,[bag,public,{write_concurrency,true}]),
<a name="3308"/> 3308:     Yes4 = ets_new(foo,[bag,protected,{write_concurrency,true}]),
<a name="3309"/> 3309:     No2 = ets_new(foo,[bag,private,{write_concurrency,true}]),
<a name="3310"/> 3310: 
<a name="3311"/> 3311:     Yes5 = ets_new(foo,[duplicate_bag,public,{write_concurrency,true}]),
<a name="3312"/> 3312:     Yes6 = ets_new(foo,[duplicate_bag,protected,{write_concurrency,true}]),
<a name="3313"/> 3313:     No3 = ets_new(foo,[duplicate_bag,private,{write_concurrency,true}]),
<a name="3314"/> 3314: 
<a name="3315"/> 3315:     NoCentCtrs = {decentralized_counters,false},
<a name="3316"/> 3316:     Yes7 = ets_new(foo,[ordered_set,public,{write_concurrency,true},NoCentCtrs]),
<a name="3317"/> 3317:     Yes8 = ets_new(foo,[ordered_set,protected,{write_concurrency,true},NoCentCtrs]),
<a name="3318"/> 3318:     Yes9 = ets_new(foo,[ordered_set,{write_concurrency,true},NoCentCtrs]),
<a name="3319"/> 3319:     Yes10 = ets_new(foo,[{write_concurrency,true},ordered_set,public,NoCentCtrs]),
<a name="3320"/> 3320:     Yes11 = ets_new(foo,[{write_concurrency,true},ordered_set,protected,NoCentCtrs]),
<a name="3321"/> 3321:     Yes12 = ets_new(foo,[set,{write_concurrency,false},
<a name="3322"/> 3322:                          {write_concurrency,true},ordered_set,public,NoCentCtrs]),
<a name="3323"/> 3323:     Yes13 = ets_new(foo,[private,public,set,{write_concurrency,false},
<a name="3324"/> 3324:                          {write_concurrency,true},ordered_set,NoCentCtrs]),
<a name="3325"/> 3325:     Yes14 = ets_new(foo,[ordered_set,public,{write_concurrency,true}]),
<a name="3326"/> 3326:     No4 = ets_new(foo,[ordered_set,private,{write_concurrency,true}]),
<a name="3327"/> 3327:     No5 = ets_new(foo,[ordered_set,public,{write_concurrency,false}]),
<a name="3328"/> 3328:     No6 = ets_new(foo,[ordered_set,protected,{write_concurrency,false}]),
<a name="3329"/> 3329:     No7 = ets_new(foo,[ordered_set,private,{write_concurrency,false}]),
<a name="3330"/> 3330: 
<a name="3331"/> 3331:     No8 = ets_new(foo,[public,{write_concurrency,false}]),
<a name="3332"/> 3332:     No9 = ets_new(foo,[protected,{write_concurrency,false}]),
<a name="3333"/> 3333: 
<a name="3334"/> 3334:     YesMem = ets:info(Yes1,memory),
<a name="3335"/> 3335:     NoHashMem = ets:info(No1,memory),
<a name="3336"/> 3336:     YesTreeMem = ets:info(Yes7,memory),
<a name="3337"/> 3337:     YesYesTreeMem = ets:info(Yes14,memory),
<a name="3338"/> 3338:     NoTreeMem = ets:info(No4,memory),
<a name="3339"/> 3339: 
<a name="3340"/> 3340:     io:format(&quot;YesMem=~p NoHashMem=~p NoTreeMem=~p YesTreeMem=~p YesYesTreeMem=~p\n&quot;,
<a name="3341"/> 3341:               [YesMem,NoHashMem,NoTreeMem,YesTreeMem,YesYesTreeMem]),
<a name="3342"/> 3342: 
<a name="3343"/> 3343:     YesMem = ets:info(Yes2,memory),
<a name="3344"/> 3344:     YesMem = ets:info(Yes3,memory),
<a name="3345"/> 3345:     YesMem = ets:info(Yes4,memory),
<a name="3346"/> 3346:     YesMem = ets:info(Yes5,memory),
<a name="3347"/> 3347:     YesMem = ets:info(Yes6,memory),
<a name="3348"/> 3348:     NoHashMem = ets:info(No2,memory),
<a name="3349"/> 3349:     NoHashMem = ets:info(No3,memory),
<a name="3350"/> 3350:     YesTreeMem = ets:info(Yes7,memory),
<a name="3351"/> 3351:     YesTreeMem = ets:info(Yes8,memory),
<a name="3352"/> 3352:     YesTreeMem = ets:info(Yes9,memory),
<a name="3353"/> 3353:     YesTreeMem = ets:info(Yes10,memory),
<a name="3354"/> 3354:     YesTreeMem = ets:info(Yes11,memory),
<a name="3355"/> 3355:     YesTreeMem = ets:info(Yes12,memory),
<a name="3356"/> 3356:     YesTreeMem = ets:info(Yes13,memory),
<a name="3357"/> 3357:     NoTreeMem = ets:info(No4,memory),
<a name="3358"/> 3358:     NoTreeMem = ets:info(No5,memory),
<a name="3359"/> 3359:     NoTreeMem = ets:info(No6,memory),
<a name="3360"/> 3360:     NoTreeMem = ets:info(No7,memory),
<a name="3361"/> 3361:     NoHashMem = ets:info(No8,memory),
<a name="3362"/> 3362:     NoHashMem = ets:info(No9,memory),
<a name="3363"/> 3363: 
<a name="3364"/> 3364:     true = YesMem &gt; YesTreeMem,
<a name="3365"/> 3365: 
<a name="3366"/> 3366:     case erlang:system_info(schedulers) of
<a name="3367"/> 3367:         1 -&gt;
<a name="3368"/> 3368:             YesMem = NoHashMem,
<a name="3369"/> 3369:             YesTreeMem = NoTreeMem,
<a name="3370"/> 3370:             YesYesTreeMem = YesTreeMem;
<a name="3371"/> 3371:         NoSchedulers -&gt;
<a name="3372"/> 3372:             true = YesMem &gt; NoHashMem,
<a name="3373"/> 3373:             true = YesMem &gt; NoTreeMem,
<a name="3374"/> 3374: 
<a name="3375"/> 3375:             %% The memory of ordered_set with write concurrency is
<a name="3376"/> 3376:             %% smaller than without write concurrency on 64-bit systems with
<a name="3377"/> 3377:             %% few schedulers.
<a name="3378"/> 3378:             Bits = 8*erlang:system_info(wordsize),
<a name="3379"/> 3379:             if Bits =:= 32;
<a name="3380"/> 3380:                NoSchedulers &gt; 6 -&gt;
<a name="3381"/> 3381:                     true = YesTreeMem &gt;= NoTreeMem;
<a name="3382"/> 3382:                true -&gt;
<a name="3383"/> 3383:                     true = YesTreeMem &lt; NoTreeMem
<a name="3384"/> 3384:             end,
<a name="3385"/> 3385:             true = YesYesTreeMem &gt; YesTreeMem
<a name="3386"/> 3386:     end,
<a name="3387"/> 3387: 
<a name="3388"/> 3388:     {'EXIT',{badarg,_}} = (catch ets_new(foo,[public,{write_concurrency,foo}])),
<a name="3389"/> 3389:     {'EXIT',{badarg,_}} = (catch ets_new(foo,[public,{write_concurrency}])),
<a name="3390"/> 3390:     {'EXIT',{badarg,_}} = (catch ets_new(foo,[public,{write_concurrency,true,foo}])),
<a name="3391"/> 3391:     {'EXIT',{badarg,_}} = (catch ets_new(foo,[public,write_concurrency])),
<a name="3392"/> 3392: 
<a name="3393"/> 3393:     lists:foreach(fun(T) -&gt; ets:delete(T) end,
<a name="3394"/> 3394:         	  [Yes1,Yes2,Yes3,Yes4,Yes5,Yes6,Yes7,Yes8,Yes9,Yes10,Yes11,Yes12,Yes13,Yes14,
<a name="3395"/> 3395:         	   No1,No2,No3,No4,No5,No6,No7,No8,No9]),
<a name="3396"/> 3396:     verify_etsmem(EtsMem),
<a name="write_concurrency-last_expr"/><a name="3397"/> 3397:     ok.
<a name="3398"/> 3398: 
<a name="3399"/> 3399: 
<a name="3400"/> 3400: <i>%% The 'heir' option.</i>
<a name="heir-1"/><a name="3401"/> 3401: <b>heir</b>(Config) when is_list(Config) -&gt;
<a name="heir-last_expr"/><a name="3402"/> 3402: <b>    repeat_for_opts</b>(fun heir_do/1).
<a name="3403"/> 3403: 
<a name="heir_do-1"/><a name="3404"/> 3404: <b>heir_do</b>(Opts) -&gt;
<a name="3405"/> 3405:     EtsMem = etsmem(),
<a name="3406"/> 3406:     Master = self(),
<a name="3407"/> 3407: 
<a name="3408"/> 3408:     %% Different types of heir data and link/monitor relations
<a name="3409"/> 3409:     TestFun = fun(Arg) -&gt; {EtsMem,Arg} end,
<a name="3410"/> 3410:     Combos = [{Data,Mode} || Data&lt;-[foo_data, &lt;&lt;&quot;binary&quot;&gt;&gt;,
<a name="3411"/> 3411: 				    lists:seq(1,10), {17,TestFun,self()},
<a name="3412"/> 3412: 				    &quot;The busy heir&quot;],
<a name="3413"/> 3413: 			     Mode&lt;-[none,link,monitor]],
<a name="3414"/> 3414:     lists:foreach(fun({Data,Mode})-&gt; heir_1(Data,Mode,Opts) end,
<a name="3415"/> 3415: 		  Combos),
<a name="3416"/> 3416: 
<a name="3417"/> 3417:     %% No heir
<a name="3418"/> 3418:     {Founder1,MrefF1} = my_spawn_monitor(fun()-&gt;heir_founder(Master,foo_data,Opts)end),
<a name="3419"/> 3419:     Founder1 ! {go, none},
<a name="3420"/> 3420:     {&quot;No heir&quot;,Founder1} = receive_any(),
<a name="3421"/> 3421:     {'DOWN', MrefF1, process, Founder1, normal} = receive_any(),
<a name="3422"/> 3422:     undefined = ets:info(foo),
<a name="3423"/> 3423: 
<a name="3424"/> 3424:     %% An already dead heir
<a name="3425"/> 3425:     {Heir2,MrefH2} = my_spawn_monitor(fun()-&gt;die end),
<a name="3426"/> 3426:     {'DOWN', MrefH2, process, Heir2, normal} = receive_any(),
<a name="3427"/> 3427:     {Founder2,MrefF2} = my_spawn_monitor(fun()-&gt;heir_founder(Master,foo_data,Opts)end),
<a name="3428"/> 3428:     Founder2 ! {go, Heir2},
<a name="3429"/> 3429:     {&quot;No heir&quot;,Founder2} = receive_any(),
<a name="3430"/> 3430:     {'DOWN', MrefF2, process, Founder2, normal} = receive_any(),
<a name="3431"/> 3431:     undefined = ets:info(foo),
<a name="3432"/> 3432: 
<a name="3433"/> 3433:     %% When heir dies before founder
<a name="3434"/> 3434:     {Founder3,MrefF3} = my_spawn_monitor(fun()-&gt;heir_founder(Master,&quot;The dying heir&quot;,Opts)end),
<a name="3435"/> 3435:     {Heir3,MrefH3} = my_spawn_monitor(fun()-&gt;heir_heir(Founder3)end),
<a name="3436"/> 3436:     Founder3 ! {go, Heir3},
<a name="3437"/> 3437:     {'DOWN', MrefH3, process, Heir3, normal} = receive_any(),
<a name="3438"/> 3438:     Founder3 ! die_please,
<a name="3439"/> 3439:     {'DOWN', MrefF3, process, Founder3, normal} = receive_any(),
<a name="3440"/> 3440:     undefined = ets:info(foo),
<a name="3441"/> 3441: 
<a name="3442"/> 3442:     %% When heir dies and pid reused before founder dies
<a name="3443"/> 3443:     repeat_while(fun() -&gt;
<a name="3444"/> 3444: 			 NextPidIx = erts_debug:get_internal_state(next_pid),
<a name="3445"/> 3445: 			 {Founder4,MrefF4} = my_spawn_monitor(fun()-&gt;heir_founder(Master,&quot;The dying heir&quot;,Opts)end),
<a name="3446"/> 3446: 			 {Heir4,MrefH4} = my_spawn_monitor(fun()-&gt;heir_heir(Founder4)end),
<a name="3447"/> 3447: 			 Founder4 ! {go, Heir4},
<a name="3448"/> 3448: 			 {'DOWN', MrefH4, process, Heir4, normal} = receive_any(),
<a name="3449"/> 3449: 			 erts_debug:set_internal_state(next_pid, NextPidIx),
<a name="3450"/> 3450: 			 DoppelGanger = spawn_monitor_with_pid(Heir4,
<a name="3451"/> 3451: 							       fun()-&gt; die_please = receive_any() end),
<a name="3452"/> 3452: 			 Founder4 ! die_please,
<a name="3453"/> 3453: 			 {'DOWN', MrefF4, process, Founder4, normal} = receive_any(),
<a name="3454"/> 3454: 			 case DoppelGanger of
<a name="3455"/> 3455: 			     {Heir4,MrefH4_B} -&gt;
<a name="3456"/> 3456: 				 Heir4 ! die_please,
<a name="3457"/> 3457: 				 {'DOWN', MrefH4_B, process, Heir4, normal} = receive_any(),
<a name="3458"/> 3458: 				 undefined = ets:info(foo),
<a name="3459"/> 3459: 				 false;
<a name="3460"/> 3460: 			     failed -&gt;
<a name="3461"/> 3461: 				 io:format(&quot;Failed to spawn process with pid ~p\n&quot;, [Heir4]),
<a name="3462"/> 3462: 				 true % try again
<a name="3463"/> 3463: 			 end
<a name="3464"/> 3464: 		 end),
<a name="3465"/> 3465: 
<a name="heir_do-last_expr"/><a name="3466"/> 3466: <b>    verify_etsmem</b>(EtsMem).
<a name="3467"/> 3467: 
<a name="heir_founder-3"/><a name="3468"/> 3468: <b>heir_founder</b>(Master, HeirData, Opts) -&gt;
<a name="3469"/> 3469:     {go,Heir} = receive_any(),
<a name="3470"/> 3470:     HeirTpl = case Heir of
<a name="3471"/> 3471: 		  none -&gt; {heir,none};
<a name="3472"/> 3472: 		  _ -&gt; {heir, Heir, HeirData}
<a name="3473"/> 3473: 	      end,
<a name="3474"/> 3474:     T = ets_new(foo,[named_table, private, HeirTpl | Opts]),
<a name="3475"/> 3475:     true = ets:insert(T,{key,1}),
<a name="3476"/> 3476:     [{key,1}] = ets:lookup(T,key),
<a name="3477"/> 3477:     Self = self(),
<a name="3478"/> 3478:     Self = ets:info(T,owner),
<a name="heir_founder-last_expr"/><a name="3479"/> 3479: <b>    case ets:info</b>(T,heir) of
<a name="3480"/> 3480: 	none -&gt;
<a name="3481"/> 3481: 	    true = (Heir =:= none) orelse (not is_process_alive(Heir)),
<a name="3482"/> 3482: 	    Master ! {&quot;No heir&quot;,self()};
<a name="3483"/> 3483: 
<a name="3484"/> 3484: 	Heir -&gt;
<a name="3485"/> 3485: 	    true = is_process_alive(Heir),
<a name="3486"/> 3486: 	    Heir ! {table,T,HeirData},
<a name="3487"/> 3487: 	    die_please = receive_any()
<a name="3488"/> 3488:     end.
<a name="3489"/> 3489: 
<a name="3490"/> 3490: 
<a name="heir_heir-1"/><a name="3491"/> 3491: <b>heir_heir</b>(Founder) -&gt;
<a name="heir_heir-last_expr"/><a name="3492"/> 3492: <b>    heir_heir</b>(Founder, none).
<a name="heir_heir-2"/><a name="3493"/> 3493: <b>heir_heir</b>(Founder, Mode) -&gt;
<a name="3494"/> 3494:     {table,T,HeirData} = receive_any(),
<a name="3495"/> 3495:     {'EXIT',{badarg,_}} = (catch ets:lookup(T,key)),
<a name="3496"/> 3496:     case HeirData of
<a name="3497"/> 3497: 	&quot;The dying heir&quot; -&gt; exit(normal);
<a name="3498"/> 3498: 	_ -&gt; ok
<a name="3499"/> 3499:     end,
<a name="3500"/> 3500: 
<a name="3501"/> 3501:     Mref = case Mode of
<a name="3502"/> 3502: 	       link -&gt; process_flag(trap_exit, true),
<a name="3503"/> 3503: 		       link(Founder);
<a name="3504"/> 3504: 	       monitor -&gt; erlang:monitor(process,Founder);
<a name="3505"/> 3505: 	       none -&gt; ok
<a name="3506"/> 3506: 	   end,
<a name="3507"/> 3507:     Founder ! die_please,
<a name="3508"/> 3508:     Msg = case HeirData of
<a name="3509"/> 3509: 	      &quot;The busy heir&quot; -&gt; receive_any_spinning();
<a name="3510"/> 3510: 	      _ -&gt; receive_any()
<a name="3511"/> 3511: 	  end,
<a name="3512"/> 3512:     {'ETS-TRANSFER', T, Founder, HeirData} = Msg,
<a name="3513"/> 3513:     foo = T,
<a name="3514"/> 3514:     Self = self(),
<a name="3515"/> 3515:     Self = ets:info(T,owner),
<a name="3516"/> 3516:     Self = ets:info(T,heir),
<a name="3517"/> 3517:     [{key,1}] = ets:lookup(T,key),
<a name="3518"/> 3518:     true = ets:insert(T,{key,2}),
<a name="3519"/> 3519:     [{key,2}] = ets:lookup(T,key),
<a name="heir_heir-last_expr"/><a name="3520"/> 3520:     case Mode of % Verify that EXIT or DOWN comes after ETS-TRANSFER
<a name="3521"/> 3521: 	link -&gt;
<a name="3522"/> 3522: 	    {'EXIT',Founder,normal} = receive_any(),
<a name="3523"/> 3523: 	    process_flag(trap_exit, false);
<a name="3524"/> 3524: 	monitor -&gt;
<a name="3525"/> 3525: 	    {'DOWN', Mref, process, Founder, normal} = receive_any();
<a name="3526"/> 3526: 	none -&gt; ok
<a name="3527"/> 3527:     end.
<a name="3528"/> 3528: 
<a name="3529"/> 3529: 
<a name="heir_1-3"/><a name="3530"/> 3530: <b>heir_1</b>(HeirData,Mode,Opts) -&gt;
<a name="3531"/> 3531:     io:format(&quot;test with heir_data = ~p\n&quot;, [HeirData]),
<a name="3532"/> 3532:     Master = self(),
<a name="3533"/> 3533:     Founder = my_spawn_link(fun() -&gt; heir_founder(Master,HeirData,Opts) end),
<a name="3534"/> 3534:     io:format(&quot;founder spawned = ~p\n&quot;, [Founder]),
<a name="3535"/> 3535:     {Heir,Mref} = my_spawn_monitor(fun() -&gt; heir_heir(Founder,Mode) end),
<a name="3536"/> 3536:     io:format(&quot;heir spawned = ~p\n&quot;, [{Heir,Mref}]),
<a name="3537"/> 3537:     Founder ! {go, Heir},
<a name="heir_1-last_expr"/><a name="3538"/> 3538: <b>    {'DOWN', Mref, process, Heir, normal} = receive_any</b>().
<a name="3539"/> 3539: 
<a name="3540"/> 3540: <i>%% Test ets:give_way/3.</i>
<a name="give_away-1"/><a name="3541"/> 3541: <b>give_away</b>(Config) when is_list(Config) -&gt;
<a name="give_away-last_expr"/><a name="3542"/> 3542: <b>    repeat_for_opts</b>(fun give_away_do/1).
<a name="3543"/> 3543: 
<a name="give_away_do-1"/><a name="3544"/> 3544: <b>give_away_do</b>(Opts) -&gt;
<a name="3545"/> 3545:     T = ets_new(foo,[named_table, private | Opts]),
<a name="3546"/> 3546:     true = ets:insert(T,{key,1}),
<a name="3547"/> 3547:     [{key,1}] = ets:lookup(T,key),
<a name="3548"/> 3548:     Parent = self(),
<a name="3549"/> 3549: 
<a name="3550"/> 3550:     %% Give and then give back
<a name="3551"/> 3551:     {Receiver,Mref} = my_spawn_monitor(fun()-&gt; give_away_receiver(T,Parent) end),
<a name="3552"/> 3552:     give_me = receive_any(),
<a name="3553"/> 3553:     true = ets:give_away(T,Receiver,here_you_are),
<a name="3554"/> 3554:     {'EXIT',{badarg,_}} = (catch ets:lookup(T,key)),
<a name="3555"/> 3555:     Receiver ! give_back,
<a name="3556"/> 3556:     {'ETS-TRANSFER',T,Receiver,&quot;Tillbakakaka&quot;} = receive_any(),
<a name="3557"/> 3557:     [{key,2}] = ets:lookup(T,key),
<a name="3558"/> 3558:     {'DOWN', Mref, process, Receiver, normal} = receive_any(),
<a name="3559"/> 3559: 
<a name="3560"/> 3560:     %% Give and then let receiver keep it
<a name="3561"/> 3561:     true = ets:insert(T,{key,1}),
<a name="3562"/> 3562:     {Receiver3,Mref3} = my_spawn_monitor(fun()-&gt; give_away_receiver(T,Parent) end),
<a name="3563"/> 3563:     give_me = receive_any(),
<a name="3564"/> 3564:     true = ets:give_away(T,Receiver3,here_you_are),
<a name="3565"/> 3565:     {'EXIT',{badarg,_}} = (catch ets:lookup(T,key)),
<a name="3566"/> 3566:     Receiver3 ! die_please,
<a name="3567"/> 3567:     {'DOWN', Mref3, process, Receiver3, normal} = receive_any(),
<a name="3568"/> 3568:     undefined = ets:info(T),
<a name="3569"/> 3569: 
<a name="3570"/> 3570:     %% Give and then kill receiver to get back
<a name="3571"/> 3571:     T2 = ets_new(foo,[private | Opts]),
<a name="3572"/> 3572:     true = ets:insert(T2,{key,1}),
<a name="3573"/> 3573:     ets:setopts(T2,{heir,self(),&quot;Som en gummiboll...&quot;}),
<a name="3574"/> 3574:     {Receiver2,Mref2} = my_spawn_monitor(fun()-&gt; give_away_receiver(T2,Parent) end),
<a name="3575"/> 3575:     give_me = receive_any(),
<a name="3576"/> 3576:     true = ets:give_away(T2,Receiver2,here_you_are),
<a name="3577"/> 3577:     {'EXIT',{badarg,_}} = (catch ets:lookup(T2,key)),
<a name="3578"/> 3578:     Receiver2 ! die_please,
<a name="3579"/> 3579:     {'ETS-TRANSFER',T2,Receiver2,&quot;Som en gummiboll...&quot;} = receive_any(),
<a name="3580"/> 3580:     [{key,2}] = ets:lookup(T2,key),
<a name="3581"/> 3581:     {'DOWN', Mref2, process, Receiver2, normal} = receive_any(),
<a name="3582"/> 3582: 
<a name="3583"/> 3583:     %% Some negative testing
<a name="3584"/> 3584:     {'EXIT',{badarg,_}} = (catch ets:give_away(T2,Receiver,&quot;To a dead one&quot;)),
<a name="3585"/> 3585:     {'EXIT',{badarg,_}} = (catch ets:give_away(T2,self(),&quot;To myself&quot;)),
<a name="3586"/> 3586:     {'EXIT',{badarg,_}} = (catch ets:give_away(T2,&quot;not a pid&quot;,&quot;To wrong type&quot;)),
<a name="3587"/> 3587: 
<a name="3588"/> 3588:     true = ets:delete(T2),
<a name="3589"/> 3589:     {ReceiverNeg,MrefNeg} = my_spawn_monitor(fun()-&gt; give_away_receiver(T2,Parent) end),
<a name="3590"/> 3590:     give_me = receive_any(),
<a name="3591"/> 3591:     {'EXIT',{badarg,_}} = (catch ets:give_away(T2,ReceiverNeg,&quot;A deleted table&quot;)),
<a name="3592"/> 3592: 
<a name="3593"/> 3593:     T3 = ets_new(foo,[public | Opts]),
<a name="3594"/> 3594:     my_spawn_link(fun()-&gt; {'EXIT',{badarg,_}} = (catch ets:give_away(T3,ReceiverNeg,&quot;From non owner&quot;)),
<a name="3595"/> 3595: 			  Parent ! done
<a name="3596"/> 3596: 		  end),
<a name="3597"/> 3597:     done = receive_any(),
<a name="3598"/> 3598:     ReceiverNeg ! no_soup_for_you,
<a name="3599"/> 3599:     {'DOWN', MrefNeg, process, ReceiverNeg, normal} = receive_any(),
<a name="give_away_do-last_expr"/><a name="3600"/> 3600:     ok.
<a name="3601"/> 3601: 
<a name="give_away_receiver-2"/><a name="3602"/> 3602: <b>give_away_receiver</b>(T, Giver) -&gt;
<a name="3603"/> 3603:     {'EXIT',{badarg,_}} = (catch ets:lookup(T,key)),
<a name="3604"/> 3604:     Giver ! give_me,
<a name="give_away_receiver-last_expr"/><a name="3605"/> 3605: <b>    case receive_any</b>() of
<a name="3606"/> 3606: 	{'ETS-TRANSFER',T,Giver,here_you_are} -&gt;
<a name="3607"/> 3607: 	    [{key,1}] = ets:lookup(T,key),
<a name="3608"/> 3608: 	    true = ets:insert(T,{key,2}),
<a name="3609"/> 3609: 	    case receive_any() of
<a name="3610"/> 3610: 		give_back -&gt;
<a name="3611"/> 3611: 		    true = ets:give_away(T,Giver,&quot;Tillbakakaka&quot;),
<a name="3612"/> 3612: 		    {'EXIT',{badarg,_}} = (catch ets:lookup(T,key));
<a name="3613"/> 3613: 		die_please -&gt;
<a name="3614"/> 3614: 		    ok
<a name="3615"/> 3615: 	    end;
<a name="3616"/> 3616: 	no_soup_for_you -&gt;
<a name="3617"/> 3617: 	    ok
<a name="3618"/> 3618:     end.
<a name="3619"/> 3619: 
<a name="3620"/> 3620: 
<a name="3621"/> 3621: <i>%% Test ets:setopts/2.</i>
<a name="setopts-1"/><a name="3622"/> 3622: <b>setopts</b>(Config) when is_list(Config) -&gt;
<a name="setopts-last_expr"/><a name="3623"/> 3623: <b>    repeat_for_opts</b>(fun setopts_do/1, [write_concurrency,all_types]).
<a name="3624"/> 3624: 
<a name="setopts_do-1"/><a name="3625"/> 3625: <b>setopts_do</b>(Opts) -&gt;
<a name="3626"/> 3626:     Self = self(),
<a name="3627"/> 3627:     T = ets_new(foo,[named_table, private | Opts]),
<a name="3628"/> 3628:     none = ets:info(T,heir),
<a name="3629"/> 3629:     Heir = my_spawn_link(fun()-&gt;heir_heir(Self) end),
<a name="3630"/> 3630:     ets:setopts(T,{heir,Heir,&quot;Data&quot;}),
<a name="3631"/> 3631:     Heir = ets:info(T,heir),
<a name="3632"/> 3632:     ets:setopts(T,{heir,self(),&quot;Data&quot;}),
<a name="3633"/> 3633:     Self = ets:info(T,heir),
<a name="3634"/> 3634:     ets:setopts(T,[{heir,Heir,&quot;Data&quot;}]),
<a name="3635"/> 3635:     Heir = ets:info(T,heir),
<a name="3636"/> 3636:     ets:setopts(T,[{heir,none}]),
<a name="3637"/> 3637:     none = ets:info(T,heir),
<a name="3638"/> 3638: 
<a name="3639"/> 3639:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,[{heir,self(),&quot;Data&quot;},false])),
<a name="3640"/> 3640:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,{heir,self()})),
<a name="3641"/> 3641:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,{heir,false})),
<a name="3642"/> 3642:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,heir)),
<a name="3643"/> 3643:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,{heir,false,&quot;Data&quot;})),
<a name="3644"/> 3644:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,{false,self(),&quot;Data&quot;})),
<a name="3645"/> 3645: 
<a name="3646"/> 3646:     ets:setopts(T,{protection,protected}),
<a name="3647"/> 3647:     ets:setopts(T,{protection,public}),
<a name="3648"/> 3648:     ets:setopts(T,{protection,private}),
<a name="3649"/> 3649:     ets:setopts(T,[{protection,protected}]),
<a name="3650"/> 3650:     ets:setopts(T,[{protection,public}]),
<a name="3651"/> 3651:     ets:setopts(T,[{protection,private}]),
<a name="3652"/> 3652: 
<a name="3653"/> 3653:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,{protection})),
<a name="3654"/> 3654:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,{protection,false})),
<a name="3655"/> 3655:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,{protection,private,false})),
<a name="3656"/> 3656:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,protection)),
<a name="3657"/> 3657:     ets:delete(T),
<a name="3658"/> 3658:     unlink(Heir),
<a name="3659"/> 3659:     exit(Heir, bang),
<a name="setopts_do-last_expr"/><a name="3660"/> 3660:     ok.
<a name="3661"/> 3661: 
<a name="3662"/> 3662: <i>%% All kinds of operations with bad table argument.</i>
<a name="bad_table-1"/><a name="3663"/> 3663: <b>bad_table</b>(Config) when is_list(Config) -&gt;
<a name="3664"/> 3664: 
<a name="3665"/> 3665:     %% Open and close disk_log to stabilize etsmem.
<a name="3666"/> 3666:     Name = make_ref(),
<a name="3667"/> 3667:     File = filename:join([proplists:get_value(priv_dir, Config),&quot;bad_table.dummy&quot;]),
<a name="3668"/> 3668:     {ok, Name} = disk_log:open([{name, Name}, {file, File}]),
<a name="3669"/> 3669:     disk_log:close(Name),
<a name="3670"/> 3670:     file:delete(File),
<a name="3671"/> 3671: 
<a name="3672"/> 3672:     EtsMem = etsmem(),
<a name="3673"/> 3673: 
<a name="3674"/> 3674:     repeat_for_opts(fun(Opts) -&gt; bad_table_do(Opts,File) end,
<a name="3675"/> 3675: 		    [write_concurrency, all_types]),
<a name="3676"/> 3676:     verify_etsmem(EtsMem),
<a name="bad_table-last_expr"/><a name="3677"/> 3677:     ok.
<a name="3678"/> 3678: 
<a name="bad_table_do-2"/><a name="3679"/> 3679: <b>bad_table_do</b>(Opts, DummyFile) -&gt;
<a name="3680"/> 3680:     Parent = self(),
<a name="3681"/> 3681:     {Pid,Mref} = my_spawn_opt(fun()-&gt; ets_new(priv,[private,named_table | Opts]),
<a name="3682"/> 3682: 				      Priv = ets_new(priv,[private | Opts]),
<a name="3683"/> 3683: 				      ets_new(prot,[protected,named_table | Opts]),
<a name="3684"/> 3684: 				      Prot = ets_new(prot,[protected | Opts]),
<a name="3685"/> 3685: 				      Parent ! {self(),Priv,Prot},
<a name="3686"/> 3686: 				      die_please = receive_any()
<a name="3687"/> 3687: 			      end,
<a name="3688"/> 3688: 			      [link, monitor]),
<a name="3689"/> 3689:     {Pid,Priv,Prot} = receive_any(),
<a name="3690"/> 3690:     MatchSpec = {{key,'_'}, [], ['$$']},
<a name="3691"/> 3691:     Fun = fun(X,_) -&gt; X end,
<a name="3692"/> 3692:     OpList = [{delete,[key],update},
<a name="3693"/> 3693: 	      {delete_all_objects,[],update},
<a name="3694"/> 3694: 	      {delete_object,[{key,data}],update},
<a name="3695"/> 3695: 	      {first,[],read},
<a name="3696"/> 3696: 	      {foldl,[Fun, 0], read, tabarg_last},
<a name="3697"/> 3697: 	      {foldr,[Fun, 0], read, tabarg_last},
<a name="3698"/> 3698: 	      %%{from_dets,[DetsTab], update},
<a name="3699"/> 3699: 	      {give_away,[Pid, data], update},
<a name="3700"/> 3700: 	      %%{info, [], read},
<a name="3701"/> 3701: 	      %%{info, [safe_fixed], read},
<a name="3702"/> 3702: 	      %%{init_table,[Name, InitFun],update},
<a name="3703"/> 3703: 	      {insert, [{key,data}], update},
<a name="3704"/> 3704: 	      {insert_new, [{key,data}], update},
<a name="3705"/> 3705: 	      {insert_new, [[{key,data},{other,data}]], update},
<a name="3706"/> 3706: 	      {last, [], read},
<a name="3707"/> 3707: 	      {lookup, [key], read},
<a name="3708"/> 3708: 	      {lookup_element, [key, 2], read},
<a name="3709"/> 3709: 	      {match, [{}], read},
<a name="3710"/> 3710: 	      {match, [{},17], read},
<a name="3711"/> 3711: 	      {match_delete, [{}], update},
<a name="3712"/> 3712: 	      {match_object, [{}], read},
<a name="3713"/> 3713: 	      {match_object, [{},17], read},
<a name="3714"/> 3714: 	      {member,[key], read},
<a name="3715"/> 3715: 	      {next, [key], read},
<a name="3716"/> 3716: 	      {prev, [key], read},
<a name="3717"/> 3717: 	      {rename, [new_name], update},
<a name="3718"/> 3718: 	      {safe_fixtable, [true], read},
<a name="3719"/> 3719: 	      {select,[MatchSpec], read},
<a name="3720"/> 3720: 	      {select,[MatchSpec,17], read},
<a name="3721"/> 3721: 	      {select_count,[MatchSpec], read},
<a name="3722"/> 3722: 	      {select_delete,[MatchSpec], update},
<a name="3723"/> 3723: 	      {setopts, [{heir,none}], update},
<a name="3724"/> 3724: 	      {slot, [0], read},
<a name="3725"/> 3725: 	      {tab2file, [DummyFile], read, {return,{error,badtab}}},
<a name="3726"/> 3726: 	      {tab2file, [DummyFile,[]], read, {return,{error,badtab}}},
<a name="3727"/> 3727: 	      {tab2list, [], read},
<a name="3728"/> 3728: 	      %%{table,[], read},
<a name="3729"/> 3729: 	      %%{to_dets, [DetsTab], read},
<a name="3730"/> 3730: 	      {update_counter,[key,1], update},
<a name="3731"/> 3731: 	      {update_element,[key,{2,new_data}], update}
<a name="3732"/> 3732: 	     ],
<a name="3733"/> 3733:     Info = {Opts, Priv, Prot},
<a name="3734"/> 3734:     lists:foreach(fun(Op) -&gt; bad_table_op(Info, Op) end,
<a name="3735"/> 3735:                   OpList),
<a name="3736"/> 3736:     Pid ! die_please,
<a name="3737"/> 3737:     {'DOWN', Mref, process, Pid, normal} = receive_any(),
<a name="bad_table_do-last_expr"/><a name="3738"/> 3738:     ok.
<a name="3739"/> 3739: 
<a name="bad_table_op-2"/><a name="3740"/> 3740: <b>bad_table_op</b>({Opts,Priv,Prot}, Op) -&gt;
<a name="3741"/> 3741:     %%io:format(&quot;Doing Op=~p on ~p's\n&quot;,[Op,Type]),
<a name="3742"/> 3742:     T1 = ets_new(noname,Opts),
<a name="3743"/> 3743:     bad_table_call(noname,Op),
<a name="3744"/> 3744:     ets:delete(T1),
<a name="3745"/> 3745:     bad_table_call(T1,Op),
<a name="3746"/> 3746:     T2 = ets_new(named,[named_table | Opts]),
<a name="3747"/> 3747:     ets:delete(T2),
<a name="3748"/> 3748:     bad_table_call(named,Op),
<a name="3749"/> 3749:     bad_table_call(T2,Op),
<a name="3750"/> 3750:     bad_table_call(priv,Op),
<a name="3751"/> 3751:     bad_table_call(Priv,Op),
<a name="bad_table_op-last_expr"/><a name="3752"/> 3752: <b>    case element</b>(3,Op) of
<a name="3753"/> 3753: 	update -&gt;
<a name="3754"/> 3754: 	    bad_table_call(prot,Op),
<a name="3755"/> 3755: 	    bad_table_call(Prot,Op);
<a name="3756"/> 3756: 	read -&gt; ok
<a name="3757"/> 3757:     end.
<a name="3758"/> 3758: 
<a name="bad_table_call-2"/><a name="3759"/> 3759: <b>bad_table_call</b>(T,{F,Args,_}) -&gt;
<a name="3760"/> 3760:     {'EXIT',{badarg,_}} = (catch apply(ets, F, [T|Args]));
<a name="3761"/> 3761: <b>bad_table_call</b>(T,{F,Args,_,tabarg_last}) -&gt;
<a name="3762"/> 3762:     {'EXIT',{badarg,_}} = (catch apply(ets, F, Args++[T]));
<a name="3763"/> 3763: <b>bad_table_call</b>(T,{F,Args,_,{return,Return}}) -&gt;
<a name="bad_table_call-last_expr"/><a name="3764"/> 3764:     try
<a name="3765"/> 3765: 	Return = apply(ets, F, [T|Args])
<a name="3766"/> 3766:     catch
<a name="3767"/> 3767: 	error:badarg -&gt; ok
<a name="3768"/> 3768:     end.
<a name="3769"/> 3769: 
<a name="3770"/> 3770: 
<a name="3771"/> 3771: <i>%% Check rename of ets tables.</i>
<a name="rename-1"/><a name="3772"/> 3772: <b>rename</b>(Config) when is_list(Config) -&gt;
<a name="rename-last_expr"/><a name="3773"/> 3773: <b>    repeat_for_opts</b>(fun rename_do/1, [write_concurrency, all_types]).
<a name="3774"/> 3774: 
<a name="rename_do-1"/><a name="3775"/> 3775: <b>rename_do</b>(Opts) -&gt;
<a name="3776"/> 3776:     EtsMem = etsmem(),
<a name="3777"/> 3777:     ets_new(foobazz,[named_table, public | Opts]),
<a name="3778"/> 3778:     ets:insert(foobazz,{foo,bazz}),
<a name="3779"/> 3779:     ungermanbazz = ets:rename(foobazz,ungermanbazz),
<a name="3780"/> 3780:     {'EXIT',{badarg, _}} = (catch ets:lookup(foobazz,foo)),
<a name="3781"/> 3781:     [{foo,bazz}] = ets:lookup(ungermanbazz,foo),
<a name="3782"/> 3782:     {'EXIT',{badarg,_}} =  (catch ets:rename(ungermanbazz,&quot;no atom&quot;)),
<a name="3783"/> 3783:     ets:delete(ungermanbazz),
<a name="rename_do-last_expr"/><a name="3784"/> 3784: <b>    verify_etsmem</b>(EtsMem).
<a name="3785"/> 3785: 
<a name="3786"/> 3786: <i>%% Check rename of unnamed ets table.</i>
<a name="rename_unnamed-1"/><a name="3787"/> 3787: <b>rename_unnamed</b>(Config) when is_list(Config) -&gt;
<a name="rename_unnamed-last_expr"/><a name="3788"/> 3788: <b>    repeat_for_opts</b>(fun rename_unnamed_do/1,
<a name="3789"/> 3789:                     [write_concurrency,all_types]).
<a name="3790"/> 3790: 
<a name="rename_unnamed_do-1"/><a name="3791"/> 3791: <b>rename_unnamed_do</b>(Opts) -&gt;
<a name="3792"/> 3792:     EtsMem = etsmem(),
<a name="3793"/> 3793:     Tab = ets_new(bonkz,[public | Opts]),
<a name="3794"/> 3794:     {'EXIT',{badarg, _}} = (catch ets:insert(bonkz,{foo,bazz})),
<a name="3795"/> 3795:     bonkz = ets:info(Tab, name),
<a name="3796"/> 3796:     Tab = ets:rename(Tab, tjabonkz),
<a name="3797"/> 3797:     {'EXIT',{badarg, _}} = (catch ets:insert(tjabonkz,{foo,bazz})),
<a name="3798"/> 3798:     tjabonkz = ets:info(Tab, name),
<a name="3799"/> 3799:     ets:delete(Tab),
<a name="rename_unnamed_do-last_expr"/><a name="3800"/> 3800: <b>    verify_etsmem</b>(EtsMem).
<a name="3801"/> 3801: 
<a name="3802"/> 3802: <i>%% Rename a table with many fixations, and at the same time delete it.</i>
<a name="evil_rename-1"/><a name="3803"/> 3803: <b>evil_rename</b>(Config) when is_list(Config) -&gt;
<a name="3804"/> 3804:     EtsMem = etsmem(),
<a name="3805"/> 3805:     evil_rename_1(old_hash, new_hash, [public,named_table]),
<a name="3806"/> 3806:     evil_rename_1(old_tree, new_tree, [public,ordered_set,named_table]),
<a name="3807"/> 3807:     wait_for_test_procs(true),
<a name="evil_rename-last_expr"/><a name="3808"/> 3808: <b>    verify_etsmem</b>(EtsMem).
<a name="3809"/> 3809: 
<a name="evil_rename_1-3"/><a name="3810"/> 3810: <b>evil_rename_1</b>(Old, New, Flags) -&gt;
<a name="3811"/> 3811:     process_flag(trap_exit, true),
<a name="3812"/> 3812:     Old = ets_new(Old, Flags),
<a name="3813"/> 3813:     Fixer = fun() -&gt; ets:safe_fixtable(Old, true) end,
<a name="3814"/> 3814:     crazy_fixtable(15000, Fixer),
<a name="3815"/> 3815:     erlang:yield(),
<a name="3816"/> 3816:     New = ets:rename(Old, New),
<a name="3817"/> 3817:     erlang:yield(),
<a name="3818"/> 3818:     ets:delete(New),
<a name="evil_rename_1-last_expr"/><a name="3819"/> 3819:     ok.
<a name="3820"/> 3820: 
<a name="crazy_fixtable-2"/><a name="3821"/> 3821: <b>crazy_fixtable</b>(N, Fixer) -&gt;
<a name="3822"/> 3822:     Dracula = ets_new(count_dracula, [public]),
<a name="3823"/> 3823:     ets:insert(Dracula, {count,0}),
<a name="3824"/> 3824:     SpawnFun = fun() -&gt;
<a name="3825"/> 3825: 		       Fixer(),
<a name="3826"/> 3826: 		       case ets:update_counter(Dracula, count, 1) rem 15 of
<a name="3827"/> 3827: 			   0 -&gt; evil_creater_destroyer();
<a name="3828"/> 3828: 			   _ -&gt; erlang:hibernate(erlang, error, [dont_wake_me])
<a name="3829"/> 3829: 		       end
<a name="3830"/> 3830: 	       end,
<a name="3831"/> 3831:     crazy_fixtable_1(N, SpawnFun),
<a name="3832"/> 3832:     crazy_fixtable_wait(N, Dracula),
<a name="crazy_fixtable-last_expr"/><a name="3833"/> 3833:     Dracula.
<a name="3834"/> 3834: 
<a name="crazy_fixtable_wait-2"/><a name="3835"/> 3835: <b>crazy_fixtable_wait</b>(N, Dracula) -&gt;
<a name="crazy_fixtable_wait-last_expr"/><a name="3836"/> 3836: <b>    case ets:lookup</b>(Dracula, count) of
<a name="3837"/> 3837: 	[{count,N}] -&gt;
<a name="3838"/> 3838: 	    ets:delete(Dracula);
<a name="3839"/> 3839: 	Other -&gt;
<a name="3840"/> 3840: 	    io:format(&quot;~p\n&quot;, [Other]),
<a name="3841"/> 3841: 	    receive after 10 -&gt; ok end,
<a name="3842"/> 3842: 	    crazy_fixtable_wait(N, Dracula)
<a name="3843"/> 3843:     end.
<a name="3844"/> 3844: 
<a name="crazy_fixtable_1-2"/><a name="3845"/> 3845: <b>crazy_fixtable_1</b>(0, _) -&gt;
<a name="3846"/> 3846:     ok;
<a name="3847"/> 3847: <b>crazy_fixtable_1</b>(N, Fun) -&gt;
<a name="3848"/> 3848:     %%FIXME my_spawn_link(Fun),
<a name="3849"/> 3849:     my_spawn_link(Fun),
<a name="crazy_fixtable_1-last_expr"/><a name="3850"/> 3850: <b>    crazy_fixtable_1</b>(N-1, Fun).
<a name="3851"/> 3851: 
<a name="evil_creater_destroyer-0"/><a name="3852"/> 3852: <b>evil_creater_destroyer</b>() -&gt;
<a name="3853"/> 3853:     T1 = evil_create_fixed_tab(),
<a name="evil_creater_destroyer-last_expr"/><a name="3854"/> 3854: <b>    ets:delete</b>(T1).
<a name="3855"/> 3855: 
<a name="evil_create_fixed_tab-0"/><a name="3856"/> 3856: <b>evil_create_fixed_tab</b>() -&gt;
<a name="3857"/> 3857:     T = ets_new(arne, [public]),
<a name="3858"/> 3858:     ets:safe_fixtable(T, true),
<a name="evil_create_fixed_tab-last_expr"/><a name="3859"/> 3859:     T.
<a name="3860"/> 3860: 
<a name="3861"/> 3861: <i>%% Tests that the return values and errors are equal for set's and</i>
<a name="3862"/> 3862: <i>%% ordered_set's where applicable.</i>
<a name="interface_equality-1"/><a name="3863"/> 3863: <b>interface_equality</b>(Config) when is_list(Config) -&gt;
<a name="interface_equality-last_expr"/><a name="3864"/> 3864: <b>    repeat_for_opts</b>(fun interface_equality_do/1).
<a name="3865"/> 3865: 
<a name="interface_equality_do-1"/><a name="3866"/> 3866: <b>interface_equality_do</b>(Opts) -&gt;
<a name="3867"/> 3867:     EtsMem = etsmem(),
<a name="3868"/> 3868:     Set = ets_new(set,[set | Opts]),
<a name="3869"/> 3869:     OrderedSet = ets_new(ordered_set,
<a name="3870"/> 3870:                          replace_dbg_hash_fixed_nr_of_locks([ordered_set | Opts])),
<a name="3871"/> 3871:     F = fun(X,T,FF) -&gt; case X of
<a name="3872"/> 3872:                            0 -&gt; true;
<a name="3873"/> 3873:                            _ -&gt;
<a name="3874"/> 3874:                                ets:insert(T, {X,
<a name="3875"/> 3875:                                               integer_to_list(X),
<a name="3876"/> 3876:                                               X rem 10}),
<a name="3877"/> 3877:                                FF(X-1,T,FF)
<a name="3878"/> 3878:                        end
<a name="3879"/> 3879:         end,
<a name="3880"/> 3880:     F(100,Set,F),
<a name="3881"/> 3881:     F(100,OrderedSet,F),
<a name="3882"/> 3882:     equal_results(ets, insert, Set, OrderedSet, [{a,&quot;a&quot;}]),
<a name="3883"/> 3883:     equal_results(ets, insert, Set, OrderedSet, [{1,1,&quot;1&quot;}]),
<a name="3884"/> 3884:     equal_results(ets, lookup, Set, OrderedSet, [10]),
<a name="3885"/> 3885:     equal_results(ets, lookup, Set, OrderedSet, [1000]),
<a name="3886"/> 3886:     equal_results(ets, delete, Set, OrderedSet, [10]),
<a name="3887"/> 3887:     equal_results(ets, delete, Set, OrderedSet, [nott]),
<a name="3888"/> 3888:     equal_results(ets, lookup, Set, OrderedSet, [1000]),
<a name="3889"/> 3889:     equal_results(ets, insert, Set, OrderedSet, [10]),
<a name="3890"/> 3890:     equal_results(ets, next, Set, OrderedSet, ['$end_of_table']),
<a name="3891"/> 3891:     equal_results(ets, prev, Set, OrderedSet, ['$end_of_table']),
<a name="3892"/> 3892:     equal_results(ets, match, Set, OrderedSet, [{'_','_','_'}]),
<a name="3893"/> 3893:     equal_results(ets, match, Set, OrderedSet, [{'_','_','_','_'}]),
<a name="3894"/> 3894:     equal_results(ets, match, Set, OrderedSet, [{$3,$2,2}]),
<a name="3895"/> 3895:     equal_results(ets, match, Set, OrderedSet, ['_']),
<a name="3896"/> 3896:     equal_results(ets, match, Set, OrderedSet, ['$1']),
<a name="3897"/> 3897:     equal_results(ets, match, Set, OrderedSet, [{'_','$50',3}]),
<a name="3898"/> 3898:     equal_results(ets, match, Set, OrderedSet, [['_','$50',3]]),
<a name="3899"/> 3899:     equal_results(ets, match_delete, Set, OrderedSet, [{'_','_',4}]),
<a name="3900"/> 3900:     equal_results(ets, match_delete, Set, OrderedSet, [{'_','_',4}]),
<a name="3901"/> 3901:     equal_results(ets, match_object, Set, OrderedSet, [{'_','_',4}]),
<a name="3902"/> 3902:     equal_results(ets, match_object, Set, OrderedSet, [{'_','_',5}]),
<a name="3903"/> 3903:     equal_results(ets, match_object, Set, OrderedSet, [{'_','_',4}]),
<a name="3904"/> 3904:     equal_results(ets, match_object, Set, OrderedSet, ['_']),
<a name="3905"/> 3905:     equal_results(ets, match_object, Set, OrderedSet, ['$5011']),
<a name="3906"/> 3906:     equal_results(ets, match_delete, Set, OrderedSet, ['$20']),
<a name="3907"/> 3907:     equal_results(ets, lookup_element, Set, OrderedSet, [13,2]),
<a name="3908"/> 3908:     equal_results(ets, lookup_element, Set, OrderedSet, [13,4]),
<a name="3909"/> 3909:     equal_results(ets, lookup_element, Set, OrderedSet, [14,2]),
<a name="3910"/> 3910:     equal_results(ets, delete, Set, OrderedSet, []),
<a name="interface_equality_do-last_expr"/><a name="3911"/> 3911: <b>    verify_etsmem</b>(EtsMem).
<a name="3912"/> 3912: 
<a name="equal_results-5"/><a name="3913"/> 3913: <b>equal_results</b>(M, F, FirstArg1, FirstArg2 ,ACommon) -&gt;
<a name="3914"/> 3914:     Res = maybe_sort((catch apply(M,F, [FirstArg1 | ACommon]))),
<a name="equal_results-last_expr"/><a name="3915"/> 3915: <b>    Res = maybe_sort</b>((catch apply(M,F,[FirstArg2 | ACommon]))).
<a name="3916"/> 3916: 
<a name="maybe_sort-1"/><a name="3917"/> 3917: <b>maybe_sort</b>(L) when is_list(L) -&gt;
<a name="3918"/> 3918:     lists:sort(L);
<a name="3919"/> 3919: <b>maybe_sort</b>({'EXIT',{Reason, List}}) when is_list(List) -&gt;
<a name="3920"/> 3920:     {'EXIT',{Reason, lists:map(fun({Module, Function, _, _}) -&gt;
<a name="3921"/> 3921: 				       {Module, Function, '_'}
<a name="3922"/> 3922: 			       end,
<a name="3923"/> 3923: 			       List)}};
<a name="3924"/> 3924: <b>maybe_sort</b>(Any) -&gt;
<a name="maybe_sort-last_expr"/><a name="3925"/> 3925:     Any.
<a name="3926"/> 3926: 
<a name="3927"/> 3927: <i>%% Test match, match_object and match_delete in ordered set's.</i>
<a name="ordered_match-1"/><a name="3928"/> 3928: <b>ordered_match</b>(Config) when is_list(Config)-&gt;
<a name="ordered_match-last_expr"/><a name="3929"/> 3929: <b>    repeat_for_opts_extra_opt</b>(fun ordered_match_do/1, ordered_set).
<a name="3930"/> 3930: 
<a name="ordered_match_do-1"/><a name="3931"/> 3931: <b>ordered_match_do</b>(Opts) -&gt;
<a name="3932"/> 3932:     EtsMem = etsmem(),
<a name="3933"/> 3933:     F = fun(X,T,FF) -&gt; case X of
<a name="3934"/> 3934: 			   0 -&gt; true;
<a name="3935"/> 3935: 			   _ -&gt;
<a name="3936"/> 3936: 			       ets:insert(T, {X,
<a name="3937"/> 3937: 					      integer_to_list(X),
<a name="3938"/> 3938: 					      X rem 10,
<a name="3939"/> 3939: 					      X rem 100,
<a name="3940"/> 3940: 					      X rem 1000}),
<a name="3941"/> 3941: 			       FF(X-1,T,FF)
<a name="3942"/> 3942: 		       end
<a name="3943"/> 3943: 	end,
<a name="3944"/> 3944:     T1 = ets_new(xxx,[ordered_set| Opts]),
<a name="3945"/> 3945:     F(3000,T1,F),
<a name="3946"/> 3946:     [[3,3],[3,3],[3,3]] = ets:match(T1, {'_','_','$1','$2',3}),
<a name="3947"/> 3947:     F2 = fun(X,Rem,Res,FF) -&gt; case X of
<a name="3948"/> 3948: 				  0 -&gt; [];
<a name="3949"/> 3949: 				  _ -&gt;
<a name="3950"/> 3950: 				      case X rem Rem of
<a name="3951"/> 3951: 					  Res -&gt;
<a name="3952"/> 3952: 					      FF(X-1,Rem,Res,FF) ++
<a name="3953"/> 3953: 						  [{X,
<a name="3954"/> 3954: 						    integer_to_list(X),
<a name="3955"/> 3955: 						    X rem 10,
<a name="3956"/> 3956: 						    X rem 100,
<a name="3957"/> 3957: 						    X rem 1000}];
<a name="3958"/> 3958: 					  _ -&gt;
<a name="3959"/> 3959: 					      FF(X-1,Rem,Res,FF)
<a name="3960"/> 3960: 				      end
<a name="3961"/> 3961: 			      end
<a name="3962"/> 3962: 	 end,
<a name="3963"/> 3963:     OL1 = F2(3000,100,2,F2),
<a name="3964"/> 3964:     OL1 = ets:match_object(T1, {'_','_','_',2,'_'}),
<a name="3965"/> 3965:     true = ets:match_delete(T1,{'_','_','_',2,'_'}),
<a name="3966"/> 3966:     [] = ets:match_object(T1, {'_','_','_',2,'_'}),
<a name="3967"/> 3967:     OL2 = F2(3000,100,3,F2),
<a name="3968"/> 3968:     OL2 = ets:match_object(T1, {'_','_','_',3,'_'}),
<a name="3969"/> 3969:     ets:delete(T1),
<a name="ordered_match_do-last_expr"/><a name="3970"/> 3970: <b>    verify_etsmem</b>(EtsMem).
<a name="3971"/> 3971: 
<a name="3972"/> 3972: 
<a name="3973"/> 3973: <i>%% Test basic functionality in ordered_set's.</i>
<a name="ordered-1"/><a name="3974"/> 3974: <b>ordered</b>(Config) when is_list(Config) -&gt;
<a name="ordered-last_expr"/><a name="3975"/> 3975: <b>    repeat_for_opts_extra_opt</b>(fun ordered_do/1, ordered_set).
<a name="3976"/> 3976: 
<a name="ordered_do-1"/><a name="3977"/> 3977: <b>ordered_do</b>(Opts) -&gt;
<a name="3978"/> 3978:     EtsMem = etsmem(),
<a name="3979"/> 3979:     T = ets_new(oset, [ordered_set | Opts]),
<a name="3980"/> 3980:     InsList = [
<a name="3981"/> 3981: 	       25,26,27,28,
<a name="3982"/> 3982: 	       5,6,7,8,
<a name="3983"/> 3983: 	       21,22,23,24,
<a name="3984"/> 3984: 	       9,10,11,12,
<a name="3985"/> 3985: 	       1,2,3,4,
<a name="3986"/> 3986: 	       17,18,19,20,
<a name="3987"/> 3987: 	       13,14,15,16,
<a name="3988"/> 3988: 	       1 bsl 33
<a name="3989"/> 3989: 	      ],
<a name="3990"/> 3990:     lists:foreach(fun(X) -&gt;
<a name="3991"/> 3991: 			  ets:insert(T,{X,integer_to_list(X)})
<a name="3992"/> 3992: 		  end,
<a name="3993"/> 3993: 		  InsList),
<a name="3994"/> 3994:     IL2 = lists:map(fun(X) -&gt; {X,integer_to_list(X)} end, InsList),
<a name="3995"/> 3995:     L1 = pick_all_forward(T),
<a name="3996"/> 3996:     L2 = pick_all_backwards(T),
<a name="3997"/> 3997:     S1 = lists:sort(IL2),
<a name="3998"/> 3998:     S2 = lists:reverse(lists:sort(IL2)),
<a name="3999"/> 3999:     S1 = L1,
<a name="4000"/> 4000:     S2 = L2,
<a name="4001"/> 4001:     [{1,&quot;1&quot;}] = ets:slot(T,0),
<a name="4002"/> 4002:     [{28,&quot;28&quot;}] = ets:slot(T,27),
<a name="4003"/> 4003:     [{1 bsl 33,_}] = ets:slot(T,28),
<a name="4004"/> 4004:     27 = ets:prev(T,28),
<a name="4005"/> 4005:     [{7,&quot;7&quot;}] = ets:slot(T,6),
<a name="4006"/> 4006:     '$end_of_table' = ets:next(T,1 bsl 33),
<a name="4007"/> 4007:     [{12,&quot;12&quot;}] = ets:slot(T,11),
<a name="4008"/> 4008:     '$end_of_table' = ets:slot(T,29),
<a name="4009"/> 4009:     [{1,&quot;1&quot;}] = ets:slot(T,0),
<a name="4010"/> 4010:     28 = ets:prev(T,1 bsl 33),
<a name="4011"/> 4011:     1 = ets:next(T,0),
<a name="4012"/> 4012:     pick_all_forward(T),
<a name="4013"/> 4013:     [{7,&quot;7&quot;}] = ets:slot(T,6),
<a name="4014"/> 4014:     L2 = pick_all_backwards(T),
<a name="4015"/> 4015:     [{7,&quot;7&quot;}] = ets:slot(T,6),
<a name="4016"/> 4016:     ets:delete(T),
<a name="ordered_do-last_expr"/><a name="4017"/> 4017: <b>    verify_etsmem</b>(EtsMem).
<a name="4018"/> 4018: 
<a name="pick_all-3"/><a name="4019"/> 4019: <b>pick_all</b>(_T,'$end_of_table',_How) -&gt;
<a name="4020"/> 4020:     [];
<a name="4021"/> 4021: <b>pick_all</b>(T,Last,How) -&gt;
<a name="4022"/> 4022:     This = case How of
<a name="4023"/> 4023: 	       next -&gt;
<a name="4024"/> 4024: 		   ets:next(T,Last);
<a name="4025"/> 4025: 	       prev -&gt;
<a name="4026"/> 4026: 		   ets:prev(T,Last)
<a name="4027"/> 4027: 	   end,
<a name="4028"/> 4028:     [LastObj] = ets:lookup(T,Last),
<a name="pick_all-last_expr"/><a name="4029"/> 4029: <b>    [LastObj | pick_all</b>(T,This,How)].
<a name="4030"/> 4030: 
<a name="pick_all_forward-1"/><a name="4031"/> 4031: <b>pick_all_forward</b>(T) -&gt;
<a name="pick_all_forward-last_expr"/><a name="4032"/> 4032: <b>    pick_all</b>(T,ets:first(T),next).
<a name="pick_all_backwards-1"/><a name="4033"/> 4033: <b>pick_all_backwards</b>(T) -&gt;
<a name="pick_all_backwards-last_expr"/><a name="4034"/> 4034: <b>    pick_all</b>(T,ets:last(T),prev).
<a name="4035"/> 4035: 
<a name="4036"/> 4036: 
<a name="4037"/> 4037: 
<a name="4038"/> 4038: <i>%% Small test case for both set and bag type ets tables.</i>
<a name="setbag-1"/><a name="4039"/> 4039: <b>setbag</b>(Config) when is_list(Config) -&gt;
<a name="4040"/> 4040:     EtsMem = etsmem(),
<a name="4041"/> 4041:     lists:foreach(fun(SetType) -&gt;
<a name="4042"/> 4042:                           Set = ets_new(SetType,[SetType]),
<a name="4043"/> 4043:                           Bag = ets_new(bag,[bag]),
<a name="4044"/> 4044:                           Key = {foo,bar},
<a name="4045"/> 4045: 
<a name="4046"/> 4046:                           %% insert some value
<a name="4047"/> 4047:                           ets:insert(Set,{Key,val1}),
<a name="4048"/> 4048:                           ets:insert(Bag,{Key,val1}),
<a name="4049"/> 4049: 
<a name="4050"/> 4050:                           %% insert new value for same key again
<a name="4051"/> 4051:                           ets:insert(Set,{Key,val2}),
<a name="4052"/> 4052:                           ets:insert(Bag,{Key,val2}),
<a name="4053"/> 4053: 
<a name="4054"/> 4054:                           %% check
<a name="4055"/> 4055:                           [{Key,val2}] = ets:lookup(Set,Key),
<a name="4056"/> 4056:                           [{Key,val1},{Key,val2}] = ets:lookup(Bag,Key),
<a name="4057"/> 4057: 
<a name="4058"/> 4058:                           true = ets:delete(Set),
<a name="4059"/> 4059:                           true = ets:delete(Bag)
<a name="4060"/> 4060:                   end, [set, cat_ord_set,stim_cat_ord_set,ordered_set]),
<a name="setbag-last_expr"/><a name="4061"/> 4061: <b>    verify_etsmem</b>(EtsMem).
<a name="4062"/> 4062: 
<a name="4063"/> 4063: <i>%% Test case to check proper return values for illegal ets_new() calls.</i>
<a name="badnew-1"/><a name="4064"/> 4064: <b>badnew</b>(Config) when is_list(Config) -&gt;
<a name="4065"/> 4065:     EtsMem = etsmem(),
<a name="4066"/> 4066:     {'EXIT',{badarg,_}} = (catch ets:new(12,[])),
<a name="4067"/> 4067:     {'EXIT',{badarg,_}} = (catch ets:new({a,b},[])),
<a name="4068"/> 4068:     {'EXIT',{badarg,_}} = (catch ets:new(name,[foo])),
<a name="4069"/> 4069:     {'EXIT',{badarg,_}} = (catch ets:new(name,{bag})),
<a name="4070"/> 4070:     {'EXIT',{badarg,_}} = (catch ets:new(name,bag)),
<a name="badnew-last_expr"/><a name="4071"/> 4071: <b>    verify_etsmem</b>(EtsMem).
<a name="4072"/> 4072: 
<a name="4073"/> 4073: <i>%% OTP-2314. Test case to check that a non-proper list does not</i>
<a name="4074"/> 4074: <i>%% crash the emulator.</i>
<a name="verybadnew-1"/><a name="4075"/> 4075: <b>verybadnew</b>(Config) when is_list(Config) -&gt;
<a name="4076"/> 4076:     EtsMem = etsmem(),
<a name="4077"/> 4077:     {'EXIT',{badarg,_}} = (catch ets:new(verybad,[set|protected])),
<a name="verybadnew-last_expr"/><a name="4078"/> 4078: <b>    verify_etsmem</b>(EtsMem).
<a name="4079"/> 4079: 
<a name="4080"/> 4080: <i>%% Small check to see if named tables work.</i>
<a name="named-1"/><a name="4081"/> 4081: <b>named</b>(Config) when is_list(Config) -&gt;
<a name="4082"/> 4082:     EtsMem = etsmem(),
<a name="4083"/> 4083:     Tab = make_table(foo,
<a name="4084"/> 4084: 		     [named_table],
<a name="4085"/> 4085: 		     [{key,val}]),
<a name="4086"/> 4086:     [{key,val}] = ets:lookup(foo,key),
<a name="4087"/> 4087:     true = ets:delete(Tab),
<a name="named-last_expr"/><a name="4088"/> 4088: <b>    verify_etsmem</b>(EtsMem).
<a name="4089"/> 4089: 
<a name="4090"/> 4090: <i>%% Test case to check if specified keypos works.</i>
<a name="keypos2-1"/><a name="4091"/> 4091: <b>keypos2</b>(Config) when is_list(Config) -&gt;
<a name="4092"/> 4092:     EtsMem = etsmem(),
<a name="4093"/> 4093:     lists:foreach(fun(SetType) -&gt;
<a name="4094"/> 4094:                           Tab = make_table(foo,
<a name="4095"/> 4095:                                            [SetType,{keypos,2}],
<a name="4096"/> 4096:                                            [{val,key}, {val2,key}]),
<a name="4097"/> 4097:                           [{val2,key}] = ets:lookup(Tab,key),
<a name="4098"/> 4098:                           true = ets:delete(Tab)
<a name="4099"/> 4099:                   end, [set, cat_ord_set,stim_cat_ord_set,ordered_set]),
<a name="keypos2-last_expr"/><a name="4100"/> 4100: <b>    verify_etsmem</b>(EtsMem).
<a name="4101"/> 4101: 
<a name="4102"/> 4102: <i>%% Privacy check. Check that a named(public/private/protected) table</i>
<a name="4103"/> 4103: <i>%% cannot be read by the wrong process(es).</i>
<a name="privacy-1"/><a name="4104"/> 4104: <b>privacy</b>(Config) when is_list(Config) -&gt;
<a name="privacy-last_expr"/><a name="4105"/> 4105: <b>    repeat_for_opts</b>(fun privacy_do/1).
<a name="4106"/> 4106: 
<a name="privacy_do-1"/><a name="4107"/> 4107: <b>privacy_do</b>(Opts) -&gt;
<a name="4108"/> 4108:     EtsMem = etsmem(),
<a name="4109"/> 4109:     process_flag(trap_exit,true),
<a name="4110"/> 4110:     Parent = self(),
<a name="4111"/> 4111:     Owner = my_spawn_link(fun() -&gt; privacy_owner(Parent, Opts) end),
<a name="4112"/> 4112:     receive
<a name="4113"/> 4113: 	{'EXIT',Owner,Reason} -&gt;
<a name="4114"/> 4114: 	    exit({privacy_test,Reason});
<a name="4115"/> 4115: 	ok -&gt;
<a name="4116"/> 4116: 	    ok
<a name="4117"/> 4117:     end,
<a name="4118"/> 4118: 
<a name="4119"/> 4119:     privacy_check(pub,prot,priv),
<a name="4120"/> 4120: 
<a name="4121"/> 4121:     Owner ! {shift,1,{pub,prot,priv}},
<a name="4122"/> 4122:     receive
<a name="4123"/> 4123:         {Pub1,Prot1,Priv1} -&gt;
<a name="4124"/> 4124:             ok = privacy_check(Pub1,Prot1,Priv1),
<a name="4125"/> 4125:             Owner ! {shift,2,{Pub1,Prot1,Priv1}}
<a name="4126"/> 4126:     end,
<a name="4127"/> 4127: 
<a name="4128"/> 4128:     receive
<a name="4129"/> 4129:         {Pub2,Prot2,Priv2} -&gt;
<a name="4130"/> 4130:             ok = privacy_check(Pub2,Prot2,Priv2),
<a name="4131"/> 4131:             Owner ! {shift,0,{Pub2,Prot2,Priv2}}
<a name="4132"/> 4132:     end,
<a name="4133"/> 4133: 
<a name="4134"/> 4134:     receive
<a name="4135"/> 4135:         {Pub3,Prot3,Priv3} -&gt;
<a name="4136"/> 4136:             ok = privacy_check(Pub3,Prot3,Priv3)
<a name="4137"/> 4137:     end,
<a name="4138"/> 4138: 
<a name="4139"/> 4139:     Owner ! die,
<a name="4140"/> 4140:     receive {'EXIT',Owner,_} -&gt; ok end,
<a name="privacy_do-last_expr"/><a name="4141"/> 4141: <b>    verify_etsmem</b>(EtsMem).
<a name="4142"/> 4142: 
<a name="privacy_check-3"/><a name="4143"/> 4143: <b>privacy_check</b>(Pub,Prot,Priv) -&gt;
<a name="4144"/> 4144:     %% check read rights
<a name="4145"/> 4145:     [] = ets:lookup(Pub, foo),
<a name="4146"/> 4146:     [] = ets:lookup(Prot,foo),
<a name="4147"/> 4147:     {'EXIT',{badarg,_}} = (catch ets:lookup(Priv,foo)),
<a name="4148"/> 4148: 
<a name="4149"/> 4149:     %% check write rights
<a name="4150"/> 4150:     true = ets:insert(Pub, {1,foo}),
<a name="4151"/> 4151:     {'EXIT',{badarg,_}} = (catch ets:insert(Prot,{2,foo})),
<a name="4152"/> 4152:     {'EXIT',{badarg,_}} = (catch ets:insert(Priv,{3,foo})),
<a name="4153"/> 4153: 
<a name="4154"/> 4154:     %% check that it really wasn't written, either
<a name="4155"/> 4155:     [] = ets:lookup(Prot,foo),
<a name="privacy_check-last_expr"/><a name="4156"/> 4156:     ok.
<a name="4157"/> 4157: 
<a name="privacy_owner-2"/><a name="4158"/> 4158: <b>privacy_owner</b>(Boss, Opts) -&gt;
<a name="4159"/> 4159:     ets_new(pub, [public,named_table | Opts]),
<a name="4160"/> 4160:     ets_new(prot,[protected,named_table | Opts]),
<a name="4161"/> 4161:     ets_new(priv,[private,named_table | Opts]),
<a name="4162"/> 4162:     Boss ! ok,
<a name="privacy_owner-last_expr"/><a name="4163"/> 4163: <b>    privacy_owner_loop</b>(Boss).
<a name="4164"/> 4164: 
<a name="privacy_owner_loop-1"/><a name="4165"/> 4165: <b>privacy_owner_loop</b>(Boss) -&gt;
<a name="privacy_owner_loop-last_expr"/><a name="4166"/> 4166:     receive
<a name="4167"/> 4167: 	{shift,N,Pub_Prot_Priv} -&gt;
<a name="4168"/> 4168: 	    {Pub,Prot,Priv} = rotate_tuple(Pub_Prot_Priv, N),
<a name="4169"/> 4169: 
<a name="4170"/> 4170: 	    ets:setopts(Pub,{protection,public}),
<a name="4171"/> 4171: 	    ets:setopts(Prot,{protection,protected}),
<a name="4172"/> 4172: 	    ets:setopts(Priv,{protection,private}),
<a name="4173"/> 4173: 	    Boss ! {Pub,Prot,Priv},
<a name="4174"/> 4174: 	    privacy_owner_loop(Boss);
<a name="4175"/> 4175: 
<a name="4176"/> 4176: 	die -&gt; ok
<a name="4177"/> 4177:     end.
<a name="4178"/> 4178: 
<a name="rotate_tuple-2"/><a name="4179"/> 4179: <b>rotate_tuple</b>(Tuple, 0) -&gt;
<a name="4180"/> 4180:     Tuple;
<a name="4181"/> 4181: <b>rotate_tuple</b>(Tuple, N) -&gt;
<a name="4182"/> 4182:     [H|T] = tuple_to_list(Tuple),
<a name="rotate_tuple-last_expr"/><a name="4183"/> 4183: <b>    rotate_tuple</b>(list_to_tuple(T ++ [H]), N-1).
<a name="4184"/> 4184: 
<a name="4185"/> 4185: 
<a name="4186"/> 4186: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="4187"/> 4187: 
<a name="4188"/> 4188: 
<a name="4189"/> 4189: <i>%% Check lookup in an empty table and lookup of a non-existing key.</i>
<a name="empty-1"/><a name="4190"/> 4190: <b>empty</b>(Config) when is_list(Config) -&gt;
<a name="empty-last_expr"/><a name="4191"/> 4191: <b>    repeat_for_opts_all_table_types</b>(fun empty_do/1).
<a name="4192"/> 4192: 
<a name="empty_do-1"/><a name="4193"/> 4193: <b>empty_do</b>(Opts) -&gt;
<a name="4194"/> 4194:     EtsMem = etsmem(),
<a name="4195"/> 4195:     Tab = ets_new(foo,Opts),
<a name="4196"/> 4196:     [] = ets:lookup(Tab,key),
<a name="4197"/> 4197:     true = ets:insert(Tab,{key2,val}),
<a name="4198"/> 4198:     [] = ets:lookup(Tab,key),
<a name="4199"/> 4199:     true = ets:delete(Tab),
<a name="empty_do-last_expr"/><a name="4200"/> 4200: <b>    verify_etsmem</b>(EtsMem).
<a name="4201"/> 4201: 
<a name="4202"/> 4202: <i>%% Check proper return values for illegal insert operations.</i>
<a name="badinsert-1"/><a name="4203"/> 4203: <b>badinsert</b>(Config) when is_list(Config) -&gt;
<a name="badinsert-last_expr"/><a name="4204"/> 4204: <b>    repeat_for_opts_all_table_types</b>(fun badinsert_do/1).
<a name="4205"/> 4205: 
<a name="badinsert_do-1"/><a name="4206"/> 4206: <b>badinsert_do</b>(Opts) -&gt;
<a name="4207"/> 4207:     EtsMem = etsmem(),
<a name="4208"/> 4208:     {'EXIT',{badarg,_}} = (catch ets:insert(foo,{key,val})),
<a name="4209"/> 4209: 
<a name="4210"/> 4210:     Tab = ets_new(foo,Opts),
<a name="4211"/> 4211:     {'EXIT',{badarg,_}} = (catch ets:insert(Tab,{})),
<a name="4212"/> 4212: 
<a name="4213"/> 4213:     Tab3 = ets_new(foo,[{keypos,3}| Opts]),
<a name="4214"/> 4214:     {'EXIT',{badarg,_}} = (catch ets:insert(Tab3,{a,b})),
<a name="4215"/> 4215: 
<a name="4216"/> 4216:     {'EXIT',{badarg,_}} = (catch ets:insert(Tab,[key,val2])),
<a name="4217"/> 4217:     true = ets:delete(Tab),
<a name="4218"/> 4218:     true = ets:delete(Tab3),
<a name="badinsert_do-last_expr"/><a name="4219"/> 4219: <b>    verify_etsmem</b>(EtsMem).
<a name="4220"/> 4220: 
<a name="4221"/> 4221: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="4222"/> 4222: 
<a name="4223"/> 4223: 
<a name="4224"/> 4224: <i>%% Check proper return values from bad lookups in existing/non existing</i>
<a name="4225"/> 4225: <i>%% ets tables.</i>
<a name="badlookup-1"/><a name="4226"/> 4226: <b>badlookup</b>(Config) when is_list(Config) -&gt;
<a name="4227"/> 4227:     EtsMem = etsmem(),
<a name="4228"/> 4228:     {'EXIT',{badarg,_}} = (catch ets:lookup(foo,key)),
<a name="4229"/> 4229:     Tab = ets_new(foo,[]),
<a name="4230"/> 4230:     ets:delete(Tab),
<a name="4231"/> 4231:     {'EXIT',{badarg,_}} = (catch ets:lookup(Tab,key)),
<a name="badlookup-last_expr"/><a name="4232"/> 4232: <b>    verify_etsmem</b>(EtsMem).
<a name="4233"/> 4233: 
<a name="4234"/> 4234: <i>%% Test that lookup returns objects in order of insertion for bag and dbag.</i>
<a name="lookup_order-1"/><a name="4235"/> 4235: <b>lookup_order</b>(Config) when is_list(Config) -&gt;
<a name="4236"/> 4236:     EtsMem = etsmem(),
<a name="4237"/> 4237:     repeat_for_opts(fun lookup_order_do/1,
<a name="4238"/> 4238:                     [write_concurrency,[bag,duplicate_bag]]),
<a name="4239"/> 4239:     verify_etsmem(EtsMem),
<a name="lookup_order-last_expr"/><a name="4240"/> 4240:     ok.
<a name="4241"/> 4241: 
<a name="lookup_order_do-1"/><a name="4242"/> 4242: <b>lookup_order_do</b>(Opts) -&gt;
<a name="4243"/> 4243:     lookup_order_2(Opts, false),
<a name="lookup_order_do-last_expr"/><a name="4244"/> 4244: <b>    lookup_order_2</b>(Opts, true).
<a name="4245"/> 4245: 
<a name="lookup_order_2-2"/><a name="4246"/> 4246: <b>lookup_order_2</b>(Opts, Fixed) -&gt;
<a name="4247"/> 4247:     io:format(&quot;Opts=~p Fixed=~p\n&quot;,[Opts,Fixed]),
<a name="4248"/> 4248: 
<a name="4249"/> 4249:     A = 1, B = 2, C = 3,
<a name="4250"/> 4250:     ABC = [A,B,C],
<a name="4251"/> 4251:     Pair = [{A,B},{B,A},{A,C},{C,A},{B,C},{C,B}],
<a name="4252"/> 4252:     Combos = [{D1,D2,D3} || D1&lt;-ABC, D2&lt;-Pair, D3&lt;-Pair],
<a name="lookup_order_2-last_expr"/><a name="4253"/> 4253: <b>    lists:foreach</b>(fun({D1,{D2a,D2b},{D3a,D3b}}) -&gt;
<a name="4254"/> 4254: 			  T = ets_new(foo,Opts),
<a name="4255"/> 4255: 			  case Fixed of
<a name="4256"/> 4256: 			      true -&gt; ets:safe_fixtable(T,true);
<a name="4257"/> 4257: 			      false -&gt; ok
<a name="4258"/> 4258: 			  end,
<a name="4259"/> 4259: 			  S10 = {T,[],key},
<a name="4260"/> 4260: 			  S20 = check_insert(S10,A),
<a name="4261"/> 4261: 			  S30 = check_insert(S20,B),
<a name="4262"/> 4262: 			  S40 = check_insert(S30,C),
<a name="4263"/> 4263: 			  S50 = check_delete(S40,D1),
<a name="4264"/> 4264: 			  S55 = check_insert(S50,D1),
<a name="4265"/> 4265: 			  S60 = check_insert(S55,D1),
<a name="4266"/> 4266: 			  S70 = check_delete(S60,D2a),
<a name="4267"/> 4267: 			  S80 = check_delete(S70,D2b),
<a name="4268"/> 4268: 			  S90 = check_insert(S80,D2a),
<a name="4269"/> 4269: 			  SA0 = check_delete(S90,D3a),
<a name="4270"/> 4270: 			  SB0 = check_delete(SA0,D3b),
<a name="4271"/> 4271: 			  check_insert_new(SB0,D3b),
<a name="4272"/> 4272: 
<a name="4273"/> 4273: 			  true = ets:delete(T)
<a name="4274"/> 4274: 		  end,
<a name="4275"/> 4275: 		  Combos).
<a name="4276"/> 4276: 
<a name="4277"/> 4277: 
<a name="check_insert-2"/><a name="4278"/> 4278: <b>check_insert</b>({T,List0,Key},Val) -&gt;
<a name="4279"/> 4279:     %%io:format(&quot;insert ~p into ~p\n&quot;,[Val,List0]),
<a name="4280"/> 4280:     ets:insert(T,{Key,Val}),
<a name="4281"/> 4281:     List1 = case (ets:info(T,type) =:= bag andalso
<a name="4282"/> 4282: 		  lists:member({Key,Val},List0)) of
<a name="4283"/> 4283: 		true -&gt; List0;
<a name="4284"/> 4284: 		false -&gt; [{Key,Val} | List0]
<a name="4285"/> 4285: 	    end,
<a name="check_insert-last_expr"/><a name="4286"/> 4286: <b>    check_check</b>({T,List1,Key}).
<a name="4287"/> 4287: 
<a name="check_insert_new-2"/><a name="4288"/> 4288: <b>check_insert_new</b>({T,List0,Key},Val) -&gt;
<a name="4289"/> 4289:     %%io:format(&quot;insert_new ~p into ~p\n&quot;,[Val,List0]),
<a name="4290"/> 4290:     Ret = ets:insert_new(T,{Key,Val}),
<a name="4291"/> 4291:     Ret = (List0 =:= []),
<a name="4292"/> 4292:     List1 = case Ret of
<a name="4293"/> 4293: 		true -&gt; [{Key,Val}];
<a name="4294"/> 4294: 		false -&gt; List0
<a name="4295"/> 4295: 	    end,
<a name="check_insert_new-last_expr"/><a name="4296"/> 4296: <b>    check_check</b>({T,List1,Key}).
<a name="4297"/> 4297: 
<a name="4298"/> 4298: 
<a name="check_delete-2"/><a name="4299"/> 4299: <b>check_delete</b>({T,List0,Key},Val) -&gt;
<a name="4300"/> 4300:     %%io:format(&quot;delete ~p from ~p\n&quot;,[Val,List0]),
<a name="4301"/> 4301:     ets:delete_object(T,{Key,Val}),
<a name="4302"/> 4302:     List1 = lists:filter(fun(Obj) -&gt; Obj =/= {Key,Val} end,
<a name="4303"/> 4303: 			 List0),
<a name="check_delete-last_expr"/><a name="4304"/> 4304: <b>    check_check</b>({T,List1,Key}).
<a name="4305"/> 4305: 
<a name="check_check-1"/><a name="4306"/> 4306: <b>check_check</b>(S={T,List,Key}) -&gt;
<a name="4307"/> 4307:     case lists:reverse(ets:lookup(T,Key)) of
<a name="4308"/> 4308: 	List -&gt; ok;
<a name="4309"/> 4309:         ETS -&gt; io:format(&quot;check failed:\nETS: ~p\nCHK: ~p\n&quot;, [ETS,List]),
<a name="4310"/> 4310: 	       ct:fail(&quot;Invalid return value from ets:lookup&quot;)
<a name="4311"/> 4311:     end,
<a name="4312"/> 4312:     Items = ets:info(T,size),
<a name="4313"/> 4313:     Items = length(List),
<a name="check_check-last_expr"/><a name="4314"/> 4314:     S.
<a name="4315"/> 4315: 
<a name="fill_tab-2"/><a name="4316"/> 4316: <b>fill_tab</b>(Tab,Val) -&gt;
<a name="4317"/> 4317:     ets:insert(Tab,{key,Val}),
<a name="4318"/> 4318:     ets:insert(Tab,{{a,144},Val}),
<a name="4319"/> 4319:     ets:insert(Tab,{{a,key2},Val}),
<a name="4320"/> 4320:     ets:insert(Tab,{14,Val}),
<a name="fill_tab-last_expr"/><a name="4321"/> 4321:     ok.
<a name="4322"/> 4322: 
<a name="4323"/> 4323: 
<a name="4324"/> 4324: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="4325"/> 4325: 
<a name="lookup_element_default-1"/><a name="4326"/> 4326: <b>lookup_element_default</b>(Config) when is_list(Config) -&gt;
<a name="4327"/> 4327:     EtsMem = etsmem(),
<a name="4328"/> 4328: 
<a name="4329"/> 4329:     TabSet = ets_new(foo, [set]),
<a name="4330"/> 4330:     ets:insert(TabSet, {key, 42}),
<a name="4331"/> 4331:     42 = ets:lookup_element(TabSet, key, 2, 13),
<a name="4332"/> 4332:     13 = ets:lookup_element(TabSet, not_key, 2, 13),
<a name="4333"/> 4333:     {'EXIT',{badarg,_}} = catch ets:lookup_element(TabSet, key, 3, 13),
<a name="4334"/> 4334:     true = ets:delete(TabSet),
<a name="4335"/> 4335: 
<a name="4336"/> 4336:     TabOrderedSet = ets_new(foo, [ordered_set]),
<a name="4337"/> 4337:     ets:insert(TabOrderedSet, {key, 42}),
<a name="4338"/> 4338:     42 = ets:lookup_element(TabOrderedSet, key, 2, 13),
<a name="4339"/> 4339:     13 = ets:lookup_element(TabOrderedSet, not_key, 2, 13),
<a name="4340"/> 4340:     {'EXIT',{badarg,_}} = catch ets:lookup_element(TabOrderedSet, key, 3, 13),
<a name="4341"/> 4341:     true = ets:delete(TabOrderedSet),
<a name="4342"/> 4342: 
<a name="4343"/> 4343:     TabBag = ets_new(foo, [bag]),
<a name="4344"/> 4344:     ets:insert(TabBag, {key, 42}),
<a name="4345"/> 4345:     ets:insert(TabBag, {key, 43, 44}),
<a name="4346"/> 4346:     [42, 43] = ets:lookup_element(TabBag, key, 2, 13),
<a name="4347"/> 4347:     13 = ets:lookup_element(TabBag, not_key, 2, 13),
<a name="4348"/> 4348:     {'EXIT',{badarg,_}} = catch ets:lookup_element(TabBag, key, 3, 13),
<a name="4349"/> 4349:     true = ets:delete(TabBag),
<a name="4350"/> 4350: 
<a name="4351"/> 4351:     TabDuplicateBag = ets_new(foo, [duplicate_bag]),
<a name="4352"/> 4352:     ets:insert(TabDuplicateBag, {key, 42}),
<a name="4353"/> 4353:     ets:insert(TabDuplicateBag, {key, 42}),
<a name="4354"/> 4354:     ets:insert(TabDuplicateBag, {key, 43, 44}),
<a name="4355"/> 4355:     [42, 42, 43] = ets:lookup_element(TabDuplicateBag, key, 2, 13),
<a name="4356"/> 4356:     13 = ets:lookup_element(TabDuplicateBag, not_key, 2, 13),
<a name="4357"/> 4357:     {'EXIT',{badarg,_}} = catch ets:lookup_element(TabDuplicateBag, key, 3, 13),
<a name="4358"/> 4358:     true = ets:delete(TabDuplicateBag),
<a name="4359"/> 4359: 
<a name="lookup_element_default-last_expr"/><a name="4360"/> 4360: <b>    verify_etsmem</b>(EtsMem).
<a name="4361"/> 4361: 
<a name="4362"/> 4362: <i>%% OTP-2386. Multiple return elements.</i>
<a name="lookup_element_mult-1"/><a name="4363"/> 4363: <b>lookup_element_mult</b>(Config) when is_list(Config) -&gt;
<a name="lookup_element_mult-last_expr"/><a name="4364"/> 4364: <b>    repeat_for_opts</b>(fun lookup_element_mult_do/1).
<a name="4365"/> 4365: 
<a name="lookup_element_mult_do-1"/><a name="4366"/> 4366: <b>lookup_element_mult_do</b>(Opts) -&gt;
<a name="4367"/> 4367:     EtsMem = etsmem(),
<a name="4368"/> 4368:     T = ets_new(service, [bag, {keypos, 2} | Opts]),
<a name="4369"/> 4369:     D = lists:reverse(lem_data()),
<a name="4370"/> 4370:     lists:foreach(fun(X) -&gt; ets:insert(T, X) end, D),
<a name="4371"/> 4371:     ok = lem_crash_3(T),
<a name="4372"/> 4372:     ets:insert(T, {0, &quot;heap_key&quot;}),
<a name="4373"/> 4373:     ets:lookup_element(T, &quot;heap_key&quot;, 2),
<a name="4374"/> 4374:     true = ets:delete(T),
<a name="lookup_element_mult_do-last_expr"/><a name="4375"/> 4375: <b>    verify_etsmem</b>(EtsMem).
<a name="4376"/> 4376: 
<a name="lem_data-0"/><a name="4377"/> 4377: <b>lem_data</b>() -&gt;
<a name="lem_data-last_expr"/><a name="4378"/> 4378: <b>    [{service,'eddie2@boromir',{150,236,14,103},httpd88,self</b>()},
<a name="4379"/> 4379:      {service,'eddie2@boromir',{150,236,14,103},httpd80,self()},
<a name="4380"/> 4380:      {service,'eddie3@boromir',{150,236,14,107},httpd88,self()},
<a name="4381"/> 4381:      {service,'eddie3@boromir',{150,236,14,107},httpd80,self()},
<a name="4382"/> 4382:      {service,'eddie4@boromir',{150,236,14,108},httpd88,self()}].
<a name="4383"/> 4383: 
<a name="lem_crash-1"/><a name="4384"/> 4384: <b>lem_crash</b>(T) -&gt;
<a name="4385"/> 4385:     L = ets:lookup_element(T, 'eddie2@boromir', 3),
<a name="lem_crash-last_expr"/><a name="4386"/> 4386: <b>    {erlang:phash2</b>(L, 256), L}.
<a name="4387"/> 4387: 
<a name="lem_crash_3-1"/><a name="4388"/> 4388: <b>lem_crash_3</b>(T) -&gt;
<a name="4389"/> 4389:     lem_crash(T),
<a name="4390"/> 4390:     io:format(&quot;Survived once~n&quot;),
<a name="4391"/> 4391:     lem_crash(T),
<a name="4392"/> 4392:     io:format(&quot;Survived twice~n&quot;),
<a name="4393"/> 4393:     lem_crash(T),
<a name="4394"/> 4394:     io:format(&quot;Survived all!~n&quot;),
<a name="lem_crash_3-last_expr"/><a name="4395"/> 4395:     ok.
<a name="4396"/> 4396: 
<a name="4397"/> 4397: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="4398"/> 4398: 
<a name="4399"/> 4399: 
<a name="4400"/> 4400: <i>%% Check delete of an element inserted in a `filled' table.</i>
<a name="delete_elem-1"/><a name="4401"/> 4401: <b>delete_elem</b>(Config) when is_list(Config) -&gt;
<a name="delete_elem-last_expr"/><a name="4402"/> 4402: <b>    repeat_for_opts</b>(fun delete_elem_do/1,
<a name="4403"/> 4403:                     [write_concurrency, all_types]).
<a name="4404"/> 4404: 
<a name="delete_elem_do-1"/><a name="4405"/> 4405: <b>delete_elem_do</b>(Opts) -&gt;
<a name="4406"/> 4406:     EtsMem = etsmem(),
<a name="4407"/> 4407:     Tab = ets_new(foo,Opts),
<a name="4408"/> 4408:     fill_tab(Tab,foo),
<a name="4409"/> 4409:     ets:insert(Tab,{{b,key},foo}),
<a name="4410"/> 4410:     ets:insert(Tab,{{c,key},foo}),
<a name="4411"/> 4411:     true = ets:delete(Tab,{b,key}),
<a name="4412"/> 4412:     [] = ets:lookup(Tab,{b,key}),
<a name="4413"/> 4413:     [{{c,key},foo}] = ets:lookup(Tab,{c,key}),
<a name="4414"/> 4414:     true = ets:delete(Tab),
<a name="delete_elem_do-last_expr"/><a name="4415"/> 4415: <b>    verify_etsmem</b>(EtsMem).
<a name="4416"/> 4416: 
<a name="4417"/> 4417: <i>%% Check that ets:delete() works and releases the name of the</i>
<a name="4418"/> 4418: <i>%% deleted table.</i>
<a name="delete_tab-1"/><a name="4419"/> 4419: <b>delete_tab</b>(Config) when is_list(Config) -&gt;
<a name="delete_tab-last_expr"/><a name="4420"/> 4420: <b>    repeat_for_opts</b>(fun delete_tab_do/1,
<a name="4421"/> 4421:                     [write_concurrency,all_types]).
<a name="4422"/> 4422: 
<a name="delete_tab_do-1"/><a name="4423"/> 4423: <b>delete_tab_do</b>(Opts) -&gt;
<a name="4424"/> 4424:     Name = foo,
<a name="4425"/> 4425:     EtsMem = etsmem(),
<a name="4426"/> 4426:     Name = ets_new(Name, [named_table | Opts]),
<a name="4427"/> 4427:     true = ets:delete(foo),
<a name="4428"/> 4428:     %% The name should be available again.
<a name="4429"/> 4429:     Name = ets_new(Name, [named_table | Opts]),
<a name="4430"/> 4430:     true = ets:delete(Name),
<a name="delete_tab_do-last_expr"/><a name="4431"/> 4431: <b>    verify_etsmem</b>(EtsMem).
<a name="4432"/> 4432: 
<a name="4433"/> 4433: <i>%% Check that ets:delete/1 works and that other processes can run.</i>
<a name="delete_large_tab-1"/><a name="4434"/> 4434: <b>delete_large_tab</b>(Config) when is_list(Config) -&gt;
<a name="4435"/> 4435:     ct:timetrap({minutes,60}), %% valgrind needs a lot
<a name="4436"/> 4436:     KeyRange = 16#ffffff,
<a name="4437"/> 4437:     Data = [{erlang:phash2(I, KeyRange),I} || I &lt;- lists:seq(1, 200000)],
<a name="4438"/> 4438:     EtsMem = etsmem(),
<a name="4439"/> 4439:     repeat_for_opts(fun(Opts) -&gt; delete_large_tab_do(Config,
<a name="4440"/> 4440:                                                      key_range(Opts,KeyRange),
<a name="4441"/> 4441:                                                      Data)
<a name="4442"/> 4442:                     end),
<a name="delete_large_tab-last_expr"/><a name="4443"/> 4443: <b>    verify_etsmem</b>(EtsMem).
<a name="4444"/> 4444: 
<a name="delete_large_tab_do-3"/><a name="4445"/> 4445: <b>delete_large_tab_do</b>(Config, Opts,Data) -&gt;
<a name="4446"/> 4446:     delete_large_tab_1(Config, foo_hash, Opts, Data, false),
<a name="4447"/> 4447:     run_if_valid_opts(
<a name="4448"/> 4448:       [ordered_set | Opts],
<a name="4449"/> 4449:       fun(OptsOrdSet) -&gt;
<a name="4450"/> 4450:               delete_large_tab_1(Config, foo_tree, OptsOrdSet, Data, false)
<a name="4451"/> 4451:       end),
<a name="4452"/> 4452:     run_if_valid_opts(
<a name="4453"/> 4453:       [stim_cat_ord_set | Opts],
<a name="4454"/> 4454:       fun(OptsCat) -&gt;
<a name="4455"/> 4455:               delete_large_tab_1(Config, foo_tree, OptsCat, Data, false)
<a name="4456"/> 4456:       end),
<a name="delete_large_tab_do-last_expr"/><a name="4457"/> 4457: <b>    delete_large_tab_1</b>(Config, foo_hash_fix, Opts, Data, true).
<a name="4458"/> 4458: 
<a name="4459"/> 4459: 
<a name="delete_large_tab_1-5"/><a name="4460"/> 4460: <b>delete_large_tab_1</b>(Config, Name, Flags, Data, Fix) -&gt;
<a name="delete_large_tab_1-last_expr"/><a name="4461"/> 4461: <b>    case is_redundant_opts_combo</b>(Flags) of
<a name="4462"/> 4462:         true -&gt; skip;
<a name="4463"/> 4463:         false -&gt;
<a name="4464"/> 4464:             delete_large_tab_2(Config, Name, Flags, Data, Fix)
<a name="4465"/> 4465:     end.
<a name="4466"/> 4466: 
<a name="delete_large_tab_2-5"/><a name="4467"/> 4467: <b>delete_large_tab_2</b>(Config, Name, Flags, Data, Fix) -&gt;
<a name="4468"/> 4468:     Tab = ets_new(Name, Flags),
<a name="4469"/> 4469:     ets:insert(Tab, Data),
<a name="4470"/> 4470: 
<a name="4471"/> 4471:     case Fix of
<a name="4472"/> 4472: 	false -&gt; ok;
<a name="4473"/> 4473: 	true -&gt;
<a name="4474"/> 4474: 	    true = ets:safe_fixtable(Tab, true),
<a name="4475"/> 4475: 	    lists:foreach(fun({K,_}) -&gt; ets:delete(Tab, K) end, Data)
<a name="4476"/> 4476:     end,
<a name="4477"/> 4477: 
<a name="4478"/> 4478:     {priority, Prio} = process_info(self(), priority),
<a name="4479"/> 4479:     Deleter = self(),
<a name="4480"/> 4480:     ForceTrap = proplists:get_bool(ets_force_trap, Config),
<a name="4481"/> 4481:     [SchedTracer]
<a name="4482"/> 4482: 	= start_loopers(1,
<a name="4483"/> 4483: 			Prio,
<a name="4484"/> 4484: 			fun (SC) -&gt;
<a name="4485"/> 4485: 				receive
<a name="4486"/> 4486: 				    {trace, Deleter, out, _} -&gt;
<a name="4487"/> 4487:                                         case {ets:info(Tab), SC, ForceTrap} of
<a name="4488"/> 4488:                                             {undefined, _, _} -&gt; ok;
<a name="4489"/> 4489:                                             {_, 0, true} -&gt;
<a name="4490"/> 4490:                                                 %% Forced first trap of ets:delete,
<a name="4491"/> 4491:                                                 %% tab still reachable
<a name="4492"/> 4492:                                                 ok
<a name="4493"/> 4493:                                         end,
<a name="4494"/> 4494:                                         SC+1;
<a name="4495"/> 4495: 				    {trace,
<a name="4496"/> 4496: 				     Deleter,
<a name="4497"/> 4497: 				     register,
<a name="4498"/> 4498: 				     delete_large_tab_done_marker}-&gt;
<a name="4499"/> 4499: 					Deleter ! {schedule_count, SC},
<a name="4500"/> 4500: 					exit(normal);
<a name="4501"/> 4501: 				    _ -&gt;
<a name="4502"/> 4502: 					SC
<a name="4503"/> 4503: 				end
<a name="4504"/> 4504: 			end,
<a name="4505"/> 4505: 			0),
<a name="4506"/> 4506:     SchedTracerMon = monitor(process, SchedTracer),
<a name="4507"/> 4507:     Loopers = start_loopers(erlang:system_info(schedulers),
<a name="4508"/> 4508: 			    Prio,
<a name="4509"/> 4509: 			    fun (_) -&gt; erlang:yield() end,
<a name="4510"/> 4510: 			    ok),
<a name="4511"/> 4511:     erlang:yield(),
<a name="4512"/> 4512:     1 = erlang:trace(self(),true,[running,procs,{tracer,SchedTracer}]),
<a name="4513"/> 4513:     true = ets:delete(Tab),
<a name="4514"/> 4514:     %% The register stuff is just a trace marker
<a name="4515"/> 4515:     true = register(delete_large_tab_done_marker, self()),
<a name="4516"/> 4516:     true = unregister(delete_large_tab_done_marker),
<a name="4517"/> 4517:     undefined = ets:info(Tab),
<a name="4518"/> 4518:     ok = stop_loopers(Loopers),
<a name="4519"/> 4519:     receive
<a name="4520"/> 4520: 	{schedule_count, N} -&gt;
<a name="4521"/> 4521: 	    io:format(&quot;~s: context switches: ~p&quot;, [Name,N]),
<a name="4522"/> 4522: 	    if
<a name="4523"/> 4523: 		N &gt;= 5 -&gt; ok;
<a name="4524"/> 4524: 		true -&gt; ct:fail(failed)
<a name="4525"/> 4525: 	    end
<a name="4526"/> 4526:     end,
<a name="4527"/> 4527:     receive {'DOWN',SchedTracerMon,process,SchedTracer,_} -&gt; ok end,
<a name="delete_large_tab_2-last_expr"/><a name="4528"/> 4528:     ok.
<a name="4529"/> 4529: 
<a name="4530"/> 4530: <i>%% Delete a large name table and try to create a new table with</i>
<a name="4531"/> 4531: <i>%% the same name in another process.</i>
<a name="delete_large_named_table-1"/><a name="4532"/> 4532: <b>delete_large_named_table</b>(Config) when is_list(Config) -&gt;
<a name="4533"/> 4533:     KeyRange = 16#ffffff,
<a name="4534"/> 4534:     Data = [{erlang:phash2(I, KeyRange),I} || I &lt;- lists:seq(1, 200000)],
<a name="4535"/> 4535:     EtsMem = etsmem(),
<a name="4536"/> 4536:     repeat_for_opts(fun(Opts) -&gt;
<a name="4537"/> 4537:                             delete_large_named_table_do(key_range(Opts,KeyRange),
<a name="4538"/> 4538:                                                         Data)
<a name="4539"/> 4539:                     end),
<a name="4540"/> 4540:     verify_etsmem(EtsMem),
<a name="delete_large_named_table-last_expr"/><a name="4541"/> 4541:     ok.
<a name="4542"/> 4542: 
<a name="delete_large_named_table_do-2"/><a name="4543"/> 4543: <b>delete_large_named_table_do</b>(Opts,Data) -&gt;
<a name="4544"/> 4544:     delete_large_named_table_1(foo_hash, [named_table | Opts], Data, false),
<a name="4545"/> 4545:     run_if_valid_opts(
<a name="4546"/> 4546:       [ordered_set,named_table | Opts],
<a name="4547"/> 4547:       fun(OptsOrdSet) -&gt;
<a name="4548"/> 4548:               delete_large_named_table_1(foo_tree, OptsOrdSet, Data, false)
<a name="4549"/> 4549:       end),
<a name="4550"/> 4550:     run_if_valid_opts(
<a name="4551"/> 4551:       [stim_cat_ord_set,named_table | Opts],
<a name="4552"/> 4552:       fun(OptsStimCat) -&gt;
<a name="4553"/> 4553:               delete_large_named_table_1(foo_tree, OptsStimCat, Data, false)
<a name="4554"/> 4554:       end),
<a name="delete_large_named_table_do-last_expr"/><a name="4555"/> 4555: <b>    delete_large_named_table_1</b>(foo_hash, [named_table | Opts], Data, true).
<a name="4556"/> 4556: 
<a name="delete_large_named_table_1-4"/><a name="4557"/> 4557: <b>delete_large_named_table_1</b>(Name, Flags, Data, Fix) -&gt;
<a name="delete_large_named_table_1-last_expr"/><a name="4558"/> 4558: <b>    case is_redundant_opts_combo</b>(Flags) of
<a name="4559"/> 4559:         true -&gt; skip;
<a name="4560"/> 4560:         false -&gt;
<a name="4561"/> 4561:             delete_large_named_table_2(Name, Flags, Data, Fix)
<a name="4562"/> 4562:     end.
<a name="4563"/> 4563: 
<a name="delete_large_named_table_2-4"/><a name="4564"/> 4564: <b>delete_large_named_table_2</b>(Name, Flags, Data, Fix) -&gt;
<a name="4565"/> 4565:     Tab = ets_new(Name, Flags),
<a name="4566"/> 4566:     ets:insert(Tab, Data),
<a name="4567"/> 4567: 
<a name="4568"/> 4568:     case Fix of
<a name="4569"/> 4569: 	false -&gt; ok;
<a name="4570"/> 4570: 	true -&gt;
<a name="4571"/> 4571: 	    true = ets:safe_fixtable(Tab, true),
<a name="4572"/> 4572: 	    lists:foreach(fun({K,_}) -&gt; ets:delete(Tab, K) end, Data)
<a name="4573"/> 4573:     end,
<a name="4574"/> 4574:     {Pid, MRef} = my_spawn_opt(fun() -&gt;
<a name="4575"/> 4575: 				       receive
<a name="4576"/> 4576: 					   ets_new -&gt;
<a name="4577"/> 4577: 					       ets_new(Name, [named_table])
<a name="4578"/> 4578: 				       end
<a name="4579"/> 4579: 			       end,
<a name="4580"/> 4580: 			       [link, monitor]),
<a name="4581"/> 4581:     true = ets:delete(Tab),
<a name="4582"/> 4582:     Pid ! ets_new,
<a name="4583"/> 4583:     receive {'DOWN',MRef,process,Pid,_} -&gt; ok end,
<a name="delete_large_named_table_2-last_expr"/><a name="4584"/> 4584:     ok.
<a name="4585"/> 4585: 
<a name="4586"/> 4586: <i>%% Delete a large table, and kill the process during the delete.</i>
<a name="evil_delete-1"/><a name="4587"/> 4587: <b>evil_delete</b>(Config) when is_list(Config) -&gt;
<a name="4588"/> 4588:     KeyRange = 100000,
<a name="4589"/> 4589:     Data = [{I,I*I} || I &lt;- lists:seq(1, KeyRange)],
<a name="evil_delete-last_expr"/><a name="4590"/> 4590: <b>    repeat_for_opts</b>(fun(Opts) -&gt;
<a name="4591"/> 4591:                             evil_delete_do(key_range(Opts,KeyRange),
<a name="4592"/> 4592:                                            Data)
<a name="4593"/> 4593:                     end).
<a name="4594"/> 4594: 
<a name="evil_delete_do-2"/><a name="4595"/> 4595: <b>evil_delete_do</b>(Opts,Data) -&gt;
<a name="4596"/> 4596:     EtsMem = etsmem(),
<a name="4597"/> 4597:     evil_delete_owner(foo_hash, Opts, Data, false),
<a name="4598"/> 4598:     verify_etsmem(EtsMem),
<a name="4599"/> 4599:     evil_delete_owner(foo_hash, Opts, Data, true),
<a name="4600"/> 4600:     verify_etsmem(EtsMem),
<a name="4601"/> 4601:     evil_delete_owner(foo_tree, [ordered_set | Opts], Data, false),
<a name="4602"/> 4602:     verify_etsmem(EtsMem),
<a name="4603"/> 4603:     evil_delete_owner(foo_catree, [stim_cat_ord_set | Opts], Data, false),
<a name="4604"/> 4604:     verify_etsmem(EtsMem),
<a name="4605"/> 4605:     TabA = evil_delete_not_owner(foo_hash, Opts, Data, false),
<a name="4606"/> 4606:     verify_etsmem(EtsMem),
<a name="4607"/> 4607:     TabB = evil_delete_not_owner(foo_hash, Opts, Data, true),
<a name="4608"/> 4608:     verify_etsmem(EtsMem),
<a name="4609"/> 4609:     TabC = evil_delete_not_owner(foo_tree, [ordered_set | Opts], Data, false),
<a name="4610"/> 4610:     verify_etsmem(EtsMem),
<a name="4611"/> 4611:     TabD = evil_delete_not_owner(foo_catree, [stim_cat_ord_set | Opts], Data, false),
<a name="4612"/> 4612:     verify_etsmem(EtsMem),
<a name="evil_delete_do-last_expr"/><a name="4613"/> 4613: <b>    lists:foreach</b>(fun(T) -&gt; undefined = ets:info(T) end,
<a name="4614"/> 4614: 		  [TabA,TabB,TabC,TabD]).
<a name="4615"/> 4615: 
<a name="evil_delete_not_owner-4"/><a name="4616"/> 4616: <b>evil_delete_not_owner</b>(Name, Flags, Data, Fix) -&gt;
<a name="evil_delete_not_owner-last_expr"/><a name="4617"/> 4617: <b>    case is_redundant_opts_combo</b>(Flags) of
<a name="4618"/> 4618:         true -&gt; skip;
<a name="4619"/> 4619:         false -&gt;
<a name="4620"/> 4620:             evil_delete_not_owner_1(Name, Flags, Data, Fix)
<a name="4621"/> 4621:     end.
<a name="4622"/> 4622: 
<a name="evil_delete_not_owner_1-4"/><a name="4623"/> 4623: <b>evil_delete_not_owner_1</b>(Name, Flags, Data, Fix) -&gt;
<a name="4624"/> 4624:     io:format(&quot;Not owner: ~p, fix = ~p&quot;, [Name,Fix]),
<a name="4625"/> 4625:     Tab = ets_new(Name, [public|Flags]),
<a name="4626"/> 4626:     ets:insert(Tab, Data),
<a name="4627"/> 4627:     case Fix of
<a name="4628"/> 4628: 	false -&gt; ok;
<a name="4629"/> 4629: 	true -&gt;
<a name="4630"/> 4630: 	    true = ets:safe_fixtable(Tab, true),
<a name="4631"/> 4631: 	    lists:foreach(fun({K,_}) -&gt; ets:delete(Tab, K) end, Data)
<a name="4632"/> 4632:     end,
<a name="4633"/> 4633:     Pid = my_spawn(fun() -&gt;
<a name="4634"/> 4634: 			   P = my_spawn_link(
<a name="4635"/> 4635: 				 fun() -&gt;
<a name="4636"/> 4636: 					 receive kill -&gt; ok end,
<a name="4637"/> 4637: 					 erlang:yield(),
<a name="4638"/> 4638: 					 exit(kill_linked_processes_now)
<a name="4639"/> 4639: 				 end),
<a name="4640"/> 4640: 			   erlang:yield(),
<a name="4641"/> 4641: 			   P ! kill,
<a name="4642"/> 4642: 			   true = ets:delete(Tab)
<a name="4643"/> 4643: 		   end),
<a name="4644"/> 4644:     Ref = erlang:monitor(process, Pid),
<a name="4645"/> 4645:     receive {'DOWN',Ref,_,_,_} -&gt; ok end,
<a name="evil_delete_not_owner_1-last_expr"/><a name="4646"/> 4646:     Tab.
<a name="4647"/> 4647: 
<a name="evil_delete_owner-4"/><a name="4648"/> 4648: <b>evil_delete_owner</b>(Name, Flags, Data, Fix) -&gt;
<a name="evil_delete_owner-last_expr"/><a name="4649"/> 4649: <b>    case is_redundant_opts_combo</b>(Flags) of
<a name="4650"/> 4650:         true -&gt; skip;
<a name="4651"/> 4651:         false -&gt;
<a name="4652"/> 4652:             evil_delete_owner_1(Name, Flags, Data, Fix)
<a name="4653"/> 4653:     end.
<a name="4654"/> 4654: 
<a name="evil_delete_owner_1-4"/><a name="4655"/> 4655: <b>evil_delete_owner_1</b>(Name, Flags, Data, Fix) -&gt;
<a name="4656"/> 4656:     Fun = fun() -&gt;
<a name="4657"/> 4657: 		  Tab = ets_new(Name, [public|Flags]),
<a name="4658"/> 4658: 		  ets:insert(Tab, Data),
<a name="4659"/> 4659: 		  case Fix of
<a name="4660"/> 4660: 		      false -&gt; ok;
<a name="4661"/> 4661: 		      true -&gt;
<a name="4662"/> 4662: 			  true = ets:safe_fixtable(Tab, true),
<a name="4663"/> 4663: 			  lists:foreach(fun({K,_}) -&gt;
<a name="4664"/> 4664: 						ets:delete(Tab, K)
<a name="4665"/> 4665: 					end, Data)
<a name="4666"/> 4666: 		  end,
<a name="4667"/> 4667: 		  erlang:yield(),
<a name="4668"/> 4668: 		  my_spawn_link(fun() -&gt;
<a name="4669"/> 4669: 					erlang:yield(),
<a name="4670"/> 4670: 					exit(kill_linked_processes_now)
<a name="4671"/> 4671: 				end),
<a name="4672"/> 4672: 		  true = ets:delete(Tab)
<a name="4673"/> 4673: 	  end,
<a name="4674"/> 4674:     Pid = my_spawn(Fun),
<a name="4675"/> 4675:     Ref = erlang:monitor(process, Pid),
<a name="evil_delete_owner_1-last_expr"/><a name="4676"/> 4676:     receive {'DOWN',Ref,_,_,_} -&gt; ok end.
<a name="4677"/> 4677: 
<a name="4678"/> 4678: 
<a name="exit_large_table_owner-1"/><a name="4679"/> 4679: <b>exit_large_table_owner</b>(Config) when is_list(Config) -&gt;
<a name="4680"/> 4680:     %%Data = [{erlang:phash2(I, 16#ffffff),I} || I &lt;- lists:seq(1, 500000)],
<a name="4681"/> 4681:     Laps = 500000 div syrup_factor(),
<a name="4682"/> 4682:     FEData = fun(Do) -&gt; repeat_while(fun(I) when I =:= Laps -&gt; {false,ok};
<a name="4683"/> 4683: 					(I) -&gt; Do({erlang:phash2(I, 16#ffffff),I}),
<a name="4684"/> 4684: 					       {true, I+1}
<a name="4685"/> 4685: 				     end, 1)
<a name="4686"/> 4686: 	     end,
<a name="4687"/> 4687:     EtsMem = etsmem(),
<a name="4688"/> 4688:     repeat_for_opts(fun(Opts) -&gt;
<a name="4689"/> 4689:                             exit_large_table_owner_do(Opts,
<a name="4690"/> 4690:                                                       FEData,
<a name="4691"/> 4691:                                                       Config)
<a name="4692"/> 4692:                     end),
<a name="exit_large_table_owner-last_expr"/><a name="4693"/> 4693: <b>    verify_etsmem</b>(EtsMem).
<a name="4694"/> 4694: 
<a name="exit_large_table_owner_do-3"/><a name="4695"/> 4695: <b>exit_large_table_owner_do</b>(Opts, FEData, Config) -&gt;
<a name="4696"/> 4696:     verify_rescheduling_exit(Config, FEData, [named_table | Opts], true, 1, 1),
<a name="exit_large_table_owner_do-last_expr"/><a name="4697"/> 4697: <b>    verify_rescheduling_exit</b>(Config, FEData, Opts, false, 1, 1).
<a name="4698"/> 4698: 
<a name="exit_many_large_table_owner-1"/><a name="4699"/> 4699: <b>exit_many_large_table_owner</b>(Config) when is_list(Config) -&gt;
<a name="4700"/> 4700:     ct:timetrap({minutes,30}), %% valgrind needs a lot
<a name="4701"/> 4701:     %%Data = [{erlang:phash2(I, 16#ffffff),I} || I &lt;- lists:seq(1, 500000)],
<a name="4702"/> 4702:     Laps = 500000 div syrup_factor(),
<a name="4703"/> 4703:     FEData = fun(Do) -&gt; repeat_while(fun(I) when I =:= Laps -&gt; {false,ok};
<a name="4704"/> 4704: 					(I) -&gt; Do({erlang:phash2(I, 16#ffffff),I}),
<a name="4705"/> 4705: 					       {true, I+1}
<a name="4706"/> 4706: 				     end, 1)
<a name="4707"/> 4707: 	     end,
<a name="4708"/> 4708:     EtsMem = etsmem(),
<a name="4709"/> 4709:     repeat_for_opts(fun(Opts) -&gt; exit_many_large_table_owner_do(Opts,FEData,Config) end),
<a name="exit_many_large_table_owner-last_expr"/><a name="4710"/> 4710: <b>    verify_etsmem</b>(EtsMem).
<a name="4711"/> 4711: 
<a name="exit_many_large_table_owner_do-3"/><a name="4712"/> 4712: <b>exit_many_large_table_owner_do</b>(Opts,FEData,Config) -&gt;
<a name="4713"/> 4713:     verify_rescheduling_exit(Config, FEData, Opts, true, 1, 4),
<a name="exit_many_large_table_owner_do-last_expr"/><a name="4714"/> 4714: <b>    verify_rescheduling_exit</b>(Config, FEData, [named_table | Opts], false, 1, 4).
<a name="4715"/> 4715: 
<a name="exit_many_tables_owner-1"/><a name="4716"/> 4716: <b>exit_many_tables_owner</b>(Config) when is_list(Config) -&gt;
<a name="4717"/> 4717:     NoData = fun(_Do) -&gt; ok end,
<a name="4718"/> 4718:     EtsMem = etsmem(),
<a name="4719"/> 4719:     verify_rescheduling_exit(Config, NoData, [named_table], false, 1000, 1),
<a name="4720"/> 4720:     verify_rescheduling_exit(Config, NoData, [named_table,{write_concurrency,true}], false, 1000, 1),
<a name="exit_many_tables_owner-last_expr"/><a name="4721"/> 4721: <b>    verify_etsmem</b>(EtsMem).
<a name="4722"/> 4722: 
<a name="exit_many_many_tables_owner-1"/><a name="4723"/> 4723: <b>exit_many_many_tables_owner</b>(Config) when is_list(Config) -&gt;
<a name="4724"/> 4724:     Data = [{erlang:phash2(I, 16#ffffff),I} || I &lt;- lists:seq(1, 50)],
<a name="4725"/> 4725:     FEData = fun(Do) -&gt; lists:foreach(Do, Data) end,
<a name="exit_many_many_tables_owner-last_expr"/><a name="4726"/> 4726: <b>    repeat_for_opts</b>(fun(Opts) -&gt; exit_many_many_tables_owner_do1(Opts,FEData,Config) end).
<a name="4727"/> 4727: 
<a name="exit_many_many_tables_owner_do1-3"/><a name="4728"/> 4728: <b>exit_many_many_tables_owner_do1</b>(Opts,FEData,Config) -&gt;
<a name="exit_many_many_tables_owner_do1-last_expr"/><a name="4729"/> 4729: <b>    case has_fixed_number_of_locks</b>(Opts) of
<a name="4730"/> 4730:         true -&gt;
<a name="4731"/> 4731:             %% Few memory hogging tables =&gt; not enough yielding for the test
<a name="4732"/> 4732:             io:format(&quot;Skip option combo ~p\n&quot;, [Opts]);
<a name="4733"/> 4733:         false -&gt;
<a name="4734"/> 4734:             exit_many_many_tables_owner_do2(Opts,FEData,Config)
<a name="4735"/> 4735:     end.
<a name="4736"/> 4736: 
<a name="exit_many_many_tables_owner_do2-3"/><a name="4737"/> 4737: <b>exit_many_many_tables_owner_do2</b>(Opts,FEData,Config) -&gt;
<a name="4738"/> 4738:     E = ets_new(tmp,Opts),
<a name="4739"/> 4739:     FEData(fun(Data) -&gt; ets:insert(E, Data) end),
<a name="4740"/> 4740:     Mem = ets:info(E,memory) * erlang:system_info(wordsize),
<a name="4741"/> 4741:     ets:delete(E),
<a name="4742"/> 4742: 
<a name="4743"/> 4743:     ct:log(&quot;Memory per table: ~p bytes&quot;,[Mem]),
<a name="4744"/> 4744: 
<a name="4745"/> 4745:     Tables =
<a name="4746"/> 4746:         case erlang:system_info(wordsize) of
<a name="4747"/> 4747:             8 -&gt;
<a name="4748"/> 4748:                 200;
<a name="4749"/> 4749:             4 -&gt;
<a name="4750"/> 4750:                 lists:min([200,2_000_000_000 div (Mem * 5)])
<a name="4751"/> 4751:         end,
<a name="4752"/> 4752: 
<a name="4753"/> 4753:     verify_rescheduling_exit(Config, FEData, [named_table | Opts], true, Tables, 5),
<a name="4754"/> 4754:     verify_rescheduling_exit(Config, FEData, Opts, false, Tables, 5),
<a name="4755"/> 4755:     wait_for_test_procs(),
<a name="4756"/> 4756:     EtsMem = etsmem(),
<a name="4757"/> 4757:     verify_rescheduling_exit(Config, FEData, Opts, true, Tables, 5),
<a name="4758"/> 4758:     verify_rescheduling_exit(Config, FEData, [named_table | Opts], false, Tables, 5),
<a name="exit_many_many_tables_owner_do2-last_expr"/><a name="4759"/> 4759: <b>    verify_etsmem</b>(EtsMem).
<a name="4760"/> 4760: 
<a name="4761"/> 4761: 
<a name="count_exit_sched-1"/><a name="4762"/> 4762: <b>count_exit_sched</b>(TP) -&gt;
<a name="count_exit_sched-last_expr"/><a name="4763"/> 4763:     receive
<a name="4764"/> 4764: 	{trace, TP, in_exiting, 0} -&gt;
<a name="4765"/> 4765: 	    count_exit_sched_out(TP, 1);
<a name="4766"/> 4766: 	{trace, TP, out_exiting, 0} -&gt;
<a name="4767"/> 4767: 	    count_exit_sched_in(TP, 1);
<a name="4768"/> 4768: 	{trace, TP, out_exited, 0} -&gt;
<a name="4769"/> 4769: 	    0
<a name="4770"/> 4770:     end.
<a name="4771"/> 4771: 
<a name="count_exit_sched_in-2"/><a name="4772"/> 4772: <b>count_exit_sched_in</b>(TP, N) -&gt;
<a name="count_exit_sched_in-last_expr"/><a name="4773"/> 4773:     receive
<a name="4774"/> 4774: 	{trace, TP, in_exiting, 0} -&gt;
<a name="4775"/> 4775: 	    count_exit_sched_out(TP, N);
<a name="4776"/> 4776: 	{trace, TP, _, _} = Msg -&gt;
<a name="4777"/> 4777: 	    exit({unexpected_trace_msg, Msg})
<a name="4778"/> 4778:     end.
<a name="4779"/> 4779: 
<a name="count_exit_sched_out-2"/><a name="4780"/> 4780: <b>count_exit_sched_out</b>(TP, N) -&gt;
<a name="count_exit_sched_out-last_expr"/><a name="4781"/> 4781:     receive
<a name="4782"/> 4782: 	{trace, TP, out_exiting, 0} -&gt;
<a name="4783"/> 4783: 	    count_exit_sched_in(TP, N+1);
<a name="4784"/> 4784: 	{trace, TP, out_exited, 0} -&gt;
<a name="4785"/> 4785: 	    N;
<a name="4786"/> 4786: 	{trace, TP, _, _} = Msg -&gt;
<a name="4787"/> 4787: 	    exit({unexpected_trace_msg, Msg})
<a name="4788"/> 4788:     end.
<a name="4789"/> 4789: 
<a name="vre_fix_tables-1"/><a name="4790"/> 4790: <b>vre_fix_tables</b>(Tab) -&gt;
<a name="4791"/> 4791:     Parent = self(),
<a name="4792"/> 4792:     Go = make_ref(),
<a name="4793"/> 4793:     my_spawn_link(fun () -&gt;
<a name="4794"/> 4794: 			  true = ets:safe_fixtable(Tab, true),
<a name="4795"/> 4795: 			  Parent ! Go,
<a name="4796"/> 4796: 			  receive infinity -&gt; ok end
<a name="4797"/> 4797: 		  end),
<a name="4798"/> 4798:     receive Go -&gt; ok end,
<a name="vre_fix_tables-last_expr"/><a name="4799"/> 4799:     ok.
<a name="4800"/> 4800: 
<a name="verify_rescheduling_exit-6"/><a name="4801"/> 4801: <b>verify_rescheduling_exit</b>(Config, ForEachData, Flags, Fix, NOTabs, NOProcs) -&gt;
<a name="4802"/> 4802:     NoFix = 5,
<a name="4803"/> 4803:     TestCase = atom_to_list(proplists:get_value(test_case, Config)),
<a name="4804"/> 4804:     Parent = self(),
<a name="4805"/> 4805:     KillMe = make_ref(),
<a name="4806"/> 4806:     PFun =
<a name="4807"/> 4807: 	fun () -&gt;
<a name="4808"/> 4808: 		repeat(
<a name="4809"/> 4809: 		  fun () -&gt;
<a name="4810"/> 4810: 			  Uniq = erlang:unique_integer([positive]),
<a name="4811"/> 4811: 			  Name = list_to_atom(TestCase ++ &quot;-&quot; ++
<a name="4812"/> 4812: 						  integer_to_list(Uniq)),
<a name="4813"/> 4813: 			  Tab = ets_new(Name, Flags),
<a name="4814"/> 4814:                           ForEachData(fun(Data) -&gt; ets:insert(Tab, Data) end),
<a name="4815"/> 4815: 			  case Fix of
<a name="4816"/> 4816: 			      false -&gt; ok;
<a name="4817"/> 4817: 			      true -&gt;
<a name="4818"/> 4818: 				  lists:foreach(fun (_) -&gt;
<a name="4819"/> 4819: 							vre_fix_tables(Tab)
<a name="4820"/> 4820: 						end,
<a name="4821"/> 4821: 						lists:seq(1,NoFix)),
<a name="4822"/> 4822:                                   KeyPos = ets:info(Tab,keypos),
<a name="4823"/> 4823:                                   ForEachData(fun(Data) -&gt;
<a name="4824"/> 4824: 						      ets:delete(Tab, element(KeyPos,Data))
<a name="4825"/> 4825:                                               end)
<a name="4826"/> 4826: 			  end
<a name="4827"/> 4827: 		  end,
<a name="4828"/> 4828: 		  NOTabs),
<a name="4829"/> 4829: 		Parent ! {KillMe, self()},
<a name="4830"/> 4830: 		receive after infinity -&gt; ok end
<a name="4831"/> 4831: 	end,
<a name="4832"/> 4832:     TPs = lists:map(fun (_) -&gt;
<a name="4833"/> 4833: 			    TP = my_spawn_link(PFun),
<a name="4834"/> 4834: 			    1 = erlang:trace(TP, true, [exiting]),
<a name="4835"/> 4835: 			    TP
<a name="4836"/> 4836: 		    end,
<a name="4837"/> 4837: 		    lists:seq(1, NOProcs)),
<a name="4838"/> 4838:     lists:foreach(fun (TP) -&gt;
<a name="4839"/> 4839: 			  receive {KillMe, TP} -&gt; ok end
<a name="4840"/> 4840: 		  end,
<a name="4841"/> 4841: 		  TPs),
<a name="4842"/> 4842:     LPs = start_loopers(erlang:system_info(schedulers),
<a name="4843"/> 4843: 			normal,
<a name="4844"/> 4844: 			fun (_) -&gt;
<a name="4845"/> 4845: 				erlang:yield()
<a name="4846"/> 4846: 			end,
<a name="4847"/> 4847: 			ok),
<a name="4848"/> 4848:     lists:foreach(fun (TP) -&gt;
<a name="4849"/> 4849: 			  unlink(TP),
<a name="4850"/> 4850: 			  exit(TP, bang)
<a name="4851"/> 4851: 		  end,
<a name="4852"/> 4852: 		  TPs),
<a name="4853"/> 4853:     lists:foreach(fun (TP) -&gt;
<a name="4854"/> 4854: 			  XScheds = count_exit_sched(TP),
<a name="4855"/> 4855: 			  io:format(&quot;~p XScheds=~p~n&quot;,
<a name="4856"/> 4856: 				    [TP, XScheds]),
<a name="4857"/> 4857: 			  true = XScheds &gt;= 3
<a name="4858"/> 4858: 		  end,
<a name="4859"/> 4859: 		  TPs),
<a name="4860"/> 4860:     stop_loopers(LPs),
<a name="verify_rescheduling_exit-last_expr"/><a name="4861"/> 4861:     ok.
<a name="4862"/> 4862: 
<a name="4863"/> 4863: 
<a name="4864"/> 4864: 
<a name="4865"/> 4865: <i>%% Make sure that slots for ets tables are cleared properly.</i>
<a name="table_leak-1"/><a name="4866"/> 4866: <b>table_leak</b>(Config) when is_list(Config) -&gt;
<a name="table_leak-last_expr"/><a name="4867"/> 4867: <b>    repeat_for_opts_all_non_stim_table_types</b>(fun(Opts) -&gt; table_leak_1(Opts,20000) end).
<a name="4868"/> 4868: 
<a name="table_leak_1-2"/><a name="4869"/> 4869: <b>table_leak_1</b>(_,0) -&gt; ok;
<a name="4870"/> 4870: <b>table_leak_1</b>(Opts,N) -&gt;
<a name="4871"/> 4871:     T = ets_new(fooflarf, Opts),
<a name="4872"/> 4872:     true = ets:delete(T),
<a name="table_leak_1-last_expr"/><a name="4873"/> 4873: <b>    table_leak_1</b>(Opts,N-1).
<a name="4874"/> 4874: 
<a name="4875"/> 4875: <i>%% Check proper return values for illegal delete operations.</i>
<a name="baddelete-1"/><a name="4876"/> 4876: <b>baddelete</b>(Config) when is_list(Config) -&gt;
<a name="4877"/> 4877:     EtsMem = etsmem(),
<a name="4878"/> 4878:     {'EXIT',{badarg,_}} = (catch ets:delete(foo)),
<a name="4879"/> 4879:     Tab = ets_new(foo,[]),
<a name="4880"/> 4880:     true = ets:delete(Tab),
<a name="4881"/> 4881:     {'EXIT',{badarg,_}} = (catch ets:delete(Tab)),
<a name="baddelete-last_expr"/><a name="4882"/> 4882: <b>    verify_etsmem</b>(EtsMem).
<a name="4883"/> 4883: 
<a name="4884"/> 4884: <i>%% Check that match_delete works. Also tests tab2list function.</i>
<a name="match_delete-1"/><a name="4885"/> 4885: <b>match_delete</b>(Config) when is_list(Config) -&gt;
<a name="4886"/> 4886:     EtsMem = etsmem(),
<a name="4887"/> 4887:     repeat_for_opts(fun match_delete_do/1,
<a name="4888"/> 4888:                     [write_concurrency,all_types]),
<a name="match_delete-last_expr"/><a name="4889"/> 4889: <b>    verify_etsmem</b>(EtsMem).
<a name="4890"/> 4890: 
<a name="match_delete_do-1"/><a name="4891"/> 4891: <b>match_delete_do</b>(Opts) -&gt;
<a name="4892"/> 4892:     EtsMem = etsmem(),
<a name="4893"/> 4893:     Tab = ets_new(kad,Opts),
<a name="4894"/> 4894:     fill_tab(Tab,foo),
<a name="4895"/> 4895:     ets:insert(Tab,{{c,key},bar}),
<a name="4896"/> 4896:     _ = ets:match_delete(Tab,{'_',foo}),
<a name="4897"/> 4897:     [{{c,key},bar}] = ets:tab2list(Tab),
<a name="4898"/> 4898:     _ = ets:match_delete(Tab,'_'),
<a name="4899"/> 4899:     [] = ets:tab2list(Tab),
<a name="4900"/> 4900:     true = ets:delete(Tab),
<a name="match_delete_do-last_expr"/><a name="4901"/> 4901: <b>    verify_etsmem</b>(EtsMem).
<a name="4902"/> 4902: 
<a name="4903"/> 4903: <i>%% OTP-3005: check match_delete with constant argument.</i>
<a name="match_delete3-1"/><a name="4904"/> 4904: <b>match_delete3</b>(Config) when is_list(Config) -&gt;
<a name="match_delete3-last_expr"/><a name="4905"/> 4905: <b>    repeat_for_opts</b>(fun match_delete3_do/1).
<a name="4906"/> 4906: 
<a name="match_delete3_do-1"/><a name="4907"/> 4907: <b>match_delete3_do</b>(Opts) -&gt;
<a name="4908"/> 4908:     EtsMem = etsmem(),
<a name="4909"/> 4909:     T = make_table(test,
<a name="4910"/> 4910: 		   [duplicate_bag | Opts],
<a name="4911"/> 4911: 		   [{aa,17},
<a name="4912"/> 4912: 		    {cA,1000},
<a name="4913"/> 4913: 		    {cA,17},
<a name="4914"/> 4914: 		    {cA,1000},
<a name="4915"/> 4915: 		    {aa,17}]),
<a name="4916"/> 4916:     %% 'aa' and 'cA' have the same hash value in the current
<a name="4917"/> 4917:     %% implementation. This causes the aa's to precede the cA's, to make
<a name="4918"/> 4918:     %% the test more interesting.
<a name="4919"/> 4919:     [{cA,1000},{cA,1000}] = ets:match_object(T, {'_', 1000}),
<a name="4920"/> 4920:     ets:match_delete(T, {cA,1000}),
<a name="4921"/> 4921:     [] = ets:match_object(T, {'_', 1000}),
<a name="4922"/> 4922:     ets:delete(T),
<a name="match_delete3_do-last_expr"/><a name="4923"/> 4923: <b>    verify_etsmem</b>(EtsMem).
<a name="4924"/> 4924: 
<a name="4925"/> 4925: 
<a name="4926"/> 4926: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="4927"/> 4927: 
<a name="4928"/> 4928: <i>%% Test ets:first/1 &amp; ets:next/2.</i>
<a name="4929"/> 4929: 
<a name="ets_first_using_first_lookup-1"/><a name="4930"/> 4930: <b>ets_first_using_first_lookup</b>(Tab) -&gt;
<a name="ets_first_using_first_lookup-last_expr"/><a name="4931"/> 4931: <b>    case ets:first_lookup</b>(Tab) of
<a name="4932"/> 4932:         '$end_of_table' -&gt;
<a name="4933"/> 4933:             '$end_of_table';
<a name="4934"/> 4934:         {Key, _} -&gt;
<a name="4935"/> 4935:             Key
<a name="4936"/> 4936:     end.
<a name="4937"/> 4937: 
<a name="ets_next_using_next_lookup-2"/><a name="4938"/> 4938: <b>ets_next_using_next_lookup</b>(Tab, Key) -&gt;
<a name="ets_next_using_next_lookup-last_expr"/><a name="4939"/> 4939: <b>    case ets:next_lookup</b>(Tab, Key) of
<a name="4940"/> 4940:         '$end_of_table' -&gt;
<a name="4941"/> 4941:             '$end_of_table';
<a name="4942"/> 4942:         {Key2, _} -&gt;
<a name="4943"/> 4943:             Key2
<a name="4944"/> 4944:     end.
<a name="4945"/> 4945: 
<a name="firstnext-1"/><a name="4946"/> 4946: <b>firstnext</b>(Config) when is_list(Config) -&gt;
<a name="firstnext-last_expr"/><a name="4947"/> 4947: <b>    repeat_for_opts_all_set_table_types</b>(
<a name="4948"/> 4948:         fun(Opts) -&gt; firstnext_do(Opts, fun ets:first/1, fun ets:next/2) end).
<a name="4949"/> 4949: 
<a name="firstnext_lookup-1"/><a name="4950"/> 4950: <b>firstnext_lookup</b>(Config) when is_list(Config) -&gt;
<a name="firstnext_lookup-last_expr"/><a name="4951"/> 4951: <b>    repeat_for_opts_all_set_table_types</b>(
<a name="4952"/> 4952:         fun(Opts) -&gt; firstnext_do(Opts, fun ets_first_using_first_lookup/1, fun ets_next_using_next_lookup/2) end).
<a name="4953"/> 4953: 
<a name="firstnext_do-3"/><a name="4954"/> 4954: <b>firstnext_do</b>(Opts, FirstKeyFun, NextKeyFun) -&gt;
<a name="4955"/> 4955:     EtsMem = etsmem(),
<a name="4956"/> 4956:     Tab = ets_new(foo,Opts),
<a name="4957"/> 4957:     [] = firstnext_collect(Tab,FirstKeyFun(Tab),[], NextKeyFun),
<a name="4958"/> 4958:     fill_tab(Tab,foo),
<a name="4959"/> 4959:     Len = length(ets:tab2list(Tab)),
<a name="4960"/> 4960:     Len = length(firstnext_collect(Tab,FirstKeyFun(Tab),[], NextKeyFun)),
<a name="4961"/> 4961:     true = ets:delete(Tab),
<a name="firstnext_do-last_expr"/><a name="4962"/> 4962: <b>    verify_etsmem</b>(EtsMem).
<a name="4963"/> 4963: 
<a name="firstnext_collect-4"/><a name="4964"/> 4964: <b>firstnext_collect</b>(_Tab,'$end_of_table',List, _NextKeyFun) -&gt;
<a name="4965"/> 4965:     List;
<a name="4966"/> 4966: <b>firstnext_collect</b>(Tab,Key,List, NextKeyFun) -&gt;
<a name="firstnext_collect-last_expr"/><a name="4967"/> 4967: <b>    firstnext_collect</b>(Tab,NextKeyFun(Tab,Key),[Key|List], NextKeyFun).
<a name="4968"/> 4968: 
<a name="firstnext_concurrent-1"/><a name="4969"/> 4969: <b>firstnext_concurrent</b>(Config) when is_list(Config) -&gt;
<a name="firstnext_concurrent-last_expr"/><a name="4970"/> 4970: <b>    firstnext_concurrent_do</b>(Config, fun ets:first/1, fun ets:next/2).
<a name="4971"/> 4971: 
<a name="firstnext_lookup_concurrent-1"/><a name="4972"/> 4972: <b>firstnext_lookup_concurrent</b>(Config) when is_list(Config) -&gt;
<a name="firstnext_lookup_concurrent-last_expr"/><a name="4973"/> 4973: <b>    firstnext_concurrent_do</b>(Config, fun ets_first_using_first_lookup/1, fun ets_next_using_next_lookup/2).
<a name="4974"/> 4974: 
<a name="firstnext_concurrent_do-3"/><a name="4975"/> 4975: <b>firstnext_concurrent_do</b>(Config, FirstKeyFun, NextKeyFun) when is_list(Config) -&gt;
<a name="firstnext_concurrent_do-last_expr"/><a name="4976"/> 4976: <b>    lists:foreach</b>(
<a name="4977"/> 4977:       fun(TableType) -&gt;
<a name="4978"/> 4978:               register(master, self()),
<a name="4979"/> 4979:               TableName = list_to_atom(atom_to_list(?MODULE) ++ atom_to_list(TableType)),
<a name="4980"/> 4980:               ets_init(TableName, 20, TableType),
<a name="4981"/> 4981:               [dynamic_go(TableName, FirstKeyFun, NextKeyFun) || _ &lt;- lists:seq(1, 2)],
<a name="4982"/> 4982:               receive
<a name="4983"/> 4983:               after 5000 -&gt; ok
<a name="4984"/> 4984:               end,
<a name="4985"/> 4985:               unregister(master)
<a name="4986"/> 4986:       end, repeat_for_opts_atom2list(ord_set_types)).
<a name="4987"/> 4987: 
<a name="ets_init-3"/><a name="4988"/> 4988: <b>ets_init</b>(Tab, N, TableType) -&gt;
<a name="4989"/> 4989:     ets_new(Tab, [named_table,public,TableType]),
<a name="ets_init-last_expr"/><a name="4990"/> 4990: <b>    cycle</b>(Tab, lists:seq(1,N+1)).
<a name="4991"/> 4991: 
<a name="cycle-2"/><a name="4992"/> 4992: <b>cycle</b>(_Tab, [H|T]) when H &gt; length(T)-&gt; ok;
<a name="4993"/> 4993: <b>cycle</b>(Tab, L) -&gt;
<a name="4994"/> 4994:     ets:insert(Tab,list_to_tuple(L)),
<a name="cycle-last_expr"/><a name="4995"/> 4995: <b>    cycle</b>(Tab, tl(L)++[hd(L)]).
<a name="4996"/> 4996: 
<a name="dynamic_go-3"/><a name="dynamic_go-last_expr"/><a name="4997"/> 4997: <b>dynamic_go</b>(TableName, FirstKeyFun, NextKeyFun) -&gt; my_spawn_link(fun() -&gt; dynamic_init(TableName, FirstKeyFun, NextKeyFun) end).
<a name="4998"/> 4998: 
<a name="dynamic_init-3"/><a name="dynamic_init-last_expr"/><a name="4999"/> 4999: <b>dynamic_init</b>(TableName, FirstKeyFun, NextKeyFun) -&gt; [dyn_lookup(TableName, FirstKeyFun, NextKeyFun) || _ &lt;- lists:seq(1, 10)].
<a name="5000"/> 5000: 
<a name="dyn_lookup-3"/><a name="dyn_lookup-last_expr"/><a name="5001"/> 5001: <b>dyn_lookup</b>(T, FirstKeyFun, NextKeyFun) -&gt; dyn_lookup_next(T, FirstKeyFun(T), NextKeyFun).
<a name="5002"/> 5002: 
<a name="dyn_lookup_next-3"/><a name="5003"/> 5003: <b>dyn_lookup_next</b>(_T, '$end_of_table', _NextKeyFun) -&gt; [];
<a name="5004"/> 5004: <b>dyn_lookup_next</b>(T, K, NextKeyFun) -&gt;
<a name="5005"/> 5005:     NextKey = NextKeyFun(T,K),
<a name="dyn_lookup_next-last_expr"/><a name="5006"/> 5006: <b>    case NextKeyFun</b>(T,K) of
<a name="5007"/> 5007: 	NextKey -&gt;
<a name="5008"/> 5008: 	    dyn_lookup_next(T, NextKey, NextKeyFun);
<a name="5009"/> 5009: 	NK -&gt;
<a name="5010"/> 5010: 	    io:fwrite(&quot;hmmm... ~p =/= ~p~n&quot;, [NextKey,NK]),
<a name="5011"/> 5011: 	    exit(failed)
<a name="5012"/> 5012:     end.
<a name="5013"/> 5013: 
<a name="5014"/> 5014: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="5015"/> 5015: 
<a name="slot-1"/><a name="5016"/> 5016: <b>slot</b>(Config) when is_list(Config) -&gt;
<a name="slot-last_expr"/><a name="5017"/> 5017: <b>    repeat_for_opts_all_set_table_types</b>(fun slot_do/1).
<a name="5018"/> 5018: 
<a name="slot_do-1"/><a name="5019"/> 5019: <b>slot_do</b>(Opts) -&gt;
<a name="5020"/> 5020:     EtsMem = etsmem(),
<a name="5021"/> 5021:     Tab = ets_new(foo,Opts),
<a name="5022"/> 5022:     fill_tab(Tab,foo),
<a name="5023"/> 5023:     Elts = ets:info(Tab,size),
<a name="5024"/> 5024:     Elts = slot_loop(Tab,0,0),
<a name="5025"/> 5025:     case ets:info(Tab, type) of
<a name="5026"/> 5026:         ordered_set -&gt;
<a name="5027"/> 5027:             '$end_of_table' = ets:slot(Tab,Elts);
<a name="5028"/> 5028:         _ -&gt; ok
<a name="5029"/> 5029:     end,
<a name="5030"/> 5030:     true = ets:delete(Tab),
<a name="slot_do-last_expr"/><a name="5031"/> 5031: <b>    verify_etsmem</b>(EtsMem).
<a name="5032"/> 5032: 
<a name="slot_loop-3"/><a name="5033"/> 5033: <b>slot_loop</b>(Tab,SlotNo,EltsSoFar) -&gt;
<a name="slot_loop-last_expr"/><a name="5034"/> 5034: <b>    case ets:slot</b>(Tab,SlotNo) of
<a name="5035"/> 5035: 	'$end_of_table' -&gt;
<a name="5036"/> 5036: 	    {'EXIT',{badarg,_}} =
<a name="5037"/> 5037: 		(catch ets:slot(Tab,SlotNo+1)),
<a name="5038"/> 5038: 	    EltsSoFar;
<a name="5039"/> 5039: 	Elts -&gt;
<a name="5040"/> 5040: 	    slot_loop(Tab,SlotNo+1,EltsSoFar+length(Elts))
<a name="5041"/> 5041:     end.
<a name="5042"/> 5042: 
<a name="5043"/> 5043: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="5044"/> 5044: 
<a name="hash_clash-1"/><a name="5045"/> 5045: <b>hash_clash</b>(Config) when is_list(Config) -&gt;
<a name="5046"/> 5046:     %% ensure that erlang:phash2 and ets:slot use different hash seed
<a name="5047"/> 5047:     Tab = ets:new(tab, [set]),
<a name="5048"/> 5048:     Buckets = erlang:element(1, ets:info(Tab, stats)),
<a name="5049"/> 5049:     Phash = erlang:phash2(&lt;&lt;&quot;123&quot;&gt;&gt;, Buckets),
<a name="5050"/> 5050:     true = ets:insert(Tab, {&lt;&lt;&quot;123&quot;&gt;&gt;, &quot;extra&quot;}),
<a name="hash_clash-last_expr"/><a name="5051"/> 5051: <b>    [] = ets:slot</b>(Tab, Phash).
<a name="5052"/> 5052: 
<a name="5053"/> 5053: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="5054"/> 5054: 
<a name="5055"/> 5055: 
<a name="match1-1"/><a name="5056"/> 5056: <b>match1</b>(Config) when is_list(Config) -&gt;
<a name="match1-last_expr"/><a name="5057"/> 5057: <b>    repeat_for_opts_all_set_table_types</b>(fun match1_do/1).
<a name="5058"/> 5058: 
<a name="match1_do-1"/><a name="5059"/> 5059: <b>match1_do</b>(Opts) -&gt;
<a name="5060"/> 5060:     EtsMem = etsmem(),
<a name="5061"/> 5061:     Tab = ets_new(foo,Opts),
<a name="5062"/> 5062:     fill_tab(Tab,foo),
<a name="5063"/> 5063:     [] = ets:match(Tab,{}),
<a name="5064"/> 5064:     ets:insert(Tab,{{one,4},4}),
<a name="5065"/> 5065:     ets:insert(Tab,{{one,5},5}),
<a name="5066"/> 5066:     ets:insert(Tab,{{two,4},4}),
<a name="5067"/> 5067:     ets:insert(Tab,{{two,5},6}),
<a name="5068"/> 5068:     case ets:match(Tab,{{one,'_'},'$0'}) of
<a name="5069"/> 5069: 	[[4],[5]] -&gt; ok;
<a name="5070"/> 5070: 	[[5],[4]] -&gt; ok
<a name="5071"/> 5071:     end,
<a name="5072"/> 5072:     case ets:match(Tab,{{two,'$1'},'$0'}) of
<a name="5073"/> 5073: 	[[4,4],[6,5]] -&gt; ok;
<a name="5074"/> 5074: 	[[6,5],[4,4]] -&gt; ok
<a name="5075"/> 5075:     end,
<a name="5076"/> 5076:     case ets:match(Tab,{{two,'$9'},'$4'}) of
<a name="5077"/> 5077: 	[[4,4],[6,5]] -&gt; ok;
<a name="5078"/> 5078: 	[[6,5],[4,4]] -&gt; ok
<a name="5079"/> 5079:     end,
<a name="5080"/> 5080:     case ets:match(Tab,{{two,'$9'},'$22'}) of
<a name="5081"/> 5081: 	[[4,4],[5,6]] -&gt; ok;
<a name="5082"/> 5082: 	[[5,6],[4,4]] -&gt; ok
<a name="5083"/> 5083:     end,
<a name="5084"/> 5084:     [[4]] = ets:match(Tab,{{two,'$0'},'$0'}),
<a name="5085"/> 5085:     Len = length(ets:match(Tab,'$0')),
<a name="5086"/> 5086:     Len = length(ets:match(Tab,'_')),
<a name="5087"/> 5087:     if Len &gt; 4 -&gt; ok end,
<a name="5088"/> 5088:     true = ets:delete(Tab),
<a name="match1_do-last_expr"/><a name="5089"/> 5089: <b>    verify_etsmem</b>(EtsMem).
<a name="5090"/> 5090: 
<a name="5091"/> 5091: <i>%% Test match with specified keypos bag table.</i>
<a name="match2-1"/><a name="5092"/> 5092: <b>match2</b>(Config) when is_list(Config) -&gt;
<a name="match2-last_expr"/><a name="5093"/> 5093: <b>    repeat_for_opts</b>(fun match2_do/1).
<a name="5094"/> 5094: 
<a name="match2_do-1"/><a name="5095"/> 5095: <b>match2_do</b>(Opts) -&gt;
<a name="5096"/> 5096:     EtsMem = etsmem(),
<a name="5097"/> 5097:     Tab = make_table(foobar,
<a name="5098"/> 5098: 		     [bag, named_table, {keypos, 2} | Opts],
<a name="5099"/> 5099: 		     [{value1, key1},
<a name="5100"/> 5100: 		      {value2_1, key2},
<a name="5101"/> 5101: 		      {value2_2, key2},
<a name="5102"/> 5102: 		      {value3_1, key3},
<a name="5103"/> 5103: 		      {value3_2, key3},
<a name="5104"/> 5104: 		      {value2_1, key2_wannabe}]),
<a name="5105"/> 5105:     case length(ets:match(Tab, '$1')) of
<a name="5106"/> 5106: 	6 -&gt; ok;
<a name="5107"/> 5107: 	_ -&gt; ct:fail(&quot;Length of matched list is wrong.&quot;)
<a name="5108"/> 5108:     end,
<a name="5109"/> 5109:     [[value3_1],[value3_2]] = ets:match(Tab, {'$1', key3}),
<a name="5110"/> 5110:     [[key1]] = ets:match(Tab, {value1, '$1'}),
<a name="5111"/> 5111:     [[key2_wannabe],[key2]] = ets:match(Tab, {value2_1, '$2'}),
<a name="5112"/> 5112:     [] = ets:match(Tab,{'$1',nosuchkey}),
<a name="5113"/> 5113:     [] = ets:match(Tab,{'$1',kgY2}), % same hash as key2
<a name="5114"/> 5114:     [] = ets:match(Tab,{nosuchvalue,'$1'}),
<a name="5115"/> 5115:     true = ets:delete(Tab),
<a name="match2_do-last_expr"/><a name="5116"/> 5116: <b>    verify_etsmem</b>(EtsMem).
<a name="5117"/> 5117: 
<a name="5118"/> 5118: <i>%% Some ets:match_object tests.</i>
<a name="match_object-1"/><a name="5119"/> 5119: <b>match_object</b>(Config) when is_list(Config) -&gt;
<a name="match_object-last_expr"/><a name="5120"/> 5120: <b>    repeat_for_opts_all_set_table_types</b>(fun match_object_do/1).
<a name="5121"/> 5121: 
<a name="match_object_do-1"/><a name="5122"/> 5122: <b>match_object_do</b>(Opts) -&gt;
<a name="5123"/> 5123:     EtsMem = etsmem(),
<a name="5124"/> 5124:     Tab = ets_new(foobar, Opts),
<a name="5125"/> 5125:     fill_tab(Tab, foo),
<a name="5126"/> 5126:     ets:insert(Tab,{{one,4},4}),
<a name="5127"/> 5127:     ets:insert(Tab,{{one,5},5}),
<a name="5128"/> 5128:     ets:insert(Tab,{{two,4},4}),
<a name="5129"/> 5129:     ets:insert(Tab,{{two,5},6}),
<a name="5130"/> 5130:     ets:insert(Tab, {#{camembert=&gt;cabécou},7}),
<a name="5131"/> 5131:     ets:insert(Tab, {#{&quot;hi&quot;=&gt;&quot;hello&quot;,&quot;wazzup&quot;=&gt;&quot;awesome&quot;,&quot;1337&quot;=&gt;&quot;42&quot;},8}),
<a name="5132"/> 5132:     ets:insert(Tab, {#{&quot;hi&quot;=&gt;&quot;hello&quot;,#{&quot;wazzup&quot;=&gt;3}=&gt;&quot;awesome&quot;,&quot;1337&quot;=&gt;&quot;42&quot;},9}),
<a name="5133"/> 5133:     ets:insert(Tab, {#{&quot;hi&quot;=&gt;&quot;hello&quot;,&quot;wazzup&quot;=&gt;#{&quot;awesome&quot;=&gt;3},&quot;1337&quot;=&gt;&quot;42&quot;},10}),
<a name="5134"/> 5134:     Is = lists:seq(1,100),
<a name="5135"/> 5135:     M1 = maps:from_list([{I,I}||I &lt;- Is]),
<a name="5136"/> 5136:     M2 = maps:from_list([{I,&quot;hi&quot;}||I &lt;- Is]),
<a name="5137"/> 5137:     ets:insert(Tab, {M1,11}),
<a name="5138"/> 5138:     ets:insert(Tab, {M2,12}),
<a name="5139"/> 5139: 
<a name="5140"/> 5140:     case ets:match_object(Tab, {{one, '_'}, '$0'}) of
<a name="5141"/> 5141: 	[{{one,5},5},{{one,4},4}] -&gt; ok;
<a name="5142"/> 5142: 	[{{one,4},4},{{one,5},5}] -&gt; ok;
<a name="5143"/> 5143: 	_ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5144"/> 5144:     end,
<a name="5145"/> 5145:     case ets:match_object(Tab, {{two, '$1'}, '$0'}) of
<a name="5146"/> 5146: 	[{{two,5},6},{{two,4},4}] -&gt; ok;
<a name="5147"/> 5147: 	[{{two,4},4},{{two,5},6}] -&gt; ok;
<a name="5148"/> 5148: 	_ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5149"/> 5149:     end,
<a name="5150"/> 5150:     case ets:match_object(Tab, {{two, '$9'}, '$4'}) of
<a name="5151"/> 5151: 	[{{two,5},6},{{two,4},4}] -&gt; ok;
<a name="5152"/> 5152: 	[{{two,4},4},{{two,5},6}] -&gt; ok;
<a name="5153"/> 5153: 	_ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5154"/> 5154:     end,
<a name="5155"/> 5155:     case ets:match_object(Tab, {{two, '$9'}, '$22'}) of
<a name="5156"/> 5156: 	[{{two,5},6},{{two,4},4}] -&gt; ok;
<a name="5157"/> 5157: 	[{{two,4},4},{{two,5},6}] -&gt; ok;
<a name="5158"/> 5158: 	_ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5159"/> 5159:     end,
<a name="5160"/> 5160: 
<a name="5161"/> 5161:     %% Check that maps are inspected for variables.
<a name="5162"/> 5162:     [{#{camembert:=cabécou},7}] = ets:match_object(Tab, {#{camembert=&gt;'_'},7}),
<a name="5163"/> 5163: 
<a name="5164"/> 5164:     [{#{&quot;hi&quot;:=&quot;hello&quot;,#{&quot;wazzup&quot;=&gt;3}:=&quot;awesome&quot;,&quot;1337&quot;:=&quot;42&quot;},9}] =
<a name="5165"/> 5165:         ets:match_object(Tab, {#{#{&quot;wazzup&quot;=&gt;3}=&gt;&quot;awesome&quot;,&quot;hi&quot;=&gt;&quot;hello&quot;,&quot;1337&quot;=&gt;&quot;42&quot;},9}),
<a name="5166"/> 5166:     [{#{&quot;hi&quot;:=&quot;hello&quot;,#{&quot;wazzup&quot;=&gt;3}:=&quot;awesome&quot;,&quot;1337&quot;:=&quot;42&quot;},9}] =
<a name="5167"/> 5167:         ets:match_object(Tab, {#{#{&quot;wazzup&quot;=&gt;3}=&gt;&quot;awesome&quot;,&quot;hi&quot;=&gt;&quot;hello&quot;,&quot;1337&quot;=&gt;'_'},'_'}),
<a name="5168"/> 5168:     [{#{&quot;hi&quot;:=&quot;hello&quot;,&quot;wazzup&quot;:=#{&quot;awesome&quot;:=3},&quot;1337&quot;:=&quot;42&quot;},10}] =
<a name="5169"/> 5169:         ets:match_object(Tab, {#{&quot;wazzup&quot;=&gt;'_',&quot;hi&quot;=&gt;'_',&quot;1337&quot;=&gt;'_'},10}),
<a name="5170"/> 5170: 
<a name="5171"/> 5171:     %% multiple patterns
<a name="5172"/> 5172:     Pat = {{#{#{&quot;wazzup&quot;=&gt;3}=&gt;&quot;awesome&quot;,&quot;hi&quot;=&gt;&quot;hello&quot;,&quot;1337&quot;=&gt;'_'},'$1'},[{is_integer,'$1'}],['$_']},
<a name="5173"/> 5173:     [{#{&quot;hi&quot;:=&quot;hello&quot;,#{&quot;wazzup&quot;=&gt;3}:=&quot;awesome&quot;,&quot;1337&quot;:=&quot;42&quot;},9}] =
<a name="5174"/> 5174:         ets:select(Tab, [Pat,Pat,Pat,Pat]),
<a name="5175"/> 5175:     case ets:match_object(Tab, {#{&quot;hi&quot;=&gt;&quot;hello&quot;,&quot;wazzup&quot;=&gt;'_',&quot;1337&quot;=&gt;&quot;42&quot;},'_'}) of
<a name="5176"/> 5176:         [{#{&quot;1337&quot; := &quot;42&quot;,&quot;hi&quot; := &quot;hello&quot;,&quot;wazzup&quot; := &quot;awesome&quot;},8},
<a name="5177"/> 5177:          {#{&quot;1337&quot; := &quot;42&quot;,&quot;hi&quot; := &quot;hello&quot;,&quot;wazzup&quot; := #{&quot;awesome&quot; := 3}},10}] -&gt; ok;
<a name="5178"/> 5178:         [{#{&quot;1337&quot; := &quot;42&quot;,&quot;hi&quot; := &quot;hello&quot;,&quot;wazzup&quot; := #{&quot;awesome&quot; := 3}},10},
<a name="5179"/> 5179:          {#{&quot;1337&quot; := &quot;42&quot;,&quot;hi&quot; := &quot;hello&quot;,&quot;wazzup&quot; := &quot;awesome&quot;},8}] -&gt; ok;
<a name="5180"/> 5180:         _ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5181"/> 5181:     end,
<a name="5182"/> 5182:     case ets:match_object(Tab, {#{&quot;hi&quot;=&gt;'_'},'_'}) of
<a name="5183"/> 5183:         [{#{&quot;1337&quot;:=&quot;42&quot;, &quot;hi&quot;:=&quot;hello&quot;},_},
<a name="5184"/> 5184:          {#{&quot;1337&quot;:=&quot;42&quot;, &quot;hi&quot;:=&quot;hello&quot;},_},
<a name="5185"/> 5185:          {#{&quot;1337&quot;:=&quot;42&quot;, &quot;hi&quot;:=&quot;hello&quot;},_}] -&gt; ok;
<a name="5186"/> 5186:         _ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5187"/> 5187:     end,
<a name="5188"/> 5188: 
<a name="5189"/> 5189:     %% match large maps
<a name="5190"/> 5190:     [{#{1:=1,2:=2,99:=99,100:=100},11}] = ets:match_object(Tab, {M1,11}),
<a name="5191"/> 5191:     [{#{1:=&quot;hi&quot;,2:=&quot;hi&quot;,99:=&quot;hi&quot;,100:=&quot;hi&quot;},12}] = ets:match_object(Tab, {M2,12}),
<a name="5192"/> 5192:     case ets:match_object(Tab, {#{1=&gt;'_',2=&gt;'_'},'_'}) of
<a name="5193"/> 5193:         %% only match a part of the map
<a name="5194"/> 5194:         [{#{1:=1,5:=5,99:=99,100:=100},11},{#{1:=&quot;hi&quot;,6:=&quot;hi&quot;,99:=&quot;hi&quot;},12}] -&gt; ok;
<a name="5195"/> 5195:         [{#{1:=&quot;hi&quot;,2:=&quot;hi&quot;,59:=&quot;hi&quot;},12},{#{1:=1,2:=2,39:=39,100:=100},11}] -&gt; ok;
<a name="5196"/> 5196:         _ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5197"/> 5197:     end,
<a name="5198"/> 5198:     case ets:match_object(Tab, {maps:from_list([{I,'_'}||I&lt;-Is]),'_'}) of
<a name="5199"/> 5199:         %% only match a part of the map
<a name="5200"/> 5200:         [{#{1:=1,5:=5,99:=99,100:=100},11},{#{1:=&quot;hi&quot;,6:=&quot;hi&quot;,99:=&quot;hi&quot;},12}] -&gt; ok;
<a name="5201"/> 5201:         [{#{1:=&quot;hi&quot;,2:=&quot;hi&quot;,59:=&quot;hi&quot;},12},{#{1:=1,2:=2,39:=39,100:=100},11}] -&gt; ok;
<a name="5202"/> 5202:         _ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5203"/> 5203:     end,
<a name="5204"/> 5204:     {'EXIT',{badarg,_}} = (catch ets:match_object(Tab, {#{'$1'=&gt;'_'},7})),
<a name="5205"/> 5205:     Mve = maps:from_list([{list_to_atom([$$|integer_to_list(I)]),'_'}||I&lt;-Is]),
<a name="5206"/> 5206:     {'EXIT',{badarg,_}} = (catch ets:match_object(Tab, {Mve,11})),
<a name="5207"/> 5207: 
<a name="5208"/> 5208:     %% Check that unsuccessful match returns an empty list.
<a name="5209"/> 5209:     [] = ets:match_object(Tab, {{three,'$0'}, '$92'}),
<a name="5210"/> 5210:     %% Check that '$0' equals '_'.
<a name="5211"/> 5211:     Len = length(ets:match_object(Tab, '$0')),
<a name="5212"/> 5212:     Len = length(ets:match_object(Tab, '_')),
<a name="5213"/> 5213:     if Len &gt; 4 -&gt; ok end,
<a name="5214"/> 5214:     true = ets:delete(Tab),
<a name="match_object_do-last_expr"/><a name="5215"/> 5215: <b>    verify_etsmem</b>(EtsMem).
<a name="5216"/> 5216: 
<a name="5217"/> 5217: <i>%% Tests that db_match_object does not generate a `badarg' when</i>
<a name="5218"/> 5218: <i>%% resuming a search with no previous matches.</i>
<a name="match_object2-1"/><a name="5219"/> 5219: <b>match_object2</b>(Config) when is_list(Config) -&gt;
<a name="match_object2-last_expr"/><a name="5220"/> 5220: <b>    repeat_for_opts_all_table_types</b>(fun match_object2_do/1).
<a name="5221"/> 5221: 
<a name="match_object2_do-1"/><a name="5222"/> 5222: <b>match_object2_do</b>(Opts) -&gt;
<a name="5223"/> 5223:     EtsMem = etsmem(),
<a name="5224"/> 5224:     KeyRange = 13005,
<a name="5225"/> 5225:     Tab = ets_new(foo, [{keypos, 2} | Opts], KeyRange),
<a name="5226"/> 5226:     fill_tab2(Tab, 0, KeyRange),     % match_db_object does 1000
<a name="5227"/> 5227: 						% elements per pass, might
<a name="5228"/> 5228: 						% change in the future.
<a name="5229"/> 5229:     [] = ets:match_object(Tab, {hej, '$1'}),
<a name="5230"/> 5230:     ets:delete(Tab),
<a name="match_object2_do-last_expr"/><a name="5231"/> 5231: <b>    verify_etsmem</b>(EtsMem).
<a name="5232"/> 5232: 
<a name="5233"/> 5233: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="5234"/> 5234: 
<a name="5235"/> 5235: 
<a name="5236"/> 5236: <i>%% OTP-3319. Test tab2list.</i>
<a name="tab2list-1"/><a name="5237"/> 5237: <b>tab2list</b>(Config) when is_list(Config) -&gt;
<a name="tab2list-last_expr"/><a name="5238"/> 5238: <b>    repeat_for_all_ord_set_table_types</b>(
<a name="5239"/> 5239:       fun(Opts) -&gt;
<a name="5240"/> 5240:               EtsMem = etsmem(),
<a name="5241"/> 5241:               Tab = make_table(foo,
<a name="5242"/> 5242:                                Opts,
<a name="5243"/> 5243:                                [{a,b}, {c,b}, {b,b}, {a,c}]),
<a name="5244"/> 5244:               [{a,c},{b,b},{c,b}] = ets:tab2list(Tab),
<a name="5245"/> 5245:               true = ets:delete(Tab),
<a name="5246"/> 5246:               verify_etsmem(EtsMem)
<a name="5247"/> 5247:       end).
<a name="5248"/> 5248: 
<a name="5249"/> 5249: <i>%% Simple general small test.  If this fails, ets is in really bad</i>
<a name="5250"/> 5250: <i>%% shape.</i>
<a name="misc1-1"/><a name="5251"/> 5251: <b>misc1</b>(Config) when is_list(Config) -&gt;
<a name="misc1-last_expr"/><a name="5252"/> 5252: <b>    repeat_for_opts_all_table_types</b>(fun misc1_do/1).
<a name="5253"/> 5253: 
<a name="misc1_do-1"/><a name="5254"/> 5254: <b>misc1_do</b>(Opts) -&gt;
<a name="5255"/> 5255:     EtsMem = etsmem(),
<a name="5256"/> 5256:     Tab = ets_new(foo,Opts),
<a name="5257"/> 5257:     true = lists:member(Tab,ets:all()),
<a name="5258"/> 5258:     ets:delete(Tab),
<a name="5259"/> 5259:     false = lists:member(Tab,ets:all()),
<a name="5260"/> 5260:     case catch ets:delete(Tab) of
<a name="5261"/> 5261: 	{'EXIT',_Reason} -&gt;
<a name="5262"/> 5262: 	    verify_etsmem(EtsMem);
<a name="5263"/> 5263: 	true -&gt;
<a name="5264"/> 5264: 	    ct:fail(&quot;Delete of nonexisting table returned `true'.&quot;)
<a name="5265"/> 5265:     end,
<a name="misc1_do-last_expr"/><a name="5266"/> 5266:     ok.
<a name="5267"/> 5267: 
<a name="5268"/> 5268: <i>%% Check the safe_fixtable function.</i>
<a name="safe_fixtable-1"/><a name="5269"/> 5269: <b>safe_fixtable</b>(Config) when is_list(Config) -&gt;
<a name="safe_fixtable-last_expr"/><a name="5270"/> 5270: <b>    repeat_for_opts_all_table_types</b>(fun safe_fixtable_do/1).
<a name="5271"/> 5271: 
<a name="safe_fixtable_do-1"/><a name="5272"/> 5272: <b>safe_fixtable_do</b>(Opts) -&gt;
<a name="5273"/> 5273:     EtsMem = etsmem(),
<a name="5274"/> 5274:     Tab = ets_new(foo, Opts),
<a name="5275"/> 5275:     fill_tab(Tab, foobar),
<a name="5276"/> 5276:     true = ets:safe_fixtable(Tab, true),
<a name="5277"/> 5277:     receive after 1 -&gt; ok end,
<a name="5278"/> 5278:     true = ets:safe_fixtable(Tab, false),
<a name="5279"/> 5279:     false = ets:info(Tab,safe_fixed_monotonic_time),
<a name="5280"/> 5280:     false = ets:info(Tab,safe_fixed),
<a name="5281"/> 5281:     SysBefore = erlang:timestamp(),
<a name="5282"/> 5282:     MonBefore = erlang:monotonic_time(),
<a name="5283"/> 5283:     true = ets:safe_fixtable(Tab, true),
<a name="5284"/> 5284:     MonAfter = erlang:monotonic_time(),
<a name="5285"/> 5285:     SysAfter = erlang:timestamp(),
<a name="5286"/> 5286:     Self = self(),
<a name="5287"/> 5287:     {FixMonTime,[{Self,1}]} = ets:info(Tab,safe_fixed_monotonic_time),
<a name="5288"/> 5288:     {FixSysTime,[{Self,1}]} = ets:info(Tab,safe_fixed),
<a name="5289"/> 5289:     true = is_integer(FixMonTime),
<a name="5290"/> 5290:     true = MonBefore =&lt; FixMonTime,
<a name="5291"/> 5291:     true = FixMonTime =&lt; MonAfter,
<a name="5292"/> 5292:     {FstMs,FstS,FstUs} = FixSysTime,
<a name="5293"/> 5293:     true = is_integer(FstMs),
<a name="5294"/> 5294:     true = is_integer(FstS),
<a name="5295"/> 5295:     true = is_integer(FstUs),
<a name="5296"/> 5296:     case erlang:system_info(time_warp_mode) of
<a name="5297"/> 5297: 	no_time_warp -&gt;
<a name="5298"/> 5298: 	    true = timer:now_diff(FixSysTime, SysBefore) &gt;= 0,
<a name="5299"/> 5299: 	    true = timer:now_diff(SysAfter, FixSysTime) &gt;= 0;
<a name="5300"/> 5300: 	_ -&gt;
<a name="5301"/> 5301: 	    %% ets:info(Tab,safe_fixed) not timewarp safe...
<a name="5302"/> 5302: 	    ignore
<a name="5303"/> 5303:     end,
<a name="5304"/> 5304:     %% Test that an unjustified 'unfix' is a no-op.
<a name="5305"/> 5305:     {Pid,MRef} = my_spawn_monitor(fun() -&gt; true = ets:safe_fixtable(Tab,false) end),
<a name="5306"/> 5306:     {'DOWN', MRef, process, Pid, normal} = receive M -&gt; M end,
<a name="5307"/> 5307:     true = ets:info(Tab,fixed),
<a name="5308"/> 5308:     {FixMonTime,[{Self,1}]} = ets:info(Tab,safe_fixed_monotonic_time),
<a name="5309"/> 5309:     {FixSysTime,[{Self,1}]} = ets:info(Tab,safe_fixed),
<a name="5310"/> 5310:     %% badarg's
<a name="5311"/> 5311:     {'EXIT', {badarg, _}} = (catch ets:safe_fixtable(Tab, foobar)),
<a name="5312"/> 5312:     true = ets:info(Tab,fixed),
<a name="5313"/> 5313:     true = ets:safe_fixtable(Tab, false),
<a name="5314"/> 5314:     false = ets:info(Tab,fixed),
<a name="5315"/> 5315:     {'EXIT', {badarg, _}} = (catch ets:safe_fixtable(Tab, foobar)),
<a name="5316"/> 5316:     false = ets:info(Tab,fixed),
<a name="5317"/> 5317:     ets:delete(Tab),
<a name="5318"/> 5318:     case catch ets:safe_fixtable(Tab, true) of
<a name="5319"/> 5319: 	{'EXIT', _Reason} -&gt;
<a name="5320"/> 5320: 	    verify_etsmem(EtsMem);
<a name="5321"/> 5321: 	_ -&gt;
<a name="5322"/> 5322: 	    ct:fail(&quot;Fixtable on nonexisting table returned `true'&quot;)
<a name="5323"/> 5323:     end,
<a name="safe_fixtable_do-last_expr"/><a name="5324"/> 5324:     ok.
<a name="5325"/> 5325: 
<a name="5326"/> 5326: <b>-define</b>(ets_info(Tab,Item,SlavePid), ets_info(Tab, Item, SlavePid, ?LINE)).
<a name="5327"/> 5327: 
<a name="5328"/> 5328: <i>%% Tests ets:info result for required tuples.</i>
<a name="info-1"/><a name="5329"/> 5329: <b>info</b>(Config) when is_list(Config) -&gt;
<a name="5330"/> 5330:     repeat_for_opts(fun info_do/1,
<a name="5331"/> 5331:                     [[void, set, bag, duplicate_bag, ordered_set],
<a name="5332"/> 5332:                      [void, private, protected, public],
<a name="5333"/> 5333:                      write_concurrency, read_concurrency, compressed]),
<a name="5334"/> 5334: 
<a name="5335"/> 5335:     undefined = ets:info(non_existing_table_xxyy),
<a name="5336"/> 5336:     undefined = ets:info(non_existing_table_xxyy,type),
<a name="5337"/> 5337:     undefined = ets:info(non_existing_table_xxyy,node),
<a name="5338"/> 5338:     undefined = ets:info(non_existing_table_xxyy,named_table),
<a name="5339"/> 5339:     undefined = ets:info(non_existing_table_xxyy,safe_fixed_monotonic_time),
<a name="5340"/> 5340:     undefined = ets:info(non_existing_table_xxyy,safe_fixed),
<a name="5341"/> 5341: 
<a name="5342"/> 5342:     {'EXIT',{badarg,_}} = (catch ets:info(42)),
<a name="5343"/> 5343:     {'EXIT',{badarg,_}} = (catch ets:info(42, type)),
<a name="5344"/> 5344:     {'EXIT',{badarg,_}} = (catch ets:info(make_ref())),
<a name="5345"/> 5345:     {'EXIT',{badarg,_}} = (catch ets:info(make_ref(), type)),
<a name="5346"/> 5346: 
<a name="5347"/> 5347:     case erlang:system_info(schedulers) of
<a name="5348"/> 5348:         1 -&gt; %% Fine grained locking is not activated when there is only one scheduler
<a name="5349"/> 5349:             lists:foreach(
<a name="5350"/> 5350:               fun(Type) -&gt;
<a name="5351"/> 5351:                       T1 = ets:new(t1, [public, Type, {write_concurrency, auto}]),
<a name="5352"/> 5352:                       false = ets:info(T1, write_concurrency),
<a name="5353"/> 5353:                       T2 = ets:new(t2, [public, Type, {write_concurrency, true}]),
<a name="5354"/> 5354:                       false = ets:info(T2, write_concurrency)
<a name="5355"/> 5355:               end,
<a name="5356"/> 5356:               [set, bag, duplicate_bag, ordered_set]),
<a name="5357"/> 5357:             T2 = ets:new(t2, [public, {write_concurrency, {debug_hash_fixed_number_of_locks, 2049}}]),
<a name="5358"/> 5358:             false = ets:info(T2, write_concurrency);
<a name="5359"/> 5359:         _ -&gt;
<a name="5360"/> 5360:             %% Test that one can set the synchronization granularity level for
<a name="5361"/> 5361:             %% tables of type set
<a name="5362"/> 5362:             T1 = ets:new(t1, [public, {write_concurrency, {debug_hash_fixed_number_of_locks, 1024}}]),
<a name="5363"/> 5363:             {debug_hash_fixed_number_of_locks, 1024} = ets:info(T1, write_concurrency),
<a name="5364"/> 5364:             T2 = ets:new(t2, [public, {write_concurrency, {debug_hash_fixed_number_of_locks, 2048}}]),
<a name="5365"/> 5365:             {debug_hash_fixed_number_of_locks, 2048} = ets:info(T2, write_concurrency),
<a name="5366"/> 5366:             T3 = ets:new(t3, [public, {write_concurrency, {debug_hash_fixed_number_of_locks, 1024}}, {write_concurrency, true}]),
<a name="5367"/> 5367:             true = ets:info(T3, write_concurrency),
<a name="5368"/> 5368:             T4 = ets:new(t4, [private, {write_concurrency, {debug_hash_fixed_number_of_locks, 1024}}]),
<a name="5369"/> 5369:             false = ets:info(T4, write_concurrency),
<a name="5370"/> 5370:             %% Test the auto option
<a name="5371"/> 5371:             lists:foreach(
<a name="5372"/> 5372:               fun(Type) -&gt;
<a name="5373"/> 5373:                       T5 = ets:new(t5, [public, Type, {write_concurrency, auto}]),
<a name="5374"/> 5374:                       auto = ets:info(T5, write_concurrency)
<a name="5375"/> 5375:               end,
<a name="5376"/> 5376:               [set, bag, duplicate_bag, ordered_set]),
<a name="5377"/> 5377:             T6 = ets:new(t6, [private, {write_concurrency, true}]),
<a name="5378"/> 5378:             false = ets:info(T6, write_concurrency),
<a name="5379"/> 5379:             T7 = ets:new(t7, [private, {write_concurrency, auto}]),
<a name="5380"/> 5380:             false = ets:info(T7, write_concurrency),
<a name="5381"/> 5381:             %% Test that the number of locks is rounded down to the nearest power of two
<a name="5382"/> 5382:             T8 = ets:new(t8, [public, {write_concurrency, {debug_hash_fixed_number_of_locks, 2049}}]),
<a name="5383"/> 5383:             {debug_hash_fixed_number_of_locks, 2048} = ets:info(T8, write_concurrency)
<a name="5384"/> 5384:     end,
<a name="info-last_expr"/><a name="5385"/> 5385:     ok.
<a name="5386"/> 5386: 
<a name="info_do-1"/><a name="5387"/> 5387: <b>info_do</b>(Opts) -&gt;
<a name="5388"/> 5388:     EtsMem = etsmem(),
<a name="5389"/> 5389:     TableType = lists:foldl(
<a name="5390"/> 5390:                   fun(Item, Curr) -&gt;
<a name="5391"/> 5391:                           case Item of
<a name="5392"/> 5392:                               set -&gt; set;
<a name="5393"/> 5393:                               ordered_set -&gt; ordered_set;
<a name="5394"/> 5394:                               cat_ord_set -&gt; ordered_set;
<a name="5395"/> 5395:                               stim_cat_ord_set -&gt; ordered_set;
<a name="5396"/> 5396:                               bag -&gt; bag;
<a name="5397"/> 5397:                               duplicate_bag -&gt; duplicate_bag;
<a name="5398"/> 5398:                               _ -&gt; Curr
<a name="5399"/> 5399:                           end
<a name="5400"/> 5400:                   end, set, Opts),
<a name="5401"/> 5401:     PublicOrCurr =
<a name="5402"/> 5402:         fun(Curr) -&gt;
<a name="5403"/> 5403:                 case lists:member({write_concurrency, false}, Opts) or
<a name="5404"/> 5404:                     lists:member(private, Opts) or
<a name="5405"/> 5405:                     lists:member(protected, Opts) of
<a name="5406"/> 5406:                     true -&gt; Curr;
<a name="5407"/> 5407:                     false -&gt; public
<a name="5408"/> 5408:                 end
<a name="5409"/> 5409:         end,
<a name="5410"/> 5410:     Protection = lists:foldl(
<a name="5411"/> 5411:                    fun(Item, Curr) -&gt;
<a name="5412"/> 5412:                            case Item of
<a name="5413"/> 5413:                                public -&gt; public;
<a name="5414"/> 5414:                                protected -&gt; protected;
<a name="5415"/> 5415:                                private -&gt; private;
<a name="5416"/> 5416:                                cat_ord_set -&gt; PublicOrCurr(Curr); %% Special items
<a name="5417"/> 5417:                                stim_cat_ord_set -&gt; PublicOrCurr(Curr);
<a name="5418"/> 5418:                                _ -&gt; Curr
<a name="5419"/> 5419:                            end
<a name="5420"/> 5420:                    end, protected, Opts),
<a name="5421"/> 5421:     MeMyselfI=self(),
<a name="5422"/> 5422:     ThisNode=node(),
<a name="5423"/> 5423:     Tab = ets_new(foobar, [{keypos, 2} | Opts]),
<a name="5424"/> 5424: 
<a name="5425"/> 5425:     %% Start slave to also do ets:info from a process not owning the table.
<a name="5426"/> 5426:     SlavePid = spawn_link(fun Slave() -&gt;
<a name="5427"/> 5427:                                   receive
<a name="5428"/> 5428:                                       {Master, Item} -&gt;
<a name="5429"/> 5429:                                           Master ! {self(), Item, ets:info(Tab, Item)}
<a name="5430"/> 5430:                                   end,
<a name="5431"/> 5431:                                   Slave()
<a name="5432"/> 5432:                           end),
<a name="5433"/> 5433: 
<a name="5434"/> 5434:     %% Note: ets:info/1 used to return a tuple, but from R11B onwards it
<a name="5435"/> 5435:     %% returns a list.
<a name="5436"/> 5436:     Res = ets:info(Tab),
<a name="5437"/> 5437:     {value, {memory, _Mem}} = lists:keysearch(memory, 1, Res),
<a name="5438"/> 5438:     {value, {owner, MeMyselfI}} = lists:keysearch(owner, 1, Res),
<a name="5439"/> 5439:     {value, {name, foobar}} = lists:keysearch(name, 1, Res),
<a name="5440"/> 5440:     {value, {size, 0}} = lists:keysearch(size, 1, Res),
<a name="5441"/> 5441:     {value, {node, ThisNode}} = lists:keysearch(node, 1, Res),
<a name="5442"/> 5442:     {value, {named_table, false}} = lists:keysearch(named_table, 1, Res),
<a name="5443"/> 5443:     {value, {type, TableType}} = lists:keysearch(type, 1, Res),
<a name="5444"/> 5444:     {value, {keypos, 2}} = lists:keysearch(keypos, 1, Res),
<a name="5445"/> 5445:     {value, {protection, Protection}} =
<a name="5446"/> 5446: 	lists:keysearch(protection, 1, Res),
<a name="5447"/> 5447:     {value, {id, Tab}} = lists:keysearch(id, 1, Res),
<a name="5448"/> 5448:     {value, {decentralized_counters, _DecentralizedCtrs}} =
<a name="5449"/> 5449:         lists:keysearch(decentralized_counters, 1, Res),
<a name="5450"/> 5450:     %% Test 'binary'
<a name="5451"/> 5451:     [] = ?ets_info(Tab, binary, SlavePid),
<a name="5452"/> 5452:     BinSz = 100,
<a name="5453"/> 5453:     RefcBin = list_to_binary(lists:seq(1,BinSz)),
<a name="5454"/> 5454:     ets:insert(Tab, {RefcBin,key}),
<a name="5455"/> 5455:     [{BinPtr,BinSz,2}] = ?ets_info(Tab,binary, SlavePid),
<a name="5456"/> 5456:     ets:insert(Tab, {RefcBin,key2}),
<a name="5457"/> 5457:     [{BinPtr,BinSz,3}, {BinPtr,BinSz,3}] = ?ets_info(Tab,binary,SlavePid),
<a name="5458"/> 5458:     ets:delete(Tab, key),
<a name="5459"/> 5459:     [{BinPtr,BinSz,2}] = ?ets_info(Tab,binary, SlavePid),
<a name="5460"/> 5460:     case TableType of
<a name="5461"/> 5461:         ordered_set -&gt;
<a name="5462"/> 5462:             ets:delete(Tab, key2);
<a name="5463"/> 5463:         _ -&gt;
<a name="5464"/> 5464:             ets:safe_fixtable(Tab, true),
<a name="5465"/> 5465:             ets:delete(Tab, key2),
<a name="5466"/> 5466:             [{BinPtr,BinSz,2}] = ?ets_info(Tab,binary, SlavePid),
<a name="5467"/> 5467:             ets:safe_fixtable(Tab, false)
<a name="5468"/> 5468:     end,
<a name="5469"/> 5469:     [] = ?ets_info(Tab,binary, SlavePid),
<a name="5470"/> 5470:     RefcBin = id(RefcBin), % keep alive
<a name="5471"/> 5471: 
<a name="5472"/> 5472:     unlink(SlavePid),
<a name="5473"/> 5473:     exit(SlavePid,kill),
<a name="5474"/> 5474:     true = ets:delete(Tab),
<a name="info_do-last_expr"/><a name="5475"/> 5475: <b>    verify_etsmem</b>(EtsMem).
<a name="5476"/> 5476: 
<a name="ets_info-4"/><a name="5477"/> 5477: <b>ets_info</b>(Tab, Item, SlavePid, _Line) -&gt;
<a name="5478"/> 5478:     R = ets:info(Tab, Item),
<a name="5479"/> 5479:     %%io:format(&quot;~p: ets:info(~p) -&gt; ~p\n&quot;, [_Line, Item, R]),
<a name="5480"/> 5480:     SlavePid ! {self(), Item},
<a name="5481"/> 5481:     {SlavePid, Item, R} = receive M -&gt; M end,
<a name="ets_info-last_expr"/><a name="5482"/> 5482:     R.
<a name="5483"/> 5483: 
<a name="5484"/> 5484: 
<a name="5485"/> 5485: 
<a name="info_binary_stress-1"/><a name="5486"/> 5486: <b>info_binary_stress</b>(_Config) -&gt;
<a name="info_binary_stress-last_expr"/><a name="5487"/> 5487: <b>    repeat_for_opts</b>(fun info_binary_stress_do/1,
<a name="5488"/> 5488:                     [[set,bag,duplicate_bag,ordered_set],
<a name="5489"/> 5489:                      compressed]).
<a name="5490"/> 5490: 
<a name="info_binary_stress_do-1"/><a name="5491"/> 5491: <b>info_binary_stress_do</b>(Opts) -&gt;
<a name="5492"/> 5492:     Tab = ets_new(info_binary_stress, [public, {write_concurrency,true} | Opts]),
<a name="5493"/> 5493: 
<a name="5494"/> 5494:     KeyRange = 1000,
<a name="5495"/> 5495:     ValueRange = 3,
<a name="5496"/> 5496:     RefcBin = list_to_binary(lists:seq(1,100)),
<a name="5497"/> 5497:     InitF = fun (_) -&gt; #{insert =&gt; 0, delete =&gt; 0, delete_object =&gt; 0}
<a name="5498"/> 5498:             end,
<a name="5499"/> 5499:     ExecF = fun (Counters) -&gt;
<a name="5500"/> 5500:                     Key = rand:uniform(KeyRange),
<a name="5501"/> 5501:                     Value = rand:uniform(ValueRange),
<a name="5502"/> 5502:                     Op = element(rand:uniform(4),{insert,insert,delete,delete_object}),
<a name="5503"/> 5503:                     case Op of
<a name="5504"/> 5504:                         insert -&gt;
<a name="5505"/> 5505:                             ets:insert(Tab, {Key,Value,RefcBin});
<a name="5506"/> 5506:                         delete -&gt;
<a name="5507"/> 5507:                             ets:delete(Tab, Key);
<a name="5508"/> 5508:                         delete_object -&gt;
<a name="5509"/> 5509:                             ets:delete_object(Tab, {Key,Value,RefcBin})
<a name="5510"/> 5510:                     end,
<a name="5511"/> 5511:                     Acc = incr_counter(Op, Counters),
<a name="5512"/> 5512: 
<a name="5513"/> 5513:                     receive stop -&gt;
<a name="5514"/> 5514:                                 [end_of_work | Acc]
<a name="5515"/> 5515:                     after 0 -&gt;
<a name="5516"/> 5516:                             Acc
<a name="5517"/> 5517:                     end
<a name="5518"/> 5518:             end,
<a name="5519"/> 5519:     FiniF = fun (Acc) -&gt; Acc end,
<a name="5520"/> 5520:     Pids = run_sched_workers(InitF, ExecF, FiniF, infinite),
<a name="5521"/> 5521:     timer:send_after(500, stop),
<a name="5522"/> 5522: 
<a name="5523"/> 5523:     Rounds = fun Loop(N, Fix) -&gt;
<a name="5524"/> 5524:                      ets:info(Tab, binary),
<a name="5525"/> 5525:                      ets:safe_fixtable(Tab, Fix),
<a name="5526"/> 5526:                      receive
<a name="5527"/> 5527:                          stop -&gt;
<a name="5528"/> 5528:                              ets:safe_fixtable(Tab, false),
<a name="5529"/> 5529:                              false = ets:info(Tab, fixed),
<a name="5530"/> 5530:                              N
<a name="5531"/> 5531:                      after 0 -&gt;
<a name="5532"/> 5532:                              Loop(N+1, not Fix)
<a name="5533"/> 5533:                      end
<a name="5534"/> 5534:              end (1, true),
<a name="5535"/> 5535:     [P ! stop || P &lt;- Pids],
<a name="5536"/> 5536:     Results = wait_pids(Pids),
<a name="5537"/> 5537:     Size = ets:info(Tab,size),
<a name="5538"/> 5538:     io:format(&quot;Ops = ~p\n&quot;, [maps_sum(Results)]),
<a name="5539"/> 5539:     io:format(&quot;Size = ~p\n&quot;, [Size]),
<a name="5540"/> 5540:     io:format(&quot;Stats = ~p\n&quot;, [ets:info(Tab,stats)]),
<a name="5541"/> 5541:     io:format(&quot;Rounds = ~p\n&quot;, [Rounds]),
<a name="5542"/> 5542:     Size = length(ets:info(Tab, binary)),
<a name="5543"/> 5543: 
<a name="5544"/> 5544:     ets:delete_all_objects(Tab),
<a name="5545"/> 5545:     [] = ets:info(Tab, binary),
<a name="5546"/> 5546:     true = ets:delete(Tab),
<a name="info_binary_stress_do-last_expr"/><a name="5547"/> 5547:     ok.
<a name="5548"/> 5548: 
<a name="5549"/> 5549: 
<a name="size_loop-4"/><a name="5550"/> 5550: <b>size_loop</b>(_T, 0, _, _) -&gt;
<a name="5551"/> 5551:     ok;
<a name="5552"/> 5552: <b>size_loop</b>(T, I, PrevSize, WhatToTest) -&gt;
<a name="5553"/> 5553:     Size = ets:info(T, WhatToTest),
<a name="5554"/> 5554:     case Size &lt; PrevSize of
<a name="5555"/> 5555:         true -&gt;
<a name="5556"/> 5556:             io:format(&quot;Bad ets:info/2 (got ~p expected &gt;=~p)&quot;,
<a name="5557"/> 5557:                       [Size, PrevSize]),
<a name="5558"/> 5558:             ct:fail(&quot;Bad ets:info/2)&quot;);
<a name="5559"/> 5559:         _ -&gt; ok
<a name="5560"/> 5560:     end,
<a name="size_loop-last_expr"/><a name="5561"/> 5561: <b>    size_loop</b>(T, I -1, Size, WhatToTest).
<a name="5562"/> 5562: 
<a name="add_loop-2"/><a name="5563"/> 5563: <b>add_loop</b>(_T, 0) -&gt;
<a name="5564"/> 5564:     ok;
<a name="5565"/> 5565: <b>add_loop</b>(T, I) -&gt;
<a name="5566"/> 5566:     ets:insert(T, {I}),
<a name="add_loop-last_expr"/><a name="5567"/> 5567: <b>    add_loop</b>(T, I -1).
<a name="5568"/> 5568: 
<a name="5569"/> 5569: 
<a name="test_table_counter_concurrency-2"/><a name="5570"/> 5570: <b>test_table_counter_concurrency</b>(WhatToTest, TableOptions) -&gt;
<a name="5571"/> 5571:     IntStatePrevOn =
<a name="5572"/> 5572:         erts_debug:set_internal_state(available_internal_state, true),
<a name="5573"/> 5573:     ItemsToAdd = 1000000,
<a name="5574"/> 5574:     SizeLoopSize = 1000,
<a name="5575"/> 5575:     T = ets:new(k, TableOptions),
<a name="5576"/> 5576:     case lists:member(ordered_set, TableOptions) of
<a name="5577"/> 5577:         true -&gt;
<a name="5578"/> 5578:             erts_debug:set_internal_state(ets_debug_random_split_join, {T, false});
<a name="5579"/> 5579:         false -&gt; ok
<a name="5580"/> 5580:     end,
<a name="5581"/> 5581:     0 = ets:info(T, size),
<a name="5582"/> 5582:     P = self(),
<a name="5583"/> 5583:     SpawnedSizeProcs =
<a name="5584"/> 5584:         [spawn_link(fun() -&gt;
<a name="5585"/> 5585:                             size_loop(T, SizeLoopSize, 0, WhatToTest),
<a name="5586"/> 5586:                             P ! done
<a name="5587"/> 5587:                     end)
<a name="5588"/> 5588:          || _ &lt;- lists:seq(1, 6)],
<a name="5589"/> 5589:     spawn_link(fun() -&gt;
<a name="5590"/> 5590:                        add_loop(T, ItemsToAdd),
<a name="5591"/> 5591:                        P ! done_add
<a name="5592"/> 5592:                end),
<a name="5593"/> 5593:     [receive
<a name="5594"/> 5594:          done -&gt; ok;
<a name="5595"/> 5595:          done_add -&gt; ok
<a name="5596"/> 5596:      end
<a name="5597"/> 5597:      || _ &lt;- [ok|SpawnedSizeProcs]],
<a name="5598"/> 5598:     case WhatToTest =:= size of
<a name="5599"/> 5599:         true -&gt;
<a name="5600"/> 5600:             ItemsToAdd = ets:info(T, size);
<a name="5601"/> 5601:         _ -&gt;
<a name="5602"/> 5602:             ok
<a name="5603"/> 5603:     end,
<a name="5604"/> 5604:     erts_debug:set_internal_state(available_internal_state, IntStatePrevOn),
<a name="test_table_counter_concurrency-last_expr"/><a name="5605"/> 5605:     ok.
<a name="5606"/> 5606: 
<a name="5607"/> 5607: <i>%% ERIERL-855: Calling info or whereis on a table being busy trapping (insert)</i>
<a name="5608"/> 5608: <i>%% could return 'undefined'.</i>
<a name="info_whereis_busy-1"/><a name="5609"/> 5609: <b>info_whereis_busy</b>(Config) when is_list(Config) -&gt;
<a name="5610"/> 5610:     TName = info_whereis_busy,
<a name="5611"/> 5611:     TName = ets:new(TName, [named_table, public]),
<a name="5612"/> 5612:     T = ets:whereis(TName),
<a name="5613"/> 5613:     NKeys = 100_000,
<a name="5614"/> 5614:     Tuples = [{K} || K &lt;- lists:seq(1,NKeys)],
<a name="5615"/> 5615:     _Inserter = spawn_link(fun() -&gt;
<a name="5616"/> 5616:                                    ets:insert(TName, Tuples)
<a name="5617"/> 5617:                            end),
<a name="5618"/> 5618:     repeat_while(fun() -&gt;
<a name="5619"/> 5619:                          Info = ets:info(TName),
<a name="5620"/> 5620:                          false = (Info =:= undefined),
<a name="5621"/> 5621:                          T = ets:whereis(TName),
<a name="5622"/> 5622:                          case lists:keyfind(size, 1, Info) of
<a name="5623"/> 5623:                              {size, NKeys} -&gt;
<a name="5624"/> 5624:                                  false;
<a name="5625"/> 5625:                              {size, _} -&gt;
<a name="5626"/> 5626:                                  true
<a name="5627"/> 5627:                          end
<a name="5628"/> 5628:                  end),
<a name="5629"/> 5629:     ets:delete(T),
<a name="info_whereis_busy-last_expr"/><a name="5630"/> 5630:     ok.
<a name="5631"/> 5631: 
<a name="5632"/> 5632: <i>%% Delete table during trapping ets:insert</i>
<a name="insert_trap_delete-1"/><a name="5633"/> 5633: <b>insert_trap_delete</b>(Config) when is_list(Config) -&gt;
<a name="5634"/> 5634:     repeat_for_opts(fun(Opts) -&gt;
<a name="5635"/> 5635:                             [insert_trap_delete_run1({Opts,InsertFunc,Mode})
<a name="5636"/> 5636:                              || InsertFunc &lt;- [insert,insert_new],
<a name="5637"/> 5637:                                 Mode &lt;- [exit, delete]]
<a name="5638"/> 5638:                     end,
<a name="5639"/> 5639:                     [all_non_stim_types, write_concurrency, compressed]),
<a name="insert_trap_delete-last_expr"/><a name="5640"/> 5640:     ok.
<a name="5641"/> 5641: 
<a name="insert_trap_delete_run1-1"/><a name="5642"/> 5642: <b>insert_trap_delete_run1</b>(Params) -&gt;
<a name="5643"/> 5643:     NKeys = 50_000 + rand:uniform(50_000),
<a name="5644"/> 5644:     %% First measure how many traps the insert op will do
<a name="5645"/> 5645:     Traps0 = insert_trap_delete_run3(unlimited, Params, NKeys),
<a name="5646"/> 5646:     %% Then do again and delete table at different moments
<a name="5647"/> 5647:     Decr = (Traps0 div 5) + 1,
<a name="insert_trap_delete_run1-last_expr"/><a name="5648"/> 5648: <b>    insert_trap_delete_run2</b>(Traps0-1, Decr, Params, NKeys).
<a name="5649"/> 5649: 
<a name="insert_trap_delete_run2-4"/><a name="5650"/> 5650: <b>insert_trap_delete_run2</b>(Traps, _Decr, Params, NKeys) when Traps =&lt; 1 -&gt;
<a name="5651"/> 5651:     insert_trap_delete_run3(1, Params, NKeys),
<a name="5652"/> 5652:     ok;
<a name="5653"/> 5653: <b>insert_trap_delete_run2</b>(Traps, Decr, Params, NKeys) -&gt;
<a name="5654"/> 5654:     insert_trap_delete_run3(Traps, Params, NKeys),
<a name="insert_trap_delete_run2-last_expr"/><a name="5655"/> 5655: <b>    insert_trap_delete_run2</b>(Traps - Decr, Decr, Params, NKeys).
<a name="5656"/> 5656: 
<a name="insert_trap_delete_run3-3"/><a name="5657"/> 5657: <b>insert_trap_delete_run3</b>(Traps, {Opts, InsertFunc, Mode}, NKeys) -&gt;
<a name="5658"/> 5658:     io:format(&quot;insert_trap_delete_run(~p, ~p, ~p) NKeys=~p\n&quot;,
<a name="5659"/> 5659:               [Traps, InsertFunc, Mode, NKeys]),
<a name="5660"/> 5660:     TabName = insert_trap_delete,
<a name="5661"/> 5661:     Tester = self(),
<a name="5662"/> 5662:     Tuples = [{K} || K &lt;- lists:seq(1,NKeys)],
<a name="5663"/> 5663: 
<a name="5664"/> 5664:     OwnerFun =
<a name="5665"/> 5665:         fun() -&gt;
<a name="5666"/> 5666:                 erlang:trace(Tester, true, [running]),
<a name="5667"/> 5667:                 ets_new(TabName, [named_table, public | Opts]),
<a name="5668"/> 5668:                 Tester ! {ets_new, ets:whereis(TabName)},
<a name="5669"/> 5669:                 io:format(&quot;Wait for ets:~p/2 to yield...\n&quot;, [InsertFunc]),
<a name="5670"/> 5670:                 GotTraps = repeat_while(
<a name="5671"/> 5671:                   fun(N) -&gt;
<a name="5672"/> 5672:                           case receive_any() of
<a name="5673"/> 5673:                               {trace, Tester, out, {ets,InsertFunc,2}} -&gt;
<a name="5674"/> 5674:                                   case N of
<a name="5675"/> 5675:                                       Traps -&gt; {false, Traps};
<a name="5676"/> 5676:                                       _ -&gt; {true, N+1}
<a name="5677"/> 5677:                                   end;
<a name="5678"/> 5678:                               &quot;Insert done&quot; -&gt;
<a name="5679"/> 5679:                                   io:format(&quot;Too late! Got ~p traps\n&quot;, [N]),
<a name="5680"/> 5680:                                   {false, N};
<a name="5681"/> 5681:                               _M -&gt;
<a name="5682"/> 5682:                                   %%io:format(&quot;[~p] Ignored msg: ~p\n&quot;, [N,_M]),
<a name="5683"/> 5683:                                   {true, N}
<a name="5684"/> 5684:                           end
<a name="5685"/> 5685:                   end,
<a name="5686"/> 5686:                   0),
<a name="5687"/> 5687:                 case Mode of
<a name="5688"/> 5688:                     delete -&gt;
<a name="5689"/> 5689:                         io:format(&quot;Delete table and then exit...\n&quot;,[]),
<a name="5690"/> 5690:                         ets:delete(TabName);
<a name="5691"/> 5691:                     exit -&gt;
<a name="5692"/> 5692:                         io:format(&quot;Exit and let table die...\n&quot;,[])
<a name="5693"/> 5693:                 end,
<a name="5694"/> 5694:                 Tester ! {traps, GotTraps}
<a name="5695"/> 5695:         end,
<a name="5696"/> 5696:     {Owner, Mon} = spawn_opt(OwnerFun, [link, monitor]),
<a name="5697"/> 5697: 
<a name="5698"/> 5698:     {ets_new, Tid} = receive_any(),
<a name="5699"/> 5699:     try ets:InsertFunc(TabName, Tuples) of
<a name="5700"/> 5700:         true -&gt;
<a name="5701"/> 5701:             try ets:lookup(Tid, NKeys) of
<a name="5702"/> 5702:                 [{NKeys}] -&gt; ok
<a name="5703"/> 5703:             catch
<a name="5704"/> 5704:                 error:badarg -&gt;
<a name="5705"/> 5705:                     %% Table must been deleted just after insert finished
<a name="5706"/> 5706:                     undefined = ets:info(Tid, id),
<a name="5707"/> 5707:                     undefined = ets:whereis(TabName)
<a name="5708"/> 5708:             end,
<a name="5709"/> 5709:             Owner ! &quot;Insert done&quot;
<a name="5710"/> 5710:     catch
<a name="5711"/> 5711:         error:badarg -&gt;
<a name="5712"/> 5712:             %% Insert failed, table must have been deleted
<a name="5713"/> 5713:             undefined = ets:info(Tid, id),
<a name="5714"/> 5714:             undefined = ets:whereis(TabName)
<a name="5715"/> 5715:     end,
<a name="5716"/> 5716:     {traps, GotTraps} = receive_any(),
<a name="5717"/> 5717:     {'DOWN', Mon, process, Owner, _} = receive_any(),
<a name="5718"/> 5718:     undefined = ets:whereis(TabName),
<a name="5719"/> 5719:     undefined = ets:info(Tid, id),
<a name="insert_trap_delete_run3-last_expr"/><a name="5720"/> 5720:     GotTraps.
<a name="5721"/> 5721: 
<a name="5722"/> 5722: <i>%% Rename table during trapping ets:insert</i>
<a name="insert_trap_rename-1"/><a name="5723"/> 5723: <b>insert_trap_rename</b>(Config) when is_list(Config) -&gt;
<a name="5724"/> 5724:     repeat_for_opts(fun(Opts) -&gt;
<a name="5725"/> 5725:                             [insert_trap_rename_run1(Opts, InsertFunc)
<a name="5726"/> 5726:                              || InsertFunc &lt;- [insert, insert_new]]
<a name="5727"/> 5727:                     end,
<a name="5728"/> 5728:                     [all_non_stim_types, write_concurrency, compressed]),
<a name="insert_trap_rename-last_expr"/><a name="5729"/> 5729:     ok.
<a name="5730"/> 5730: 
<a name="insert_trap_rename_run1-2"/><a name="5731"/> 5731: <b>insert_trap_rename_run1</b>(Opts, InsertFunc) -&gt;
<a name="5732"/> 5732:     NKeys = 50_000 + rand:uniform(50_000),
<a name="5733"/> 5733:     %% First measure how many traps the insert op will do
<a name="5734"/> 5734:     Traps0 = insert_trap_rename_run3(Opts, unlimited, InsertFunc, NKeys),
<a name="5735"/> 5735:     %% Then do again and rename table at different moments
<a name="5736"/> 5736:     Decr = (Traps0 div 5) + 1,
<a name="5737"/> 5737:     insert_trap_rename_run2(Opts, Traps0-1, Decr, InsertFunc, NKeys),
<a name="insert_trap_rename_run1-last_expr"/><a name="5738"/> 5738:     ok.
<a name="5739"/> 5739: 
<a name="insert_trap_rename_run2-5"/><a name="5740"/> 5740: <b>insert_trap_rename_run2</b>(Opts, Traps, _Decr, InsertFunc, NKeys) when Traps =&lt; 1 -&gt;
<a name="5741"/> 5741:     insert_trap_rename_run3(Opts, 1, InsertFunc, NKeys),
<a name="5742"/> 5742:     ok;
<a name="5743"/> 5743: <b>insert_trap_rename_run2</b>(Opts, Traps, Decr, InsertFunc, NKeys) -&gt;
<a name="5744"/> 5744:     insert_trap_rename_run3(Opts, Traps, InsertFunc, NKeys),
<a name="insert_trap_rename_run2-last_expr"/><a name="5745"/> 5745: <b>    insert_trap_rename_run2</b>(Opts, Traps - Decr, Decr, InsertFunc, NKeys).
<a name="5746"/> 5746: 
<a name="5747"/> 5747: 
<a name="insert_trap_rename_run3-4"/><a name="5748"/> 5748: <b>insert_trap_rename_run3</b>(Opts, Traps, InsertFunc, NKeys) -&gt;
<a name="5749"/> 5749:     io:format(&quot;insert_trap_rename_run(~p, ~p)\n&quot;, [Traps, InsertFunc]),
<a name="5750"/> 5750:     TabName = insert_trap_rename,
<a name="5751"/> 5751:     TabRenamed = insert_trap_rename_X,
<a name="5752"/> 5752:     Tester = self(),
<a name="5753"/> 5753:     Tuples = [{K} || K &lt;- lists:seq(1,NKeys)],
<a name="5754"/> 5754: 
<a name="5755"/> 5755:     OwnerFun =
<a name="5756"/> 5756:         fun() -&gt;
<a name="5757"/> 5757:                 erlang:trace(Tester, true, [running]),
<a name="5758"/> 5758:                 ets_new(TabName, [named_table, public | Opts]),
<a name="5759"/> 5759:                 Tester ! {ets_new, ets:whereis(TabName)},
<a name="5760"/> 5760:                 io:format(&quot;Wait for ets:~p/2 to yield...\n&quot;, [InsertFunc]),
<a name="5761"/> 5761:                 GotTraps = repeat_while(
<a name="5762"/> 5762:                   fun(N) -&gt;
<a name="5763"/> 5763:                           case receive_any() of
<a name="5764"/> 5764:                               {trace, Tester, out, {ets,InsertFunc,2}} -&gt;
<a name="5765"/> 5765:                                   case N of
<a name="5766"/> 5766:                                       Traps -&gt; {false, ok};
<a name="5767"/> 5767:                                       _ -&gt; {true, N+1}
<a name="5768"/> 5768:                                   end;
<a name="5769"/> 5769:                               &quot;Insert done&quot; -&gt;
<a name="5770"/> 5770:                                   io:format(&quot;Too late! Got ~p traps\n&quot;, [N]),
<a name="5771"/> 5771:                                   {false, N};
<a name="5772"/> 5772:                               _M -&gt;
<a name="5773"/> 5773:                                   %%io:format(&quot;[~p] Ignored msg: ~p\n&quot;, [N,_M]),
<a name="5774"/> 5774:                                   {true, N}
<a name="5775"/> 5775:                           end
<a name="5776"/> 5776:                   end,
<a name="5777"/> 5777:                   0),
<a name="5778"/> 5778:                 io:format(&quot;Rename table and wait...\n&quot;,[]),
<a name="5779"/> 5779:                 ets:rename(TabName, TabRenamed),
<a name="5780"/> 5780:                 ets:delete(TabRenamed, 42),
<a name="5781"/> 5781:                 Tester ! {renamed, GotTraps},
<a name="5782"/> 5782:                 receive die -&gt; ok end
<a name="5783"/> 5783:         end,
<a name="5784"/> 5784:     {Owner, Mon} = spawn_opt(OwnerFun, [link,monitor]),
<a name="5785"/> 5785: 
<a name="5786"/> 5786:     {ets_new, Tid} = receive_any(),
<a name="5787"/> 5787:     try ets:InsertFunc(TabName, Tuples) of
<a name="5788"/> 5788:         true -&gt;
<a name="5789"/> 5789:             io:format(&quot;ets:~p succeeded\n&quot;, [InsertFunc]),
<a name="5790"/> 5790:             true = ets:member(Tid, 1),
<a name="5791"/> 5791:             true = ets:member(Tid, NKeys)
<a name="5792"/> 5792:     catch
<a name="5793"/> 5793:         error:badarg -&gt;
<a name="5794"/> 5794:             io:format(&quot;ets:~p failed\n&quot;, [InsertFunc]),
<a name="5795"/> 5795:             false = ets:member(Tid, 1),
<a name="5796"/> 5796:             false = ets:member(Tid, NKeys)
<a name="5797"/> 5797:     end,
<a name="5798"/> 5798:     Owner ! &quot;Insert done&quot;,
<a name="5799"/> 5799:     {renamed, GotTraps} = receive_any(),
<a name="5800"/> 5800:     [] = ets:lookup(Tid, 42),
<a name="5801"/> 5801:     undefined = ets:whereis(TabName),
<a name="5802"/> 5802:     Tid = ets:whereis(TabRenamed),
<a name="5803"/> 5803:     Owner ! die,
<a name="5804"/> 5804:     {'DOWN', Mon, process, Owner, _} = receive_any(),
<a name="5805"/> 5805:     undefined = ets:whereis(TabName),
<a name="5806"/> 5806:     undefined = ets:whereis(TabRenamed),
<a name="insert_trap_rename_run3-last_expr"/><a name="5807"/> 5807:     GotTraps.
<a name="5808"/> 5808: 
<a name="5809"/> 5809: 
<a name="test_table_size_concurrency-1"/><a name="5810"/> 5810: <b>test_table_size_concurrency</b>(Config) when is_list(Config) -&gt;
<a name="test_table_size_concurrency-last_expr"/><a name="5811"/> 5811: <b>    case erlang:system_info</b>(schedulers) of
<a name="5812"/> 5812:         1 -&gt; {skip,&quot;Only valid on smp &gt; 1 systems&quot;};
<a name="5813"/> 5813:         _ -&gt;
<a name="5814"/> 5814:             lists:foreach(
<a name="5815"/> 5815:               fun(WriteConcurrencyOpt) -&gt;
<a name="5816"/> 5816:                       BaseOptions = [public, {write_concurrency, WriteConcurrencyOpt}],
<a name="5817"/> 5817:                       test_table_counter_concurrency(size, [set | BaseOptions]),
<a name="5818"/> 5818:                       test_table_counter_concurrency(size, [ordered_set | BaseOptions])
<a name="5819"/> 5819:               end,
<a name="5820"/> 5820:               [true, auto])
<a name="5821"/> 5821:     end.
<a name="5822"/> 5822: 
<a name="test_table_memory_concurrency-1"/><a name="5823"/> 5823: <b>test_table_memory_concurrency</b>(Config) when is_list(Config) -&gt;
<a name="test_table_memory_concurrency-last_expr"/><a name="5824"/> 5824: <b>    case erlang:system_info</b>(schedulers) of
<a name="5825"/> 5825:         1 -&gt; {skip,&quot;Only valid on smp &gt; 1 systems&quot;};
<a name="5826"/> 5826:         _ -&gt;
<a name="5827"/> 5827:             lists:foreach(
<a name="5828"/> 5828:               fun(WriteConcurrencyOpt) -&gt;
<a name="5829"/> 5829:                       BaseOptions = [public, {write_concurrency, WriteConcurrencyOpt}],
<a name="5830"/> 5830:                       test_table_counter_concurrency(memory, [set | BaseOptions]),
<a name="5831"/> 5831:                       test_table_counter_concurrency(memory, [ordered_set | BaseOptions])
<a name="5832"/> 5832:               end,
<a name="5833"/> 5833:               [true, auto])
<a name="5834"/> 5834:     end.
<a name="5835"/> 5835: 
<a name="5836"/> 5836: <i>%% Tests that calling the ets:delete operation on a table T with</i>
<a name="5837"/> 5837: <i>%% decentralized counters works while ets:info(T, size) operations are</i>
<a name="5838"/> 5838: <i>%% active</i>
<a name="test_delete_table_while_size_snapshot-1"/><a name="5839"/> 5839: <b>test_delete_table_while_size_snapshot</b>(Config) when is_list(Config) -&gt;
<a name="5840"/> 5840:     %% Run test case in a slave node as other test suites in stdlib
<a name="5841"/> 5841:     %% depend on that pids are ordered in creation order which is no
<a name="5842"/> 5842:     %% longer the case when many processes have been started before
<a name="5843"/> 5843:     {ok, Peer, Node} = ?CT_PEER(),
<a name="5844"/> 5844:     [ok = rpc:call(Node,
<a name="5845"/> 5845:                    ?MODULE,
<a name="5846"/> 5846:                    test_delete_table_while_size_snapshot_helper,
<a name="5847"/> 5847:                    [TableType])
<a name="5848"/> 5848:      || TableType &lt;- [set, ordered_set]],
<a name="5849"/> 5849:     peer:stop(Peer),
<a name="test_delete_table_while_size_snapshot-last_expr"/><a name="5850"/> 5850:     ok.
<a name="5851"/> 5851: 
<a name="test_delete_table_while_size_snapshot_helper-1"/><a name="5852"/> 5852: <b>test_delete_table_while_size_snapshot_helper</b>(TableType) -&gt;
<a name="5853"/> 5853:     TopParent = self(),
<a name="5854"/> 5854:     repeat_par(
<a name="5855"/> 5855:       fun() -&gt;
<a name="5856"/> 5856:               Table = ets:new(t, [public, TableType,
<a name="5857"/> 5857:                                   {decentralized_counters, true},
<a name="5858"/> 5858:                                   {write_concurrency, true}]),
<a name="5859"/> 5859:               Parent = self(),
<a name="5860"/> 5860:               NrOfSizeProcs = 100,
<a name="5861"/> 5861:               Pids = [ spawn(fun()-&gt; size_process(Table, Parent) end)
<a name="5862"/> 5862:                        || _ &lt;- lists:seq(1, NrOfSizeProcs)],
<a name="5863"/> 5863:               timer:sleep(1),
<a name="5864"/> 5864:               ets:delete(Table),
<a name="5865"/> 5865:               [receive
<a name="5866"/> 5866:                    table_gone -&gt;  ok;
<a name="5867"/> 5867:                    Problem -&gt; TopParent ! Problem
<a name="5868"/> 5868:                end || _ &lt;- Pids]
<a name="5869"/> 5869:       end,
<a name="5870"/> 5870:       100*erlang:system_info(schedulers_online)),
<a name="test_delete_table_while_size_snapshot_helper-last_expr"/><a name="5871"/> 5871:     receive
<a name="5872"/> 5872:         Problem -&gt; throw(Problem)
<a name="5873"/> 5873:     after 0 -&gt; ok
<a name="5874"/> 5874:     end.
<a name="5875"/> 5875: 
<a name="size_process-2"/><a name="5876"/> 5876: <b>size_process</b>(Table, Parent) -&gt;
<a name="size_process-last_expr"/><a name="5877"/> 5877: <b>    try ets:info</b>(Table, size) of
<a name="5878"/> 5878:         N when is_integer(N) -&gt;
<a name="5879"/> 5879:             size_process(Table, Parent);
<a name="5880"/> 5880:         undefined -&gt; Parent ! table_gone;
<a name="5881"/> 5881:         E -&gt; Parent ! {got_unexpected, E}
<a name="5882"/> 5882:     catch
<a name="5883"/> 5883:         E -&gt; Parent ! {got_unexpected_exception, E}
<a name="5884"/> 5884:     end.
<a name="5885"/> 5885: 
<a name="repeat_par-2"/><a name="5886"/> 5886: <b>repeat_par</b>(FunToRepeat, NrOfTimes) -&gt;
<a name="repeat_par-last_expr"/><a name="5887"/> 5887: <b>    repeat_par_help</b>(FunToRepeat, NrOfTimes, NrOfTimes).
<a name="5888"/> 5888: 
<a name="repeat_par_help-3"/><a name="5889"/> 5889: <b>repeat_par_help</b>(_FunToRepeat, 0, OrgNrOfTimes) -&gt;
<a name="5890"/> 5890:     repeat(fun()-&gt; receive done -&gt; ok end end, OrgNrOfTimes);
<a name="5891"/> 5891: <b>repeat_par_help</b>(FunToRepeat, NrOfTimes, OrgNrOfTimes) -&gt;
<a name="5892"/> 5892:     Parent = self(),
<a name="5893"/> 5893:     case NrOfTimes rem 5 of
<a name="5894"/> 5894:         0 -&gt; timer:sleep(1);
<a name="5895"/> 5895:         _ -&gt; ok
<a name="5896"/> 5896:     end,
<a name="5897"/> 5897:     spawn(fun()-&gt;
<a name="5898"/> 5898:                   FunToRepeat(),
<a name="5899"/> 5899:                   Parent ! done
<a name="5900"/> 5900:           end),
<a name="repeat_par_help-last_expr"/><a name="5901"/> 5901: <b>    repeat_par_help</b>(FunToRepeat, NrOfTimes-1, OrgNrOfTimes).
<a name="5902"/> 5902: 
<a name="test_decentralized_counters_setting-1"/><a name="5903"/> 5903: <b>test_decentralized_counters_setting</b>(Config) when is_list(Config) -&gt;
<a name="test_decentralized_counters_setting-last_expr"/><a name="5904"/> 5904: <b>    case erlang:system_info</b>(schedulers) of
<a name="5905"/> 5905:         1 -&gt; {skip,&quot;Only relevant when the number of shedulers &gt; 1&quot;};
<a name="5906"/> 5906:         _ -&gt; EtsMem = etsmem(),
<a name="5907"/> 5907:              do_test_decentralized_counters_setting(set),
<a name="5908"/> 5908:              do_test_decentralized_counters_setting(ordered_set),
<a name="5909"/> 5909:              do_test_decentralized_counters_default_setting(),
<a name="5910"/> 5910:              verify_etsmem(EtsMem)
<a name="5911"/> 5911:     end.
<a name="5912"/> 5912: 
<a name="do_test_decentralized_counters_setting-1"/><a name="5913"/> 5913: <b>do_test_decentralized_counters_setting</b>(TableType) -&gt;
<a name="5914"/> 5914:     wait_for_memory_deallocations(),
<a name="5915"/> 5915:     FlxCtrMemUsage = erts_debug:get_internal_state(flxctr_memory_usage),
<a name="5916"/> 5916:     FixOptsList =
<a name="5917"/> 5917:         fun(Opts) -&gt;
<a name="5918"/> 5918:                 case TableType of
<a name="5919"/> 5919:                     ordered_set -&gt;
<a name="5920"/> 5920:                         replace_dbg_hash_fixed_nr_of_locks(Opts);
<a name="5921"/> 5921:                     set -&gt;
<a name="5922"/> 5922:                         Opts
<a name="5923"/> 5923:                 end
<a name="5924"/> 5924:         end,
<a name="5925"/> 5925:     lists:foreach(
<a name="5926"/> 5926:       fun(OptList) -&gt;
<a name="5927"/> 5927:               T1 = ets:new(t1, FixOptsList([public, TableType] ++ OptList ++ [TableType])),
<a name="5928"/> 5928:               check_decentralized_counters(T1, false, FlxCtrMemUsage),
<a name="5929"/> 5929:               ets:delete(T1)
<a name="5930"/> 5930:       end,
<a name="5931"/> 5931:       [[{write_concurrency, false}]] ++
<a name="5932"/> 5932:           case TableType of
<a name="5933"/> 5933:               set -&gt;
<a name="5934"/> 5934:                   [[{write_concurrency, true}, {decentralized_counters, false}],
<a name="5935"/> 5935:                    [{write_concurrency, {debug_hash_fixed_number_of_locks, 1024}}, {write_concurrency, true}]];
<a name="5936"/> 5936:               ordered_set -&gt; []
<a name="5937"/> 5937:           end),
<a name="5938"/> 5938:     lists:foreach(
<a name="5939"/> 5939:       fun(OptList) -&gt;
<a name="5940"/> 5940:               T1 = ets:new(t1,
<a name="5941"/> 5941:                            FixOptsList([public,
<a name="5942"/> 5942:                                         TableType,
<a name="5943"/> 5943:                                         {write_concurrency, true}] ++ OptList ++ [TableType])),
<a name="5944"/> 5944:               check_decentralized_counters(T1, true, FlxCtrMemUsage),
<a name="5945"/> 5945:               ets:delete(T1),
<a name="5946"/> 5946:               wait_for_memory_deallocations(),
<a name="5947"/> 5947:               FlxCtrMemUsage = erts_debug:get_internal_state(flxctr_memory_usage)
<a name="5948"/> 5948:       end,
<a name="5949"/> 5949:       [[{decentralized_counters, true}],
<a name="5950"/> 5950:        [{write_concurrency, {debug_hash_fixed_number_of_locks, 1024}}],
<a name="5951"/> 5951:        [{write_concurrency, auto}]]),
<a name="do_test_decentralized_counters_setting-last_expr"/><a name="5952"/> 5952:     ok.
<a name="5953"/> 5953: 
<a name="do_test_decentralized_counters_default_setting-0"/><a name="5954"/> 5954: <b>do_test_decentralized_counters_default_setting</b>() -&gt;
<a name="5955"/> 5955:     wait_for_memory_deallocations(),
<a name="5956"/> 5956:     FlxCtrMemUsage = erts_debug:get_internal_state(flxctr_memory_usage),
<a name="5957"/> 5957:     Set = ets:new(t1, [public, {write_concurrency, true}]),
<a name="5958"/> 5958:     check_decentralized_counters(Set, false, FlxCtrMemUsage),
<a name="5959"/> 5959:     ets:delete(Set),
<a name="5960"/> 5960:     Set2 = ets:new(t1, [public, set, {write_concurrency, true}]),
<a name="5961"/> 5961:     check_decentralized_counters(Set2, false, FlxCtrMemUsage),
<a name="5962"/> 5962:     ets:delete(Set2),
<a name="5963"/> 5963:     OrdSet = ets:new(t1, [public, ordered_set, {write_concurrency, true}]),
<a name="5964"/> 5964:     check_decentralized_counters(OrdSet, true, FlxCtrMemUsage),
<a name="5965"/> 5965:     ets:delete(OrdSet),
<a name="do_test_decentralized_counters_default_setting-last_expr"/><a name="5966"/> 5966:     ok.
<a name="5967"/> 5967: 
<a name="check_decentralized_counters-3"/><a name="5968"/> 5968: <b>check_decentralized_counters</b>(T, ExpectedState, InitMemUsage) -&gt;
<a name="5969"/> 5969:     case {ExpectedState, erts_debug:get_internal_state(flxctr_memory_usage)} of
<a name="5970"/> 5970:         {false, notsup} -&gt; ok;
<a name="5971"/> 5971:         {false, X} -&gt; InitMemUsage = X;
<a name="5972"/> 5972:         {true, notsup} -&gt; ok;
<a name="5973"/> 5973:         {true, X} when X &gt; InitMemUsage -&gt; ok;
<a name="5974"/> 5974:         {true, _} -&gt; ct:fail(&quot;Decentralized counter not used.&quot;)
<a name="5975"/> 5975:     end,
<a name="check_decentralized_counters-last_expr"/><a name="5976"/> 5976: <b>    ExpectedState = ets:info</b>(T, decentralized_counters).
<a name="5977"/> 5977: 
<a name="5978"/> 5978: <i>%% Test various duplicate_bags stuff.</i>
<a name="dups-1"/><a name="5979"/> 5979: <b>dups</b>(Config) when is_list(Config) -&gt;
<a name="dups-last_expr"/><a name="5980"/> 5980: <b>    repeat_for_opts</b>(fun dups_do/1).
<a name="5981"/> 5981: 
<a name="dups_do-1"/><a name="5982"/> 5982: <b>dups_do</b>(Opts) -&gt;
<a name="5983"/> 5983:     EtsMem = etsmem(),
<a name="5984"/> 5984:     T = make_table(funky,
<a name="5985"/> 5985: 		   [duplicate_bag | Opts],
<a name="5986"/> 5986: 		   [{1, 2}, {1, 2}]),
<a name="5987"/> 5987:     2 = length(ets:tab2list(T)),
<a name="5988"/> 5988:     ets:delete(T, 1),
<a name="5989"/> 5989:     [] = ets:lookup(T, 1),
<a name="5990"/> 5990: 
<a name="5991"/> 5991:     ets:insert(T, {1, 2, 2}),
<a name="5992"/> 5992:     ets:insert(T, {1, 2, 4}),
<a name="5993"/> 5993:     ets:insert(T, {1, 2, 2}),
<a name="5994"/> 5994:     ets:insert(T, {1, 2, 2}),
<a name="5995"/> 5995:     ets:insert(T, {1, 2, 4}),
<a name="5996"/> 5996: 
<a name="5997"/> 5997:     5 = length(ets:tab2list(T)),
<a name="5998"/> 5998: 
<a name="5999"/> 5999:     5 = length(ets:match(T, {'$1', 2, '$2'})),
<a name="6000"/> 6000:     3 = length(ets:match(T, {'_', '$1', '$1'})),
<a name="6001"/> 6001:     ets:match_delete(T, {'_', '$1', '$1'}),
<a name="6002"/> 6002:     0 = length(ets:match(T, {'_', '$1', '$1'})),
<a name="6003"/> 6003:     ets:delete(T),
<a name="dups_do-last_expr"/><a name="6004"/> 6004: <b>    verify_etsmem</b>(EtsMem).
<a name="6005"/> 6005: 
<a name="6006"/> 6006: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="6007"/> 6007: 
<a name="6008"/> 6008: <i>%% Test the ets:tab2file function on an empty ets table.</i>
<a name="tab2file-1"/><a name="6009"/> 6009: <b>tab2file</b>(Config) when is_list(Config) -&gt;
<a name="6010"/> 6010:     FName = filename:join([proplists:get_value(priv_dir, Config),&quot;tab2file_case&quot;]),
<a name="6011"/> 6011:     tab2file_do(FName, [], set),
<a name="6012"/> 6012:     tab2file_do(FName, [], ordered_set),
<a name="6013"/> 6013:     tab2file_do(FName, [], cat_ord_set),
<a name="6014"/> 6014:     tab2file_do(FName, [], stim_cat_ord_set),
<a name="6015"/> 6015:     tab2file_do(FName, [{sync,true}], set),
<a name="6016"/> 6016:     tab2file_do(FName, [{sync,false}], set),
<a name="6017"/> 6017:     {'EXIT',{{badmatch,{error,_}},_}} = (catch tab2file_do(FName, [{sync,yes}], set)),
<a name="6018"/> 6018:     {'EXIT',{{badmatch,{error,_}},_}} = (catch tab2file_do(FName, [sync], set)),
<a name="tab2file-last_expr"/><a name="6019"/> 6019:     ok.
<a name="6020"/> 6020: 
<a name="tab2file_do-3"/><a name="6021"/> 6021: <b>tab2file_do</b>(FName, Opts, TableType) -&gt;
<a name="6022"/> 6022:     %% Write an empty ets table to a file, read back and check properties.
<a name="6023"/> 6023:     Tab = ets_new(ets_SUITE_foo_tab, [named_table, TableType, public,
<a name="6024"/> 6024: 				      {keypos, 2},
<a name="6025"/> 6025: 				      compressed,
<a name="6026"/> 6026: 				      {write_concurrency,true},
<a name="6027"/> 6027: 				      {read_concurrency,true}]),
<a name="6028"/> 6028:     ActualTableType =
<a name="6029"/> 6029:         case TableType of
<a name="6030"/> 6030:             cat_ord_set -&gt; ordered_set;
<a name="6031"/> 6031:             stim_cat_ord_set -&gt; ordered_set;
<a name="6032"/> 6032:             _ -&gt; TableType
<a name="6033"/> 6033:         end,
<a name="6034"/> 6034:     catch file:delete(FName),
<a name="6035"/> 6035:     Res = ets:tab2file(Tab, FName, Opts),
<a name="6036"/> 6036:     true = ets:delete(Tab),
<a name="6037"/> 6037:     ok = Res,
<a name="6038"/> 6038:     %%
<a name="6039"/> 6039:     EtsMem = etsmem(),
<a name="6040"/> 6040:     {ok, Tab2} = ets:file2tab(FName),
<a name="6041"/> 6041:     public = ets:info(Tab2, protection),
<a name="6042"/> 6042:     true = ets:info(Tab2, named_table),
<a name="6043"/> 6043:     2 = ets:info(Tab2, keypos),
<a name="6044"/> 6044:     ActualTableType = ets:info(Tab2, type),
<a name="6045"/> 6045:     true = ets:info(Tab2, compressed),
<a name="6046"/> 6046:     Smp = erlang:system_info(smp_support),
<a name="6047"/> 6047:     Smp = ets:info(Tab2, read_concurrency),
<a name="6048"/> 6048:     Smp = ets:info(Tab2, write_concurrency) orelse erlang:system_info(schedulers) == 1,
<a name="6049"/> 6049:     true = ets:delete(Tab2),
<a name="tab2file_do-last_expr"/><a name="6050"/> 6050: <b>    verify_etsmem</b>(EtsMem).
<a name="6051"/> 6051: 
<a name="6052"/> 6052: 
<a name="6053"/> 6053: <i>%% Check the ets:tab2file function on a filled set/bag type ets table.</i>
<a name="tab2file2-1"/><a name="6054"/> 6054: <b>tab2file2</b>(Config) when is_list(Config) -&gt;
<a name="tab2file2-last_expr"/><a name="6055"/> 6055: <b>    repeat_for_opts</b>(fun(Opts) -&gt;
<a name="6056"/> 6056:                             tab2file2_do(Opts, Config)
<a name="6057"/> 6057:                     end, [[stim_cat_ord_set,cat_ord_set,set,bag],compressed]).
<a name="6058"/> 6058: 
<a name="tab2file2_do-2"/><a name="6059"/> 6059: <b>tab2file2_do</b>(Opts, Config) -&gt;
<a name="6060"/> 6060:     EtsMem = etsmem(),
<a name="6061"/> 6061:     KeyRange = 10000,
<a name="6062"/> 6062:     Tab = ets_new(ets_SUITE_foo_tab, [named_table, private, {keypos, 2} | Opts],
<a name="6063"/> 6063:                   KeyRange),
<a name="6064"/> 6064:     FName = filename:join([proplists:get_value(priv_dir, Config),&quot;tab2file2_case&quot;]),
<a name="6065"/> 6065:     ok = fill_tab2(Tab, 0, KeyRange),   % Fill up the table (grucho mucho!)
<a name="6066"/> 6066:     Len = length(ets:tab2list(Tab)),
<a name="6067"/> 6067:     Mem = ets:info(Tab, memory),
<a name="6068"/> 6068:     Type = ets:info(Tab, type),
<a name="6069"/> 6069:     %%io:format(&quot;org tab: ~p\n&quot;,[ets:info(Tab)]),
<a name="6070"/> 6070:     ok = ets:tab2file(Tab, FName),
<a name="6071"/> 6071:     true = ets:delete(Tab),
<a name="6072"/> 6072: 
<a name="6073"/> 6073:     EtsMem4 = etsmem(),
<a name="6074"/> 6074: 
<a name="6075"/> 6075:     {ok, Tab2} = ets:file2tab(FName),
<a name="6076"/> 6076:     %%io:format(&quot;loaded tab: ~p\n&quot;,[ets:info(Tab2)]),
<a name="6077"/> 6077:     private = ets:info(Tab2, protection),
<a name="6078"/> 6078:     true = ets:info(Tab2, named_table),
<a name="6079"/> 6079:     2 = ets:info(Tab2, keypos),
<a name="6080"/> 6080:     Type = ets:info(Tab2, type),
<a name="6081"/> 6081:     Len = length(ets:tab2list(Tab2)),
<a name="6082"/> 6082:     Mem = ets:info(Tab2, memory),
<a name="6083"/> 6083:     true = ets:delete(Tab2),
<a name="6084"/> 6084:     io:format(&quot;Between = ~p\n&quot;, [EtsMem4]),
<a name="tab2file2_do-last_expr"/><a name="6085"/> 6085: <b>    verify_etsmem</b>(EtsMem).
<a name="6086"/> 6086: 
<a name="6087"/> 6087: <b>-define</b>(test_list, [8,5,4,1,58,125,255, 250, 245, 240, 235,
<a name="6088"/> 6088: 		    230, Num rem 255, 255, 125, 130, 135, 140, 145,
<a name="6089"/> 6089: 		    150, 134, 12, 54, Val rem 255, 12, 3, 6, 9, 126]).
<a name="6090"/> 6090: <b>-define</b>(big_test_list, [Num rem 256|lists:seq(1, 66)]).
<a name="6091"/> 6091: <b>-define</b>(test_integer, 2846287468+Num).
<a name="6092"/> 6092: <b>-define</b>(test_float, 187263.18236-Val).
<a name="6093"/> 6093: <b>-define</b>(test_atom, some_crazy_atom).
<a name="6094"/> 6094: <b>-define</b>(test_tuple, {just, 'Some', 'Tuple', 1, [list, item], Val+Num}).
<a name="6095"/> 6095: 
<a name="6096"/> 6096: <i>%% Insert different datatypes into a ets table.</i>
<a name="fill_tab2-3"/><a name="6097"/> 6097: <b>fill_tab2</b>(_Tab, _Val, 0) -&gt;
<a name="6098"/> 6098:     ok;
<a name="6099"/> 6099: <b>fill_tab2</b>(Tab, Val, Num) -&gt;
<a name="6100"/> 6100:     Item =
<a name="6101"/> 6101: 	case Num rem 10 of
<a name="6102"/> 6102: 	    0 -&gt; &quot;String&quot;;
<a name="6103"/> 6103: 	    1 -&gt; ?test_atom;
<a name="6104"/> 6104: 	    2 -&gt; ?test_tuple;
<a name="6105"/> 6105: 	    3 -&gt; ?test_integer;
<a name="6106"/> 6106: 	    4 -&gt; ?test_float;
<a name="6107"/> 6107: 	    5 -&gt; list_to_binary(?test_list); %Heap binary
<a name="6108"/> 6108: 	    6 -&gt; list_to_binary(?big_test_list); %Refc binary
<a name="6109"/> 6109: 	    7 -&gt; make_sub_binary(?test_list, Num); %Sub binary
<a name="6110"/> 6110: 	    8 -&gt; ?test_list;
<a name="6111"/> 6111: 	    9 -&gt; fun(X) -&gt; {Tab,Val,X*Num} end
<a name="6112"/> 6112: 	end,
<a name="6113"/> 6113:     true=ets:insert(Tab, {Item, Val}),
<a name="6114"/> 6114:     fill_tab2(Tab, Val+1, Num-1),
<a name="fill_tab2-last_expr"/><a name="6115"/> 6115:     ok.
<a name="6116"/> 6116: 
<a name="6117"/> 6117: <i>%% Test verification of tables with object count extended_info.</i>
<a name="tabfile_ext1-1"/><a name="6118"/> 6118: <b>tabfile_ext1</b>(Config) when is_list(Config) -&gt;
<a name="tabfile_ext1-last_expr"/><a name="6119"/> 6119: <b>    repeat_for_opts_all_set_table_types</b>(fun(Opts) -&gt; tabfile_ext1_do(Opts, Config) end).
<a name="6120"/> 6120: 
<a name="tabfile_ext1_do-2"/><a name="6121"/> 6121: <b>tabfile_ext1_do</b>(Opts,Config) -&gt;
<a name="6122"/> 6122:     FName = filename:join([proplists:get_value(priv_dir, Config),&quot;nisse.dat&quot;]),
<a name="6123"/> 6123:     FName2 = filename:join([proplists:get_value(priv_dir, Config),&quot;countflip.dat&quot;]),
<a name="6124"/> 6124:     KeyRange = 10,
<a name="6125"/> 6125:     L = lists:seq(1,KeyRange),
<a name="6126"/> 6126:     T = ets_new(x,Opts,KeyRange),
<a name="6127"/> 6127:     Name = make_ref(),
<a name="6128"/> 6128:     [ets:insert(T,{X,integer_to_list(X)}) || X &lt;- L],
<a name="6129"/> 6129:     ok = ets:tab2file(T,FName,[{extended_info,[object_count]}]),
<a name="6130"/> 6130:     true = lists:sort(ets:tab2list(T)) =:=
<a name="6131"/> 6131: 	lists:sort(ets:tab2list(element(2,ets:file2tab(FName)))),
<a name="6132"/> 6132:     true = lists:sort(ets:tab2list(T)) =:=
<a name="6133"/> 6133: 	lists:sort(ets:tab2list(
<a name="6134"/> 6134: 		     element(2,ets:file2tab(FName,[{verify,true}])))),
<a name="6135"/> 6135:     {ok,Name} = disk_log:open([{name,Name},{file,FName}]),
<a name="6136"/> 6136:     {_,[H0|T0]} = disk_log:chunk(Name,start),
<a name="6137"/> 6137:     disk_log:close(Name),
<a name="6138"/> 6138:     LH0=tuple_to_list(H0),
<a name="6139"/> 6139:     {value,{size,N}}=lists:keysearch(size,1,LH0),
<a name="6140"/> 6140:     NewLH0 = lists:keyreplace(size,1,LH0,{size,N-1}),
<a name="6141"/> 6141:     NewH0 = list_to_tuple(NewLH0),
<a name="6142"/> 6142:     NewT0=lists:keydelete(8,1,T0),
<a name="6143"/> 6143:     file:delete(FName2),
<a name="6144"/> 6144:     disk_log:open([{name,Name},{file,FName2},{mode,read_write}]),
<a name="6145"/> 6145:     disk_log:log_terms(Name,[NewH0|NewT0]),
<a name="6146"/> 6146:     disk_log:close(Name),
<a name="6147"/> 6147:     9 = length(ets:tab2list(element(2,ets:file2tab(FName2)))),
<a name="6148"/> 6148:     {error,invalid_object_count} = ets:file2tab(FName2,[{verify,true}]),
<a name="6149"/> 6149:     {ok, _} = ets:tabfile_info(FName2),
<a name="6150"/> 6150:     {ok, _} = ets:tabfile_info(FName),
<a name="6151"/> 6151:     file:delete(FName),
<a name="6152"/> 6152:     file:delete(FName2),
<a name="tabfile_ext1_do-last_expr"/><a name="6153"/> 6153:     ok.
<a name="6154"/> 6154: 
<a name="6155"/> 6155: 
<a name="6156"/> 6156: <i>%% Test verification of tables with md5sum extended_info.</i>
<a name="tabfile_ext2-1"/><a name="6157"/> 6157: <b>tabfile_ext2</b>(Config) when is_list(Config) -&gt;
<a name="tabfile_ext2-last_expr"/><a name="6158"/> 6158: <b>    repeat_for_opts_all_set_table_types</b>(fun(Opts) -&gt; tabfile_ext2_do(Opts,Config) end).
<a name="6159"/> 6159: 
<a name="tabfile_ext2_do-2"/><a name="6160"/> 6160: <b>tabfile_ext2_do</b>(Opts,Config) -&gt;
<a name="6161"/> 6161:     FName = filename:join([proplists:get_value(priv_dir, Config),&quot;olle.dat&quot;]),
<a name="6162"/> 6162:     FName2 = filename:join([proplists:get_value(priv_dir, Config),&quot;bitflip.dat&quot;]),
<a name="6163"/> 6163:     KeyRange = 10,
<a name="6164"/> 6164:     L = lists:seq(1, KeyRange),
<a name="6165"/> 6165:     T = ets_new(x, Opts, KeyRange),
<a name="6166"/> 6166:     Name = make_ref(),
<a name="6167"/> 6167:     [ets:insert(T,{X,integer_to_list(X)}) || X &lt;- L],
<a name="6168"/> 6168:     ok = ets:tab2file(T,FName,[{extended_info,[md5sum]}]),
<a name="6169"/> 6169:     true = lists:sort(ets:tab2list(T)) =:=
<a name="6170"/> 6170: 	lists:sort(ets:tab2list(element(2,ets:file2tab(FName)))),
<a name="6171"/> 6171:     true = lists:sort(ets:tab2list(T)) =:=
<a name="6172"/> 6172: 	lists:sort(ets:tab2list(
<a name="6173"/> 6173: 		     element(2,ets:file2tab(FName,[{verify,true}])))),
<a name="6174"/> 6174:     {ok, Name} = disk_log:open([{name,Name},{file,FName}]),
<a name="6175"/> 6175:     {_,[H1|T1]} = disk_log:chunk(Name,start),
<a name="6176"/> 6176:     disk_log:close(Name),
<a name="6177"/> 6177:     NewT1=lists:keyreplace(8,1,T1,{8,&quot;9&quot;}),
<a name="6178"/> 6178:     file:delete(FName2),
<a name="6179"/> 6179:     disk_log:open([{name,Name},{file,FName2},{mode,read_write}]),
<a name="6180"/> 6180:     disk_log:log_terms(Name,[H1|NewT1]),
<a name="6181"/> 6181:     disk_log:close(Name),
<a name="6182"/> 6182:     {value,{8,&quot;9&quot;}} = lists:keysearch(8,1,
<a name="6183"/> 6183: 				      ets:tab2list(
<a name="6184"/> 6184: 					element(2,ets:file2tab(FName2)))),
<a name="6185"/> 6185:     {error,checksum_error} = ets:file2tab(FName2,[{verify,true}]),
<a name="6186"/> 6186:     {value,{extended_info,[md5sum]}} =
<a name="6187"/> 6187: 	lists:keysearch(extended_info,1,element(2,ets:tabfile_info(FName2))),
<a name="6188"/> 6188:     {value,{extended_info,[md5sum]}} =
<a name="6189"/> 6189: 	lists:keysearch(extended_info,1,element(2,ets:tabfile_info(FName))),
<a name="6190"/> 6190:     file:delete(FName),
<a name="6191"/> 6191:     file:delete(FName2),
<a name="tabfile_ext2_do-last_expr"/><a name="6192"/> 6192:     ok.
<a name="6193"/> 6193: 
<a name="6194"/> 6194: <i>%% Test verification of (named) tables without extended info.</i>
<a name="tabfile_ext3-1"/><a name="6195"/> 6195: <b>tabfile_ext3</b>(Config) when is_list(Config) -&gt;
<a name="6196"/> 6196:     repeat_for_all_set_table_types(
<a name="6197"/> 6197:       fun(Opts) -&gt;
<a name="6198"/> 6198:               FName = filename:join([proplists:get_value(priv_dir, Config),&quot;namn.dat&quot;]),
<a name="6199"/> 6199:               FName2 = filename:join([proplists:get_value(priv_dir, Config),&quot;ncountflip.dat&quot;]),
<a name="6200"/> 6200:               L = lists:seq(1,10),
<a name="6201"/> 6201:               Name = make_ref(),
<a name="6202"/> 6202:               ?MODULE = ets_new(?MODULE,[named_table|Opts]),
<a name="6203"/> 6203:               [ets:insert(?MODULE,{X,integer_to_list(X)}) || X &lt;- L],
<a name="6204"/> 6204:               ets:tab2file(?MODULE,FName),
<a name="6205"/> 6205:               {error,cannot_create_table} = ets:file2tab(FName),
<a name="6206"/> 6206:               true = ets:delete(?MODULE),
<a name="6207"/> 6207:               {ok,?MODULE} = ets:file2tab(FName),
<a name="6208"/> 6208:               true = ets:delete(?MODULE),
<a name="6209"/> 6209:               disk_log:open([{name,Name},{file,FName}]),
<a name="6210"/> 6210:               {_,[H2|T2]} = disk_log:chunk(Name,start),
<a name="6211"/> 6211:               disk_log:close(Name),
<a name="6212"/> 6212:               NewT2=lists:keydelete(8,1,T2),
<a name="6213"/> 6213:               file:delete(FName2),
<a name="6214"/> 6214:               disk_log:open([{name,Name},{file,FName2},{mode,read_write}]),
<a name="6215"/> 6215:               disk_log:log_terms(Name,[H2|NewT2]),
<a name="6216"/> 6216:               disk_log:close(Name),
<a name="6217"/> 6217:               9 = length(ets:tab2list(element(2,ets:file2tab(FName2)))),
<a name="6218"/> 6218:               true = ets:delete(?MODULE),
<a name="6219"/> 6219:               {error,invalid_object_count} = ets:file2tab(FName2,[{verify,true}]),
<a name="6220"/> 6220:               {'EXIT',_} = (catch ets:delete(?MODULE)),
<a name="6221"/> 6221:               {ok,_} = ets:tabfile_info(FName2),
<a name="6222"/> 6222:               {ok,_} = ets:tabfile_info(FName),
<a name="6223"/> 6223:               file:delete(FName),
<a name="6224"/> 6224:               file:delete(FName2)
<a name="6225"/> 6225:       end),
<a name="tabfile_ext3-last_expr"/><a name="6226"/> 6226:     ok.
<a name="6227"/> 6227: 
<a name="6228"/> 6228: <i>%% Tests verification of large table with md5 sum.</i>
<a name="tabfile_ext4-1"/><a name="6229"/> 6229: <b>tabfile_ext4</b>(Config) when is_list(Config) -&gt;
<a name="6230"/> 6230:     repeat_for_all_set_table_types(
<a name="6231"/> 6231:       fun(Opts) -&gt;
<a name="6232"/> 6232:               FName = filename:join([proplists:get_value(priv_dir, Config),&quot;bauta.dat&quot;]),
<a name="6233"/> 6233:               LL = lists:seq(1,10000),
<a name="6234"/> 6234:               TL = ets_new(x,Opts),
<a name="6235"/> 6235:               Name2 = make_ref(),
<a name="6236"/> 6236:               [ets:insert(TL,{X,integer_to_list(X)}) || X &lt;- LL],
<a name="6237"/> 6237:               ok = ets:tab2file(TL,FName,[{extended_info,[md5sum]}]),
<a name="6238"/> 6238:               {ok, Name2} = disk_log:open([{name, Name2}, {file, FName},
<a name="6239"/> 6239:                                            {mode, read_only}]),
<a name="6240"/> 6240:               {C,[_|_]} = disk_log:chunk(Name2,start),
<a name="6241"/> 6241:               {_,[_|_]} = disk_log:chunk(Name2,C),
<a name="6242"/> 6242:               disk_log:close(Name2),
<a name="6243"/> 6243:               true = lists:sort(ets:tab2list(TL)) =:=
<a name="6244"/> 6244:                   lists:sort(ets:tab2list(element(2,ets:file2tab(FName)))),
<a name="6245"/> 6245:               Res = [begin
<a name="6246"/> 6246:                          {ok,FD} = file:open(FName,[binary,read,write]),
<a name="6247"/> 6247:                          {ok, Bin} = file:pread(FD,0,1000),
<a name="6248"/> 6248:                          &lt;&lt;B1:N/binary,Ch:8,B2/binary&gt;&gt; = Bin,
<a name="6249"/> 6249:                          Ch2 = (Ch + 1) rem 255,
<a name="6250"/> 6250:                          Bin2 = &lt;&lt;B1/binary,Ch2:8,B2/binary&gt;&gt;,
<a name="6251"/> 6251:                          ok = file:pwrite(FD,0,Bin2),
<a name="6252"/> 6252:                          ok = file:close(FD),
<a name="6253"/> 6253:                          X = case ets:file2tab(FName) of
<a name="6254"/> 6254:                                  {ok,TL2} -&gt;
<a name="6255"/> 6255:                                      true = lists:sort(ets:tab2list(TL)) =/=
<a name="6256"/> 6256:                                          lists:sort(ets:tab2list(TL2));
<a name="6257"/> 6257:                                  _ -&gt;
<a name="6258"/> 6258:                                      totally_broken
<a name="6259"/> 6259:                              end,
<a name="6260"/> 6260:                          {error,Y} = ets:file2tab(FName,[{verify,true}]),
<a name="6261"/> 6261:                          ets:tab2file(TL,FName,[{extended_info,[md5sum]}]),
<a name="6262"/> 6262:                          {X,Y}
<a name="6263"/> 6263:                      end || N &lt;- lists:seq(700,800)],
<a name="6264"/> 6264:               io:format(&quot;~p~n&quot;,[Res]),
<a name="6265"/> 6265:               file:delete(FName)
<a name="6266"/> 6266:       end),
<a name="tabfile_ext4-last_expr"/><a name="6267"/> 6267:     ok.
<a name="6268"/> 6268: 
<a name="6269"/> 6269: <i>%% Test that no disk_log is left open when file has been corrupted.</i>
<a name="badfile-1"/><a name="6270"/> 6270: <b>badfile</b>(Config) when is_list(Config) -&gt;
<a name="6271"/> 6271:     PrivDir = proplists:get_value(priv_dir,Config),
<a name="6272"/> 6272:     File = filename:join(PrivDir, &quot;badfile&quot;),
<a name="6273"/> 6273:     _ = file:delete(File),
<a name="6274"/> 6274:     T = ets:new(table, []),
<a name="6275"/> 6275:     true = ets:insert(T, [{a,1},{b,2}]),
<a name="6276"/> 6276:     ok = ets:tab2file(T, File, []),
<a name="6277"/> 6277:     true = ets:delete(T),
<a name="6278"/> 6278:     [H0 | Ts ] = get_all_terms(l, File),
<a name="6279"/> 6279:     H1 = tuple_to_list(H0),
<a name="6280"/> 6280:     H2 = [{K,V} || {K,V} &lt;- H1, K =/= protection],
<a name="6281"/> 6281:     H = list_to_tuple(H2),
<a name="6282"/> 6282:     ok = file:delete(File),
<a name="6283"/> 6283:     write_terms(l, File, [H | Ts]),
<a name="6284"/> 6284:     %% All mandatory keys are no longer members of the header
<a name="6285"/> 6285:     {error, badfile} = ets:file2tab(File),
<a name="6286"/> 6286:     {error, badfile} = ets:tabfile_info(File),
<a name="6287"/> 6287:     file:delete(File),
<a name="6288"/> 6288:     [] = disk_log:all(),
<a name="badfile-last_expr"/><a name="6289"/> 6289:     ok.
<a name="6290"/> 6290: 
<a name="get_all_terms-2"/><a name="6291"/> 6291: <b>get_all_terms</b>(Log, File) -&gt;
<a name="6292"/> 6292:     {ok, Log} = disk_log:open([{name,Log},
<a name="6293"/> 6293:                                {file, File},
<a name="6294"/> 6294:                                {mode, read_only}]),
<a name="6295"/> 6295:     Ts = get_all_terms(Log),
<a name="6296"/> 6296:     ok = disk_log:close(Log),
<a name="get_all_terms-last_expr"/><a name="6297"/> 6297:     Ts.
<a name="6298"/> 6298: 
<a name="get_all_terms-1"/><a name="6299"/> 6299: <b>get_all_terms</b>(Log) -&gt;
<a name="get_all_terms-last_expr"/><a name="6300"/> 6300: <b>    get_all_terms1</b>(Log, start, []).
<a name="6301"/> 6301: 
<a name="get_all_terms1-3"/><a name="6302"/> 6302: <b>get_all_terms1</b>(Log, Cont, Res) -&gt;
<a name="get_all_terms1-last_expr"/><a name="6303"/> 6303: <b>    case disk_log:chunk</b>(Log, Cont) of
<a name="6304"/> 6304: 	{error, _R} -&gt;
<a name="6305"/> 6305:             throw(fel);
<a name="6306"/> 6306: 	{Cont2, Terms} -&gt;
<a name="6307"/> 6307: 	    get_all_terms1(Log, Cont2, Res ++ Terms);
<a name="6308"/> 6308: 	eof -&gt;
<a name="6309"/> 6309: 	    Res
<a name="6310"/> 6310:     end.
<a name="6311"/> 6311: 
<a name="write_terms-3"/><a name="6312"/> 6312: <b>write_terms</b>(Log, File, Terms) -&gt;
<a name="6313"/> 6313:     {ok, Log} = disk_log:open([{name,Log},{file, File},{mode,read_write}]),
<a name="6314"/> 6314:     ok = disk_log:log(Log, Terms),
<a name="write_terms-last_expr"/><a name="6315"/> 6315: <b>    ok = disk_log:close</b>(Log).
<a name="6316"/> 6316: 
<a name="6317"/> 6317: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="6318"/> 6318: 
<a name="make_sub_binary-2"/><a name="6319"/> 6319: <b>make_sub_binary</b>(List, Num) when is_list(List) -&gt;
<a name="6320"/> 6320:     N = Num rem 23,
<a name="6321"/> 6321:     Bin = list_to_binary([lists:seq(0, N)|List]),
<a name="6322"/> 6322:     {_,B} = split_binary(Bin, N+1),
<a name="make_sub_binary-last_expr"/><a name="6323"/> 6323:     B.
<a name="6324"/> 6324: 
<a name="6325"/> 6325: 
<a name="6326"/> 6326: <i>%% Lookup stuff like crazy...</i>
<a name="6327"/> 6327: 
<a name="6328"/> 6328: <i>%% Perform multiple lookups for every key in a large table.</i>
<a name="heavy_lookup-1"/><a name="6329"/> 6329: <b>heavy_lookup</b>(Config) when is_list(Config) -&gt;
<a name="heavy_lookup-last_expr"/><a name="6330"/> 6330: <b>    repeat_for_opts_all_set_table_types</b>(fun heavy_lookup_do/1).
<a name="6331"/> 6331: 
<a name="heavy_lookup_do-1"/><a name="6332"/> 6332: <b>heavy_lookup_do</b>(Opts) -&gt;
<a name="6333"/> 6333:     EtsMem = etsmem(),
<a name="6334"/> 6334:     KeyRange = 7000,
<a name="6335"/> 6335:     Tab = ets_new(foobar_table, [{keypos, 2} | Opts], KeyRange),
<a name="6336"/> 6336:     ok = fill_tab2(Tab, 0, KeyRange),
<a name="6337"/> 6337:     _ = [do_lookup(Tab, KeyRange-1) || _ &lt;- lists:seq(1, 50)],
<a name="6338"/> 6338:     true = ets:delete(Tab),
<a name="heavy_lookup_do-last_expr"/><a name="6339"/> 6339: <b>    verify_etsmem</b>(EtsMem).
<a name="6340"/> 6340: 
<a name="do_lookup-2"/><a name="6341"/> 6341: <b>do_lookup</b>(_Tab, 0) -&gt; ok;
<a name="6342"/> 6342: <b>do_lookup</b>(Tab, N) -&gt;
<a name="do_lookup-last_expr"/><a name="6343"/> 6343: <b>    case ets:lookup</b>(Tab, N) of
<a name="6344"/> 6344: 	[] -&gt;
<a name="6345"/> 6345: 	    io:format(&quot;Set #~p was reported as empty. Not valid.&quot;,
<a name="6346"/> 6346: 		      [N]),
<a name="6347"/> 6347: 	    exit('Invalid lookup');
<a name="6348"/> 6348: 	_ -&gt;
<a name="6349"/> 6349: 	    do_lookup(Tab, N-1)
<a name="6350"/> 6350:     end.
<a name="6351"/> 6351: 
<a name="6352"/> 6352: <i>%% Perform multiple lookups for every element in a large table.</i>
<a name="heavy_lookup_element-1"/><a name="6353"/> 6353: <b>heavy_lookup_element</b>(Config) when is_list(Config) -&gt;
<a name="heavy_lookup_element-last_expr"/><a name="6354"/> 6354: <b>    repeat_for_opts_all_set_table_types</b>(fun heavy_lookup_element_do/1).
<a name="6355"/> 6355: 
<a name="heavy_lookup_element_do-1"/><a name="6356"/> 6356: <b>heavy_lookup_element_do</b>(Opts) -&gt;
<a name="6357"/> 6357:     EtsMem = etsmem(),
<a name="6358"/> 6358:     KeyRange = 7000,
<a name="6359"/> 6359:     Tab = ets_new(foobar_table, [{keypos, 2} | Opts], KeyRange),
<a name="6360"/> 6360:     ok = fill_tab2(Tab, 0, KeyRange),
<a name="6361"/> 6361:     %% lookup ALL elements 50 times
<a name="6362"/> 6362:     Laps = 50 div syrup_factor(),
<a name="6363"/> 6363:     _ = [do_lookup_element(Tab, KeyRange-1, 1) || _ &lt;- lists:seq(1, Laps)],
<a name="6364"/> 6364:     true = ets:delete(Tab),
<a name="heavy_lookup_element_do-last_expr"/><a name="6365"/> 6365: <b>    verify_etsmem</b>(EtsMem).
<a name="6366"/> 6366: 
<a name="do_lookup_element-3"/><a name="6367"/> 6367: <b>do_lookup_element</b>(_Tab, 0, _) -&gt; ok;
<a name="6368"/> 6368: <b>do_lookup_element</b>(Tab, N, M) -&gt;
<a name="do_lookup_element-last_expr"/><a name="6369"/> 6369: <b>    case catch ets:lookup_element</b>(Tab, N, M) of
<a name="6370"/> 6370: 	{'EXIT', {badarg, _}} -&gt;
<a name="6371"/> 6371: 	    case M of
<a name="6372"/> 6372: 		1 -&gt; ct:fail(&quot;Set #~p reported as empty. Not valid.&quot;,
<a name="6373"/> 6373: 			     [N]),
<a name="6374"/> 6374: 		     exit('Invalid lookup_element');
<a name="6375"/> 6375: 		_ -&gt; do_lookup_element(Tab, N-1, 1)
<a name="6376"/> 6376: 	    end;
<a name="6377"/> 6377: 	_ -&gt; do_lookup_element(Tab, N, M+1)
<a name="6378"/> 6378:     end.
<a name="6379"/> 6379: 
<a name="6380"/> 6380: 
<a name="heavy_concurrent-1"/><a name="6381"/> 6381: <b>heavy_concurrent</b>(Config) when is_list(Config) -&gt;
<a name="6382"/> 6382:     ct:timetrap({minutes,120}), %% valgrind needs a lot of time
<a name="heavy_concurrent-last_expr"/><a name="6383"/> 6383: <b>    repeat_for_opts_all_set_table_types</b>(fun do_heavy_concurrent/1).
<a name="6384"/> 6384: 
<a name="do_heavy_concurrent-1"/><a name="6385"/> 6385: <b>do_heavy_concurrent</b>(Opts) -&gt;
<a name="6386"/> 6386:     KeyRange = 10000,
<a name="6387"/> 6387:     Laps = 10000 div syrup_factor(),
<a name="6388"/> 6388:     EtsMem = etsmem(),
<a name="6389"/> 6389:     Tab = ets_new(blupp, [public, {keypos, 2} | Opts], KeyRange),
<a name="6390"/> 6390:     ok = fill_tab2(Tab, 0, KeyRange),
<a name="6391"/> 6391:     Procs = lists:map(
<a name="6392"/> 6392: 	      fun (N) -&gt;
<a name="6393"/> 6393: 		      my_spawn_link(
<a name="6394"/> 6394: 			fun () -&gt;
<a name="6395"/> 6395: 				do_heavy_concurrent_proc(Tab, Laps, N)
<a name="6396"/> 6396: 			end)
<a name="6397"/> 6397: 	      end,
<a name="6398"/> 6398: 	      lists:seq(1, 500)),
<a name="6399"/> 6399:     lists:foreach(fun (P) -&gt;
<a name="6400"/> 6400: 			  M = erlang:monitor(process, P),
<a name="6401"/> 6401: 			  receive
<a name="6402"/> 6402: 			      {'DOWN', M, process, P, _} -&gt;
<a name="6403"/> 6403: 				  ok
<a name="6404"/> 6404: 			  end
<a name="6405"/> 6405: 		  end,
<a name="6406"/> 6406: 		  Procs),
<a name="6407"/> 6407:     true = ets:delete(Tab),
<a name="do_heavy_concurrent-last_expr"/><a name="6408"/> 6408: <b>    verify_etsmem</b>(EtsMem).
<a name="6409"/> 6409: 
<a name="do_heavy_concurrent_proc-3"/><a name="6410"/> 6410: <b>do_heavy_concurrent_proc</b>(_Tab, 0, _Offs) -&gt;
<a name="6411"/> 6411:     done;
<a name="6412"/> 6412: <b>do_heavy_concurrent_proc</b>(Tab, N, Offs) when (N+Offs) rem 100 == 0 -&gt;
<a name="6413"/> 6413:     Data = {&quot;here&quot;, are, &quot;S O M E &quot;, data, &quot;toooooooooooooooooo&quot;, insert,
<a name="6414"/> 6414: 	    make_ref(), make_ref(), make_ref()},
<a name="6415"/> 6415:     true=ets:insert(Tab, {{self(),Data}, N}),
<a name="6416"/> 6416:     do_heavy_concurrent_proc(Tab, N-1, Offs);
<a name="6417"/> 6417: <b>do_heavy_concurrent_proc</b>(Tab, N, Offs) -&gt;
<a name="6418"/> 6418:     _ = ets:lookup(Tab, N),
<a name="do_heavy_concurrent_proc-last_expr"/><a name="6419"/> 6419: <b>    do_heavy_concurrent_proc</b>(Tab, N-1, Offs).
<a name="6420"/> 6420: 
<a name="6421"/> 6421: 
<a name="fold_empty-1"/><a name="6422"/> 6422: <b>fold_empty</b>(Config) when is_list(Config) -&gt;
<a name="6423"/> 6423:     repeat_for_opts_all_set_table_types(
<a name="6424"/> 6424:       fun(Opts) -&gt;
<a name="6425"/> 6425:               EtsMem = etsmem(),
<a name="6426"/> 6426:               Tab = make_table(a, Opts, []),
<a name="6427"/> 6427:               [] = ets:foldl(fun(_X) -&gt; exit(hej) end, [], Tab),
<a name="6428"/> 6428:               [] = ets:foldr(fun(_X) -&gt; exit(hej) end, [], Tab),
<a name="6429"/> 6429:               true = ets:delete(Tab),
<a name="6430"/> 6430:               verify_etsmem(EtsMem)
<a name="6431"/> 6431:       end),
<a name="fold_empty-last_expr"/><a name="6432"/> 6432:     ok.
<a name="6433"/> 6433: 
<a name="fold_badarg-1"/><a name="6434"/> 6434: <b>fold_badarg</b>(Config) when is_list(Config) -&gt;
<a name="6435"/> 6435:     F = fun(_, _) -&gt; ok end,
<a name="6436"/> 6436:     ?assertError(badarg, ets:foldl(F, [], non_existing)),
<a name="fold_badarg-last_expr"/><a name="6437"/> 6437: <b>    ?assertError</b>(badarg, ets:foldr(F, [], non_existing)).
<a name="6438"/> 6438: 
<a name="foldl-1"/><a name="6439"/> 6439: <b>foldl</b>(Config) when is_list(Config) -&gt;
<a name="6440"/> 6440:     repeat_for_opts_all_table_types(
<a name="6441"/> 6441:       fun(Opts) -&gt;
<a name="6442"/> 6442:               EtsMem = etsmem(),
<a name="6443"/> 6443:               L = [{a,1}, {c,3}, {b,2}],
<a name="6444"/> 6444:               LS = lists:sort(L),
<a name="6445"/> 6445:               Tab = make_table(a, Opts, L),
<a name="6446"/> 6446:               LS = lists:sort(ets:foldl(fun(E,A) -&gt; [E|A] end, [], Tab)),
<a name="6447"/> 6447:               true = ets:delete(Tab),
<a name="6448"/> 6448:               verify_etsmem(EtsMem)
<a name="6449"/> 6449:       end),
<a name="foldl-last_expr"/><a name="6450"/> 6450:     ok.
<a name="6451"/> 6451: 
<a name="foldr-1"/><a name="6452"/> 6452: <b>foldr</b>(Config) when is_list(Config) -&gt;
<a name="6453"/> 6453:     repeat_for_opts_all_table_types(
<a name="6454"/> 6454:       fun(Opts) -&gt;
<a name="6455"/> 6455:               EtsMem = etsmem(),
<a name="6456"/> 6456:               L = [{a,1}, {c,3}, {b,2}],
<a name="6457"/> 6457:               LS = lists:sort(L),
<a name="6458"/> 6458:               Tab = make_table(a, Opts, L),
<a name="6459"/> 6459:               LS = lists:sort(ets:foldr(fun(E,A) -&gt; [E|A] end, [], Tab)),
<a name="6460"/> 6460:               true = ets:delete(Tab),
<a name="6461"/> 6461:               verify_etsmem(EtsMem)
<a name="6462"/> 6462:       end),
<a name="foldr-last_expr"/><a name="6463"/> 6463:     ok.
<a name="6464"/> 6464: 
<a name="foldl_ordered-1"/><a name="6465"/> 6465: <b>foldl_ordered</b>(Config) when is_list(Config) -&gt;
<a name="6466"/> 6466:     repeat_for_opts_all_ord_set_table_types(
<a name="6467"/> 6467:       fun(Opts) -&gt;
<a name="6468"/> 6468:               EtsMem = etsmem(),
<a name="6469"/> 6469:               L = [{a,1}, {c,3}, {b,2}],
<a name="6470"/> 6470:               LS = lists:sort(L),
<a name="6471"/> 6471:               Tab = make_table(a, Opts, L),
<a name="6472"/> 6472:               LS = lists:reverse(ets:foldl(fun(E,A) -&gt; [E|A] end, [], Tab)),
<a name="6473"/> 6473:               true = ets:delete(Tab),
<a name="6474"/> 6474:               verify_etsmem(EtsMem)
<a name="6475"/> 6475:       end),
<a name="foldl_ordered-last_expr"/><a name="6476"/> 6476:     ok.
<a name="6477"/> 6477: 
<a name="foldr_ordered-1"/><a name="6478"/> 6478: <b>foldr_ordered</b>(Config) when is_list(Config) -&gt;
<a name="6479"/> 6479:     repeat_for_opts_all_ord_set_table_types(
<a name="6480"/> 6480:       fun(Opts) -&gt;
<a name="6481"/> 6481:               EtsMem = etsmem(),
<a name="6482"/> 6482:               L = [{a,1}, {c,3}, {b,2}],
<a name="6483"/> 6483:               LS = lists:sort(L),
<a name="6484"/> 6484:               Tab = make_table(a, Opts, L),
<a name="6485"/> 6485:               LS = ets:foldr(fun(E,A) -&gt; [E|A] end, [], Tab),
<a name="6486"/> 6486:               true = ets:delete(Tab),
<a name="6487"/> 6487:               verify_etsmem(EtsMem)
<a name="6488"/> 6488:       end),
<a name="foldr_ordered-last_expr"/><a name="6489"/> 6489:     ok.
<a name="6490"/> 6490: 
<a name="6491"/> 6491: <i>%% Test ets:member BIF.</i>
<a name="member-1"/><a name="6492"/> 6492: <b>member</b>(Config) when is_list(Config) -&gt;
<a name="member-last_expr"/><a name="6493"/> 6493: <b>    repeat_for_opts</b>(fun member_do/1, [write_concurrency, all_types]).
<a name="6494"/> 6494: 
<a name="member_do-1"/><a name="6495"/> 6495: <b>member_do</b>(Opts) -&gt;
<a name="6496"/> 6496:     EtsMem = etsmem(),
<a name="6497"/> 6497:     T = ets_new(xxx, Opts),
<a name="6498"/> 6498:     false = ets:member(T,hej),
<a name="6499"/> 6499:     E = fun(0,_F)-&gt;ok;
<a name="6500"/> 6500: 	   (N,F) -&gt;
<a name="6501"/> 6501: 		ets:insert(T,{N,N rem 10}),
<a name="6502"/> 6502: 		F(N-1,F)
<a name="6503"/> 6503: 	end,
<a name="6504"/> 6504:     E(10000,E),
<a name="6505"/> 6505:     false = ets:member(T,hej),
<a name="6506"/> 6506:     true = ets:member(T,1),
<a name="6507"/> 6507:     false = ets:member(T,20000),
<a name="6508"/> 6508:     ets:delete(T,5),
<a name="6509"/> 6509:     false = ets:member(T,5),
<a name="6510"/> 6510:     ets:safe_fixtable(T,true),
<a name="6511"/> 6511:     ets:delete(T,6),
<a name="6512"/> 6512:     false = ets:member(T,6),
<a name="6513"/> 6513:     ets:safe_fixtable(T,false),
<a name="6514"/> 6514:     false = ets:member(T,6),
<a name="6515"/> 6515:     ets:delete(T),
<a name="6516"/> 6516:     {'EXIT',{badarg,_}} = (catch ets:member(finnsinte, 23)),
<a name="6517"/> 6517:     {'EXIT',{badarg,_}} = (catch ets:member(T, 23)),
<a name="member_do-last_expr"/><a name="6518"/> 6518: <b>    verify_etsmem</b>(EtsMem).
<a name="6519"/> 6519: 
<a name="6520"/> 6520: 
<a name="build_table-3"/><a name="6521"/> 6521: <b>build_table</b>(L1,L2,Num) -&gt;
<a name="6522"/> 6522:     T = ets_new(xxx, [ordered_set]),
<a name="6523"/> 6523:     lists:foreach(
<a name="6524"/> 6524:       fun(X1) -&gt;
<a name="6525"/> 6525: 	      lists:foreach(
<a name="6526"/> 6526: 		fun(X2) -&gt;
<a name="6527"/> 6527: 			F = fun(FF,N) -&gt;
<a name="6528"/> 6528: 				    ets:insert(T,{{X1,X2,N}, X1, X2, N}),
<a name="6529"/> 6529: 				    case N of
<a name="6530"/> 6530: 					0 -&gt;
<a name="6531"/> 6531: 					    ok;
<a name="6532"/> 6532: 					_ -&gt;
<a name="6533"/> 6533: 					    FF(FF,N-1)
<a name="6534"/> 6534: 				    end
<a name="6535"/> 6535: 			    end,
<a name="6536"/> 6536: 			F(F,Num)
<a name="6537"/> 6537: 		end, L2)
<a name="6538"/> 6538:       end, L1),
<a name="build_table-last_expr"/><a name="6539"/> 6539:     T.
<a name="6540"/> 6540: 
<a name="build_table2-3"/><a name="6541"/> 6541: <b>build_table2</b>(L1,L2,Num) -&gt;
<a name="6542"/> 6542:     T = ets_new(xxx, [ordered_set]),
<a name="6543"/> 6543:     lists:foreach(
<a name="6544"/> 6544:       fun(X1) -&gt;
<a name="6545"/> 6545: 	      lists:foreach(
<a name="6546"/> 6546: 		fun(X2) -&gt;
<a name="6547"/> 6547: 			F = fun(FF,N) -&gt;
<a name="6548"/> 6548: 				    ets:insert(T,{{N,X1,X2}, N, X1, X2}),
<a name="6549"/> 6549: 				    case N of
<a name="6550"/> 6550: 					0 -&gt;
<a name="6551"/> 6551: 					    ok;
<a name="6552"/> 6552: 					_ -&gt;
<a name="6553"/> 6553: 					    FF(FF,N-1)
<a name="6554"/> 6554: 				    end
<a name="6555"/> 6555: 			    end,
<a name="6556"/> 6556: 			F(F,Num)
<a name="6557"/> 6557: 		end, L2)
<a name="6558"/> 6558:       end, L1),
<a name="build_table2-last_expr"/><a name="6559"/> 6559:     T.
<a name="6560"/> 6560: 
<a name="time_match_object-3"/><a name="6561"/> 6561: <b>time_match_object</b>(Tab,Match, Res) -&gt;
<a name="6562"/> 6562:     T1 = erlang:monotonic_time(microsecond),
<a name="6563"/> 6563:     Res = ets:match_object(Tab,Match),
<a name="6564"/> 6564:     T2 = erlang:monotonic_time(microsecond),
<a name="time_match_object-last_expr"/><a name="6565"/> 6565:     T2 - T1.
<a name="6566"/> 6566: 
<a name="time_match-2"/><a name="6567"/> 6567: <b>time_match</b>(Tab,Match) -&gt;
<a name="6568"/> 6568:     T1 = erlang:monotonic_time(microsecond),
<a name="6569"/> 6569:     ets:match(Tab,Match),
<a name="6570"/> 6570:     T2 = erlang:monotonic_time(microsecond),
<a name="time_match-last_expr"/><a name="6571"/> 6571:     T2 - T1.
<a name="6572"/> 6572: 
<a name="seventyfive_percent_success-4"/><a name="6573"/> 6573: <b>seventyfive_percent_success</b>(_,S,Fa,0) -&gt;
<a name="6574"/> 6574:     true = (S &gt; ((S + Fa) * 0.75));
<a name="6575"/> 6575: 
<a name="6576"/> 6576: <b>seventyfive_percent_success</b>(F, S, Fa, N) when is_function(F, 0) -&gt;
<a name="seventyfive_percent_success-last_expr"/><a name="6577"/> 6577: <b>    try F</b>() of
<a name="6578"/> 6578:         _ -&gt;
<a name="6579"/> 6579: 	    seventyfive_percent_success(F, S+1, Fa, N-1)
<a name="6580"/> 6580:     catch error:_ -&gt;
<a name="6581"/> 6581: 	    seventyfive_percent_success(F, S, Fa+1, N-1)
<a name="6582"/> 6582:     end.
<a name="6583"/> 6583: 
<a name="fifty_percent_success-4"/><a name="6584"/> 6584: <b>fifty_percent_success</b>(_,S,Fa,0) -&gt;
<a name="6585"/> 6585:     true = (S &gt; ((S + Fa) * 0.5));
<a name="6586"/> 6586: 
<a name="6587"/> 6587: <b>fifty_percent_success</b>(F, S, Fa, N) when is_function(F, 0) -&gt;
<a name="fifty_percent_success-last_expr"/><a name="6588"/> 6588: <b>    try F</b>() of
<a name="6589"/> 6589:         _ -&gt;
<a name="6590"/> 6590: 	    fifty_percent_success(F, S+1, Fa, N-1)
<a name="6591"/> 6591:     catch
<a name="6592"/> 6592:         error:_ -&gt;
<a name="6593"/> 6593: 	    fifty_percent_success(F, S, Fa+1, N-1)
<a name="6594"/> 6594:     end.
<a name="6595"/> 6595: 
<a name="create_random_string-1"/><a name="6596"/> 6596: <b>create_random_string</b>(0) -&gt;
<a name="6597"/> 6597:     [];
<a name="6598"/> 6598: 
<a name="6599"/> 6599: <b>create_random_string</b>(OfLength) -&gt;
<a name="6600"/> 6600:     C = case rand:uniform(2) of
<a name="6601"/> 6601: 	    1 -&gt;
<a name="6602"/> 6602: 		(rand:uniform($Z - $A + 1) - 1) + $A;
<a name="6603"/> 6603: 	    _ -&gt;
<a name="6604"/> 6604: 		(rand:uniform($z - $a + 1) - 1) + $a
<a name="6605"/> 6605: 	end,
<a name="create_random_string-last_expr"/><a name="6606"/> 6606: <b>    [C | create_random_string</b>(OfLength - 1)].
<a name="6607"/> 6607: 
<a name="6608"/> 6608: 
<a name="create_random_tuple-1"/><a name="6609"/> 6609: <b>create_random_tuple</b>(OfLength) -&gt;
<a name="create_random_tuple-last_expr"/><a name="6610"/> 6610: <b>    list_to_tuple</b>(lists:map(fun(X) -&gt;
<a name="6611"/> 6611: 				    list_to_atom([X])
<a name="6612"/> 6612: 			    end,create_random_string(OfLength))).
<a name="6613"/> 6613: 
<a name="create_partly_bound_tuple-1"/><a name="6614"/> 6614: <b>create_partly_bound_tuple</b>(OfLength) -&gt;
<a name="create_partly_bound_tuple-last_expr"/><a name="6615"/> 6615: <b>    case rand:uniform</b>(2) of
<a name="6616"/> 6616: 	1 -&gt;
<a name="6617"/> 6617: 	    create_partly_bound_tuple1(OfLength);
<a name="6618"/> 6618: 	_ -&gt;
<a name="6619"/> 6619: 	    create_partly_bound_tuple3(OfLength)
<a name="6620"/> 6620:     end.
<a name="6621"/> 6621: 
<a name="create_partly_bound_tuple1-1"/><a name="6622"/> 6622: <b>create_partly_bound_tuple1</b>(OfLength) -&gt;
<a name="6623"/> 6623:     T0 = create_random_tuple(OfLength),
<a name="6624"/> 6624:     I = rand:uniform(OfLength),
<a name="create_partly_bound_tuple1-last_expr"/><a name="6625"/> 6625: <b>    setelement</b>(I,T0,'$1').
<a name="6626"/> 6626: 
<a name="6627"/> 6627: 
<a name="set_n_random_elements-4"/><a name="6628"/> 6628: <b>set_n_random_elements</b>(T0,0,_,_) -&gt;
<a name="6629"/> 6629:     T0;
<a name="6630"/> 6630: <b>set_n_random_elements</b>(T0,N,OfLength,GenFun) -&gt;
<a name="6631"/> 6631:     I = rand:uniform(OfLength),
<a name="6632"/> 6632:     What = GenFun(I),
<a name="set_n_random_elements-last_expr"/><a name="6633"/> 6633: <b>    case element</b>(I,T0) of
<a name="6634"/> 6634: 	What -&gt;
<a name="6635"/> 6635: 	    set_n_random_elements(T0,N,OfLength,GenFun);
<a name="6636"/> 6636: 	_Else -&gt;
<a name="6637"/> 6637: 	    set_n_random_elements(setelement(I,T0,What),
<a name="6638"/> 6638: 				  N-1,OfLength,GenFun)
<a name="6639"/> 6639:     end.
<a name="6640"/> 6640: 
<a name="make_dollar_atom-1"/><a name="6641"/> 6641: <b>make_dollar_atom</b>(I) -&gt;
<a name="make_dollar_atom-last_expr"/><a name="6642"/> 6642: <b>    list_to_atom</b>([$$] ++ integer_to_list(I)).
<a name="create_partly_bound_tuple2-1"/><a name="6643"/> 6643: <b>create_partly_bound_tuple2</b>(OfLength) -&gt;
<a name="6644"/> 6644:     T0 = create_random_tuple(OfLength),
<a name="6645"/> 6645:     I = rand:uniform(OfLength - 1),
<a name="create_partly_bound_tuple2-last_expr"/><a name="6646"/> 6646: <b>    set_n_random_elements</b>(T0,I,OfLength,fun make_dollar_atom/1).
<a name="6647"/> 6647: 
<a name="create_partly_bound_tuple3-1"/><a name="6648"/> 6648: <b>create_partly_bound_tuple3</b>(OfLength) -&gt;
<a name="6649"/> 6649:     T0 = create_random_tuple(OfLength),
<a name="6650"/> 6650:     I = rand:uniform(OfLength - 1),
<a name="create_partly_bound_tuple3-last_expr"/><a name="6651"/> 6651: <b>    set_n_random_elements</b>(T0,I,OfLength,fun(_) -&gt; '_' end).
<a name="6652"/> 6652: 
<a name="do_n_times-2"/><a name="6653"/> 6653: <b>do_n_times</b>(_,0) -&gt;
<a name="6654"/> 6654:     ok;
<a name="6655"/> 6655: <b>do_n_times</b>(Fun,N) -&gt;
<a name="6656"/> 6656:     Fun(),
<a name="6657"/> 6657:     case N rem 1000 of
<a name="6658"/> 6658: 	0 -&gt;
<a name="6659"/> 6659: 	    io:format(&quot;.&quot;);
<a name="6660"/> 6660: 	_ -&gt;
<a name="6661"/> 6661: 	    ok
<a name="6662"/> 6662:     end,
<a name="do_n_times-last_expr"/><a name="6663"/> 6663: <b>    do_n_times</b>(Fun,N-1).
<a name="6664"/> 6664: 
<a name="make_table-3"/><a name="6665"/> 6665: <b>make_table</b>(Name, Options, Elements) -&gt;
<a name="6666"/> 6666:     T = ets_new(Name, Options),
<a name="6667"/> 6667:     lists:foreach(fun(E) -&gt; ets:insert(T, E) end, Elements),
<a name="make_table-last_expr"/><a name="6668"/> 6668:     T.
<a name="6669"/> 6669: 
<a name="filltabint-2"/><a name="6670"/> 6670: <b>filltabint</b>(Tab,0) -&gt;
<a name="6671"/> 6671:     Tab;
<a name="6672"/> 6672: <b>filltabint</b>(Tab,N) -&gt;
<a name="6673"/> 6673:     ets:insert(Tab,{N,integer_to_list(N)}),
<a name="filltabint-last_expr"/><a name="6674"/> 6674: <b>    filltabint</b>(Tab,N-1).
<a name="6675"/> 6675: 
<a name="filltabint2-2"/><a name="6676"/> 6676: <b>filltabint2</b>(Tab,0) -&gt;
<a name="6677"/> 6677:     Tab;
<a name="6678"/> 6678: <b>filltabint2</b>(Tab,N) -&gt;
<a name="6679"/> 6679:     ets:insert(Tab,{N + N rem 2,integer_to_list(N)}),
<a name="filltabint2-last_expr"/><a name="6680"/> 6680: <b>    filltabint2</b>(Tab,N-1).
<a name="filltabint3-2"/><a name="6681"/> 6681: <b>filltabint3</b>(Tab,0) -&gt;
<a name="6682"/> 6682:     Tab;
<a name="6683"/> 6683: <b>filltabint3</b>(Tab,N) -&gt;
<a name="6684"/> 6684:     ets:insert(Tab,{N + N rem 2,integer_to_list(N + N rem 2)}),
<a name="filltabint3-last_expr"/><a name="6685"/> 6685: <b>    filltabint3</b>(Tab,N-1).
<a name="xfilltabint-2"/><a name="6686"/> 6686: <b>xfilltabint</b>(Tab,N) -&gt;
<a name="xfilltabint-last_expr"/><a name="6687"/> 6687: <b>    case ets:info</b>(Tab,type) of
<a name="6688"/> 6688: 	bag -&gt;
<a name="6689"/> 6689: 	    filltabint2(Tab,N);
<a name="6690"/> 6690: 	duplicate_bag -&gt;
<a name="6691"/> 6691: 	    ets:select_delete(Tab,[{'_',[],[true]}]),
<a name="6692"/> 6692: 	    filltabint3(Tab,N);
<a name="6693"/> 6693: 	_ -&gt;
<a name="6694"/> 6694: 	    filltabint(Tab,N)
<a name="6695"/> 6695:     end.
<a name="6696"/> 6696: 
<a name="filltabintup-2"/><a name="6697"/> 6697: <b>filltabintup</b>(Tab,0) -&gt;
<a name="6698"/> 6698:     Tab;
<a name="6699"/> 6699: <b>filltabintup</b>(Tab,N) -&gt;
<a name="6700"/> 6700:     ets:insert(Tab,{{N,integer_to_list(N)},integer_to_list(N)}),
<a name="filltabintup-last_expr"/><a name="6701"/> 6701: <b>    filltabintup</b>(Tab,N-1).
<a name="6702"/> 6702: 
<a name="filltabintup2-2"/><a name="6703"/> 6703: <b>filltabintup2</b>(Tab,0) -&gt;
<a name="6704"/> 6704:     Tab;
<a name="6705"/> 6705: <b>filltabintup2</b>(Tab,N) -&gt;
<a name="6706"/> 6706:     ets:insert(Tab,{{N + N rem 2,integer_to_list(N)},integer_to_list(N)}),
<a name="filltabintup2-last_expr"/><a name="6707"/> 6707: <b>    filltabintup2</b>(Tab,N-1).
<a name="filltabintup3-2"/><a name="6708"/> 6708: <b>filltabintup3</b>(Tab,0) -&gt;
<a name="6709"/> 6709:     Tab;
<a name="6710"/> 6710: <b>filltabintup3</b>(Tab,N) -&gt;
<a name="6711"/> 6711:     ets:insert(Tab,{{N + N rem 2,integer_to_list(N + N rem 2)},integer_to_list(N + N rem 2)}),
<a name="filltabintup3-last_expr"/><a name="6712"/> 6712: <b>    filltabintup3</b>(Tab,N-1).
<a name="6713"/> 6713: 
<a name="filltabstr-2"/><a name="6714"/> 6714: <b>filltabstr</b>(Tab,N) -&gt;
<a name="filltabstr-last_expr"/><a name="6715"/> 6715: <b>    filltabstr</b>(Tab,0,N).
<a name="filltabstr-3"/><a name="6716"/> 6716: <b>filltabstr</b>(Tab,N,N) -&gt;
<a name="6717"/> 6717:     Tab;
<a name="6718"/> 6718: <b>filltabstr</b>(Tab,Floor,N) when N &gt; Floor -&gt;
<a name="6719"/> 6719:     ets:insert(Tab,{integer_to_list(N),N}),
<a name="filltabstr-last_expr"/><a name="6720"/> 6720: <b>    filltabstr</b>(Tab,Floor,N-1).
<a name="6721"/> 6721: 
<a name="filltabstr2-2"/><a name="6722"/> 6722: <b>filltabstr2</b>(Tab,0) -&gt;
<a name="6723"/> 6723:     Tab;
<a name="6724"/> 6724: <b>filltabstr2</b>(Tab,N) -&gt;
<a name="6725"/> 6725:     ets:insert(Tab,{integer_to_list(N),N}),
<a name="6726"/> 6726:     ets:insert(Tab,{integer_to_list(N),N+1}),
<a name="filltabstr2-last_expr"/><a name="6727"/> 6727: <b>    filltabstr2</b>(Tab,N-1).
<a name="filltabstr3-2"/><a name="6728"/> 6728: <b>filltabstr3</b>(Tab,0) -&gt;
<a name="6729"/> 6729:     Tab;
<a name="6730"/> 6730: <b>filltabstr3</b>(Tab,N) -&gt;
<a name="6731"/> 6731:     ets:insert(Tab,{integer_to_list(N),N}),
<a name="6732"/> 6732:     ets:insert(Tab,{integer_to_list(N),N}),
<a name="filltabstr3-last_expr"/><a name="6733"/> 6733: <b>    filltabstr3</b>(Tab,N-1).
<a name="xfilltabstr-2"/><a name="6734"/> 6734: <b>xfilltabstr</b>(Tab,N) -&gt;
<a name="xfilltabstr-last_expr"/><a name="6735"/> 6735: <b>    case ets:info</b>(Tab,type) of
<a name="6736"/> 6736: 	bag -&gt;
<a name="6737"/> 6737: 	    filltabstr2(Tab,N);
<a name="6738"/> 6738: 	duplicate_bag -&gt;
<a name="6739"/> 6739: 	    ets:select_delete(Tab,[{'_',[],[true]}]),
<a name="6740"/> 6740: 	    filltabstr3(Tab,N);
<a name="6741"/> 6741: 	_ -&gt;
<a name="6742"/> 6742: 	    filltabstr(Tab,N)
<a name="6743"/> 6743:     end.
<a name="6744"/> 6744: 
<a name="fill_sets_int-1"/><a name="6745"/> 6745: <b>fill_sets_int</b>(N) -&gt;
<a name="fill_sets_int-last_expr"/><a name="6746"/> 6746: <b>    fill_sets_int</b>(N,[]).
<a name="fill_sets_int-2"/><a name="6747"/> 6747: <b>fill_sets_int</b>(N,Opts) -&gt;
<a name="6748"/> 6748:     Tab1 = ets_new(xxx,
<a name="6749"/> 6749:                    replace_dbg_hash_fixed_nr_of_locks([ordered_set|Opts])),
<a name="6750"/> 6750:     filltabint(Tab1,N),
<a name="6751"/> 6751:     Tab2 = ets_new(xxx, [set|Opts]),
<a name="6752"/> 6752:     filltabint(Tab2,N),
<a name="6753"/> 6753:     Tab3 = ets_new(xxx, [bag|Opts]),
<a name="6754"/> 6754:     filltabint2(Tab3,N),
<a name="6755"/> 6755:     Tab4 = ets_new(xxx, [duplicate_bag|Opts]),
<a name="6756"/> 6756:     filltabint3(Tab4,N),
<a name="fill_sets_int-last_expr"/><a name="6757"/> 6757:     [Tab1,Tab2,Tab3,Tab4].
<a name="6758"/> 6758: 
<a name="fill_sets_intup-2"/><a name="6759"/> 6759: <b>fill_sets_intup</b>(N,Opts) -&gt;
<a name="6760"/> 6760:     Tab1 = ets_new(xxx,
<a name="6761"/> 6761:                    replace_dbg_hash_fixed_nr_of_locks([ordered_set|Opts])),
<a name="6762"/> 6762:     filltabintup(Tab1,N),
<a name="6763"/> 6763:     Tab2 = ets_new(xxx, [set|Opts]),
<a name="6764"/> 6764:     filltabintup(Tab2,N),
<a name="6765"/> 6765:     Tab3 = ets_new(xxx, [bag|Opts]),
<a name="6766"/> 6766:     filltabintup2(Tab3,N),
<a name="6767"/> 6767:     Tab4 = ets_new(xxx, [duplicate_bag|Opts]),
<a name="6768"/> 6768:     filltabintup3(Tab4,N),
<a name="fill_sets_intup-last_expr"/><a name="6769"/> 6769:     [Tab1,Tab2,Tab3,Tab4].
<a name="6770"/> 6770: 
<a name="check_fun-3"/><a name="6771"/> 6771: <b>check_fun</b>(_Tab,_Fun,'$end_of_table') -&gt;
<a name="6772"/> 6772:     ok;
<a name="6773"/> 6773: <b>check_fun</b>(Tab,Fun,Item) -&gt;
<a name="6774"/> 6774:     lists:foreach(fun(Obj) -&gt;
<a name="6775"/> 6775: 			  true = Fun(Obj)
<a name="6776"/> 6776: 		  end,
<a name="6777"/> 6777: 		  ets:lookup(Tab,Item)),
<a name="check_fun-last_expr"/><a name="6778"/> 6778: <b>    check_fun</b>(Tab,Fun,ets:next(Tab,Item)).
<a name="6779"/> 6779: 
<a name="check-3"/><a name="6780"/> 6780: <b>check</b>(Tab,Fun,N) -&gt;
<a name="6781"/> 6781:     N = ets:info(Tab, size),
<a name="check-last_expr"/><a name="6782"/> 6782: <b>    check_fun</b>(Tab,Fun,ets:first(Tab)).
<a name="6783"/> 6783: 
<a name="6784"/> 6784: 
<a name="6785"/> 6785: 
<a name="del_one_by_one_set-3"/><a name="6786"/> 6786: <b>del_one_by_one_set</b>(T,N,N) -&gt;
<a name="6787"/> 6787:     0 = ets:info(T,size),
<a name="6788"/> 6788:     ok;
<a name="6789"/> 6789: <b>del_one_by_one_set</b>(T,From,To) -&gt;
<a name="6790"/> 6790:     N = ets:info(T,size),
<a name="6791"/> 6791:     ets:delete_object(T,{From, integer_to_list(From)}),
<a name="6792"/> 6792:     N = (ets:info(T,size) + 1),
<a name="6793"/> 6793:     Next = if
<a name="6794"/> 6794: 	       From &lt; To -&gt;
<a name="6795"/> 6795: 		   From + 1;
<a name="6796"/> 6796: 	       true -&gt;
<a name="6797"/> 6797: 		   From - 1
<a name="6798"/> 6798: 	   end,
<a name="del_one_by_one_set-last_expr"/><a name="6799"/> 6799: <b>    del_one_by_one_set</b>(T,Next,To).
<a name="6800"/> 6800: 
<a name="del_one_by_one_bag-3"/><a name="6801"/> 6801: <b>del_one_by_one_bag</b>(T,N,N) -&gt;
<a name="6802"/> 6802:     0 = ets:info(T,size),
<a name="6803"/> 6803:     ok;
<a name="6804"/> 6804: <b>del_one_by_one_bag</b>(T,From,To) -&gt;
<a name="6805"/> 6805:     N = ets:info(T,size),
<a name="6806"/> 6806:     ets:delete_object(T,{From + From rem 2, integer_to_list(From)}),
<a name="6807"/> 6807:     N = (ets:info(T,size) + 1),
<a name="6808"/> 6808:     Next = if
<a name="6809"/> 6809: 	       From &lt; To -&gt;
<a name="6810"/> 6810: 		   From + 1;
<a name="6811"/> 6811: 	       true -&gt;
<a name="6812"/> 6812: 		   From - 1
<a name="6813"/> 6813: 	   end,
<a name="del_one_by_one_bag-last_expr"/><a name="6814"/> 6814: <b>    del_one_by_one_bag</b>(T,Next,To).
<a name="6815"/> 6815: 
<a name="6816"/> 6816: 
<a name="del_one_by_one_dbag_1-3"/><a name="6817"/> 6817: <b>del_one_by_one_dbag_1</b>(T,N,N) -&gt;
<a name="6818"/> 6818:     0 = ets:info(T,size),
<a name="6819"/> 6819:     ok;
<a name="6820"/> 6820: <b>del_one_by_one_dbag_1</b>(T,From,To) -&gt;
<a name="6821"/> 6821:     N = ets:info(T,size),
<a name="6822"/> 6822:     ets:delete_object(T,{From, integer_to_list(From)}),
<a name="6823"/> 6823:     case From rem 2 of
<a name="6824"/> 6824: 	0 -&gt;
<a name="6825"/> 6825: 	    N = (ets:info(T,size) + 2);
<a name="6826"/> 6826: 	1 -&gt;
<a name="6827"/> 6827: 	    N = ets:info(T,size)
<a name="6828"/> 6828:     end,
<a name="6829"/> 6829:     Next = if
<a name="6830"/> 6830: 	       From &lt; To -&gt;
<a name="6831"/> 6831: 		   From + 1;
<a name="6832"/> 6832: 	       true -&gt;
<a name="6833"/> 6833: 		   From - 1
<a name="6834"/> 6834: 	   end,
<a name="del_one_by_one_dbag_1-last_expr"/><a name="6835"/> 6835: <b>    del_one_by_one_dbag_1</b>(T,Next,To).
<a name="6836"/> 6836: 
<a name="del_one_by_one_dbag_2-3"/><a name="6837"/> 6837: <b>del_one_by_one_dbag_2</b>(T,N,N) -&gt;
<a name="6838"/> 6838:     0 = ets:info(T,size),
<a name="6839"/> 6839:     ok;
<a name="6840"/> 6840: <b>del_one_by_one_dbag_2</b>(T,From,To) -&gt;
<a name="6841"/> 6841:     N = ets:info(T,size),
<a name="6842"/> 6842:     ets:delete_object(T,{From, integer_to_list(From)}),
<a name="6843"/> 6843:     case From rem 2 of
<a name="6844"/> 6844: 	0 -&gt;
<a name="6845"/> 6845: 	    N = (ets:info(T,size) + 3);
<a name="6846"/> 6846: 	1 -&gt;
<a name="6847"/> 6847: 	    N = (ets:info(T,size) + 1)
<a name="6848"/> 6848:     end,
<a name="6849"/> 6849:     Next = if
<a name="6850"/> 6850: 	       From &lt; To -&gt;
<a name="6851"/> 6851: 		   From + 1;
<a name="6852"/> 6852: 	       true -&gt;
<a name="6853"/> 6853: 		   From - 1
<a name="6854"/> 6854: 	   end,
<a name="del_one_by_one_dbag_2-last_expr"/><a name="6855"/> 6855: <b>    del_one_by_one_dbag_2</b>(T,Next,To).
<a name="6856"/> 6856: 
<a name="del_one_by_one_dbag_3-3"/><a name="6857"/> 6857: <b>del_one_by_one_dbag_3</b>(T,N,N) -&gt;
<a name="6858"/> 6858:     0 = ets:info(T,size),
<a name="6859"/> 6859:     ok;
<a name="6860"/> 6860: <b>del_one_by_one_dbag_3</b>(T,From,To) -&gt;
<a name="6861"/> 6861:     N = ets:info(T,size),
<a name="6862"/> 6862:     Obj = {From + From rem 2, integer_to_list(From)},
<a name="6863"/> 6863:     ets:delete_object(T,Obj),
<a name="6864"/> 6864:     case From rem 2 of
<a name="6865"/> 6865: 	0 -&gt;
<a name="6866"/> 6866: 	    N = (ets:info(T,size) + 2);
<a name="6867"/> 6867: 	1 -&gt;
<a name="6868"/> 6868: 	    N = (ets:info(T,size) + 1),
<a name="6869"/> 6869: 	    Obj2 = {From, integer_to_list(From)},
<a name="6870"/> 6870: 	    ets:delete_object(T,Obj2),
<a name="6871"/> 6871: 	    N = (ets:info(T,size) + 2)
<a name="6872"/> 6872:     end,
<a name="6873"/> 6873:     Next = if
<a name="6874"/> 6874: 	       From &lt; To -&gt;
<a name="6875"/> 6875: 		   From + 1;
<a name="6876"/> 6876: 	       true -&gt;
<a name="6877"/> 6877: 		   From - 1
<a name="6878"/> 6878: 	   end,
<a name="del_one_by_one_dbag_3-last_expr"/><a name="6879"/> 6879: <b>    del_one_by_one_dbag_3</b>(T,Next,To).
<a name="6880"/> 6880: 
<a name="6881"/> 6881: 
<a name="successive_delete-4"/><a name="6882"/> 6882: <b>successive_delete</b>(Table,From,To,Type) -&gt;
<a name="successive_delete-last_expr"/><a name="6883"/> 6883: <b>    successive_delete</b>(Table,From,To,Type,ets:info(Table,type)).
<a name="6884"/> 6884: 
<a name="successive_delete-5"/><a name="6885"/> 6885: <b>successive_delete</b>(_Table,N,N,_,_) -&gt;
<a name="6886"/> 6886:     ok;
<a name="6887"/> 6887: <b>successive_delete</b>(Table,From,To,Type,TType) -&gt;
<a name="6888"/> 6888:     MS = case Type of
<a name="6889"/> 6889: 	     bound -&gt;
<a name="6890"/> 6890: 		 [{{From,'_'},[],[true]}];
<a name="6891"/> 6891: 	     unbound -&gt;
<a name="6892"/> 6892: 		 [{{'$1','_'},[],[{'==', '$1', From}]}]
<a name="6893"/> 6893: 	 end,
<a name="6894"/> 6894:     case TType of
<a name="6895"/> 6895: 	X when X == bag; X == duplicate_bag -&gt;
<a name="6896"/> 6896: 	    %%erlang:display(From),
<a name="6897"/> 6897: 	    case From rem 2 of
<a name="6898"/> 6898: 		0 -&gt;
<a name="6899"/> 6899: 		    2 = ets:select_delete(Table,MS);
<a name="6900"/> 6900: 		_ -&gt;
<a name="6901"/> 6901: 		    0 = ets:select_delete(Table,MS)
<a name="6902"/> 6902: 	    end;
<a name="6903"/> 6903: 	_ -&gt;
<a name="6904"/> 6904: 	    1 = ets:select_delete(Table,MS)
<a name="6905"/> 6905:     end,
<a name="6906"/> 6906:     Next = if
<a name="6907"/> 6907: 	       From &lt; To -&gt;
<a name="6908"/> 6908: 		   From + 1;
<a name="6909"/> 6909: 	       true -&gt;
<a name="6910"/> 6910: 		   From - 1
<a name="6911"/> 6911: 	   end,
<a name="successive_delete-last_expr"/><a name="6912"/> 6912: <b>    successive_delete</b>(Table, Next, To, Type,TType).
<a name="6913"/> 6913: 
<a name="gen_dets_filename-2"/><a name="6914"/> 6914: <b>gen_dets_filename</b>(Config,N) -&gt;
<a name="gen_dets_filename-last_expr"/><a name="6915"/> 6915: <b>    filename:join</b>(proplists:get_value(priv_dir,Config),
<a name="6916"/> 6916: 		  &quot;testdets_&quot; ++ integer_to_list(N) ++ &quot;.dets&quot;).
<a name="6917"/> 6917: 
<a name="otp_6842_select_1000-1"/><a name="6918"/> 6918: <b>otp_6842_select_1000</b>(Config) when is_list(Config) -&gt;
<a name="6919"/> 6919:     repeat_for_opts_all_ord_set_table_types(
<a name="6920"/> 6920:       fun(Opts) -&gt;
<a name="6921"/> 6921:               KeyRange = 10000,
<a name="6922"/> 6922:               Tab = ets_new(xxx, Opts, KeyRange),
<a name="6923"/> 6923:               [ets:insert(Tab,{X,X}) || X &lt;- lists:seq(1,KeyRange)],
<a name="6924"/> 6924:               AllTrue = lists:duplicate(10,true),
<a name="6925"/> 6925:               AllTrue =
<a name="6926"/> 6926:                   [ length(
<a name="6927"/> 6927:                       element(1,
<a name="6928"/> 6928:                               ets:select(Tab,[{'_',[],['$_']}],X*1000))) =:=
<a name="6929"/> 6929:                         X*1000 || X &lt;- lists:seq(1,10) ],
<a name="6930"/> 6930:               Sequences = [[1000,1000,1000,1000,1000,1000,1000,1000,1000,1000],
<a name="6931"/> 6931:                            [2000,2000,2000,2000,2000],
<a name="6932"/> 6932:                            [3000,3000,3000,1000],
<a name="6933"/> 6933:                            [4000,4000,2000],
<a name="6934"/> 6934:                            [5000,5000],
<a name="6935"/> 6935:                            [6000,4000],
<a name="6936"/> 6936:                            [7000,3000],
<a name="6937"/> 6937:                            [8000,2000],
<a name="6938"/> 6938:                            [9000,1000],
<a name="6939"/> 6939:                            [10000]],
<a name="6940"/> 6940:               AllTrue = [ check_seq(Tab, ets:select(Tab,[{'_',[],['$_']}],hd(L)),L) ||
<a name="6941"/> 6941:                             L &lt;- Sequences ],
<a name="6942"/> 6942:               ets:delete(Tab)
<a name="6943"/> 6943:       end),
<a name="otp_6842_select_1000-last_expr"/><a name="6944"/> 6944:     ok.
<a name="6945"/> 6945: 
<a name="check_seq-3"/><a name="6946"/> 6946: <b>check_seq</b>(_,'$end_of_table',[]) -&gt;
<a name="6947"/> 6947:     true;
<a name="6948"/> 6948: <b>check_seq</b>(Tab,{L,C},[H|T]) when length(L) =:= H -&gt;
<a name="6949"/> 6949:     check_seq(Tab, ets:select(C),T);
<a name="6950"/> 6950: <b>check_seq</b>(A,B,C) -&gt;
<a name="6951"/> 6951:     erlang:display({A,B,C}),
<a name="check_seq-last_expr"/><a name="6952"/> 6952:     false.
<a name="6953"/> 6953: 
<a name="otp_6338-1"/><a name="6954"/> 6954: <b>otp_6338</b>(Config) when is_list(Config) -&gt;
<a name="6955"/> 6955:     repeat_for_opts_all_ord_set_table_types(
<a name="6956"/> 6956:       fun(Opts) -&gt;
<a name="6957"/> 6957:               L = binary_to_term(&lt;&lt;131,108,0,0,0,2,104,2,108,0,0,0,2,103,100,0,19,112,112,
<a name="6958"/> 6958:                                    98,49,95,98,115,49,50,64,98,108,97,100,101,95,48,95,53,
<a name="6959"/> 6959:                                    0,0,33,50,0,0,0,4,1,98,0,0,23,226,106,100,0,4,101,120,
<a name="6960"/> 6960:                                    105,116,104,2,108,0,0,0,2,104,2,100,0,3,115,98,109,100,
<a name="6961"/> 6961:                                    0,19,112,112,98,50,95,98,115,49,50,64,98,108,97,100,
<a name="6962"/> 6962:                                    101,95,48,95,56,98,0,0,18,231,106,100,0,4,114,101,99,
<a name="6963"/> 6963:                                    118,106&gt;&gt;),
<a name="6964"/> 6964:               T = ets_new(xxx,Opts),
<a name="6965"/> 6965:               lists:foreach(fun(X) -&gt; ets:insert(T,X) end,L),
<a name="6966"/> 6966:               [[4839,recv]] = ets:match(T,{[{sbm,ppb2_bs12@blade_0_8},'$1'],'$2'}),
<a name="6967"/> 6967:               ets:delete(T)
<a name="6968"/> 6968:       end),
<a name="otp_6338-last_expr"/><a name="6969"/> 6969:     ok.
<a name="6970"/> 6970: 
<a name="6971"/> 6971: <i>%% OTP-15660: Verify select not doing excessive trapping</i>
<a name="6972"/> 6972: <i>%%            when process have mbuf heap fragments.</i>
<a name="select_mbuf_trapping-1"/><a name="6973"/> 6973: <b>select_mbuf_trapping</b>(Config) when is_list(Config) -&gt;
<a name="6974"/> 6974:     select_mbuf_trapping_do(set),
<a name="select_mbuf_trapping-last_expr"/><a name="6975"/> 6975: <b>    select_mbuf_trapping_do</b>(ordered_set).
<a name="6976"/> 6976: 
<a name="select_mbuf_trapping_do-1"/><a name="6977"/> 6977: <b>select_mbuf_trapping_do</b>(Type) -&gt;
<a name="6978"/> 6978:     T = ets:new(xxx, [Type]),
<a name="6979"/> 6979:     NKeys = 50,
<a name="6980"/> 6980:     [ets:insert(T, {K, value}) || K &lt;- lists:seq(1,NKeys)],
<a name="6981"/> 6981: 
<a name="6982"/> 6982:     {priority, Prio} = process_info(self(), priority),
<a name="6983"/> 6983:     Tracee = self(),
<a name="6984"/> 6984:     [SchedTracer]
<a name="6985"/> 6985: 	= start_loopers(1, Prio,
<a name="6986"/> 6986: 			fun (SC) -&gt;
<a name="6987"/> 6987: 				receive
<a name="6988"/> 6988: 				    {trace, Tracee, out, _} -&gt;
<a name="6989"/> 6989: 					SC+1;
<a name="6990"/> 6990: 				    done -&gt;
<a name="6991"/> 6991: 					Tracee ! {schedule_count, SC},
<a name="6992"/> 6992:                                         exit(normal)
<a name="6993"/> 6993: 				end
<a name="6994"/> 6994: 			end,
<a name="6995"/> 6995: 			0),
<a name="6996"/> 6996: 
<a name="6997"/> 6997:     erlang:garbage_collect(),
<a name="6998"/> 6998:     1 = erlang:trace(self(), true, [running,{tracer,SchedTracer}]),
<a name="6999"/> 6999: 
<a name="7000"/> 7000:     %% Artificially create an mbuf heap fragment
<a name="7001"/> 7001:     MbufTerm = &quot;Frag me up&quot;,
<a name="7002"/> 7002:     MbufTerm = erts_debug:set_internal_state(mbuf, MbufTerm),
<a name="7003"/> 7003: 
<a name="7004"/> 7004:     Keys = ets:select(T, [{{'$1', value}, [], ['$1']}]),
<a name="7005"/> 7005:     NKeys = length(Keys),
<a name="7006"/> 7006: 
<a name="7007"/> 7007:     1 = erlang:trace(self(), false, [running]),
<a name="7008"/> 7008:     Ref = erlang:trace_delivered(Tracee),
<a name="7009"/> 7009:     receive
<a name="7010"/> 7010:         {trace_delivered, Tracee, Ref} -&gt;
<a name="7011"/> 7011:             SchedTracer ! done
<a name="7012"/> 7012:     end,
<a name="7013"/> 7013:     receive
<a name="7014"/> 7014: 	{schedule_count, N} -&gt;
<a name="7015"/> 7015: 	    io:format(&quot;~p context switches: ~p&quot;, [Type,N]),
<a name="7016"/> 7016: 	    if
<a name="7017"/> 7017: 		N &lt; 3 -&gt; ok;
<a name="7018"/> 7018: 		true -&gt; ct:fail(failed)
<a name="7019"/> 7019: 	    end
<a name="7020"/> 7020:     end,
<a name="7021"/> 7021:     true = ets:delete(T),
<a name="select_mbuf_trapping_do-last_expr"/><a name="7022"/> 7022:     ok.
<a name="7023"/> 7023: 
<a name="7024"/> 7024: 
<a name="7025"/> 7025: 
<a name="7026"/> 7026: <i>%% Elements could come in the wrong order in a bag if a rehash occurred.</i>
<a name="otp_5340-1"/><a name="7027"/> 7027: <b>otp_5340</b>(Config) when is_list(Config) -&gt;
<a name="otp_5340-last_expr"/><a name="7028"/> 7028: <b>    repeat_for_opts</b>(fun otp_5340_do/1).
<a name="7029"/> 7029: 
<a name="otp_5340_do-1"/><a name="7030"/> 7030: <b>otp_5340_do</b>(Opts) -&gt;
<a name="7031"/> 7031:     N = 3000,
<a name="7032"/> 7032:     T = ets_new(otp_5340, [bag,public | Opts]),
<a name="7033"/> 7033:     Ids = [1,2,3,4,5],
<a name="7034"/> 7034:     [w(T, N, Id) || Id &lt;- Ids],
<a name="7035"/> 7035:     verify(T, Ids),
<a name="otp_5340_do-last_expr"/><a name="7036"/> 7036: <b>    ets:delete</b>(T).
<a name="7037"/> 7037: 
<a name="w-3"/><a name="7038"/> 7038: <b>w</b>(_,0, _) -&gt; ok;
<a name="7039"/> 7039: <b>w</b>(T,N, Id) -&gt;
<a name="7040"/> 7040:     ets:insert(T, {N, Id}),
<a name="w-last_expr"/><a name="7041"/> 7041: <b>    w</b>(T,N-1,Id).
<a name="7042"/> 7042: 
<a name="verify-2"/><a name="7043"/> 7043: <b>verify</b>(T, Ids) -&gt;
<a name="7044"/> 7044:     List = my_tab_to_list(T),
<a name="7045"/> 7045:     Errors = lists:filter(fun(Bucket) -&gt;
<a name="7046"/> 7046: 				  verify2(Bucket, Ids)
<a name="7047"/> 7047: 			  end, List),
<a name="verify-last_expr"/><a name="7048"/> 7048:     case Errors of
<a name="7049"/> 7049: 	[] -&gt;
<a name="7050"/> 7050: 	    ok;
<a name="7051"/> 7051: 	_ -&gt;
<a name="7052"/> 7052: 	    io:format(&quot;Failed:\n~p\n&quot;, [Errors]),
<a name="7053"/> 7053: 	    ct:fail(failed)
<a name="7054"/> 7054:     end.
<a name="7055"/> 7055: 
<a name="verify2-2"/><a name="7056"/> 7056: <b>verify2</b>([{_N,Id}|RL], [Id|R]) -&gt;
<a name="7057"/> 7057:     verify2(RL,R);
<a name="7058"/> 7058: <b>verify2</b>([],[]) -&gt; false;
<a name="7059"/> 7059: <b>verify2</b>(_Err, _) -&gt;
<a name="verify2-last_expr"/><a name="7060"/> 7060:     true.
<a name="7061"/> 7061: 
<a name="7062"/> 7062: <i>%% delete_object followed by delete on fixed bag failed to delete objects.</i>
<a name="otp_7665-1"/><a name="7063"/> 7063: <b>otp_7665</b>(Config) when is_list(Config) -&gt;
<a name="otp_7665-last_expr"/><a name="7064"/> 7064: <b>    repeat_for_opts</b>(fun otp_7665_do/1).
<a name="7065"/> 7065: 
<a name="otp_7665_do-1"/><a name="7066"/> 7066: <b>otp_7665_do</b>(Opts) -&gt;
<a name="7067"/> 7067:     Tab = ets_new(otp_7665,[bag | Opts]),
<a name="7068"/> 7068:     Min = 0,
<a name="7069"/> 7069:     Max = 10,
<a name="7070"/> 7070:     lists:foreach(fun(N)-&gt; otp_7665_act(Tab,Min,Max,N) end,
<a name="7071"/> 7071: 		  lists:seq(Min,Max)),
<a name="otp_7665_do-last_expr"/><a name="7072"/> 7072: <b>    true = ets:delete</b>(Tab).
<a name="7073"/> 7073: 
<a name="otp_7665_act-4"/><a name="7074"/> 7074: <b>otp_7665_act</b>(Tab,Min,Max,DelNr) -&gt;
<a name="7075"/> 7075:     List1 = [{key,N} || N &lt;- lists:seq(Min,Max)],
<a name="7076"/> 7076:     true = ets:insert(Tab, List1),
<a name="7077"/> 7077:     true = ets:safe_fixtable(Tab, true),
<a name="7078"/> 7078:     true = ets:delete_object(Tab, {key,DelNr}),
<a name="7079"/> 7079:     List2 = lists:sort(lists:delete({key,DelNr}, List1)),
<a name="7080"/> 7080: 
<a name="7081"/> 7081:     %% Now verify that we find all remaining objects
<a name="7082"/> 7082:     List2 = lists:sort(ets:lookup(Tab,key)),
<a name="7083"/> 7083:     EList2 = lists:sort(lists:map(fun({key,N})-&gt; N end,
<a name="7084"/> 7084:                                   List2)),
<a name="7085"/> 7085:     EList2 = lists:sort(ets:lookup_element(Tab,key,2)),
<a name="7086"/> 7086:     true = ets:delete(Tab, key),
<a name="7087"/> 7087:     [] = ets:lookup(Tab, key),
<a name="7088"/> 7088:     true = ets:safe_fixtable(Tab, false),
<a name="otp_7665_act-last_expr"/><a name="7089"/> 7089:     ok.
<a name="7090"/> 7090: 
<a name="7091"/> 7091: <i>%% Whitebox testing of meta name table hashing.</i>
<a name="meta_wb-1"/><a name="7092"/> 7092: <b>meta_wb</b>(Config) when is_list(Config) -&gt;
<a name="7093"/> 7093:     EtsMem = etsmem(),
<a name="7094"/> 7094:     repeat_for_opts_all_non_stim_table_types(fun meta_wb_do/1),
<a name="meta_wb-last_expr"/><a name="7095"/> 7095: <b>    verify_etsmem</b>(EtsMem).
<a name="7096"/> 7096: 
<a name="7097"/> 7097: 
<a name="meta_wb_do-1"/><a name="7098"/> 7098: <b>meta_wb_do</b>(Opts) -&gt;
<a name="7099"/> 7099:     %% Do random new/delete/rename of colliding named tables
<a name="7100"/> 7100:     Names0 = [pioneer | colliding_names(pioneer)],
<a name="7101"/> 7101: 
<a name="7102"/> 7102:     %% Remove any names that happen to exist as tables already
<a name="7103"/> 7103:     Names = lists:filter(fun(Name) -&gt; ets:info(Name) == undefined end,
<a name="7104"/> 7104:                          Names0),
<a name="7105"/> 7105:     Len = length(Names),
<a name="7106"/> 7106:     OpFuns = {fun meta_wb_new/4, fun meta_wb_delete/4, fun meta_wb_rename/4},
<a name="7107"/> 7107: 
<a name="7108"/> 7108:     true = (Len &gt;= 3),
<a name="7109"/> 7109: 
<a name="7110"/> 7110:     io:format(&quot;Colliding names = ~p\n&quot;,[Names]),
<a name="7111"/> 7111:     F = fun(0,_,_) -&gt; ok;
<a name="7112"/> 7112: 	   (N,Tabs,Me) -&gt;
<a name="7113"/> 7113: 		Name1 = lists:nth(rand:uniform(Len), Names),
<a name="7114"/> 7114: 		Name2 = lists:nth(rand:uniform(Len), Names),
<a name="7115"/> 7115: 		Op = element(rand:uniform(3),OpFuns),
<a name="7116"/> 7116: 		NTabs = Op(Name1, Name2, Tabs, Opts),
<a name="7117"/> 7117: 		Me(N-1, NTabs, Me)
<a name="7118"/> 7118: 	end,
<a name="7119"/> 7119:     F(Len*100, [], F),
<a name="7120"/> 7120: 
<a name="7121"/> 7121:     %% cleanup
<a name="meta_wb_do-last_expr"/><a name="7122"/> 7122: <b>    lists:foreach</b>(fun(Name)-&gt;catch ets:delete(Name) end,
<a name="7123"/> 7123: 		  Names).
<a name="7124"/> 7124: 
<a name="meta_wb_new-4"/><a name="7125"/> 7125: <b>meta_wb_new</b>(Name, _, Tabs, Opts) -&gt;
<a name="meta_wb_new-last_expr"/><a name="7126"/> 7126: <b>    case </b>(catch ets_new(Name,[named_table|Opts])) of
<a name="7127"/> 7127: 	Name -&gt;
<a name="7128"/> 7128: 	    false = lists:member(Name, Tabs),
<a name="7129"/> 7129: 	    [Name | Tabs];
<a name="7130"/> 7130: 	{'EXIT',{badarg,_}} -&gt;
<a name="7131"/> 7131: 	    true = lists:member(Name, Tabs),
<a name="7132"/> 7132: 	    Tabs
<a name="7133"/> 7133:     end.
<a name="meta_wb_delete-4"/><a name="7134"/> 7134: <b>meta_wb_delete</b>(Name, _, Tabs, _) -&gt;
<a name="meta_wb_delete-last_expr"/><a name="7135"/> 7135: <b>    case </b>(catch ets:delete(Name)) of
<a name="7136"/> 7136: 	true -&gt;
<a name="7137"/> 7137: 	    true = lists:member(Name, Tabs),
<a name="7138"/> 7138: 	    lists:delete(Name, Tabs);
<a name="7139"/> 7139: 	{'EXIT',{badarg,_}} -&gt;
<a name="7140"/> 7140: 	    false = lists:member(Name, Tabs),
<a name="7141"/> 7141: 	    Tabs
<a name="7142"/> 7142:     end.
<a name="meta_wb_rename-4"/><a name="7143"/> 7143: <b>meta_wb_rename</b>(Old, New, Tabs, _) -&gt;
<a name="meta_wb_rename-last_expr"/><a name="7144"/> 7144: <b>    case </b>(catch ets:rename(Old,New)) of
<a name="7145"/> 7145: 	New -&gt;
<a name="7146"/> 7146: 	    true = lists:member(Old, Tabs)
<a name="7147"/> 7147: 		andalso not lists:member(New, Tabs),
<a name="7148"/> 7148: 	    [New | lists:delete(Old, Tabs)];
<a name="7149"/> 7149: 	{'EXIT',{badarg,_}} -&gt;
<a name="7150"/> 7150: 	    true = not lists:member(Old, Tabs)
<a name="7151"/> 7151: 		orelse lists:member(New,Tabs),
<a name="7152"/> 7152: 	    Tabs
<a name="7153"/> 7153:     end.
<a name="7154"/> 7154: 
<a name="7155"/> 7155: 
<a name="colliding_names-1"/><a name="7156"/> 7156: <b>colliding_names</b>(Name) -&gt;
<a name="colliding_names-last_expr"/><a name="7157"/> 7157: <b>    erts_debug:set_internal_state</b>(colliding_names, {Name,5}).
<a name="7158"/> 7158: 
<a name="7159"/> 7159: 
<a name="7160"/> 7160: <i>%% OTP_6913: Grow and shrink.</i>
<a name="7161"/> 7161: 
<a name="grow_shrink-1"/><a name="7162"/> 7162: <b>grow_shrink</b>(Config) when is_list(Config) -&gt;
<a name="grow_shrink-last_expr"/><a name="7163"/> 7163: <b>    repeat_for_all_set_table_types</b>(
<a name="7164"/> 7164:       fun(Opts) -&gt;
<a name="7165"/> 7165:               EtsMem = etsmem(),
<a name="7166"/> 7166: 
<a name="7167"/> 7167:               Set = ets_new(a, Opts, 5000),
<a name="7168"/> 7168:               grow_shrink_0(0, 3071, 3000, 5000, Set),
<a name="7169"/> 7169:               ets:delete(Set),
<a name="7170"/> 7170: 
<a name="7171"/> 7171:               verify_etsmem(EtsMem)
<a name="7172"/> 7172:       end).
<a name="7173"/> 7173: 
<a name="grow_shrink_0-5"/><a name="7174"/> 7174: <b>grow_shrink_0</b>(N, _, _, Max, _) when N &gt;= Max -&gt;
<a name="7175"/> 7175:     ok;
<a name="7176"/> 7176: <b>grow_shrink_0</b>(N0, GrowN, ShrinkN, Max, T) -&gt;
<a name="7177"/> 7177:     N1 = grow_shrink_1(N0, GrowN, ShrinkN, T),
<a name="grow_shrink_0-last_expr"/><a name="7178"/> 7178: <b>    grow_shrink_0</b>(N1, GrowN, ShrinkN, Max, T).
<a name="7179"/> 7179: 
<a name="grow_shrink_1-4"/><a name="7180"/> 7180: <b>grow_shrink_1</b>(N0, GrowN, ShrinkN, T) -&gt;
<a name="7181"/> 7181:     N1 = grow_shrink_2(N0+1, N0 + GrowN, T),
<a name="grow_shrink_1-last_expr"/><a name="7182"/> 7182: <b>    grow_shrink_3</b>(N1, N1 - ShrinkN, T).
<a name="7183"/> 7183: 
<a name="grow_shrink_2-3"/><a name="7184"/> 7184: <b>grow_shrink_2</b>(N, GrowTo, _) when N &gt; GrowTo -&gt;
<a name="7185"/> 7185:     GrowTo;
<a name="7186"/> 7186: <b>grow_shrink_2</b>(N, GrowTo, T) -&gt;
<a name="7187"/> 7187:     true = ets:insert(T, {N,a}),
<a name="grow_shrink_2-last_expr"/><a name="7188"/> 7188: <b>    grow_shrink_2</b>(N+1, GrowTo, T).
<a name="7189"/> 7189: 
<a name="grow_shrink_3-3"/><a name="7190"/> 7190: <b>grow_shrink_3</b>(N, ShrinkTo, _) when N =&lt; ShrinkTo -&gt;
<a name="7191"/> 7191:     ShrinkTo;
<a name="7192"/> 7192: <b>grow_shrink_3</b>(N, ShrinkTo, T) -&gt;
<a name="7193"/> 7193:     true = ets:delete(T, N),
<a name="grow_shrink_3-last_expr"/><a name="7194"/> 7194: <b>    grow_shrink_3</b>(N-1, ShrinkTo, T).
<a name="7195"/> 7195: 
<a name="7196"/> 7196: <i>%% Grow a hash table that still contains pseudo-deleted objects.</i>
<a name="grow_pseudo_deleted-1"/><a name="7197"/> 7197: <b>grow_pseudo_deleted</b>(Config) when is_list(Config) -&gt;
<a name="grow_pseudo_deleted-last_expr"/><a name="7198"/> 7198: <b>    only_if_smp</b>(fun() -&gt; grow_pseudo_deleted_do() end).
<a name="7199"/> 7199: 
<a name="grow_pseudo_deleted_do-0"/><a name="7200"/> 7200: <b>grow_pseudo_deleted_do</b>() -&gt;
<a name="grow_pseudo_deleted_do-last_expr"/><a name="7201"/> 7201: <b>    lists:foreach</b>(fun(Type) -&gt; grow_pseudo_deleted_do(Type) end,
<a name="7202"/> 7202: 		  [set,bag,duplicate_bag]).
<a name="7203"/> 7203: 
<a name="grow_pseudo_deleted_do-1"/><a name="7204"/> 7204: <b>grow_pseudo_deleted_do</b>(Type) -&gt;
<a name="7205"/> 7205:     process_flag(scheduler,1),
<a name="7206"/> 7206:     Self = self(),
<a name="7207"/> 7207:     T = ets_new(kalle,[Type,public,{write_concurrency,true}]),
<a name="7208"/> 7208:     Mod = 7, Mult = 10000,
<a name="7209"/> 7209:     filltabint(T,Mod*Mult),
<a name="7210"/> 7210:     true = ets:safe_fixtable(T,true),
<a name="7211"/> 7211:     Mult = ets:select_delete(T,
<a name="7212"/> 7212: 			     [{{'$1', '_'},
<a name="7213"/> 7213: 			       [{'=:=', {'rem', '$1', Mod}, 0}],
<a name="7214"/> 7214: 			       [true]}]),
<a name="7215"/> 7215:     Left = Mult*(Mod-1),
<a name="7216"/> 7216:     Left = ets:info(T,size),
<a name="7217"/> 7217:     Mult = get_kept_objects(T),
<a name="7218"/> 7218:     filltabstr(T,Mult),
<a name="7219"/> 7219:     my_spawn_opt(
<a name="7220"/> 7220:       fun() -&gt;
<a name="7221"/> 7221: 	      true = ets:info(T,fixed),
<a name="7222"/> 7222: 	      Self ! start,
<a name="7223"/> 7223: 	      io:put_chars(&quot;Starting to filltabstr...\n&quot;),
<a name="7224"/> 7224: 	      do_tc(fun() -&gt;
<a name="7225"/> 7225: 			    filltabstr(T, Mult, Mult+10000)
<a name="7226"/> 7226: 		    end,
<a name="7227"/> 7227: 		    fun(Elapsed) -&gt;
<a name="7228"/> 7228: 			    io:format(&quot;Done with filltabstr in ~p ms\n&quot;,
<a name="7229"/> 7229: 				      [Elapsed])
<a name="7230"/> 7230: 		    end),
<a name="7231"/> 7231: 	      Self ! done
<a name="7232"/> 7232:       end, [link, {scheduler,2}]),
<a name="7233"/> 7233:     start = receive_any(),
<a name="7234"/> 7234:     io:format(&quot;Unfixing table... nitems=~p\n&quot;, [ets:info(T, size)]),
<a name="7235"/> 7235:     do_tc(fun() -&gt;
<a name="7236"/> 7236: 		  true = ets:safe_fixtable(T, false)
<a name="7237"/> 7237: 	  end,
<a name="7238"/> 7238: 	  fun(Elapsed) -&gt;
<a name="7239"/> 7239: 		  io:format(&quot;Unfix table done in ~p ms. nitems=~p\n&quot;,
<a name="7240"/> 7240: 			    [Elapsed,ets:info(T, size)])
<a name="7241"/> 7241: 	  end),
<a name="7242"/> 7242:     false = ets:info(T,fixed),
<a name="7243"/> 7243:     0 = get_kept_objects(T),
<a name="7244"/> 7244:     done = receive_any(),
<a name="7245"/> 7245:     %%verify_table_load(T), % may fail if concurrency is poor (genny)
<a name="7246"/> 7246:     ets:delete(T),
<a name="grow_pseudo_deleted_do-last_expr"/><a name="7247"/> 7247: <b>    process_flag</b>(scheduler,0).
<a name="7248"/> 7248: 
<a name="7249"/> 7249: <i>%% Shrink a hash table that still contains pseudo-deleted objects.</i>
<a name="shrink_pseudo_deleted-1"/><a name="7250"/> 7250: <b>shrink_pseudo_deleted</b>(Config) when is_list(Config) -&gt;
<a name="shrink_pseudo_deleted-last_expr"/><a name="7251"/> 7251: <b>    only_if_smp</b>(fun()-&gt;shrink_pseudo_deleted_do() end).
<a name="7252"/> 7252: 
<a name="shrink_pseudo_deleted_do-0"/><a name="7253"/> 7253: <b>shrink_pseudo_deleted_do</b>() -&gt;
<a name="shrink_pseudo_deleted_do-last_expr"/><a name="7254"/> 7254: <b>    lists:foreach</b>(fun(Type) -&gt; shrink_pseudo_deleted_do(Type) end,
<a name="7255"/> 7255: 		  [set,bag,duplicate_bag]).
<a name="7256"/> 7256: 
<a name="shrink_pseudo_deleted_do-1"/><a name="7257"/> 7257: <b>shrink_pseudo_deleted_do</b>(Type) -&gt;
<a name="7258"/> 7258:     process_flag(scheduler,1),
<a name="7259"/> 7259:     Self = self(),
<a name="7260"/> 7260:     T = ets_new(kalle,[Type,public,{write_concurrency,true}]),
<a name="7261"/> 7261:     Half = 10000,
<a name="7262"/> 7262:     filltabint(T,Half*2),
<a name="7263"/> 7263:     true = ets:safe_fixtable(T,true),
<a name="7264"/> 7264:     Half = ets:select_delete(T,
<a name="7265"/> 7265: 			     [{{'$1', '_'},
<a name="7266"/> 7266: 			       [{'&gt;', '$1', Half}],
<a name="7267"/> 7267: 			       [true]}]),
<a name="7268"/> 7268:     Half = ets:info(T,size),
<a name="7269"/> 7269:     Half = get_kept_objects(T),
<a name="7270"/> 7270:     my_spawn_opt(
<a name="7271"/> 7271:       fun()-&gt; true = ets:info(T,fixed),
<a name="7272"/> 7272: 	      Self ! start,
<a name="7273"/> 7273: 	      io:put_chars(&quot;Starting to delete... ~p\n&quot;),
<a name="7274"/> 7274: 	      do_tc(fun() -&gt;
<a name="7275"/> 7275: 			    del_one_by_one_set(T, 1, Half+1)
<a name="7276"/> 7276: 		    end,
<a name="7277"/> 7277: 		    fun(Elapsed) -&gt;
<a name="7278"/> 7278: 			    io:format(&quot;Done with delete in ~p ms.\n&quot;,
<a name="7279"/> 7279: 				      [Elapsed])
<a name="7280"/> 7280: 		    end),
<a name="7281"/> 7281: 	      Self ! done
<a name="7282"/> 7282:       end, [link, {scheduler,2}]),
<a name="7283"/> 7283:     start = receive_any(),
<a name="7284"/> 7284:     io:format(&quot;Unfixing table... nitems=~p\n&quot;, [ets:info(T, size)]),
<a name="7285"/> 7285:     do_tc(fun() -&gt;
<a name="7286"/> 7286: 		  true = ets:safe_fixtable(T, false)
<a name="7287"/> 7287: 	  end,
<a name="7288"/> 7288: 	  fun(Elapsed) -&gt;
<a name="7289"/> 7289: 		  io:format(&quot;Unfix table done in ~p ms. nitems=~p\n&quot;,
<a name="7290"/> 7290: 			    [Elapsed,ets:info(T, size)])
<a name="7291"/> 7291: 	  end),
<a name="7292"/> 7292:     false = ets:info(T,fixed),
<a name="7293"/> 7293:     0 = get_kept_objects(T),
<a name="7294"/> 7294:     done = receive_any(),
<a name="7295"/> 7295:     %%verify_table_load(T), % may fail if concurrency is poor (genny)
<a name="7296"/> 7296:     ets:delete(T),
<a name="shrink_pseudo_deleted_do-last_expr"/><a name="7297"/> 7297: <b>    process_flag</b>(scheduler,0).
<a name="7298"/> 7298: 
<a name="7299"/> 7299: 
<a name="7300"/> 7300: 
<a name="meta_lookup_unnamed_read-1"/><a name="7301"/> 7301: <b>meta_lookup_unnamed_read</b>(Config) when is_list(Config) -&gt;
<a name="7302"/> 7302:     InitF = fun(_) -&gt; Tab = ets_new(unnamed,[]),
<a name="7303"/> 7303: 		      true = ets:insert(Tab,{key,data}),
<a name="7304"/> 7304: 		      Tab
<a name="7305"/> 7305: 	    end,
<a name="7306"/> 7306:     ExecF = fun(Tab) -&gt; [{key,data}] = ets:lookup(Tab,key),
<a name="7307"/> 7307: 			Tab
<a name="7308"/> 7308: 	    end,
<a name="7309"/> 7309:     FiniF = fun(Tab) -&gt; true = ets:delete(Tab)
<a name="7310"/> 7310: 	    end,
<a name="meta_lookup_unnamed_read-last_expr"/><a name="7311"/> 7311: <b>    run_smp_workers</b>(InitF,ExecF,FiniF,10000).
<a name="7312"/> 7312: 
<a name="meta_lookup_unnamed_write-1"/><a name="7313"/> 7313: <b>meta_lookup_unnamed_write</b>(Config) when is_list(Config) -&gt;
<a name="7314"/> 7314:     InitF = fun(_) -&gt; Tab = ets_new(unnamed,[]),
<a name="7315"/> 7315: 		      {Tab,0}
<a name="7316"/> 7316: 	    end,
<a name="7317"/> 7317:     ExecF = fun({Tab,N}) -&gt; true = ets:insert(Tab,{key,N}),
<a name="7318"/> 7318: 			    {Tab,N+1}
<a name="7319"/> 7319: 	    end,
<a name="7320"/> 7320:     FiniF = fun({Tab,_}) -&gt; true = ets:delete(Tab)
<a name="7321"/> 7321: 	    end,
<a name="meta_lookup_unnamed_write-last_expr"/><a name="7322"/> 7322: <b>    run_smp_workers</b>(InitF,ExecF,FiniF,10000).
<a name="7323"/> 7323: 
<a name="meta_lookup_named_read-1"/><a name="7324"/> 7324: <b>meta_lookup_named_read</b>(Config) when is_list(Config) -&gt;
<a name="7325"/> 7325:     InitF = fun([ProcN|_]) -&gt; Name = list_to_atom(integer_to_list(ProcN)),
<a name="7326"/> 7326: 			      Tab = ets_new(Name,[named_table]),
<a name="7327"/> 7327: 			      true = ets:insert(Tab,{key,data}),
<a name="7328"/> 7328: 			      Tab
<a name="7329"/> 7329: 	    end,
<a name="7330"/> 7330:     ExecF = fun(Tab) -&gt; [{key,data}] = ets:lookup(Tab,key),
<a name="7331"/> 7331: 			Tab
<a name="7332"/> 7332: 	    end,
<a name="7333"/> 7333:     FiniF = fun(Tab) -&gt; true = ets:delete(Tab)
<a name="7334"/> 7334: 	    end,
<a name="meta_lookup_named_read-last_expr"/><a name="7335"/> 7335: <b>    run_smp_workers</b>(InitF,ExecF,FiniF,10000).
<a name="7336"/> 7336: 
<a name="meta_lookup_named_write-1"/><a name="7337"/> 7337: <b>meta_lookup_named_write</b>(Config) when is_list(Config) -&gt;
<a name="7338"/> 7338:     InitF = fun([ProcN|_]) -&gt; Name = list_to_atom(integer_to_list(ProcN)),
<a name="7339"/> 7339: 			      Tab = ets_new(Name,[named_table]),
<a name="7340"/> 7340: 			      {Tab,0}
<a name="7341"/> 7341: 	    end,
<a name="7342"/> 7342:     ExecF = fun({Tab,N}) -&gt; true = ets:insert(Tab,{key,N}),
<a name="7343"/> 7343: 			    {Tab,N+1}
<a name="7344"/> 7344: 	    end,
<a name="7345"/> 7345:     FiniF = fun({Tab,_}) -&gt; true = ets:delete(Tab)
<a name="7346"/> 7346: 	    end,
<a name="meta_lookup_named_write-last_expr"/><a name="7347"/> 7347: <b>    run_smp_workers</b>(InitF,ExecF,FiniF,10000).
<a name="7348"/> 7348: 
<a name="meta_newdel_unnamed-1"/><a name="7349"/> 7349: <b>meta_newdel_unnamed</b>(Config) when is_list(Config) -&gt;
<a name="7350"/> 7350:     InitF = fun(_) -&gt; ok end,
<a name="7351"/> 7351:     ExecF = fun(_) -&gt; Tab = ets_new(unnamed,[]),
<a name="7352"/> 7352: 		      true = ets:delete(Tab)
<a name="7353"/> 7353: 	    end,
<a name="7354"/> 7354:     FiniF = fun(_) -&gt; ok end,
<a name="meta_newdel_unnamed-last_expr"/><a name="7355"/> 7355: <b>    run_smp_workers</b>(InitF,ExecF,FiniF,10000).
<a name="7356"/> 7356: 
<a name="meta_newdel_named-1"/><a name="7357"/> 7357: <b>meta_newdel_named</b>(Config) when is_list(Config) -&gt;
<a name="7358"/> 7358:     InitF = fun([ProcN|_]) -&gt; list_to_atom(integer_to_list(ProcN))
<a name="7359"/> 7359: 	    end,
<a name="7360"/> 7360:     ExecF = fun(Name) -&gt; Name = ets_new(Name,[named_table]),
<a name="7361"/> 7361: 			 true = ets:delete(Name),
<a name="7362"/> 7362: 			 Name
<a name="7363"/> 7363: 	    end,
<a name="7364"/> 7364:     FiniF = fun(_) -&gt; ok end,
<a name="meta_newdel_named-last_expr"/><a name="7365"/> 7365: <b>    run_smp_workers</b>(InitF,ExecF,FiniF,10000).
<a name="7366"/> 7366: 
<a name="7367"/> 7367: <i>%% Concurrent insert's on same table.</i>
<a name="smp_insert-1"/><a name="7368"/> 7368: <b>smp_insert</b>(Config) when is_list(Config) -&gt;
<a name="smp_insert-last_expr"/><a name="7369"/> 7369: <b>    repeat_for_opts</b>(fun smp_insert_do/1,
<a name="7370"/> 7370:                     [[set,ordered_set,stim_cat_ord_set]]).
<a name="7371"/> 7371: 
<a name="smp_insert_do-1"/><a name="7372"/> 7372: <b>smp_insert_do</b>(Opts) -&gt;
<a name="7373"/> 7373:     KeyRange = 10000,
<a name="7374"/> 7374:     ets_new(smp_insert,[named_table,public,{write_concurrency,true}|Opts],
<a name="7375"/> 7375:             KeyRange),
<a name="7376"/> 7376:     InitF = fun(_) -&gt; ok end,
<a name="7377"/> 7377:     ExecF = fun(_) -&gt; true = ets:insert(smp_insert,{rand:uniform(KeyRange)})
<a name="7378"/> 7378:             end,
<a name="7379"/> 7379:     FiniF = fun(_) -&gt; ok end,
<a name="7380"/> 7380:     run_smp_workers(InitF,ExecF,FiniF,100000),
<a name="7381"/> 7381:     verify_table_load(smp_insert),
<a name="smp_insert_do-last_expr"/><a name="7382"/> 7382: <b>    ets:delete</b>(smp_insert).
<a name="7383"/> 7383: 
<a name="7384"/> 7384: <i>%% Concurrent deletes on same fixated table.</i>
<a name="smp_fixed_delete-1"/><a name="7385"/> 7385: <b>smp_fixed_delete</b>(Config) when is_list(Config) -&gt;
<a name="smp_fixed_delete-last_expr"/><a name="7386"/> 7386: <b>    only_if_smp</b>(fun() -&gt; smp_fixed_delete_do() end).
<a name="7387"/> 7387: 
<a name="smp_fixed_delete_do-0"/><a name="7388"/> 7388: <b>smp_fixed_delete_do</b>() -&gt;
<a name="7389"/> 7389:     T = ets_new(foo,[public,{write_concurrency,true}]),
<a name="7390"/> 7390:     %%Mem = ets:info(T,memory),
<a name="7391"/> 7391:     NumOfObjs = 100000,
<a name="7392"/> 7392:     filltabint(T,NumOfObjs),
<a name="7393"/> 7393:     ets:safe_fixtable(T,true),
<a name="7394"/> 7394:     Buckets = num_of_buckets(T),
<a name="7395"/> 7395:     InitF = fun([ProcN,NumOfProcs|_]) -&gt; {ProcN,NumOfProcs} end,
<a name="7396"/> 7396:     ExecF = fun({Key,_}) when Key &gt; NumOfObjs -&gt;
<a name="7397"/> 7397:                     [end_of_work];
<a name="7398"/> 7398:                ({Key,Increment}) -&gt;
<a name="7399"/> 7399:                     true = ets:delete(T,Key),
<a name="7400"/> 7400:                     {Key+Increment,Increment}
<a name="7401"/> 7401:             end,
<a name="7402"/> 7402:     FiniF = fun(_) -&gt; ok end,
<a name="7403"/> 7403:     run_sched_workers(InitF,ExecF,FiniF,NumOfObjs),
<a name="7404"/> 7404:     0 = ets:info(T,size),
<a name="7405"/> 7405:     true = ets:info(T,fixed),
<a name="7406"/> 7406:     Buckets = num_of_buckets(T),
<a name="7407"/> 7407:     case ets:info(T,type) of
<a name="7408"/> 7408:         set -&gt; NumOfObjs = get_kept_objects(T);
<a name="7409"/> 7409:         _ -&gt; ok
<a name="7410"/> 7410:     end,
<a name="7411"/> 7411:     ets:safe_fixtable(T,false),
<a name="7412"/> 7412:     %% Will fail as unfix does not shrink the table:
<a name="7413"/> 7413:     %%Mem = ets:info(T,memory),
<a name="7414"/> 7414:     %%verify_table_load(T),
<a name="smp_fixed_delete_do-last_expr"/><a name="7415"/> 7415: <b>    ets:delete</b>(T).
<a name="7416"/> 7416: 
<a name="7417"/> 7417: <i>%% ERL-720</i>
<a name="7418"/> 7418: <i>%% Provoke race between ets:delete and table unfix (by select_count)</i>
<a name="7419"/> 7419: <i>%% that caused ets_misc memory counter to indicate false leak.</i>
<a name="delete_unfix_race-1"/><a name="7420"/> 7420: <b>delete_unfix_race</b>(Config) when is_list(Config) -&gt;
<a name="7421"/> 7421:     EtsMem = etsmem(),
<a name="7422"/> 7422:     Table = ets:new(t,[set,public,{write_concurrency,true}]),
<a name="7423"/> 7423:     InsertOp =
<a name="7424"/> 7424:         fun() -&gt;
<a name="7425"/> 7425:                 receive stop -&gt;
<a name="7426"/> 7426:                         false
<a name="7427"/> 7427:                 after 0 -&gt;
<a name="7428"/> 7428:                         ets:insert(Table, {rand:uniform(10)}),
<a name="7429"/> 7429:                         true
<a name="7430"/> 7430:                 end
<a name="7431"/> 7431:         end,
<a name="7432"/> 7432:     DeleteOp =
<a name="7433"/> 7433:         fun() -&gt;
<a name="7434"/> 7434:                 receive stop -&gt;
<a name="7435"/> 7435:                         false
<a name="7436"/> 7436:                 after 0 -&gt;
<a name="7437"/> 7437:                         ets:delete(Table, rand:uniform(10)),
<a name="7438"/> 7438:                         true
<a name="7439"/> 7439:                 end
<a name="7440"/> 7440:         end,
<a name="7441"/> 7441:     SelectOp =
<a name="7442"/> 7442:         fun() -&gt;
<a name="7443"/> 7443:                 ets:select_count(Table, ets:fun2ms(fun(X) -&gt; true end))
<a name="7444"/> 7444:         end,
<a name="7445"/> 7445:     Main = self(),
<a name="7446"/> 7446:     Ins = spawn(fun()-&gt; repeat_while(InsertOp), Main ! self() end),
<a name="7447"/> 7447:     Del = spawn(fun()-&gt; repeat_while(DeleteOp), Main ! self() end),
<a name="7448"/> 7448:     spawn(fun()-&gt;
<a name="7449"/> 7449:                   repeat(SelectOp, 10000),
<a name="7450"/> 7450:                   Del ! stop,
<a name="7451"/> 7451:                   Ins ! stop
<a name="7452"/> 7452:           end),
<a name="7453"/> 7453:     [receive Pid -&gt; ok end || Pid &lt;- [Ins,Del]],
<a name="7454"/> 7454:     ets:delete(Table),
<a name="delete_unfix_race-last_expr"/><a name="7455"/> 7455: <b>    verify_etsmem</b>(EtsMem).
<a name="7456"/> 7456: 
<a name="num_of_buckets-1"/><a name="7457"/> 7457: <b>num_of_buckets</b>(T) -&gt;
<a name="num_of_buckets-last_expr"/><a name="7458"/> 7458: <b>    case ets:info</b>(T,type) of
<a name="7459"/> 7459:         set -&gt; element(1,ets:info(T,stats));
<a name="7460"/> 7460:         bag -&gt; element(1,ets:info(T,stats));
<a name="7461"/> 7461:         duplicate_bag -&gt; element(1,ets:info(T,stats));
<a name="7462"/> 7462:         _ -&gt; ok
<a name="7463"/> 7463:     end.
<a name="7464"/> 7464: 
<a name="7465"/> 7465: <i>%% Fixate hash table while other process is busy doing unfix.</i>
<a name="smp_unfix_fix-1"/><a name="7466"/> 7466: <b>smp_unfix_fix</b>(Config) when is_list(Config) -&gt;
<a name="smp_unfix_fix-last_expr"/><a name="7467"/> 7467: <b>    only_if_smp</b>(fun()-&gt; smp_unfix_fix_do() end).
<a name="7468"/> 7468: 
<a name="smp_unfix_fix_do-0"/><a name="7469"/> 7469: <b>smp_unfix_fix_do</b>() -&gt;
<a name="7470"/> 7470:     process_flag(scheduler,1),
<a name="7471"/> 7471:     Parent = self(),
<a name="7472"/> 7472:     T = ets_new(foo,[public,{write_concurrency,true}]),
<a name="7473"/> 7473:     %%Mem = ets:info(T,memory),
<a name="7474"/> 7474:     NumOfObjs = 100000,
<a name="7475"/> 7475:     Deleted = 50000,
<a name="7476"/> 7476:     filltabint(T,NumOfObjs),
<a name="7477"/> 7477:     ets:safe_fixtable(T,true),
<a name="7478"/> 7478:     Buckets = num_of_buckets(T),
<a name="7479"/> 7479:     Deleted = ets:select_delete(T,[{{'$1', '_'},
<a name="7480"/> 7480: 				    [{'=&lt;','$1', Deleted}],
<a name="7481"/> 7481: 				    [true]}]),
<a name="7482"/> 7482:     Buckets = num_of_buckets(T),
<a name="7483"/> 7483:     Left = NumOfObjs - Deleted,
<a name="7484"/> 7484:     Left = ets:info(T,size),
<a name="7485"/> 7485:     true = ets:info(T,fixed),
<a name="7486"/> 7486:     Deleted = get_kept_objects(T),
<a name="7487"/> 7487: 
<a name="7488"/> 7488:     {Child, Mref} =
<a name="7489"/> 7489: 	my_spawn_opt(
<a name="7490"/> 7490: 	  fun()-&gt;
<a name="7491"/> 7491: 		  true = ets:info(T,fixed),
<a name="7492"/> 7492: 		  Parent ! start,
<a name="7493"/> 7493: 		  io:format(&quot;Child waiting for table to be unfixed... mem=~p\n&quot;,
<a name="7494"/> 7494: 			    [ets:info(T, memory)]),
<a name="7495"/> 7495: 		  do_tc(fun() -&gt;
<a name="7496"/> 7496: 				repeat_while(fun()-&gt; ets:info(T, fixed) end)
<a name="7497"/> 7497: 			end,
<a name="7498"/> 7498: 			fun(Elapsed) -&gt;
<a name="7499"/> 7499: 				io:format(&quot;Table unfixed in ~p ms.&quot;
<a name="7500"/> 7500: 					  &quot; Child Fixating! mem=~p\n&quot;,
<a name="7501"/> 7501: 					  [Elapsed,ets:info(T,memory)])
<a name="7502"/> 7502: 			end),
<a name="7503"/> 7503: 		  true = ets:safe_fixtable(T,true),
<a name="7504"/> 7504: 		  repeat_while(fun(Key) when Key =&lt; NumOfObjs -&gt;
<a name="7505"/> 7505: 				       ets:delete(T,Key), {true,Key+1};
<a name="7506"/> 7506: 				  (Key) -&gt; {false,Key}
<a name="7507"/> 7507: 			       end,
<a name="7508"/> 7508: 			       Deleted),
<a name="7509"/> 7509: 		  0 = ets:info(T,size),
<a name="7510"/> 7510: 		  true = get_kept_objects(T) &gt;= Left,
<a name="7511"/> 7511: 		  done = receive_any()
<a name="7512"/> 7512: 	  end,
<a name="7513"/> 7513: 	  [link, monitor, {scheduler,2}]),
<a name="7514"/> 7514: 
<a name="7515"/> 7515:     start = receive_any(),
<a name="7516"/> 7516:     true = ets:info(T,fixed),
<a name="7517"/> 7517:     io:put_chars(&quot;Parent starting to unfix... ~p\n&quot;),
<a name="7518"/> 7518:     do_tc(fun() -&gt;
<a name="7519"/> 7519: 		  ets:safe_fixtable(T, false)
<a name="7520"/> 7520: 	  end,
<a name="7521"/> 7521: 	  fun(Elapsed) -&gt;
<a name="7522"/> 7522: 		  io:format(&quot;Parent done with unfix in ~p ms.\n&quot;,
<a name="7523"/> 7523: 			    [Elapsed])
<a name="7524"/> 7524: 	  end),
<a name="7525"/> 7525:     Child ! done,
<a name="7526"/> 7526:     {'DOWN', Mref, process, Child, normal} = receive_any(),
<a name="7527"/> 7527:     false = ets:info(T,fixed),
<a name="7528"/> 7528:     0 = get_kept_objects(T),
<a name="7529"/> 7529:     %%verify_table_load(T),
<a name="7530"/> 7530:     ets:delete(T),
<a name="smp_unfix_fix_do-last_expr"/><a name="7531"/> 7531: <b>    process_flag</b>(scheduler,0).
<a name="7532"/> 7532: 
<a name="7533"/> 7533: <i>%% Unsafe unfix was done by trapping select/match.</i>
<a name="otp_8166-1"/><a name="7534"/> 7534: <b>otp_8166</b>(Config) when is_list(Config) -&gt;
<a name="otp_8166-last_expr"/><a name="7535"/> 7535: <b>    only_if_smp</b>(3, fun()-&gt; otp_8166_do(false),
<a name="7536"/> 7536: 			   otp_8166_do(true)
<a name="7537"/> 7537: 		   end).
<a name="7538"/> 7538: 
<a name="otp_8166_do-1"/><a name="7539"/> 7539: <b>otp_8166_do</b>(WC) -&gt;
<a name="7540"/> 7540:     %% Bug scenario: One process segv while reading the table because another
<a name="7541"/> 7541:     %% process is doing unfix without write-lock at the end of a trapping match_object.
<a name="7542"/> 7542:     process_flag(scheduler,1),
<a name="7543"/> 7543:     T = ets_new(foo,[public, {write_concurrency,WC}]),
<a name="7544"/> 7544:     NumOfObjs = 3000,  %% Need more than 1000 live objects for match_object to trap one time
<a name="7545"/> 7545:     Deleted = NumOfObjs div 2,
<a name="7546"/> 7546:     filltabint(T,NumOfObjs),
<a name="7547"/> 7547:     {ReaderPid, ReaderMref} = my_spawn_opt(fun()-&gt; otp_8166_reader(T,NumOfObjs) end,
<a name="7548"/> 7548:                                            [link, monitor, {scheduler,2}]),
<a name="7549"/> 7549:     {ZombieCrPid, ZombieCrMref} = my_spawn_opt(fun()-&gt; otp_8166_zombie_creator(T,Deleted) end,
<a name="7550"/> 7550:                                                [link, monitor, {scheduler,3}]),
<a name="7551"/> 7551: 
<a name="7552"/> 7552:     repeat(fun() -&gt; ZombieCrPid ! {loop, self()},
<a name="7553"/> 7553: 		    zombies_created = receive_any(),
<a name="7554"/> 7554: 		    otp_8166_trapper(T, 10, ZombieCrPid)
<a name="7555"/> 7555: 	   end, 100),
<a name="7556"/> 7556: 
<a name="7557"/> 7557:     ReaderPid ! quit,
<a name="7558"/> 7558:     {'DOWN', ReaderMref, process, ReaderPid, normal} = receive_any(),
<a name="7559"/> 7559:     ZombieCrPid ! quit,
<a name="7560"/> 7560:     {'DOWN', ZombieCrMref, process, ZombieCrPid, normal} = receive_any(),
<a name="7561"/> 7561:     false = ets:info(T,fixed),
<a name="7562"/> 7562:     0 = get_kept_objects(T),
<a name="7563"/> 7563:     %%verify_table_load(T),
<a name="7564"/> 7564:     ets:delete(T),
<a name="otp_8166_do-last_expr"/><a name="7565"/> 7565: <b>    process_flag</b>(scheduler,0).
<a name="7566"/> 7566: 
<a name="7567"/> 7567: <i>%% Keep reading the table</i>
<a name="otp_8166_reader-2"/><a name="7568"/> 7568: <b>otp_8166_reader</b>(T, NumOfObjs) -&gt;
<a name="otp_8166_reader-last_expr"/><a name="7569"/> 7569: <b>    repeat_while</b>(fun(0) -&gt;
<a name="7570"/> 7570: 			 receive quit -&gt; {false,done}
<a name="7571"/> 7571: 			 after 0 -&gt; {true,NumOfObjs}
<a name="7572"/> 7572: 			 end;
<a name="7573"/> 7573: 		    (Key) -&gt;
<a name="7574"/> 7574: 			 ets:lookup(T,Key),
<a name="7575"/> 7575: 			 {true, Key-1}
<a name="7576"/> 7576: 		 end,
<a name="7577"/> 7577: 		 NumOfObjs).
<a name="7578"/> 7578: 
<a name="7579"/> 7579: <i>%% Do a match_object that will trap and thereby fixate and then unfixate the table</i>
<a name="otp_8166_trapper-3"/><a name="7580"/> 7580: <b>otp_8166_trapper</b>(T, Try, ZombieCrPid) -&gt;
<a name="7581"/> 7581:     [] = ets:match_object(T,{'_',&quot;Pink Unicorn&quot;}),
<a name="otp_8166_trapper-last_expr"/><a name="7582"/> 7582: <b>    case {ets:info</b>(T,fixed),Try} of
<a name="7583"/> 7583: 	{true,1} -&gt;
<a name="7584"/> 7584: 	    io:format(&quot;failed to provoke unsafe unfix, give up...\n&quot;,[]),
<a name="7585"/> 7585: 	    ZombieCrPid ! unfix;
<a name="7586"/> 7586: 	{true,_} -&gt;
<a name="7587"/> 7587: 	    io:format(&quot;trapper too fast, trying again...\n&quot;,[]),
<a name="7588"/> 7588: 	    otp_8166_trapper(T, Try-1, ZombieCrPid);
<a name="7589"/> 7589: 	{false,_} -&gt; done
<a name="7590"/> 7590:     end.
<a name="7591"/> 7591: 
<a name="7592"/> 7592: 
<a name="7593"/> 7593: <i>%% Fixate table and create some pseudo-deleted objects (zombies)</i>
<a name="7594"/> 7594: <i>%% Then wait for trapper to fixate before unfixing, as we want the trappers'</i>
<a name="7595"/> 7595: <i>%% unfix to be the one that purges the zombies.</i>
<a name="otp_8166_zombie_creator-2"/><a name="7596"/> 7596: <b>otp_8166_zombie_creator</b>(T,Deleted) -&gt;
<a name="otp_8166_zombie_creator-last_expr"/><a name="7597"/> 7597: <b>    case receive_any</b>() of
<a name="7598"/> 7598: 	quit -&gt; done;
<a name="7599"/> 7599: 
<a name="7600"/> 7600: 	{loop,Pid} -&gt;
<a name="7601"/> 7601: 	    filltabint(T,Deleted),
<a name="7602"/> 7602: 	    ets:safe_fixtable(T,true),
<a name="7603"/> 7603: 	    Deleted = ets:select_delete(T,[{{'$1', '_'},
<a name="7604"/> 7604: 					    [{'=&lt;','$1', Deleted}],
<a name="7605"/> 7605: 					    [true]}]),
<a name="7606"/> 7606: 	    Pid ! zombies_created,
<a name="7607"/> 7607: 	    repeat_while(fun() -&gt; case ets:info(T,safe_fixed_monotonic_time) of
<a name="7608"/> 7608: 				      {_,[_P1,_P2]} -&gt;
<a name="7609"/> 7609: 					  false;
<a name="7610"/> 7610: 				      _ -&gt;
<a name="7611"/> 7611: 					  receive unfix -&gt; false
<a name="7612"/> 7612: 					  after 0 -&gt; true
<a name="7613"/> 7613: 					  end
<a name="7614"/> 7614: 				  end
<a name="7615"/> 7615: 			 end),
<a name="7616"/> 7616: 	    ets:safe_fixtable(T,false),
<a name="7617"/> 7617: 	    otp_8166_zombie_creator(T,Deleted);
<a name="7618"/> 7618: 
<a name="7619"/> 7619: 	unfix -&gt;
<a name="7620"/> 7620: 	    io:format(&quot;ignore unfix in outer loop?\n&quot;,[]),
<a name="7621"/> 7621: 	    otp_8166_zombie_creator(T,Deleted)
<a name="7622"/> 7622:     end.
<a name="7623"/> 7623: 
<a name="7624"/> 7624: 
<a name="7625"/> 7625: 
<a name="7626"/> 7626: 
<a name="verify_table_load-1"/><a name="7627"/> 7627: <b>verify_table_load</b>(T) -&gt;
<a name="verify_table_load-last_expr"/><a name="7628"/> 7628: <b>    case ets:info</b>(T,type) of
<a name="7629"/> 7629:         ordered_set -&gt; ok;
<a name="7630"/> 7630:         _ -&gt;
<a name="7631"/> 7631:             Stats = ets:info(T,stats),
<a name="7632"/> 7632:             {Buckets,AvgLen,StdDev,ExpSD,_MinLen,_MaxLen,_,_} = Stats,
<a name="7633"/> 7633:             ok = if
<a name="7634"/> 7634:                      AvgLen &gt; 1.2 -&gt;
<a name="7635"/> 7635:                          io:format(&quot;Table overloaded: Stats=~p\n~p\n&quot;,
<a name="7636"/> 7636:                                    [Stats, ets:info(T)]),
<a name="7637"/> 7637:                          false;
<a name="7638"/> 7638: 
<a name="7639"/> 7639:                      Buckets&gt;256, AvgLen &lt; 0.47 -&gt;
<a name="7640"/> 7640:                          io:format(&quot;Table underloaded: Stats=~p\n~p\n&quot;,
<a name="7641"/> 7641:                                    [Stats, ets:info(T)]),
<a name="7642"/> 7642:                          false;
<a name="7643"/> 7643: 
<a name="7644"/> 7644:                      StdDev &gt; ExpSD*2 -&gt;
<a name="7645"/> 7645:                          io:format(&quot;Too large standard deviation (poor hashing?),&quot;
<a name="7646"/> 7646:                                    &quot; stats=~p\n~p\n&quot;,[Stats, ets:info(T)]),
<a name="7647"/> 7647:                          false;
<a name="7648"/> 7648: 
<a name="7649"/> 7649:                      true -&gt;
<a name="7650"/> 7650:                          io:format(&quot;Stats = ~p\n~p\n&quot;,[Stats, ets:info(T)]),
<a name="7651"/> 7651:                          ok
<a name="7652"/> 7652:                  end
<a name="7653"/> 7653:     end.
<a name="7654"/> 7654: 
<a name="7655"/> 7655: 
<a name="7656"/> 7656: <i>%% ets:select on a tree with NIL key object.</i>
<a name="otp_8732-1"/><a name="7657"/> 7657: <b>otp_8732</b>(Config) when is_list(Config) -&gt;
<a name="7658"/> 7658:     repeat_for_all_ord_set_table_types(
<a name="7659"/> 7659:       fun(Opts) -&gt;
<a name="7660"/> 7660:               KeyRange = 999,
<a name="7661"/> 7661:               KeyFun = fun(K) -&gt; integer_to_list(K) end,
<a name="7662"/> 7662:               Tab = ets_new(noname,Opts, KeyRange, KeyFun),
<a name="7663"/> 7663:               filltabstr(Tab, KeyRange),
<a name="7664"/> 7664:               ets:insert(Tab,{[],&quot;nasty NIL object&quot;}),
<a name="7665"/> 7665:               [] = ets:match(Tab,{'_',nomatch}) %% Will hang if bug not fixed
<a name="7666"/> 7666:       end),
<a name="otp_8732-last_expr"/><a name="7667"/> 7667:     ok.
<a name="7668"/> 7668: 
<a name="7669"/> 7669: 
<a name="7670"/> 7670: <i>%% Run concurrent select_delete (and inserts) on same table.</i>
<a name="smp_select_delete-1"/><a name="7671"/> 7671: <b>smp_select_delete</b>(Config) when is_list(Config) -&gt;
<a name="smp_select_delete-last_expr"/><a name="7672"/> 7672: <b>    repeat_for_opts</b>(fun smp_select_delete_do/1,
<a name="7673"/> 7673:                     [[set,ordered_set,stim_cat_ord_set],
<a name="7674"/> 7674:                      read_concurrency, compressed]).
<a name="7675"/> 7675: 
<a name="smp_select_delete_do-1"/><a name="7676"/> 7676: <b>smp_select_delete_do</b>(Opts) -&gt;
<a name="7677"/> 7677:     KeyRange = 10000,
<a name="7678"/> 7678:     begin % indentation
<a name="7679"/> 7679:               T = ets_new(smp_select_delete,[named_table,public,{write_concurrency,true}|Opts],
<a name="7680"/> 7680:                           KeyRange),
<a name="7681"/> 7681:               Mod = 17,
<a name="7682"/> 7682:               Zeros = erlang:make_tuple(Mod,0),
<a name="7683"/> 7683:               InitF = fun(_) -&gt; Zeros end,
<a name="7684"/> 7684:               ExecF = fun(Diffs0) -&gt;
<a name="7685"/> 7685:                               case rand:uniform(20) of
<a name="7686"/> 7686:                                   1 -&gt;
<a name="7687"/> 7687:                                       Mod = 17,
<a name="7688"/> 7688:                                       Eq = rand:uniform(Mod) - 1,
<a name="7689"/> 7689:                                       Deleted = ets:select_delete(T,
<a name="7690"/> 7690:                                                                   [{{'_', '$1'},
<a name="7691"/> 7691:                                                                     [{'=:=', {'rem', '$1', Mod}, Eq}],
<a name="7692"/> 7692:                                                                     [true]}]),
<a name="7693"/> 7693:                                       Diffs1 = setelement(Eq+1, Diffs0,
<a name="7694"/> 7694:                                                           element(Eq+1,Diffs0) - Deleted),
<a name="7695"/> 7695:                                       Diffs1;
<a name="7696"/> 7696:                                   _ -&gt;
<a name="7697"/> 7697:                                       Key = rand:uniform(KeyRange),
<a name="7698"/> 7698:                                       Eq = Key rem Mod,
<a name="7699"/> 7699:                                       case ets:insert_new(T,{Key,Key}) of
<a name="7700"/> 7700:                                           true -&gt;
<a name="7701"/> 7701:                                               Diffs1 = setelement(Eq+1, Diffs0,
<a name="7702"/> 7702:                                                                   element(Eq+1,Diffs0)+1),
<a name="7703"/> 7703:                                               Diffs1;
<a name="7704"/> 7704:                                           false -&gt; Diffs0
<a name="7705"/> 7705:                                       end
<a name="7706"/> 7706:                               end
<a name="7707"/> 7707:                       end,
<a name="7708"/> 7708:               FiniF = fun(Result) -&gt; Result end,
<a name="7709"/> 7709:               Results = run_sched_workers(InitF,ExecF,FiniF,20000),
<a name="7710"/> 7710:               TotCnts = lists:foldl(fun(Diffs, Sum) -&gt; add_lists(Sum,tuple_to_list(Diffs)) end,
<a name="7711"/> 7711:                                     lists:duplicate(Mod, 0), Results),
<a name="7712"/> 7712:               io:format(&quot;TotCnts = ~p\n&quot;,[TotCnts]),
<a name="7713"/> 7713:               LeftInTab = lists:foldl(fun(N,Sum) -&gt; Sum+N end,
<a name="7714"/> 7714:                                       0, TotCnts),
<a name="7715"/> 7715:               io:format(&quot;LeftInTab = ~p\n&quot;,[LeftInTab]),
<a name="7716"/> 7716:               LeftInTab = ets:info(T,size),
<a name="7717"/> 7717:               lists:foldl(fun(Cnt,Eq) -&gt;
<a name="7718"/> 7718:                                   WasCnt = ets:select_count(T,
<a name="7719"/> 7719:                                                             [{{'_', '$1'},
<a name="7720"/> 7720:                                                               [{'=:=', {'rem', '$1', Mod}, Eq}],
<a name="7721"/> 7721:                                                               [true]}]),
<a name="7722"/> 7722:                                   io:format(&quot;~p: ~p =?= ~p\n&quot;,[Eq,Cnt,WasCnt]),
<a name="7723"/> 7723:                                   Cnt = WasCnt,
<a name="7724"/> 7724:                                   Eq+1
<a name="7725"/> 7725:                           end,
<a name="7726"/> 7726:                           0, TotCnts),
<a name="7727"/> 7727:               %% May fail as select_delete does not shrink table (enough)
<a name="7728"/> 7728:               %%verify_table_load(T),
<a name="7729"/> 7729:               LeftInTab = ets:select_delete(T, [{{'$1','$1'}, [], [true]}]),
<a name="7730"/> 7730:               0 = ets:info(T,size),
<a name="7731"/> 7731:               false = ets:info(T,fixed),
<a name="7732"/> 7732:               ets:delete(T)
<a name="7733"/> 7733:     end, % indentation
<a name="smp_select_delete_do-last_expr"/><a name="7734"/> 7734:     ok.
<a name="7735"/> 7735: 
<a name="smp_select_replace-1"/><a name="7736"/> 7736: <b>smp_select_replace</b>(Config) when is_list(Config) -&gt;
<a name="smp_select_replace-last_expr"/><a name="7737"/> 7737: <b>    repeat_for_opts</b>(fun smp_select_replace_do/1,
<a name="7738"/> 7738:                     [[set,ordered_set,stim_cat_ord_set,duplicate_bag],
<a name="7739"/> 7739:                      compressed]).
<a name="7740"/> 7740: 
<a name="smp_select_replace_do-1"/><a name="7741"/> 7741: <b>smp_select_replace_do</b>(Opts) -&gt;
<a name="7742"/> 7742:     KeyRange = 20,
<a name="7743"/> 7743:     T = ets_new(smp_select_replace,
<a name="7744"/> 7744:                 [public, {write_concurrency, true} | Opts],
<a name="7745"/> 7745:                 KeyRange),
<a name="7746"/> 7746:     InitF = fun (_) -&gt; 0 end,
<a name="7747"/> 7747:     ExecF = fun (Cnt0) -&gt;
<a name="7748"/> 7748:                     CounterId = rand:uniform(KeyRange),
<a name="7749"/> 7749:                     Match = [{{'$1', '$2'},
<a name="7750"/> 7750:                               [{'=:=', '$1', CounterId}],
<a name="7751"/> 7751:                               [{{'$1', {'+', '$2', 1}}}]}],
<a name="7752"/> 7752:                     Cnt1 = case ets:select_replace(T, Match) of
<a name="7753"/> 7753:                                1 -&gt; Cnt0+1;
<a name="7754"/> 7754:                                0 -&gt;
<a name="7755"/> 7755:                                    ets:insert_new(T, {CounterId, 0}),
<a name="7756"/> 7756:                                    Cnt0
<a name="7757"/> 7757:                            end,
<a name="7758"/> 7758:                     receive stop -&gt;
<a name="7759"/> 7759:                             [end_of_work | Cnt1]
<a name="7760"/> 7760:                     after 0 -&gt;
<a name="7761"/> 7761:                             Cnt1
<a name="7762"/> 7762:                     end
<a name="7763"/> 7763:             end,
<a name="7764"/> 7764:     FiniF = fun (Cnt) -&gt; Cnt end,
<a name="7765"/> 7765:     Pids = run_sched_workers(InitF, ExecF, FiniF, infinite),
<a name="7766"/> 7766:     receive after 3*1000 -&gt; ok end,
<a name="7767"/> 7767:     [P ! stop || P &lt;- Pids],
<a name="7768"/> 7768:     Results = wait_pids(Pids),
<a name="7769"/> 7769:     FinalCounts = ets:select(T, [{{'_', '$1'}, [], ['$1']}]),
<a name="7770"/> 7770:     Total = lists:sum(FinalCounts),
<a name="7771"/> 7771:     Total = lists:sum(Results),
<a name="7772"/> 7772:     KeyRange = ets:select_delete(T, [{{'_', '_'}, [], [true]}]),
<a name="7773"/> 7773:     0 = ets:info(T, size),
<a name="7774"/> 7774:     true = ets:delete(T),
<a name="smp_select_replace_do-last_expr"/><a name="7775"/> 7775:     ok.
<a name="7776"/> 7776: 
<a name="7777"/> 7777: <i>%% Iterate ordered_set with write_concurrency</i>
<a name="7778"/> 7778: <i>%% and make sure we hit all &quot;stable&quot; long lived keys</i>
<a name="7779"/> 7779: <i>%% while &quot;volatile&quot; objects are randomly inserted and deleted.</i>
<a name="smp_ordered_iteration-1"/><a name="7780"/> 7780: <b>smp_ordered_iteration</b>(Config) when is_list(Config) -&gt;
<a name="smp_ordered_iteration-last_expr"/><a name="7781"/> 7781: <b>    repeat_for_opts</b>(fun smp_ordered_iteration_do/1,
<a name="7782"/> 7782:                     [[cat_ord_set,stim_cat_ord_set]]).
<a name="7783"/> 7783: 
<a name="7784"/> 7784: 
<a name="smp_ordered_iteration_do-1"/><a name="7785"/> 7785: <b>smp_ordered_iteration_do</b>(Opts) -&gt;
<a name="7786"/> 7786:     KeyRange = 1000,
<a name="7787"/> 7787:     OffHeap = erts_test_utils:mk_ext_pid({a@b,1}, 4711, 1),
<a name="7788"/> 7788:     KeyFun = fun(K, Type) -&gt;
<a name="7789"/> 7789:                      {K div 10, K rem 10, Type, OffHeap}
<a name="7790"/> 7790:              end,
<a name="7791"/> 7791:     StimKeyFun = fun(K) -&gt;
<a name="7792"/> 7792:                          KeyFun(K, element(rand:uniform(3),
<a name="7793"/> 7793:                                            {stable, other, volatile}))
<a name="7794"/> 7794:                  end,
<a name="7795"/> 7795:     T = ets_new(smp_ordered_iteration, [public, {write_concurrency,true} | Opts],
<a name="7796"/> 7796:                 KeyRange, StimKeyFun),
<a name="7797"/> 7797:     NStable = KeyRange div 4,
<a name="7798"/> 7798:     prefill_table(T, KeyRange, NStable, fun(K) -&gt; {KeyFun(K, stable), 0} end),
<a name="7799"/> 7799:     NStable = ets:info(T, size),
<a name="7800"/> 7800:     NVolatile = KeyRange div 2,
<a name="7801"/> 7801:     prefill_table(T, KeyRange, NVolatile, fun(K) -&gt; {KeyFun(K, volatile), 0} end),
<a name="7802"/> 7802: 
<a name="7803"/> 7803:     InitF = fun (_) -&gt; #{insert =&gt; 0, delete =&gt; 0,
<a name="7804"/> 7804:                          select_delete_bk =&gt; 0, select_delete_pbk =&gt; 0,
<a name="7805"/> 7805:                          select_replace_bk =&gt; 0, select_replace_pbk =&gt; 0}
<a name="7806"/> 7806:             end,
<a name="7807"/> 7807:     ExecF = fun (Counters) -&gt;
<a name="7808"/> 7808:                     K = rand:uniform(KeyRange),
<a name="7809"/> 7809:                     Key = KeyFun(K, volatile),
<a name="7810"/> 7810:                     Acc = case rand:uniform(22) of
<a name="7811"/> 7811:                               R when R =&lt; 10 -&gt;
<a name="7812"/> 7812:                                   ets:insert(T, {Key}),
<a name="7813"/> 7813:                                   incr_counter(insert, Counters);
<a name="7814"/> 7814:                               R when R =&lt; 15 -&gt;
<a name="7815"/> 7815:                                   ets:delete(T, Key),
<a name="7816"/> 7816:                                   incr_counter(delete, Counters);
<a name="7817"/> 7817:                               R when R =&lt; 19 -&gt;
<a name="7818"/> 7818:                                   %% Delete bound key
<a name="7819"/> 7819:                                   ets:select_delete(T, [{{Key, '_'}, [], [true]}]),
<a name="7820"/> 7820:                                   incr_counter(select_delete_bk, Counters);
<a name="7821"/> 7821:                               R when R =&lt; 20 -&gt;
<a name="7822"/> 7822:                                   %% Delete partially bound key
<a name="7823"/> 7823:                                   ets:select_delete(T, [{{{K div 10, '_', volatile, '_'}, '_'}, [], [true]}]),
<a name="7824"/> 7824:                                   incr_counter(select_delete_pbk, Counters);
<a name="7825"/> 7825:                               R when R =&lt; 21 -&gt;
<a name="7826"/> 7826:                                   %% Replace bound key
<a name="7827"/> 7827:                                   ets:select_replace(T, [{{Key, '$1'}, [],
<a name="7828"/> 7828:                                                           [{{{const,Key}, {'+','$1',1}}}]}]),
<a name="7829"/> 7829:                                   incr_counter(select_replace_bk, Counters);
<a name="7830"/> 7830:                               _ -&gt;
<a name="7831"/> 7831:                                   %% Replace partially bound key
<a name="7832"/> 7832:                                   ets:select_replace(T, [{{{K div 10, '_', volatile, '_'}, '$1'}, [],
<a name="7833"/> 7833:                                                           [{{{element,1,'$_'}, {'+','$1',1}}}]}]),
<a name="7834"/> 7834:                                   incr_counter(select_replace_pbk, Counters)
<a name="7835"/> 7835:                     end,
<a name="7836"/> 7836:                     receive stop -&gt;
<a name="7837"/> 7837:                             [end_of_work | Acc]
<a name="7838"/> 7838:                     after 0 -&gt;
<a name="7839"/> 7839:                             Acc
<a name="7840"/> 7840:                     end
<a name="7841"/> 7841:             end,
<a name="7842"/> 7842:     FiniF = fun (Acc) -&gt; Acc end,
<a name="7843"/> 7843:     Pids = run_sched_workers(InitF, ExecF, FiniF, infinite),
<a name="7844"/> 7844:     timer:send_after(1000, stop),
<a name="7845"/> 7845: 
<a name="7846"/> 7846:     Log2ChunkMax = math:log2(NStable*2),
<a name="7847"/> 7847:     Rounds = fun Loop(N) -&gt;
<a name="7848"/> 7848:                      MS = [{{{'_', '_', stable, '_'}, '_'}, [], [true]}],
<a name="7849"/> 7849:                      NStable = ets:select_count(T, MS),
<a name="7850"/> 7850:                      NStable = count_stable(T, next, ets:first(T), 0),
<a name="7851"/> 7851:                      NStable = count_stable(T, prev, ets:last(T), 0),
<a name="7852"/> 7852:                      NStable = length(ets:select(T, MS)),
<a name="7853"/> 7853:                      NStable = length(ets:select_reverse(T, MS)),
<a name="7854"/> 7854:                      Chunk = round(math:pow(2, rand:uniform()*Log2ChunkMax)),
<a name="7855"/> 7855:                      NStable = ets_select_chunks_count(T, MS, Chunk),
<a name="7856"/> 7856:                      receive stop -&gt; N
<a name="7857"/> 7857:                      after 0 -&gt; Loop(N+1)
<a name="7858"/> 7858:                      end
<a name="7859"/> 7859:              end (1),
<a name="7860"/> 7860:     [P ! stop || P &lt;- Pids],
<a name="7861"/> 7861:     Results = wait_pids(Pids),
<a name="7862"/> 7862:     io:format(&quot;Ops = ~p\n&quot;, [maps_sum(Results)]),
<a name="7863"/> 7863:     io:format(&quot;Diff = ~p\n&quot;, [ets:info(T,size) - NStable - NVolatile]),
<a name="7864"/> 7864:     io:format(&quot;Stats = ~p\n&quot;, [ets:info(T,stats)]),
<a name="7865"/> 7865:     io:format(&quot;Rounds = ~p\n&quot;, [Rounds]),
<a name="7866"/> 7866:     true = ets:delete(T),
<a name="7867"/> 7867: 
<a name="7868"/> 7868:     %% Verify no leakage of offheap key data
<a name="7869"/> 7869:     ok = erts_test_utils:check_node_dist(),
<a name="smp_ordered_iteration_do-last_expr"/><a name="7870"/> 7870:     ok.
<a name="7871"/> 7871: 
<a name="incr_counter-2"/><a name="7872"/> 7872: <b>incr_counter</b>(Name, Counters) -&gt;
<a name="incr_counter-last_expr"/><a name="7873"/> 7873: <b>    Counters#{Name =&gt; maps:get</b>(Name, Counters, 0) + 1}.
<a name="7874"/> 7874: 
<a name="count_stable-4"/><a name="7875"/> 7875: <b>count_stable</b>(T, Next, {_, _, stable, _}=Key, N) -&gt;
<a name="7876"/> 7876:     count_stable(T, Next, ets:Next(T, Key), N+1);
<a name="7877"/> 7877: <b>count_stable</b>(T, Next, {_, _, volatile, _}=Key, N) -&gt;
<a name="7878"/> 7878:     count_stable(T, Next, ets:Next(T, Key), N);
<a name="7879"/> 7879: <b>count_stable</b>(_, _, '$end_of_table', N) -&gt;
<a name="count_stable-last_expr"/><a name="7880"/> 7880:     N.
<a name="7881"/> 7881: 
<a name="ets_select_chunks_count-3"/><a name="7882"/> 7882: <b>ets_select_chunks_count</b>(T, MS, Chunk) -&gt;
<a name="ets_select_chunks_count-last_expr"/><a name="7883"/> 7883: <b>    ets_select_chunks_count</b>(ets:select(T, MS, Chunk), 0).
<a name="7884"/> 7884: 
<a name="ets_select_chunks_count-2"/><a name="7885"/> 7885: <b>ets_select_chunks_count</b>('$end_of_table', N) -&gt;
<a name="7886"/> 7886:     N;
<a name="7887"/> 7887: <b>ets_select_chunks_count</b>({List, Continuation}, N) -&gt;
<a name="ets_select_chunks_count-last_expr"/><a name="7888"/> 7888: <b>    ets_select_chunks_count</b>(ets:select(Continuation),
<a name="7889"/> 7889:                            length(List) + N).
<a name="7890"/> 7890: 
<a name="maps_sum-1"/><a name="7891"/> 7891: <b>maps_sum</b>([Ma | Tail]) when is_map(Ma) -&gt;
<a name="7892"/> 7892:     maps_sum([lists:sort(maps:to_list(Ma)) | Tail]);
<a name="7893"/> 7893: <b>maps_sum</b>([La, Mb | Tail]) -&gt;
<a name="7894"/> 7894:     Lab = lists:zipwith(fun({K,Va}, {K,Vb}) -&gt; {K,Va+Vb} end,
<a name="7895"/> 7895:                         La,
<a name="7896"/> 7896:                         lists:sort(maps:to_list(Mb))),
<a name="7897"/> 7897:     maps_sum([Lab | Tail]);
<a name="7898"/> 7898: <b>maps_sum</b>([L]) -&gt;
<a name="maps_sum-last_expr"/><a name="7899"/> 7899:     L.
<a name="7900"/> 7900: 
<a name="7901"/> 7901: 
<a name="7902"/> 7902: 
<a name="7903"/> 7903: 
<a name="7904"/> 7904: <i>%% Test different types.</i>
<a name="types-1"/><a name="7905"/> 7905: <b>types</b>(Config) when is_list(Config) -&gt;
<a name="7906"/> 7906:     init_externals(),
<a name="types-last_expr"/><a name="7907"/> 7907: <b>    repeat_for_opts</b>(fun types_do/1, [repeat_for_opts_atom2list(set_types),
<a name="7908"/> 7908:                                      compressed,
<a name="7909"/> 7909:                                      [ordered_set, compressed]]).
<a name="7910"/> 7910: 
<a name="types_do-1"/><a name="7911"/> 7911: <b>types_do</b>(Opts) -&gt;
<a name="7912"/> 7912:     EtsMem = etsmem(),
<a name="7913"/> 7913:     T = ets_new(xxx,Opts),
<a name="7914"/> 7914:     Fun = fun(Term) -&gt;
<a name="7915"/> 7915: 		  ets:insert(T,{Term}),
<a name="7916"/> 7916: 		  [{Term}] = ets:lookup(T,Term),
<a name="7917"/> 7917: 		  ets:insert(T,{Term,xxx}),
<a name="7918"/> 7918: 		  [{Term,xxx}] = ets:lookup(T,Term),
<a name="7919"/> 7919: 		  ets:insert(T,{Term,&quot;xxx&quot;}),
<a name="7920"/> 7920: 		  [{Term,&quot;xxx&quot;}] = ets:lookup(T,Term),
<a name="7921"/> 7921: 		  ets:insert(T,{xxx,Term}),
<a name="7922"/> 7922: 		  [{xxx,Term}] = ets:lookup(T,xxx),
<a name="7923"/> 7923: 		  ets:insert(T,{&quot;xxx&quot;,Term}),
<a name="7924"/> 7924: 		  [{&quot;xxx&quot;,Term}] = ets:lookup(T,&quot;xxx&quot;),
<a name="7925"/> 7925: 		  ets:delete_all_objects(T),
<a name="7926"/> 7926: 		  0 = ets:info(T,size)
<a name="7927"/> 7927:           end,
<a name="7928"/> 7928:     test_terms(Fun, strict),
<a name="7929"/> 7929:     ets:delete(T),
<a name="types_do-last_expr"/><a name="7930"/> 7930: <b>    verify_etsmem</b>(EtsMem).
<a name="7931"/> 7931: 
<a name="7932"/> 7932: 
<a name="7933"/> 7933: <i>%% OTP-9932: Memory overwrite when inserting large integers in compressed bag.</i>
<a name="7934"/> 7934: <i>%% Will crash with segv on 64-bit opt if not fixed.</i>
<a name="otp_9932-1"/><a name="7935"/> 7935: <b>otp_9932</b>(Config) when is_list(Config) -&gt;
<a name="7936"/> 7936:     T = ets_new(xxx, [bag, compressed]),
<a name="7937"/> 7937:     Fun = fun(N) -&gt;
<a name="7938"/> 7938: 		  Key = {1316110174588445 bsl N,1316110174588583 bsl N},
<a name="7939"/> 7939: 		  S = {Key, Key},
<a name="7940"/> 7940: 		  true = ets:insert(T, S),
<a name="7941"/> 7941: 		  [S] = ets:lookup(T, Key),
<a name="7942"/> 7942: 		  true = ets:insert(T, S),
<a name="7943"/> 7943: 		  [S] = ets:lookup(T, Key)
<a name="7944"/> 7944: 	  end,
<a name="7945"/> 7945:     lists:foreach(Fun, lists:seq(0, 16)),
<a name="otp_9932-last_expr"/><a name="7946"/> 7946: <b>    ets:delete</b>(T).
<a name="7947"/> 7947: 
<a name="7948"/> 7948: 
<a name="7949"/> 7949: <i>%% vm-deadlock caused by race between ets:delete and others on</i>
<a name="7950"/> 7950: <i>%% write_concurrency table.</i>
<a name="otp_9423-1"/><a name="7951"/> 7951: <b>otp_9423</b>(Config) when is_list(Config) -&gt;
<a name="otp_9423-last_expr"/><a name="7952"/> 7952: <b>    repeat_for_all_non_stim_set_table_types</b>(
<a name="7953"/> 7953:       fun(Opts) -&gt;
<a name="7954"/> 7954:               InitF = fun(_) -&gt; {0,0} end,
<a name="7955"/> 7955:               ExecF = fun({S,F}) -&gt;
<a name="7956"/> 7956:                               receive
<a name="7957"/> 7957:                                   stop -&gt;
<a name="7958"/> 7958:                                       io:format(&quot;~p got stop\n&quot;, [self()]),
<a name="7959"/> 7959:                                       [end_of_work | {&quot;Succeded=&quot;,S,&quot;Failed=&quot;,F}]
<a name="7960"/> 7960:                               after 0 -&gt;
<a name="7961"/> 7961:                                       %%io:format(&quot;~p (~p) doing lookup\n&quot;, [self(), {S,F}]),
<a name="7962"/> 7962:                                       try ets:lookup(otp_9423, key) of
<a name="7963"/> 7963:                                           [] -&gt; {S+1,F}
<a name="7964"/> 7964:                                       catch
<a name="7965"/> 7965:                                           error:badarg -&gt; {S,F+1}
<a name="7966"/> 7966:                                       end
<a name="7967"/> 7967:                               end
<a name="7968"/> 7968:                       end,
<a name="7969"/> 7969:               FiniF = fun(R) -&gt; R end,
<a name="7970"/> 7970:               case run_smp_workers(InitF, ExecF, FiniF, infinite, 1) of
<a name="7971"/> 7971:                   Pids when is_list(Pids) -&gt;
<a name="7972"/> 7972:                       %%[P ! start || P &lt;- Pids],
<a name="7973"/> 7973:                       repeat(fun() -&gt; ets_new(otp_9423, [named_table, public,
<a name="7974"/> 7974:                                                          {write_concurrency,true}|Opts]),
<a name="7975"/> 7975:                                       ets:delete(otp_9423)
<a name="7976"/> 7976:                              end, 10000),
<a name="7977"/> 7977:                       [P ! stop || P &lt;- Pids],
<a name="7978"/> 7978:                       wait_pids(Pids),
<a name="7979"/> 7979:                       ok;
<a name="7980"/> 7980: 
<a name="7981"/> 7981:                   Skipped -&gt; Skipped
<a name="7982"/> 7982:               end
<a name="7983"/> 7983:       end).
<a name="7984"/> 7984: 
<a name="7985"/> 7985: 
<a name="7986"/> 7986: 
<a name="7987"/> 7987: <i>%% Corrupted binary in compressed table</i>
<a name="otp_10182-1"/><a name="7988"/> 7988: <b>otp_10182</b>(Config) when is_list(Config) -&gt;
<a name="otp_10182-last_expr"/><a name="7989"/> 7989: <b>    repeat_for_opts_all_table_types</b>(
<a name="7990"/> 7990:       fun(Opts) -&gt;
<a name="7991"/> 7991:               Bin = &lt;&lt;&quot;aHR0cDovL2hvb3RzdWl0ZS5jb20vYy9wcm8tYWRyb2xsLWFi&quot;&gt;&gt;,
<a name="7992"/> 7992:               Key = {test, Bin},
<a name="7993"/> 7993:               Value = base64:decode(Bin),
<a name="7994"/> 7994:               In = {Key,Value},
<a name="7995"/> 7995:               Db = ets_new(undefined, Opts),
<a name="7996"/> 7996:               ets:insert(Db, In),
<a name="7997"/> 7997:               [Out] = ets:lookup(Db, Key),
<a name="7998"/> 7998:               io:format(&quot;In :  ~p\nOut: ~p\n&quot;, [In,Out]),
<a name="7999"/> 7999:               ets:delete(Db),
<a name="8000"/> 8000:               In = Out
<a name="8001"/> 8001:       end).
<a name="8002"/> 8002: 
<a name="8003"/> 8003: <i>%% Verify magic refs in compressed table are reference counted correctly</i>
<a name="compress_magic_ref-1"/><a name="8004"/> 8004: <b>compress_magic_ref</b>(Config) when is_list(Config)-&gt;
<a name="8005"/> 8005:     F = fun(Opts) -&gt;
<a name="8006"/> 8006:                 T = ets:new(banana, Opts),
<a name="8007"/> 8007:                 ets:insert(T, {key, atomics:new(2, [])}),
<a name="8008"/> 8008:                 erlang:garbage_collect(),  % make really sure no ref on heap
<a name="8009"/> 8009:                 [{_, Ref}] = ets:lookup(T, key),
<a name="8010"/> 8010:                 #{size := 2} = atomics:info(Ref), % Still alive!
<a name="8011"/> 8011: 
<a name="8012"/> 8012:                 %% Now test ets:delete will deallocate if last ref
<a name="8013"/> 8013:                 WeakRef = term_to_binary(Ref),
<a name="8014"/> 8014:                 erlang:garbage_collect(),  % make sure no Ref on heap
<a name="8015"/> 8015:                 ets:delete(T, key),
<a name="8016"/> 8016:                 StaleRef = binary_to_term(WeakRef),
<a name="8017"/> 8017:                 badarg = try atomics:info(StaleRef)
<a name="8018"/> 8018:                          catch error:badarg -&gt; badarg end,
<a name="8019"/> 8019:                 ets:delete(T),
<a name="8020"/> 8020:                 ok
<a name="8021"/> 8021:           end,
<a name="8022"/> 8022:     repeat_for_opts(F, [[set, ordered_set], compressed]),
<a name="compress_magic_ref-last_expr"/><a name="8023"/> 8023:     ok.
<a name="8024"/> 8024: 
<a name="8025"/> 8025: <i>%% Test that ets:all include/exclude tables that we know are created/deleted</i>
<a name="ets_all-1"/><a name="8026"/> 8026: <b>ets_all</b>(Config) when is_list(Config) -&gt;
<a name="8027"/> 8027:     Pids = [spawn_link(fun() -&gt; ets_all_run() end) || _ &lt;- [1,2]],
<a name="8028"/> 8028:     receive after 3*1000 -&gt; ok end,
<a name="8029"/> 8029:     [begin unlink(P), exit(P,kill) end || P &lt;- Pids],
<a name="ets_all-last_expr"/><a name="8030"/> 8030:     ok.
<a name="8031"/> 8031: 
<a name="ets_all_run-0"/><a name="8032"/> 8032: <b>ets_all_run</b>() -&gt;
<a name="8033"/> 8033:     Table = ets:new(undefined, []),
<a name="8034"/> 8034:     true = lists:member(Table, ets:all()),
<a name="8035"/> 8035:     ets:delete(Table),
<a name="8036"/> 8036:     false = lists:member(Table, ets:all()),
<a name="ets_all_run-last_expr"/><a name="8037"/> 8037: <b>    ets_all_run</b>().
<a name="8038"/> 8038: 
<a name="create_tables-1"/><a name="8039"/> 8039: <b>create_tables</b>(N) -&gt;
<a name="create_tables-last_expr"/><a name="8040"/> 8040: <b>    create_tables</b>(N, []).
<a name="8041"/> 8041: 
<a name="create_tables-2"/><a name="8042"/> 8042: <b>create_tables</b>(0, Ts) -&gt;
<a name="8043"/> 8043:     Ts;
<a name="8044"/> 8044: <b>create_tables</b>(N, Ts) -&gt;
<a name="create_tables-last_expr"/><a name="8045"/> 8045: <b>    create_tables</b>(N-1, [ets:new(tjo, [])|Ts]).
<a name="8046"/> 8046: 
<a name="massive_ets_all-1"/><a name="8047"/> 8047: <b>massive_ets_all</b>(Config) when is_list(Config) -&gt;
<a name="8048"/> 8048:     Me = self(),
<a name="8049"/> 8049:     InitTables = lists:sort(ets:all()),
<a name="8050"/> 8050:     io:format(&quot;InitTables=~p~n&quot;, [InitTables]),
<a name="8051"/> 8051:     PMs0 = lists:map(fun (Sid) -&gt;
<a name="8052"/> 8052:                              my_spawn_opt(fun () -&gt;
<a name="8053"/> 8053:                                                   Ts = create_tables(250),
<a name="8054"/> 8054:                                                   Me ! {self(), up, Ts},
<a name="8055"/> 8055:                                                   receive {Me, die} -&gt; ok end
<a name="8056"/> 8056:                                           end,
<a name="8057"/> 8057:                                           [link, monitor, {scheduler, Sid}])
<a name="8058"/> 8058:                      end,
<a name="8059"/> 8059:                      lists:seq(1, erlang:system_info(schedulers_online))),
<a name="8060"/> 8060:     AllRes = lists:sort(lists:foldl(fun ({P, _M}, Ts) -&gt;
<a name="8061"/> 8061:                                             receive
<a name="8062"/> 8062:                                                 {P, up, PTs} -&gt;
<a name="8063"/> 8063:                                                     PTs ++ Ts
<a name="8064"/> 8064:                                             end
<a name="8065"/> 8065:                                     end,
<a name="8066"/> 8066:                                     InitTables,
<a name="8067"/> 8067:                                     PMs0)),
<a name="8068"/> 8068:     AllRes = lists:sort(ets:all()),
<a name="8069"/> 8069:     PMs1 = lists:map(fun (_) -&gt;
<a name="8070"/> 8070:                              my_spawn_opt(fun () -&gt;
<a name="8071"/> 8071:                                                   AllRes = lists:sort(ets:all())
<a name="8072"/> 8072:                                           end,
<a name="8073"/> 8073:                                           [link, monitor])
<a name="8074"/> 8074:                      end, lists:seq(1, 50)),
<a name="8075"/> 8075:     lists:foreach(fun ({P, M}) -&gt;
<a name="8076"/> 8076:                           receive
<a name="8077"/> 8077:                               {'DOWN', M, process, P, _} -&gt;
<a name="8078"/> 8078:                                   ok
<a name="8079"/> 8079:                           end
<a name="8080"/> 8080:                   end, PMs1),
<a name="8081"/> 8081:     PMs2 = lists:map(fun (_) -&gt;
<a name="8082"/> 8082:                              my_spawn_opt(fun () -&gt;
<a name="8083"/> 8083:                                                   _ = ets:all()
<a name="8084"/> 8084:                                           end,
<a name="8085"/> 8085:                                           [link, monitor])
<a name="8086"/> 8086:                      end, lists:seq(1, 50)),
<a name="8087"/> 8087:     lists:foreach(fun ({P, _M}) -&gt;
<a name="8088"/> 8088:                           P ! {Me, die}
<a name="8089"/> 8089:                   end, PMs0),
<a name="8090"/> 8090:     lists:foreach(fun ({P, M}) -&gt;
<a name="8091"/> 8091:                           receive
<a name="8092"/> 8092:                               {'DOWN', M, process, P, _} -&gt;
<a name="8093"/> 8093:                                   ok
<a name="8094"/> 8094:                           end
<a name="8095"/> 8095:                   end, PMs0 ++ PMs2),
<a name="8096"/> 8096:     EndTables = lists:sort(ets:all()),
<a name="8097"/> 8097:     io:format(&quot;EndTables=~p~n&quot;, [EndTables]),
<a name="8098"/> 8098:     InitTables = EndTables,
<a name="massive_ets_all-last_expr"/><a name="8099"/> 8099:     ok.
<a name="8100"/> 8100: 
<a name="8101"/> 8101: 
<a name="take-1"/><a name="8102"/> 8102: <b>take</b>(Config) when is_list(Config) -&gt;
<a name="8103"/> 8103:     %% Simple test for set tables.
<a name="8104"/> 8104:     T1 = ets_new(a, [set]),
<a name="8105"/> 8105:     [] = ets:take(T1, foo),
<a name="8106"/> 8106:     ets:insert(T1, {foo,bar}),
<a name="8107"/> 8107:     [] = ets:take(T1, bar),
<a name="8108"/> 8108:     [{foo,bar}] = ets:take(T1, foo),
<a name="8109"/> 8109:     [] = ets:tab2list(T1),
<a name="8110"/> 8110:     %% Non-immediate key.
<a name="8111"/> 8111:     ets:insert(T1, {{'not',&lt;&lt;&quot;immediate&quot;&gt;&gt;},ok}),
<a name="8112"/> 8112:     [{{'not',&lt;&lt;&quot;immediate&quot;&gt;&gt;},ok}] = ets:take(T1, {'not',&lt;&lt;&quot;immediate&quot;&gt;&gt;}),
<a name="8113"/> 8113:     %% Same with ordered tables.
<a name="8114"/> 8114:     repeat_for_all_ord_set_table_types(
<a name="8115"/> 8115:       fun(Opts) -&gt;
<a name="8116"/> 8116:               T2 = ets_new(b, Opts),
<a name="8117"/> 8117:               [] = ets:take(T2, foo),
<a name="8118"/> 8118:               ets:insert(T2, {foo,bar}),
<a name="8119"/> 8119:               [] = ets:take(T2, bar),
<a name="8120"/> 8120:               [{foo,bar}] = ets:take(T2, foo),
<a name="8121"/> 8121:               [] = ets:tab2list(T2),
<a name="8122"/> 8122:               ets:insert(T2, {{'not',&lt;&lt;&quot;immediate&quot;&gt;&gt;},ok}),
<a name="8123"/> 8123:               [{{'not',&lt;&lt;&quot;immediate&quot;&gt;&gt;},ok}] = ets:take(T2, {'not',&lt;&lt;&quot;immediate&quot;&gt;&gt;}),
<a name="8124"/> 8124:               %% Arithmetically-equal keys.
<a name="8125"/> 8125:               ets:insert(T2, [{1.0,float},{2,integer}]),
<a name="8126"/> 8126:               [{1.0,float}] = ets:take(T2, 1),
<a name="8127"/> 8127:               [{2,integer}] = ets:take(T2, 2.0),
<a name="8128"/> 8128:               [] = ets:tab2list(T2),
<a name="8129"/> 8129:               ets:delete(T2)
<a name="8130"/> 8130:       end),
<a name="8131"/> 8131:     %% Same with bag.
<a name="8132"/> 8132:     T3 = ets_new(c, [bag]),
<a name="8133"/> 8133:     ets:insert(T3, [{1,1},{1,2},{3,3}]),
<a name="8134"/> 8134:     R = lists:sort([{1,1},{1,2}]),
<a name="8135"/> 8135:     R = lists:sort(ets:take(T3, 1)),
<a name="8136"/> 8136:     [{3,3}] = ets:take(T3, 3),
<a name="8137"/> 8137:     [] = ets:tab2list(T3),
<a name="8138"/> 8138:     ets:delete(T1),
<a name="8139"/> 8139:     ets:delete(T3),
<a name="take-last_expr"/><a name="8140"/> 8140:     ok.
<a name="8141"/> 8141: 
<a name="whereis_table-1"/><a name="8142"/> 8142: <b>whereis_table</b>(Config) when is_list(Config) -&gt;
<a name="8143"/> 8143:     %% Do we return 'undefined' when the named table doesn't exist?
<a name="8144"/> 8144:     undefined = ets:whereis(whereis_test),
<a name="8145"/> 8145: 
<a name="8146"/> 8146:     %% Does the tid() refer to the same table as the name?
<a name="8147"/> 8147:     whereis_test = ets:new(whereis_test, [named_table]),
<a name="8148"/> 8148:     Tid = ets:whereis(whereis_test),
<a name="8149"/> 8149: 
<a name="8150"/> 8150:     ets:insert(whereis_test, [{hello}, {there}]),
<a name="8151"/> 8151:     CheckMatch =
<a name="8152"/> 8152:         fun(MatchRes) -&gt;
<a name="8153"/> 8153:                 case MatchRes of
<a name="8154"/> 8154:                     [[{there}],[{hello}]] -&gt; ok;
<a name="8155"/> 8155:                     [[{hello}],[{there}]] -&gt; ok
<a name="8156"/> 8156:                 end
<a name="8157"/> 8157:         end,
<a name="8158"/> 8158:     CheckMatch(ets:match(whereis_test, '$1')),
<a name="8159"/> 8159:     CheckMatch(ets:match(Tid, '$1')),
<a name="8160"/> 8160: 
<a name="8161"/> 8161:     true = ets:delete_all_objects(Tid),
<a name="8162"/> 8162: 
<a name="8163"/> 8163:     [] = ets:match(whereis_test, '$1'),
<a name="8164"/> 8164:     [] = ets:match(Tid, '$1'),
<a name="8165"/> 8165: 
<a name="8166"/> 8166:     %% Does the name disappear when deleted through the tid()?
<a name="8167"/> 8167:     true = ets:delete(Tid),
<a name="8168"/> 8168:     undefined = ets:info(whereis_test),
<a name="8169"/> 8169:     {'EXIT',{badarg, _}} = (catch ets:match(whereis_test, '$1')),
<a name="8170"/> 8170: 
<a name="8171"/> 8171:     %% Is the old tid() broken when the table is re-created with the same
<a name="8172"/> 8172:     %% name?
<a name="8173"/> 8173:     whereis_test = ets:new(whereis_test, [named_table]),
<a name="8174"/> 8174:     [] = ets:match(whereis_test, '$1'),
<a name="8175"/> 8175:     {'EXIT',{badarg, _}} = (catch ets:match(Tid, '$1')),
<a name="8176"/> 8176: 
<a name="whereis_table-last_expr"/><a name="8177"/> 8177:     ok.
<a name="8178"/> 8178: 
<a name="ms_excessive_nesting-1"/><a name="8179"/> 8179: <b>ms_excessive_nesting</b>(Config) when is_list(Config) -&gt;
<a name="8180"/> 8180:     MkMSCond = fun (_Fun, N) when N &lt; 0 -&gt; true;
<a name="8181"/> 8181:                    (Fun, N) -&gt; {'orelse', {'==', N, '$1'}, Fun(Fun, N-1)}
<a name="8182"/> 8182:                end,
<a name="8183"/> 8183:     %% Ensure it compiles with substantial but reasonable
<a name="8184"/> 8184:     %% (hmm...) nesting
<a name="8185"/> 8185:     MS = [{{'$1', '$2'}, [MkMSCond(MkMSCond, 100)], [{{'$1', blipp}}]}],
<a name="8186"/> 8186:     io:format(&quot;~p~n&quot;, [erlang:match_spec_test({1, blupp}, MS, table)]),
<a name="8187"/> 8187:     _ = ets:match_spec_compile(MS),
<a name="8188"/> 8188:     %% Now test match_spec_compile() and select_replace()
<a name="8189"/> 8189:     %% with tree and hash using excessive nesting. These
<a name="8190"/> 8190:     %% used to seg-fault the emulator due to recursion
<a name="8191"/> 8191:     %% beyond the end of the C-stack.
<a name="8192"/> 8192:     %%
<a name="8193"/> 8193:     %% We expect to get a system_limit error, but don't
<a name="8194"/> 8194:     %% fail if it compiles (someone must have rewritten
<a name="8195"/> 8195:     %% compilation of match specs to use an explicit
<a name="8196"/> 8196:     %% stack instead of using recursion).
<a name="8197"/> 8197:     ENMS = [{{'$1', '$2'}, [MkMSCond(MkMSCond, 1000000)], [{{'$1', blipp}}]}],
<a name="8198"/> 8198:     io:format(&quot;~p~n&quot;, [erlang:match_spec_test({1, blupp}, ENMS, table)]),
<a name="8199"/> 8199:     ENMSC = try
<a name="8200"/> 8200:                 ets:match_spec_compile(ENMS),
<a name="8201"/> 8201:                 &quot;compiled&quot;
<a name="8202"/> 8202:             catch
<a name="8203"/> 8203:                 error:system_limit -&gt;
<a name="8204"/> 8204:                     &quot;got system_limit&quot;
<a name="8205"/> 8205:             end,
<a name="8206"/> 8206:     Tree = ets:new(tree, [ordered_set]),
<a name="8207"/> 8207:     SRT = try
<a name="8208"/> 8208:               ets:select_replace(Tree, ENMS),
<a name="8209"/> 8209:               &quot;compiled&quot;
<a name="8210"/> 8210:           catch
<a name="8211"/> 8211:               error:system_limit -&gt;
<a name="8212"/> 8212:                   &quot;got system_limit&quot;
<a name="8213"/> 8213:           end,
<a name="8214"/> 8214:     Hash = ets:new(hash, [set]),
<a name="8215"/> 8215:     SRH = try
<a name="8216"/> 8216:               ets:select_replace(Hash, ENMS),
<a name="8217"/> 8217:               &quot;compiled&quot;
<a name="8218"/> 8218:           catch
<a name="8219"/> 8219:               error:system_limit -&gt;
<a name="8220"/> 8220:                   &quot;got system_limit&quot;
<a name="8221"/> 8221:           end,
<a name="ms_excessive_nesting-last_expr"/><a name="8222"/> 8222: <b>    {comment, &quot;match_spec_compile</b>() &quot;++ENMSC++&quot;; select_replace(_,[ordered_set]) &quot;++SRT++&quot;; select_replace(_,[set]) &quot;++SRH}.
<a name="8223"/> 8223: 
<a name="8224"/> 8224: <i>%% The following help functions are used by</i>
<a name="8225"/> 8225: <i>%% throughput_benchmark. They are declared on the top level beacuse</i>
<a name="8226"/> 8226: <i>%% declaring them as function local funs cause a scalability issue.</i>
<a name="get_op-2"/><a name="8227"/> 8227: <b>get_op</b>([{_,O}], _RandNum) -&gt;
<a name="8228"/> 8228:     O;
<a name="8229"/> 8229: <b>get_op</b>([{Prob,O}|Rest], RandNum) -&gt;
<a name="get_op-last_expr"/><a name="8230"/> 8230:     case RandNum &lt; Prob of
<a name="8231"/> 8231:         true -&gt; O;
<a name="8232"/> 8232:         false -&gt; get_op(Rest, RandNum)
<a name="8233"/> 8233:     end.
<a name="do_op-4"/><a name="8234"/> 8234: <b>do_op</b>(Table, ProbHelpTab, Range, Operations) -&gt;
<a name="8235"/> 8235:     RandNum = rand:uniform(),
<a name="8236"/> 8236:     Op = get_op(ProbHelpTab, RandNum),
<a name="8237"/> 8237:     #{ Op := TheOp} = Operations,
<a name="do_op-last_expr"/><a name="8238"/> 8238: <b>    TheOp</b>(Table, Range).
<a name="do_work-5"/><a name="8239"/> 8239: <b>do_work</b>(WorksDoneSoFar, Table, ProbHelpTab, Range, Operations) -&gt;
<a name="do_work-last_expr"/><a name="8240"/> 8240:     receive
<a name="8241"/> 8241:         stop -&gt; WorksDoneSoFar
<a name="8242"/> 8242:     after
<a name="8243"/> 8243:         0 -&gt; do_op(Table, ProbHelpTab, Range, Operations),
<a name="8244"/> 8244:              do_work(WorksDoneSoFar + 1, Table, ProbHelpTab, Range, Operations)
<a name="8245"/> 8245:     end.
<a name="8246"/> 8246: 
<a name="prefill_table-4"/><a name="8247"/> 8247: <b>prefill_table</b>(T, KeyRange, Num, ObjFun) -&gt;
<a name="8248"/> 8248:     Parent = self(),
<a name="8249"/> 8249:     spawn_link(fun() -&gt;
<a name="8250"/> 8250:                        prefill_table_helper(T, KeyRange, Num, ObjFun),
<a name="8251"/> 8251:                        Parent ! done
<a name="8252"/> 8252:                end),
<a name="prefill_table-last_expr"/><a name="8253"/> 8253:     receive done -&gt; ok end.
<a name="8254"/> 8254: 
<a name="prefill_table_helper-4"/><a name="8255"/> 8255: <b>prefill_table_helper</b>(T, KeyRange, Num, ObjFun) -&gt;
<a name="8256"/> 8256:     Seed = rand:uniform(KeyRange),
<a name="8257"/> 8257:     %%io:format(&quot;prefill_table: Seed = ~p\n&quot;, [Seed]),
<a name="8258"/> 8258:     RState = unique_rand_start(KeyRange, Seed),
<a name="prefill_table_helper-last_expr"/><a name="8259"/> 8259: <b>    prefill_table_loop</b>(T, RState, Num, ObjFun).
<a name="8260"/> 8260: 
<a name="prefill_table_loop-4"/><a name="8261"/> 8261: <b>prefill_table_loop</b>(_, _, 0, _) -&gt;
<a name="8262"/> 8262:     ok;
<a name="8263"/> 8263: <b>prefill_table_loop</b>(T, RS0, N, ObjFun) -&gt;
<a name="8264"/> 8264:     {Key, RS1} = unique_rand_next(RS0),
<a name="8265"/> 8265:     ets:insert(T, ObjFun(Key)),
<a name="prefill_table_loop-last_expr"/><a name="8266"/> 8266: <b>    prefill_table_loop</b>(T, RS1, N-1, ObjFun).
<a name="8267"/> 8267: 
<a name="inserter_proc_starter-3"/><a name="8268"/> 8268: <b>inserter_proc_starter</b>(T, ToInsert, Parent) -&gt;
<a name="8269"/> 8269:     receive
<a name="8270"/> 8270:         start -&gt; ok
<a name="8271"/> 8271:     end,
<a name="inserter_proc_starter-last_expr"/><a name="8272"/> 8272: <b>    inserter_proc</b>(T, ToInsert, [], Parent, false).
<a name="8273"/> 8273: 
<a name="inserter_proc-5"/><a name="8274"/> 8274: <b>inserter_proc</b>(T, [], Inserted, Parent, _) -&gt;
<a name="8275"/> 8275:     inserter_proc(T, Inserted, [], Parent, true);
<a name="8276"/> 8276: <b>inserter_proc</b>(T, [I | ToInsert], Inserted, Parent, CanStop) -&gt;
<a name="8277"/> 8277:     Stop =
<a name="8278"/> 8278:         case CanStop of
<a name="8279"/> 8279:             true -&gt;
<a name="8280"/> 8280:                 receive
<a name="8281"/> 8281:                     stop -&gt; Parent ! stopped
<a name="8282"/> 8282:                 after 0 -&gt; no_stop
<a name="8283"/> 8283:                 end;
<a name="8284"/> 8284:             false -&gt; no_stop
<a name="8285"/> 8285:         end,
<a name="inserter_proc-last_expr"/><a name="8286"/> 8286:     case Stop of
<a name="8287"/> 8287:         no_stop -&gt;
<a name="8288"/> 8288:             ets:insert(T, I),
<a name="8289"/> 8289:             inserter_proc(T, ToInsert, [I | Inserted], Parent, CanStop);
<a name="8290"/> 8290:         _ -&gt; ok
<a name="8291"/> 8291:     end.
<a name="8292"/> 8292: 
<a name="prefill_table_parallel-4"/><a name="8293"/> 8293: <b>prefill_table_parallel</b>(T, KeyRange, Num, ObjFun) -&gt;
<a name="8294"/> 8294:     Parent = self(),
<a name="8295"/> 8295:     spawn_link(fun() -&gt;
<a name="8296"/> 8296:                        prefill_table_parallel_helper(T, KeyRange, Num, ObjFun),
<a name="8297"/> 8297:                        Parent ! done
<a name="8298"/> 8298:                end),
<a name="prefill_table_parallel-last_expr"/><a name="8299"/> 8299:     receive done -&gt; ok end.
<a name="8300"/> 8300: 
<a name="prefill_table_parallel_helper-4"/><a name="8301"/> 8301: <b>prefill_table_parallel_helper</b>(T, KeyRange, Num, ObjFun) -&gt;
<a name="8302"/> 8302:     NrOfSchedulers = erlang:system_info(schedulers),
<a name="8303"/> 8303:     Seed = rand:uniform(KeyRange),
<a name="8304"/> 8304:     %%io:format(&quot;prefill_table: Seed = ~p\n&quot;, [Seed]),
<a name="8305"/> 8305:     RState = unique_rand_start(KeyRange, Seed),
<a name="8306"/> 8306:     InsertMap = prefill_insert_map_loop(T, RState, Num, ObjFun, #{}, NrOfSchedulers),
<a name="8307"/> 8307:     Self = self(),
<a name="8308"/> 8308:     Pids = [
<a name="8309"/> 8309:         begin
<a name="8310"/> 8310:             InserterFun =
<a name="8311"/> 8311:                 fun() -&gt;
<a name="8312"/> 8312:                     inserter_proc_starter(T, ToInsert, Self)
<a name="8313"/> 8313:                 end,
<a name="8314"/> 8314:             spawn_link(InserterFun)
<a name="8315"/> 8315:         end
<a name="8316"/> 8316:         || ToInsert &lt;- maps:values(InsertMap)],
<a name="8317"/> 8317:     [Pid ! start || Pid &lt;- Pids],
<a name="8318"/> 8318:     timer:sleep(1000),
<a name="8319"/> 8319:     [Pid ! stop || Pid &lt;- Pids],
<a name="prefill_table_parallel_helper-last_expr"/><a name="8320"/> 8320:     [receive stopped -&gt; ok end || _Pid &lt;- Pids].
<a name="8321"/> 8321: 
<a name="prefill_insert_map_loop-6"/><a name="8322"/> 8322: <b>prefill_insert_map_loop</b>(_, _, 0, _, InsertMap, _NrOfSchedulers) -&gt;
<a name="8323"/> 8323:     InsertMap;
<a name="8324"/> 8324: <b>prefill_insert_map_loop</b>(T, RS0, N, ObjFun, InsertMap, NrOfSchedulers) -&gt;
<a name="8325"/> 8325:     {Key, RS1} = unique_rand_next(RS0),
<a name="8326"/> 8326:     Sched = N rem NrOfSchedulers,
<a name="8327"/> 8327:     PrevInserts = maps:get(Sched, InsertMap, []),
<a name="8328"/> 8328:     NewPrevInserts = [ObjFun(Key) | PrevInserts],
<a name="8329"/> 8329:     NewInsertMap = maps:put(Sched, NewPrevInserts, InsertMap),
<a name="prefill_insert_map_loop-last_expr"/><a name="8330"/> 8330: <b>    prefill_insert_map_loop</b>(T, RS1, N-1, ObjFun, NewInsertMap, NrOfSchedulers).
<a name="8331"/> 8331: 
<a name="8332"/> 8332: <b>-record</b>(ets_throughput_bench_config,
<a name="8333"/> 8333:         {benchmark_duration_ms = 3000,
<a name="8334"/> 8334:          recover_time_ms = 1000,
<a name="8335"/> 8335:          thread_counts = not_set,
<a name="8336"/> 8336:          key_ranges = [1000000],
<a name="8337"/> 8337:          init_functions = [fun prefill_table/4],
<a name="8338"/> 8338:          nr_of_repeats = 1,
<a name="8339"/> 8339:          scenarios =
<a name="8340"/> 8340:              [
<a name="8341"/> 8341:               [
<a name="8342"/> 8342:                {0.5, insert},
<a name="8343"/> 8343:                {0.5, delete}
<a name="8344"/> 8344:               ],
<a name="8345"/> 8345:               [
<a name="8346"/> 8346:                {0.1, insert},
<a name="8347"/> 8347:                {0.1, delete},
<a name="8348"/> 8348:                {0.8, lookup}
<a name="8349"/> 8349:               ],
<a name="8350"/> 8350:               [
<a name="8351"/> 8351:                {0.01, insert},
<a name="8352"/> 8352:                {0.01, delete},
<a name="8353"/> 8353:                {0.98, lookup}
<a name="8354"/> 8354:               ],
<a name="8355"/> 8355:               [
<a name="8356"/> 8356:                {1.0, lookup}
<a name="8357"/> 8357:               ],
<a name="8358"/> 8358:               [
<a name="8359"/> 8359:                {0.1, insert},
<a name="8360"/> 8360:                {0.1, delete},
<a name="8361"/> 8361:                {0.4, lookup},
<a name="8362"/> 8362:                {0.4, nextseq10}
<a name="8363"/> 8363:               ],
<a name="8364"/> 8364:               [
<a name="8365"/> 8365:                {0.1, insert},
<a name="8366"/> 8366:                {0.1, delete},
<a name="8367"/> 8367:                {0.4, lookup},
<a name="8368"/> 8368:                {0.4, nextseq100}
<a name="8369"/> 8369:               ],
<a name="8370"/> 8370:               [
<a name="8371"/> 8371:                {0.1, insert},
<a name="8372"/> 8372:                {0.1, delete},
<a name="8373"/> 8373:                {0.4, lookup},
<a name="8374"/> 8374:                {0.4, nextseq1000}
<a name="8375"/> 8375:               ],
<a name="8376"/> 8376:               [
<a name="8377"/> 8377:                {1.0, nextseq1000}
<a name="8378"/> 8378:               ],
<a name="8379"/> 8379:               [
<a name="8380"/> 8380:                {0.1, insert},
<a name="8381"/> 8381:                {0.1, delete},
<a name="8382"/> 8382:                {0.79, lookup},
<a name="8383"/> 8383:                {0.01, selectAll}
<a name="8384"/> 8384:               ],
<a name="8385"/> 8385:               [
<a name="8386"/> 8386:                {0.1, insert},
<a name="8387"/> 8387:                {0.1, delete},
<a name="8388"/> 8388:                {0.7999, lookup},
<a name="8389"/> 8389:                {0.0001, selectAll}
<a name="8390"/> 8390:               ],
<a name="8391"/> 8391:               [
<a name="8392"/> 8392:                {0.1, insert},
<a name="8393"/> 8393:                {0.1, delete},
<a name="8394"/> 8394:                {0.799999, lookup},
<a name="8395"/> 8395:                {0.000001, selectAll}
<a name="8396"/> 8396:               ],
<a name="8397"/> 8397:               [
<a name="8398"/> 8398:                {0.1, insert},
<a name="8399"/> 8399:                {0.1, delete},
<a name="8400"/> 8400:                {0.79, lookup},
<a name="8401"/> 8401:                {0.01, partial_select1000}
<a name="8402"/> 8402:               ],
<a name="8403"/> 8403:               [
<a name="8404"/> 8404:                {0.1, insert},
<a name="8405"/> 8405:                {0.1, delete},
<a name="8406"/> 8406:                {0.7999, lookup},
<a name="8407"/> 8407:                {0.0001, partial_select1000}
<a name="8408"/> 8408:               ],
<a name="8409"/> 8409:               [
<a name="8410"/> 8410:                {0.1, insert},
<a name="8411"/> 8411:                {0.1, delete},
<a name="8412"/> 8412:                {0.799999, lookup},
<a name="8413"/> 8413:                {0.000001, partial_select1000}
<a name="8414"/> 8414:               ]
<a name="8415"/> 8415:              ],
<a name="8416"/> 8416:          table_types =
<a name="8417"/> 8417:              [
<a name="8418"/> 8418:               [ordered_set, public],
<a name="8419"/> 8419:               [ordered_set, public, {write_concurrency, true}],
<a name="8420"/> 8420:               [ordered_set, public, {read_concurrency, true}],
<a name="8421"/> 8421:               [ordered_set, public, {write_concurrency, true}, {read_concurrency, true}],
<a name="8422"/> 8422:               [set, public],
<a name="8423"/> 8423:               [set, public, {write_concurrency, true}],
<a name="8424"/> 8424:               [set, public, {read_concurrency, true}],
<a name="8425"/> 8425:               [set, public, {write_concurrency, true}, {read_concurrency, true}],
<a name="8426"/> 8426:               [set, public, {write_concurrency, auto}, {read_concurrency, true}],
<a name="8427"/> 8427:               [set, public, {write_concurrency, {debug_hash_fixed_number_of_locks, 16384}}]
<a name="8428"/> 8428:              ],
<a name="8429"/> 8429:          etsmem_fun = fun() -&gt; ok end,
<a name="8430"/> 8430:          verify_etsmem_fun = fun(_) -&gt; true end,
<a name="8431"/> 8431:          notify_res_fun = fun(_Name, _Throughput) -&gt; ok end,
<a name="8432"/> 8432:          print_result_paths_fun =
<a name="8433"/> 8433:              fun(ResultPath, _LatestResultPath) -&gt;
<a name="8434"/> 8434:                      Comment =
<a name="8435"/> 8435:                          io_lib:format(&quot;&lt;a href=\&quot;file:///~s\&quot;&gt;Result visualization&lt;/a&gt;&quot;,[ResultPath]),
<a name="8436"/> 8436:                      {comment, Comment}
<a name="8437"/> 8437:              end
<a name="8438"/> 8438:        }).
<a name="8439"/> 8439: 
<a name="stdout_notify_res-2"/><a name="8440"/> 8440: <b>stdout_notify_res</b>(ResultPath, LatestResultPath) -&gt;
<a name="8441"/> 8441:     io:format(&quot;Result Location: /~s~n&quot;, [ResultPath]),
<a name="stdout_notify_res-last_expr"/><a name="8442"/> 8442: <b>    io:format</b>(&quot;Latest Result Location: ~s~n&quot;, [LatestResultPath]).
<a name="8443"/> 8443: 
<a name="throughput_benchmark-0"/><a name="8444"/> 8444: <b>throughput_benchmark</b>() -&gt;
<a name="throughput_benchmark-last_expr"/><a name="8445"/> 8445: <b>    throughput_benchmark</b>(
<a name="8446"/> 8446:       #ets_throughput_bench_config{
<a name="8447"/> 8447:          print_result_paths_fun = fun stdout_notify_res/2}).
<a name="8448"/> 8448: 
<a name="throughput_benchmark-1"/><a name="8449"/> 8449: <b>throughput_benchmark</b>(
<a name="8450"/> 8450:   #ets_throughput_bench_config{
<a name="8451"/> 8451:      benchmark_duration_ms  = BenchmarkDurationMs,
<a name="8452"/> 8452:      recover_time_ms        = RecoverTimeMs,
<a name="8453"/> 8453:      thread_counts          = ThreadCountsOpt,
<a name="8454"/> 8454:      key_ranges             = KeyRanges,
<a name="8455"/> 8455:      init_functions         = InitFuns,
<a name="8456"/> 8456:      nr_of_repeats          = NrOfRepeats,
<a name="8457"/> 8457:      scenarios              = Scenarios,
<a name="8458"/> 8458:      table_types            = TableTypes,
<a name="8459"/> 8459:      etsmem_fun             = ETSMemFun,
<a name="8460"/> 8460:      verify_etsmem_fun      = VerifyETSMemFun,
<a name="8461"/> 8461:      notify_res_fun         = NotifyResFun,
<a name="8462"/> 8462:      print_result_paths_fun = PrintResultPathsFun}) -&gt;
<a name="8463"/> 8463:     NrOfSchedulers = erlang:system_info(schedulers),
<a name="8464"/> 8464:     %% Definitions of operations that are supported by the benchmark
<a name="8465"/> 8465:     NextSeqOp =
<a name="8466"/> 8466:         fun (T, KeyRange, SeqSize) -&gt;
<a name="8467"/> 8467:                 Start = rand:uniform(KeyRange),
<a name="8468"/> 8468:                 Last =
<a name="8469"/> 8469:                     lists:foldl(
<a name="8470"/> 8470:                       fun(_, Prev) -&gt;
<a name="8471"/> 8471:                               case Prev of
<a name="8472"/> 8472:                                   '$end_of_table'-&gt; ok;
<a name="8473"/> 8473:                                   _ -&gt;
<a name="8474"/> 8474:                                       try ets:next(T, Prev) of
<a name="8475"/> 8475:                                            Normal -&gt; Normal
<a name="8476"/> 8476:                                        catch
<a name="8477"/> 8477:                                            error:badarg -&gt;
<a name="8478"/> 8478:                                                % sets (not ordered_sets) cannot handle when the argument
<a name="8479"/> 8479:                                                % to next is not in the set
<a name="8480"/> 8480:                                                rand:uniform(KeyRange)
<a name="8481"/> 8481:                                        end
<a name="8482"/> 8482:                               end
<a name="8483"/> 8483:                       end,
<a name="8484"/> 8484:                       Start,
<a name="8485"/> 8485:                       lists:seq(1, SeqSize)),
<a name="8486"/> 8486:                 case Last =:= -1 of
<a name="8487"/> 8487:                     true -&gt; io:format(&quot;Will never be printed&quot;);
<a name="8488"/> 8488:                     false -&gt; ok
<a name="8489"/> 8489:                 end
<a name="8490"/> 8490:         end,
<a name="8491"/> 8491:     PartialSelectOp =
<a name="8492"/> 8492:         fun (T, KeyRange, SeqSize) -&gt;
<a name="8493"/> 8493:                 Start = rand:uniform(KeyRange),
<a name="8494"/> 8494:                 Last = Start + SeqSize,
<a name="8495"/> 8495:                 case -1 =:= ets:select_count(T,
<a name="8496"/> 8496:                                              ets:fun2ms(fun({X}) when X &gt; Start andalso X =&lt; Last  -&gt; true end)) of
<a name="8497"/> 8497:                     true -&gt; io:format(&quot;Will never be printed&quot;);
<a name="8498"/> 8498:                     false -&gt; ok
<a name="8499"/> 8499:                 end
<a name="8500"/> 8500: 
<a name="8501"/> 8501:         end,
<a name="8502"/> 8502:     %% Mapping benchmark operation names to their corresponding functions that do them
<a name="8503"/> 8503:     Operations =
<a name="8504"/> 8504:         #{insert =&gt;
<a name="8505"/> 8505:               fun(T,KeyRange) -&gt;
<a name="8506"/> 8506:                       Num = rand:uniform(KeyRange),
<a name="8507"/> 8507:                       ets:insert(T, {Num})
<a name="8508"/> 8508:               end,
<a name="8509"/> 8509:           delete =&gt;
<a name="8510"/> 8510:               fun(T,KeyRange) -&gt;
<a name="8511"/> 8511:                       Num = rand:uniform(KeyRange),
<a name="8512"/> 8512:                       ets:delete(T, Num)
<a name="8513"/> 8513:               end,
<a name="8514"/> 8514:           lookup =&gt;
<a name="8515"/> 8515:               fun(T,KeyRange) -&gt;
<a name="8516"/> 8516:                       Num = rand:uniform(KeyRange),
<a name="8517"/> 8517:                       ets:lookup(T, Num)
<a name="8518"/> 8518:               end,
<a name="8519"/> 8519:           nextseq10 =&gt;
<a name="8520"/> 8520:               fun(T,KeyRange) -&gt; NextSeqOp(T,KeyRange,10) end,
<a name="8521"/> 8521:           nextseq100 =&gt;
<a name="8522"/> 8522:               fun(T,KeyRange) -&gt; NextSeqOp(T,KeyRange,100) end,
<a name="8523"/> 8523:           nextseq1000 =&gt;
<a name="8524"/> 8524:               fun(T,KeyRange) -&gt; NextSeqOp(T,KeyRange,1000) end,
<a name="8525"/> 8525:           selectAll =&gt;
<a name="8526"/> 8526:               fun(T,_KeyRange) -&gt;
<a name="8527"/> 8527:                       case -1 =:= ets:select_count(T, ets:fun2ms(fun(_X) -&gt; true end)) of
<a name="8528"/> 8528:                           true -&gt; io:format(&quot;Will never be printed&quot;);
<a name="8529"/> 8529:                           false -&gt; ok
<a name="8530"/> 8530:                       end
<a name="8531"/> 8531:               end,
<a name="8532"/> 8532:           partial_select1000 =&gt;
<a name="8533"/> 8533:               fun(T,KeyRange) -&gt; PartialSelectOp(T,KeyRange,1000) end
<a name="8534"/> 8534:          },
<a name="8535"/> 8535:     %% Helper functions
<a name="8536"/> 8536:     CalculateThreadCounts = fun Calculate([Count|Rest]) -&gt;
<a name="8537"/> 8537:                                     case Count &gt; NrOfSchedulers of
<a name="8538"/> 8538:                                         true -&gt; lists:reverse(Rest);
<a name="8539"/> 8539:                                         false -&gt; Calculate([Count*2,Count|Rest])
<a name="8540"/> 8540:                                     end
<a name="8541"/> 8541:                             end,
<a name="8542"/> 8542:     CalculateOpsProbHelpTab =
<a name="8543"/> 8543:         fun Calculate([{_, OpName}], _) -&gt;
<a name="8544"/> 8544:                 [{1.0, OpName}];
<a name="8545"/> 8545:             Calculate([{OpPropability, OpName}|Res], Current) -&gt;
<a name="8546"/> 8546:                 NewCurrent = Current + OpPropability,
<a name="8547"/> 8547:                 [{NewCurrent, OpName}| Calculate(Res, NewCurrent)]
<a name="8548"/> 8548:         end,
<a name="8549"/> 8549:     RenderScenario =
<a name="8550"/> 8550:         fun R([], StringSoFar) -&gt;
<a name="8551"/> 8551:                 StringSoFar;
<a name="8552"/> 8552:             R([{Fraction, Operation}], StringSoFar) -&gt;
<a name="8553"/> 8553:                 io_lib:format(&quot;~s ~f% ~p&quot;,[StringSoFar, Fraction * 100.0, Operation]);
<a name="8554"/> 8554:             R([{Fraction, Operation}|Rest], StringSoFar) -&gt;
<a name="8555"/> 8555:                 R(Rest,
<a name="8556"/> 8556:                   io_lib:format(&quot;~s ~f% ~p, &quot;,[StringSoFar, Fraction * 100.0, Operation]))
<a name="8557"/> 8557:         end,
<a name="8558"/> 8558:     SafeFixTableIfRequired =
<a name="8559"/> 8559:         fun(Table, Scenario, On) -&gt;
<a name="8560"/> 8560:                 case set =:= ets:info(Table, type) of
<a name="8561"/> 8561:                     true -&gt;
<a name="8562"/> 8562:                         HasNotRequiringOp  =
<a name="8563"/> 8563:                             lists:search(
<a name="8564"/> 8564:                               fun({_,nextseq10}) -&gt; true;
<a name="8565"/> 8565:                                  ({_,nextseq100}) -&gt; true;
<a name="8566"/> 8566:                                  ({_,nextseq1000}) -&gt; true;
<a name="8567"/> 8567:                                  (_) -&gt; false
<a name="8568"/> 8568:                               end, Scenario),
<a name="8569"/> 8569:                         case HasNotRequiringOp of
<a name="8570"/> 8570:                             false -&gt; ok;
<a name="8571"/> 8571:                             _ -&gt; ets:safe_fixtable(Table, On)
<a name="8572"/> 8572:                         end;
<a name="8573"/> 8573:                     false -&gt; ok
<a name="8574"/> 8574:                 end
<a name="8575"/> 8575:         end,
<a name="8576"/> 8576:     DataHolder =
<a name="8577"/> 8577:         fun DataHolderFun(Data)-&gt;
<a name="8578"/> 8578:                 receive
<a name="8579"/> 8579:                     {get_data, Pid} -&gt; Pid ! {ets_bench_data, Data};
<a name="8580"/> 8580:                     D -&gt; DataHolderFun([Data,D])
<a name="8581"/> 8581:                 end
<a name="8582"/> 8582:         end,
<a name="8583"/> 8583:     DataHolderPid = spawn_link(fun()-&gt; DataHolder([]) end),
<a name="8584"/> 8584:     PrintData =
<a name="8585"/> 8585:         fun (Str, List) -&gt;
<a name="8586"/> 8586:                 io:format(Str, List),
<a name="8587"/> 8587:                 DataHolderPid ! io_lib:format(Str, List)
<a name="8588"/> 8588:         end,
<a name="8589"/> 8589:     GetData =
<a name="8590"/> 8590:         fun () -&gt;
<a name="8591"/> 8591:                 DataHolderPid ! {get_data, self()},
<a name="8592"/> 8592:                 receive {ets_bench_data, Data} -&gt; Data end
<a name="8593"/> 8593:         end,
<a name="8594"/> 8594:     %% Function that runs a benchmark instance and returns the number
<a name="8595"/> 8595:     %% of operations that were performed
<a name="8596"/> 8596:     RunBenchmark =
<a name="8597"/> 8597:         fun({NrOfProcs, TableConfig, Scenario, Range, Duration, InitFun}) -&gt;
<a name="8598"/> 8598:                 ProbHelpTab = CalculateOpsProbHelpTab(Scenario, 0),
<a name="8599"/> 8599:                 Table = ets:new(t, TableConfig),
<a name="8600"/> 8600:                 Nobj = Range div 2,
<a name="8601"/> 8601:                 case InitFun of
<a name="8602"/> 8602:                     not_set -&gt; prefill_table(Table, Range, Nobj, fun(K) -&gt; {K} end);
<a name="8603"/> 8603:                     _ -&gt; InitFun(Table, Range, Nobj, fun(K) -&gt; {K} end)
<a name="8604"/> 8604:                 end,
<a name="8605"/> 8605:                 Nobj = ets:info(Table, size),
<a name="8606"/> 8606:                 SafeFixTableIfRequired(Table, Scenario, true),
<a name="8607"/> 8607:                 ParentPid = self(),
<a name="8608"/> 8608:                 Worker =
<a name="8609"/> 8609:                     fun() -&gt;
<a name="8610"/> 8610:                             receive start -&gt; ok end,
<a name="8611"/> 8611:                             WorksDone =
<a name="8612"/> 8612:                                 do_work(0, Table, ProbHelpTab, Range, Operations),
<a name="8613"/> 8613:                             ParentPid ! WorksDone
<a name="8614"/> 8614:                     end,
<a name="8615"/> 8615:                 ChildPids =
<a name="8616"/> 8616:                     lists:map(fun(_N) -&gt;spawn_link(Worker)end, lists:seq(1, NrOfProcs)),
<a name="8617"/> 8617:                 erlang:garbage_collect(),
<a name="8618"/> 8618:                 timer:sleep(RecoverTimeMs),
<a name="8619"/> 8619:                 lists:foreach(fun(Pid) -&gt; Pid ! start end, ChildPids),
<a name="8620"/> 8620:                 timer:sleep(Duration),
<a name="8621"/> 8621:                 lists:foreach(fun(Pid) -&gt; Pid ! stop end, ChildPids),
<a name="8622"/> 8622:                 TotalWorksDone = lists:foldl(
<a name="8623"/> 8623:                                    fun(_, Sum) -&gt;
<a name="8624"/> 8624:                                            receive
<a name="8625"/> 8625:                                                Count -&gt; Sum + Count
<a name="8626"/> 8626:                                            end
<a name="8627"/> 8627:                                    end, 0, ChildPids),
<a name="8628"/> 8628:                 SafeFixTableIfRequired(Table, Scenario, false),
<a name="8629"/> 8629:                 ets:delete(Table),
<a name="8630"/> 8630:                 TotalWorksDone
<a name="8631"/> 8631:         end,
<a name="8632"/> 8632:     RunBenchmarkInSepProcess =
<a name="8633"/> 8633:         fun(ParameterTuple) -&gt;
<a name="8634"/> 8634:                 P = self(),
<a name="8635"/> 8635:                 Results =
<a name="8636"/> 8636:                     [begin
<a name="8637"/> 8637:                          spawn_link(fun()-&gt; P ! {bench_result, RunBenchmark(ParameterTuple)} end),
<a name="8638"/> 8638:                          receive {bench_result, Res} -&gt; Res end
<a name="8639"/> 8639:                      end || _ &lt;- lists:seq(1, NrOfRepeats)],
<a name="8640"/> 8640:                 lists:sum(Results) / NrOfRepeats
<a name="8641"/> 8641:         end,
<a name="8642"/> 8642:     RunBenchmarkAndReport =
<a name="8643"/> 8643:         fun(ThreadCount,
<a name="8644"/> 8644:             TableType,
<a name="8645"/> 8645:             Scenario,
<a name="8646"/> 8646:             KeyRange,
<a name="8647"/> 8647:             Duration,
<a name="8648"/> 8648:             InitFunName,
<a name="8649"/> 8649:             InitFun) -&gt;
<a name="8650"/> 8650:                 Result = RunBenchmarkInSepProcess({ThreadCount,
<a name="8651"/> 8651:                                                    TableType,
<a name="8652"/> 8652:                                                    Scenario,
<a name="8653"/> 8653:                                                    KeyRange,
<a name="8654"/> 8654:                                                    Duration,
<a name="8655"/> 8655:                                                    InitFun}),
<a name="8656"/> 8656:                 Throughput = Result/(Duration/1000.0),
<a name="8657"/> 8657:                 PrintData(&quot;; ~f&quot;,[Throughput]),
<a name="8658"/> 8658:                 Name = io_lib:format(&quot;Scenario: ~s, ~w, Key Range Size: ~w, &quot;
<a name="8659"/> 8659:                                      &quot;# of Processes: ~w, Table Type: ~w&quot;,
<a name="8660"/> 8660:                                      [InitFunName, Scenario, KeyRange, ThreadCount, TableType]),
<a name="8661"/> 8661:                 NotifyResFun(Name, Throughput)
<a name="8662"/> 8662:         end,
<a name="8663"/> 8663:     ThreadCounts =
<a name="8664"/> 8664:         case ThreadCountsOpt of
<a name="8665"/> 8665:             not_set -&gt;
<a name="8666"/> 8666:                 CalculateThreadCounts([1]);
<a name="8667"/> 8667:             _ -&gt; ThreadCountsOpt
<a name="8668"/> 8668:         end,
<a name="8669"/> 8669:     %% Run the benchmark
<a name="8670"/> 8670:     PrintData(&quot;# Each instance of the benchmark runs for ~w seconds:~n&quot;, [BenchmarkDurationMs/1000]),
<a name="8671"/> 8671:     PrintData(&quot;# The result of a benchmark instance is presented as a number representing~n&quot;,[]),
<a name="8672"/> 8672:     PrintData(&quot;# the number of operations performed per second:~n~n~n&quot;,[]),
<a name="8673"/> 8673:     PrintData(&quot;# To plot graphs for the results below:~n&quot;,[]),
<a name="8674"/> 8674:     PrintData(&quot;# 1. Open \&quot;$ERL_TOP/lib/stdlib/test/ets_SUITE_data/visualize_throughput.html\&quot; in a web browser~n&quot;,[]),
<a name="8675"/> 8675:     PrintData(&quot;# 2. Copy the lines between \&quot;#BENCHMARK STARTED$\&quot; and \&quot;#BENCHMARK ENDED$\&quot; below~n&quot;,[]),
<a name="8676"/> 8676:     PrintData(&quot;# 3. Paste the lines copied in step 2 to the text box in the browser window opened in~n&quot;,[]),
<a name="8677"/> 8677:     PrintData(&quot;#    step 1 and press the Render button~n~n&quot;,[]),
<a name="8678"/> 8678:     PrintData(&quot;#BENCHMARK STARTED$~n&quot;,[]),
<a name="8679"/> 8679:     EtsMem = ETSMemFun(),
<a name="8680"/> 8680:     %% The following loop runs all benchmark scenarios and prints the results (i.e, operations/second)
<a name="8681"/> 8681:     lists:foreach(
<a name="8682"/> 8682:       fun(KeyRange) -&gt;
<a name="8683"/> 8683:               lists:foreach(
<a name="8684"/> 8684:                 fun(Scenario) -&gt;
<a name="8685"/> 8685:                         PrintData(&quot;Scenario: ~s | Key Range Size: ~w$~n&quot;,
<a name="8686"/> 8686:                                   [RenderScenario(Scenario, &quot;&quot;), KeyRange]),
<a name="8687"/> 8687:                         lists:foreach(
<a name="8688"/> 8688:                           fun(ThreadCount) -&gt;
<a name="8689"/> 8689:                                   PrintData(&quot;; ~w&quot;,[ThreadCount])
<a name="8690"/> 8690:                           end,
<a name="8691"/> 8691:                           ThreadCounts),
<a name="8692"/> 8692:                         PrintData(&quot;$~n&quot;,[]),
<a name="8693"/> 8693:                         lists:foreach(
<a name="8694"/> 8694:                           fun(TableType) -&gt;
<a name="8695"/> 8695:                                   lists:foreach(
<a name="8696"/> 8696:                                     fun(InitFunArg) -&gt;
<a name="8697"/> 8697:                                             {InitFunName, InitFun} =
<a name="8698"/> 8698:                                                 case InitFunArg of
<a name="8699"/> 8699:                                                     {FunName, Fun} -&gt; {FunName, Fun};
<a name="8700"/> 8700:                                                     Fun -&gt; {&quot;&quot;, Fun}
<a name="8701"/> 8701:                                                 end,
<a name="8702"/> 8702:                                             PrintData(&quot;~s,~w &quot;,[InitFunName,TableType]),
<a name="8703"/> 8703:                                             lists:foreach(
<a name="8704"/> 8704:                                               fun(ThreadCount) -&gt;
<a name="8705"/> 8705:                                                       RunBenchmarkAndReport(ThreadCount,
<a name="8706"/> 8706:                                                                             TableType,
<a name="8707"/> 8707:                                                                             Scenario,
<a name="8708"/> 8708:                                                                             KeyRange,
<a name="8709"/> 8709:                                                                             BenchmarkDurationMs,
<a name="8710"/> 8710:                                                                             InitFunName,
<a name="8711"/> 8711:                                                                             InitFun)
<a name="8712"/> 8712:                                               end,
<a name="8713"/> 8713:                                               ThreadCounts),
<a name="8714"/> 8714:                                             PrintData(&quot;$~n&quot;,[])
<a name="8715"/> 8715:                                     end,
<a name="8716"/> 8716:                                     InitFuns)
<a name="8717"/> 8717: 
<a name="8718"/> 8718:                           end,
<a name="8719"/> 8719:                           TableTypes)
<a name="8720"/> 8720:                 end,
<a name="8721"/> 8721:                 Scenarios)
<a name="8722"/> 8722:       end,
<a name="8723"/> 8723:       KeyRanges),
<a name="8724"/> 8724:     PrintData(&quot;~n#BENCHMARK ENDED$~n~n&quot;,[]),
<a name="8725"/> 8725:     VerifyETSMemFun(EtsMem),
<a name="8726"/> 8726:     DataDir = filename:join(filename:dirname(code:which(?MODULE)), &quot;ets_SUITE_data&quot;),
<a name="8727"/> 8727:     TemplatePath = filename:join(DataDir, &quot;visualize_throughput.html&quot;),
<a name="8728"/> 8728:     {ok, Template} = file:read_file(TemplatePath),
<a name="8729"/> 8729:     OutputData = string:replace(Template, &quot;#bench_data_placeholder&quot;, GetData()),
<a name="8730"/> 8730:     OutputPath1 = filename:join(DataDir, &quot;ets_bench_result.html&quot;),
<a name="8731"/> 8731:     {{Year, Month, Day}, {Hour, Minute, Second}} = calendar:now_to_datetime(erlang:timestamp()),
<a name="8732"/> 8732:     StrTime = lists:flatten(io_lib:format(&quot;~4..0w-~2..0w-~2..0wT~2..0w:~2..0w:~2..0w&quot;,[Year,Month,Day,Hour,Minute,Second])),
<a name="8733"/> 8733:     OutputPath2 = filename:join(DataDir, io_lib:format(&quot;ets_bench_result_~s.html&quot;, [StrTime])),
<a name="8734"/> 8734:     file:write_file(OutputPath1, OutputData),
<a name="8735"/> 8735:     file:write_file(OutputPath2, OutputData),
<a name="throughput_benchmark-last_expr"/><a name="8736"/> 8736: <b>    PrintResultPathsFun</b>(OutputPath2, OutputPath1).
<a name="8737"/> 8737: 
<a name="test_throughput_benchmark-1"/><a name="8738"/> 8738: <b>test_throughput_benchmark</b>(Config) when is_list(Config) -&gt;
<a name="test_throughput_benchmark-last_expr"/><a name="8739"/> 8739: <b>    throughput_benchmark</b>(
<a name="8740"/> 8740:       #ets_throughput_bench_config{
<a name="8741"/> 8741:          benchmark_duration_ms = 100,
<a name="8742"/> 8742:          recover_time_ms = 0,
<a name="8743"/> 8743:          thread_counts = [1, erlang:system_info(schedulers)],
<a name="8744"/> 8744:          key_ranges = [50000],
<a name="8745"/> 8745:          etsmem_fun = fun etsmem/0,
<a name="8746"/> 8746:          verify_etsmem_fun = fun verify_etsmem/1}).
<a name="8747"/> 8747: 
<a name="long_throughput_benchmark-1"/><a name="8748"/> 8748: <b>long_throughput_benchmark</b>(Config) when is_list(Config) -&gt;
<a name="8749"/> 8749:     N = erlang:system_info(schedulers),
<a name="long_throughput_benchmark-last_expr"/><a name="8750"/> 8750: <b>    throughput_benchmark</b>(
<a name="8751"/> 8751:       #ets_throughput_bench_config{
<a name="8752"/> 8752:          benchmark_duration_ms = 3000,
<a name="8753"/> 8753:          recover_time_ms = 1000,
<a name="8754"/> 8754:          thread_counts = [1, N div 2, N],
<a name="8755"/> 8755:          key_ranges = [1000000],
<a name="8756"/> 8756:          scenarios =
<a name="8757"/> 8757:              [
<a name="8758"/> 8758:               [
<a name="8759"/> 8759:                {0.5, insert},
<a name="8760"/> 8760:                {0.5, delete}
<a name="8761"/> 8761:               ],
<a name="8762"/> 8762:               [
<a name="8763"/> 8763:                {0.1, insert},
<a name="8764"/> 8764:                {0.1, delete},
<a name="8765"/> 8765:                {0.8, lookup}
<a name="8766"/> 8766:               ],
<a name="8767"/> 8767:               [
<a name="8768"/> 8768:                {0.01, insert},
<a name="8769"/> 8769:                {0.01, delete},
<a name="8770"/> 8770:                {0.98, lookup}
<a name="8771"/> 8771:               ],
<a name="8772"/> 8772:               [
<a name="8773"/> 8773:                {0.1, insert},
<a name="8774"/> 8774:                {0.1, delete},
<a name="8775"/> 8775:                {0.4, lookup},
<a name="8776"/> 8776:                {0.4, nextseq100}
<a name="8777"/> 8777:               ],
<a name="8778"/> 8778:               [
<a name="8779"/> 8779:                {0.1, insert},
<a name="8780"/> 8780:                {0.1, delete},
<a name="8781"/> 8781:                {0.79, lookup},
<a name="8782"/> 8782:                {0.01, selectAll}
<a name="8783"/> 8783:               ],
<a name="8784"/> 8784:               [
<a name="8785"/> 8785:                {0.1, insert},
<a name="8786"/> 8786:                {0.1, delete},
<a name="8787"/> 8787:                {0.79, lookup},
<a name="8788"/> 8788:                {0.01, partial_select1000}
<a name="8789"/> 8789:               ]
<a name="8790"/> 8790:              ],
<a name="8791"/> 8791:          table_types =
<a name="8792"/> 8792:              ([
<a name="8793"/> 8793:                [ordered_set, public, {write_concurrency, true}, {read_concurrency, true}],
<a name="8794"/> 8794:                [set, public, {write_concurrency, true}, {read_concurrency, true}]
<a name="8795"/> 8795:               ] ++
<a name="8796"/> 8796:                   case catch list_to_integer(erlang:system_info(otp_release)) of
<a name="8797"/> 8797:                       Recent when is_integer(Recent), Recent &gt;= 25 -&gt;
<a name="8798"/> 8798:                           [[set, public, {write_concurrency, auto}, {read_concurrency, true}]];
<a name="8799"/> 8799:                       _Old -&gt; []
<a name="8800"/> 8800:                   end),
<a name="8801"/> 8801:          etsmem_fun = fun etsmem/0,
<a name="8802"/> 8802:          verify_etsmem_fun = fun verify_etsmem/1,
<a name="8803"/> 8803:          notify_res_fun =
<a name="8804"/> 8804:              fun(Name, Throughput) -&gt;
<a name="8805"/> 8805:                      SummaryTable =
<a name="8806"/> 8806:                          proplists:get_value(ets_benchmark_result_summary_tab, Config),
<a name="8807"/> 8807:                      AddToSummaryCounter =
<a name="8808"/> 8808:                          case SummaryTable of
<a name="8809"/> 8809:                              undefined -&gt;
<a name="8810"/> 8810:                                  fun(_, _) -&gt;
<a name="8811"/> 8811:                                          ok
<a name="8812"/> 8812:                                  end;
<a name="8813"/> 8813:                              Tab -&gt;
<a name="8814"/> 8814:                                  fun(CounterName, ToAdd) -&gt;
<a name="8815"/> 8815:                                          OldVal = ets:lookup_element(Tab, CounterName, 2),
<a name="8816"/> 8816:                                          NewVal = OldVal + ToAdd,
<a name="8817"/> 8817:                                          ets:insert(Tab, {CounterName, NewVal})
<a name="8818"/> 8818:                                  end
<a name="8819"/> 8819:                          end,
<a name="8820"/> 8820:                      Record =
<a name="8821"/> 8821:                          fun(NoOfBenchsCtr, TotThrputCtr) -&gt;
<a name="8822"/> 8822:                                  AddToSummaryCounter(NoOfBenchsCtr, 1),
<a name="8823"/> 8823:                                  AddToSummaryCounter(TotThrputCtr, Throughput)
<a name="8824"/> 8824:                          end,
<a name="8825"/> 8825:                      Record(nr_of_benchmarks, total_throughput),
<a name="8826"/> 8826:                      case string:find(Name, &quot;ordered_set&quot;) of
<a name="8827"/> 8827:                          nomatch -&gt;
<a name="8828"/> 8828:                              Record(nr_of_set_benchmarks, total_throughput_set);
<a name="8829"/> 8829:                          _ -&gt;
<a name="8830"/> 8830:                              Record(nr_of_ordered_set_benchmarks,
<a name="8831"/> 8831:                                     total_throughput_ordered_set)
<a name="8832"/> 8832:                      end,
<a name="8833"/> 8833:                      ct_event:notify(
<a name="8834"/> 8834:                           #event{name = benchmark_data,
<a name="8835"/> 8835:                                  data = [{suite,&quot;ets_bench&quot;},
<a name="8836"/> 8836:                                          {name, Name},
<a name="8837"/> 8837:                                          {value,Throughput}]})
<a name="8838"/> 8838:              end
<a name="8839"/> 8839:         }).
<a name="8840"/> 8840: 
<a name="8841"/> 8841: <i>%% This function compares the lookup operation's performance for</i>
<a name="8842"/> 8842: <i>%% ordered_set ETS tables with and without write_concurrency enabled</i>
<a name="8843"/> 8843: <i>%% when the data structures have been populated in parallel and</i>
<a name="8844"/> 8844: <i>%% sequentially.</i>
<a name="8845"/> 8845: <i>%%</i>
<a name="8846"/> 8846: <i>%% The main purpose of this function is to check that the</i>
<a name="8847"/> 8847: <i>%% implementation of ordered_set with write_concurrency (CA tree)</i>
<a name="8848"/> 8848: <i>%% adapts its structure to contention even when only lookup operations</i>
<a name="8849"/> 8849: <i>%% are used.</i>
<a name="lookup_catree_par_vs_seq_init_benchmark-0"/><a name="8850"/> 8850: <b>lookup_catree_par_vs_seq_init_benchmark</b>() -&gt;
<a name="8851"/> 8851:     N = erlang:system_info(schedulers),
<a name="lookup_catree_par_vs_seq_init_benchmark-last_expr"/><a name="8852"/> 8852: <b>    throughput_benchmark</b>(
<a name="8853"/> 8853:       #ets_throughput_bench_config{
<a name="8854"/> 8854:          benchmark_duration_ms = 600000,
<a name="8855"/> 8855:          recover_time_ms = 1000,
<a name="8856"/> 8856:          thread_counts = [1, N div 2, N],
<a name="8857"/> 8857:          key_ranges = [1000000],
<a name="8858"/> 8858:          init_functions = [{&quot;seq_init&quot;, fun prefill_table/4},
<a name="8859"/> 8859:                            {&quot;par_init&quot;, fun prefill_table_parallel/4}],
<a name="8860"/> 8860:          nr_of_repeats = 1,
<a name="8861"/> 8861:          scenarios =
<a name="8862"/> 8862:              [
<a name="8863"/> 8863:               [
<a name="8864"/> 8864:                {1.0, lookup}
<a name="8865"/> 8865:               ]
<a name="8866"/> 8866:              ],
<a name="8867"/> 8867:          table_types =
<a name="8868"/> 8868:              [
<a name="8869"/> 8869:               [ordered_set, public, {write_concurrency, true}],
<a name="8870"/> 8870:               [ordered_set, public]
<a name="8871"/> 8871:              ],
<a name="8872"/> 8872:           print_result_paths_fun = fun stdout_notify_res/2
<a name="8873"/> 8873:         }).
<a name="8874"/> 8874: 
<a name="add_lists-2"/><a name="8875"/> 8875: <b>add_lists</b>(L1,L2) -&gt;
<a name="add_lists-last_expr"/><a name="8876"/> 8876: <b>    add_lists</b>(L1,L2,[]).
<a name="add_lists-3"/><a name="8877"/> 8877: <b>add_lists</b>([],[],Acc) -&gt;
<a name="8878"/> 8878:     lists:reverse(Acc);
<a name="8879"/> 8879: <b>add_lists</b>([E1|T1], [E2|T2], Acc) -&gt;
<a name="add_lists-last_expr"/><a name="8880"/> 8880: <b>    add_lists</b>(T1, T2, [E1+E2 | Acc]).
<a name="8881"/> 8881: 
<a name="run_smp_workers-4"/><a name="8882"/> 8882: <b>run_smp_workers</b>(InitF,ExecF,FiniF,Laps) -&gt;
<a name="run_smp_workers-last_expr"/><a name="8883"/> 8883: <b>    run_smp_workers</b>(InitF,ExecF,FiniF,Laps, 0).
<a name="run_smp_workers-5"/><a name="8884"/> 8884: <b>run_smp_workers</b>(InitF,ExecF,FiniF,Laps, Exclude) -&gt;
<a name="run_smp_workers-last_expr"/><a name="8885"/> 8885: <b>    case erlang:system_info</b>(schedulers_online) of
<a name="8886"/> 8886:         N when N &gt; Exclude -&gt;
<a name="8887"/> 8887:             run_workers_do(InitF,ExecF,FiniF,Laps, N - Exclude);
<a name="8888"/> 8888:         _ -&gt;
<a name="8889"/> 8889:             {skipped, &quot;Too few schedulers online&quot;}
<a name="8890"/> 8890:     end.
<a name="8891"/> 8891: 
<a name="run_sched_workers-4"/><a name="8892"/> 8892: <b>run_sched_workers</b>(InitF,ExecF,FiniF,Laps) -&gt;
<a name="run_sched_workers-last_expr"/><a name="8893"/> 8893: <b>    run_workers_do</b>(InitF,ExecF,FiniF,Laps,
<a name="8894"/> 8894:                    erlang:system_info(schedulers)).
<a name="8895"/> 8895: 
<a name="run_workers_do-5"/><a name="8896"/> 8896: <b>run_workers_do</b>(InitF,ExecF,FiniF,Laps, NumOfProcs) -&gt;
<a name="8897"/> 8897:     io:format(&quot;starting ~p workers\n&quot;,[NumOfProcs]),
<a name="8898"/> 8898:     Seeds = [{ProcN,rand:uniform(9999)} || ProcN &lt;- lists:seq(1,NumOfProcs)],
<a name="8899"/> 8899:     Parent = self(),
<a name="8900"/> 8900:     Pids = [my_spawn_link(fun()-&gt; worker(Seed,InitF,ExecF,FiniF,Laps,Parent,NumOfProcs) end)
<a name="8901"/> 8901: 	    || Seed &lt;- Seeds],
<a name="run_workers_do-last_expr"/><a name="8902"/> 8902:     case Laps of
<a name="8903"/> 8903: 	infinite -&gt; Pids;
<a name="8904"/> 8904: 	_ -&gt; wait_pids(Pids)
<a name="8905"/> 8905:     end.
<a name="8906"/> 8906: 
<a name="worker-7"/><a name="8907"/> 8907: <b>worker</b>({ProcN,Seed}, InitF, ExecF, FiniF, Laps, Parent, NumOfProcs) -&gt;
<a name="8908"/> 8908:     io:format(&quot;smp worker ~p, seed=~p~n&quot;,[self(),Seed]),
<a name="8909"/> 8909:     rand:seed(default, {Seed,Seed,Seed}),
<a name="8910"/> 8910:     State1 = InitF([ProcN, NumOfProcs]),
<a name="8911"/> 8911:     State2 = worker_loop(Laps, ExecF, State1),
<a name="8912"/> 8912:     Result = FiniF(State2),
<a name="8913"/> 8913:     io:format(&quot;worker ~p done\n&quot;,[self()]),
<a name="worker-last_expr"/><a name="8914"/> 8914: <b>    Parent ! {self</b>(), Result}.
<a name="8915"/> 8915: 
<a name="worker_loop-3"/><a name="8916"/> 8916: <b>worker_loop</b>(0, _, State) -&gt;
<a name="8917"/> 8917:     State;
<a name="8918"/> 8918: <b>worker_loop</b>(_, _, [end_of_work|State]) -&gt;
<a name="8919"/> 8919:     State;
<a name="8920"/> 8920: <b>worker_loop</b>(infinite, ExecF, State) -&gt;
<a name="8921"/> 8921:     worker_loop(infinite,ExecF,ExecF(State));
<a name="8922"/> 8922: <b>worker_loop</b>(N, ExecF, State) -&gt;
<a name="worker_loop-last_expr"/><a name="8923"/> 8923: <b>    worker_loop</b>(N-1,ExecF,ExecF(State)).
<a name="8924"/> 8924: 
<a name="wait_pids-1"/><a name="8925"/> 8925: <b>wait_pids</b>(Pids) -&gt;
<a name="wait_pids-last_expr"/><a name="8926"/> 8926: <b>    wait_pids</b>(Pids,[]).
<a name="wait_pids-2"/><a name="8927"/> 8927: <b>wait_pids</b>([],Acc) -&gt;
<a name="8928"/> 8928:     Acc;
<a name="8929"/> 8929: <b>wait_pids</b>(Pids, Acc) -&gt;
<a name="wait_pids-last_expr"/><a name="8930"/> 8930:     receive
<a name="8931"/> 8931: 	{Pid,Result} -&gt;
<a name="8932"/> 8932: 	    true = lists:member(Pid,Pids),
<a name="8933"/> 8933: 	    Others = lists:delete(Pid,Pids),
<a name="8934"/> 8934: 	    %%io:format(&quot;wait_pid got ~p from ~p\n&quot;,[Result,Pid]),
<a name="8935"/> 8935: 	    wait_pids(Others,[Result | Acc])
<a name="8936"/> 8936:     after 60*1000 -&gt;
<a name="8937"/> 8937: 	    io:format(&quot;Still waiting for workers ~p\n&quot;,[Pids]),
<a name="8938"/> 8938:             wait_pids(Pids, Acc)
<a name="8939"/> 8939:     end.
<a name="8940"/> 8940: 
<a name="8941"/> 8941: 
<a name="8942"/> 8942: 
<a name="8943"/> 8943: 
<a name="my_tab_to_list-1"/><a name="8944"/> 8944: <b>my_tab_to_list</b>(Ts) -&gt;
<a name="8945"/> 8945:     Key = ets:first(Ts),
<a name="my_tab_to_list-last_expr"/><a name="8946"/> 8946: <b>    my_tab_to_list</b>(Ts,ets:next(Ts,Key),[ets:lookup(Ts, Key)]).
<a name="8947"/> 8947: 
<a name="my_tab_to_list-3"/><a name="8948"/> 8948: <b>my_tab_to_list</b>(_Ts,'$end_of_table', Acc) -&gt; lists:reverse(Acc);
<a name="8949"/> 8949: <b>my_tab_to_list</b>(Ts,Key, Acc) -&gt;
<a name="my_tab_to_list-last_expr"/><a name="8950"/> 8950: <b>    my_tab_to_list</b>(Ts,ets:next(Ts,Key),[ets:lookup(Ts, Key)| Acc]).
<a name="8951"/> 8951: 
<a name="8952"/> 8952: 
<a name="wait_for_memory_deallocations-0"/><a name="8953"/> 8953: <b>wait_for_memory_deallocations</b>() -&gt;
<a name="wait_for_memory_deallocations-last_expr"/><a name="8954"/> 8954:     try
<a name="8955"/> 8955: 	erts_debug:set_internal_state(wait, thread_progress),
<a name="8956"/> 8956: 	erts_debug:set_internal_state(wait, deallocations)
<a name="8957"/> 8957:     catch
<a name="8958"/> 8958: 	error:undef -&gt;
<a name="8959"/> 8959: 	    erts_debug:set_internal_state(available_internal_state, true),
<a name="8960"/> 8960: 	    wait_for_memory_deallocations();
<a name="8961"/> 8961:         error:badarg -&gt;
<a name="8962"/> 8962:             %% The emulator we run on does not have the wait internal state
<a name="8963"/> 8963:             %% so we just sleep some time instead...
<a name="8964"/> 8964:             timer:sleep(100)
<a name="8965"/> 8965:     end.
<a name="8966"/> 8966: 
<a name="etsmem-0"/><a name="8967"/> 8967: <b>etsmem</b>() -&gt;
<a name="etsmem-last_expr"/><a name="8968"/> 8968: <b>    etsmem</b>(get_etsmem(), 1).
<a name="8969"/> 8969: 
<a name="etsmem-2"/><a name="8970"/> 8970: <b>etsmem</b>(PrevEtsMem, Try) when Try &lt; 10 -&gt;
<a name="8971"/> 8971:     case get_etsmem() of
<a name="8972"/> 8972:         PrevEtsMem -&gt;
<a name="8973"/> 8973:             PrevEtsMem;
<a name="8974"/> 8974:         EtsMem -&gt;
<a name="8975"/> 8975:             io:format(&quot;etsmem(): Change in attempt ~p~n~nbefore:~n~p~n~nafter:~n~p~n~n&quot;,
<a name="8976"/> 8976:                       [Try, PrevEtsMem, EtsMem]),
<a name="8977"/> 8977:             etsmem(EtsMem, Try+1)
<a name="8978"/> 8978:     end;
<a name="8979"/> 8979: <b>etsmem</b>(_, _) -&gt;
<a name="etsmem-last_expr"/><a name="8980"/> 8980: <b>    ct:fail</b>(&quot;Failed to get a stable/consistent memory snapshot&quot;).
<a name="8981"/> 8981: 
<a name="get_etsmem-0"/><a name="8982"/> 8982: <b>get_etsmem</b>() -&gt;
<a name="8983"/> 8983:     AllTabsExceptions = [logger, code],
<a name="8984"/> 8984:     %% The logger table is excluded from the AllTabs list
<a name="8985"/> 8985:     %% below because it uses decentralized counters to keep
<a name="8986"/> 8986:     %% track of the size and the memory counters. This cause
<a name="8987"/> 8987:     %% ets:info(T,size) and ets:info(T,memory) to trigger
<a name="8988"/> 8988:     %% allocations and frees that may change the amount of
<a name="8989"/> 8989:     %% memory that is allocated for ETS.
<a name="8990"/> 8990:     %%
<a name="8991"/> 8991:     %% The code table is excluded from the list below
<a name="8992"/> 8992:     %% because the amount of memory allocated for it may
<a name="8993"/> 8993:     %% change if the tested code loads a new module.
<a name="8994"/> 8994:     AllTabs =
<a name="8995"/> 8995:         lists:sort(
<a name="8996"/> 8996:           [begin
<a name="8997"/> 8997:                try ets:info(T, decentralized_counters) of
<a name="8998"/> 8998:                    true -&gt;
<a name="8999"/> 8999:                        ct:fail(&quot;Background ETS table (~p) that &quot;
<a name="9000"/> 9000:                                &quot;uses decentralized counters (Add exception?)&quot;,
<a name="9001"/> 9001:                                [ets:info(T,name)]);
<a name="9002"/> 9002:                    _ -&gt; ok
<a name="9003"/> 9003:                catch _:_ -&gt;
<a name="9004"/> 9004:                        ok
<a name="9005"/> 9005:                end,
<a name="9006"/> 9006:                {T,
<a name="9007"/> 9007:                 ets:info(T,name),
<a name="9008"/> 9008:                 ets:info(T,size),
<a name="9009"/> 9009:                 ets:info(T,memory),
<a name="9010"/> 9010:                 ets:info(T,type)}
<a name="9011"/> 9011:            end
<a name="9012"/> 9012:            || T &lt;- ets:all(),
<a name="9013"/> 9013:               not lists:member(ets:info(T, name), AllTabsExceptions)]),
<a name="9014"/> 9014:     wait_for_memory_deallocations(),
<a name="9015"/> 9015:     EtsAllocSize = erts_debug:alloc_blocks_size(ets_alloc),
<a name="9016"/> 9016:     ErlangMemoryEts = try erlang:memory(ets)
<a name="9017"/> 9017:                       catch error:notsup -&gt; notsup end,
<a name="9018"/> 9018:     FlxCtrMemUsage = try erts_debug:get_internal_state(flxctr_memory_usage)
<a name="9019"/> 9019:                      catch error:badarg -&gt; notsup end,
<a name="9020"/> 9020:     Mem = {ErlangMemoryEts, EtsAllocSize, FlxCtrMemUsage},
<a name="get_etsmem-last_expr"/><a name="9021"/> 9021:     {Mem, AllTabs}.
<a name="9022"/> 9022: 
<a name="verify_etsmem-1"/><a name="9023"/> 9023: <b>verify_etsmem</b>(MI) -&gt;
<a name="9024"/> 9024:     wait_for_test_procs(),
<a name="verify_etsmem-last_expr"/><a name="9025"/> 9025: <b>    verify_etsmem</b>(MI, 1).
<a name="9026"/> 9026: 
<a name="verify_etsmem-2"/><a name="9027"/> 9027: <b>verify_etsmem</b>({MemInfo,AllTabs}, Try) -&gt;
<a name="verify_etsmem-last_expr"/><a name="9028"/> 9028: <b>    case etsmem</b>() of
<a name="9029"/> 9029: 	{MemInfo,_} -&gt;
<a name="9030"/> 9030: 	    io:format(&quot;Ets mem info: ~p&quot;, [MemInfo]),
<a name="9031"/> 9031: 	    case {MemInfo, Try} of
<a name="9032"/> 9032: 		{{ErlMem,EtsAlloc},_} when ErlMem == notsup; EtsAlloc == undefined -&gt;
<a name="9033"/> 9033: 		    %% Use 'erl +Mea max' to do more complete memory leak testing.
<a name="9034"/> 9034: 		    {comment,&quot;Incomplete or no mem leak testing&quot;};
<a name="9035"/> 9035: 		{_, 1} -&gt;
<a name="9036"/> 9036:                     ok;
<a name="9037"/> 9037:                 _ -&gt;
<a name="9038"/> 9038:                     {comment, &quot;Transient memory discrepancy&quot;}
<a name="9039"/> 9039: 	    end;
<a name="9040"/> 9040: 
<a name="9041"/> 9041: 	{MemInfo2, AllTabs2} -&gt;
<a name="9042"/> 9042: 	    io:format(&quot;#Expected: ~p&quot;, [MemInfo]),
<a name="9043"/> 9043: 	    io:format(&quot;#Actual:   ~p&quot;, [MemInfo2]),
<a name="9044"/> 9044: 	    io:format(&quot;#Changed tables before: ~p\n&quot;,[AllTabs -- AllTabs2]),
<a name="9045"/> 9045: 	    io:format(&quot;#Changed tables after: ~p\n&quot;, [AllTabs2 -- AllTabs]),
<a name="9046"/> 9046:             case Try &lt; 2 of
<a name="9047"/> 9047:                 true -&gt;
<a name="9048"/> 9048:                     io:format(&quot;\n#This discrepancy could be caused by an &quot;
<a name="9049"/> 9049:                               &quot;inconsistent memory \&quot;snapshot\&quot;&quot;
<a name="9050"/> 9050:                               &quot;\n#Try again...\n&quot;, []),
<a name="9051"/> 9051:                     verify_etsmem({MemInfo, AllTabs}, Try+1);
<a name="9052"/> 9052:                 false -&gt;
<a name="9053"/> 9053:                     ct:fail(&quot;Failed memory check&quot;)
<a name="9054"/> 9054:             end
<a name="9055"/> 9055:     end.
<a name="9056"/> 9056: 
<a name="9057"/> 9057: 
<a name="start_loopers-4"/><a name="9058"/> 9058: <b>start_loopers</b>(N, Prio, Fun, State) -&gt;
<a name="start_loopers-last_expr"/><a name="9059"/> 9059: <b>    lists:map</b>(fun (_) -&gt;
<a name="9060"/> 9060: 		      my_spawn_opt(fun () -&gt; looper(Fun, State) end,
<a name="9061"/> 9061: 				   [{priority, Prio}, link])
<a name="9062"/> 9062: 	      end,
<a name="9063"/> 9063: 	      lists:seq(1, N)).
<a name="9064"/> 9064: 
<a name="stop_loopers-1"/><a name="9065"/> 9065: <b>stop_loopers</b>(Loopers) -&gt;
<a name="9066"/> 9066:     lists:foreach(fun (P) -&gt;
<a name="9067"/> 9067: 			  unlink(P),
<a name="9068"/> 9068: 			  exit(P, bang)
<a name="9069"/> 9069: 		  end,
<a name="9070"/> 9070: 		  Loopers),
<a name="stop_loopers-last_expr"/><a name="9071"/> 9071:     ok.
<a name="9072"/> 9072: 
<a name="looper-2"/><a name="9073"/> 9073: <b>looper</b>(Fun, State) -&gt;
<a name="looper-last_expr"/><a name="9074"/> 9074: <b>    looper</b>(Fun, Fun(State)).
<a name="9075"/> 9075: 
<a name="spawn_logger-1"/><a name="9076"/> 9076: <b>spawn_logger</b>(Procs) -&gt;
<a name="spawn_logger-last_expr"/><a name="9077"/> 9077:     receive
<a name="9078"/> 9078: 	{new_test_proc, Proc} -&gt;
<a name="9079"/> 9079: 	    spawn_logger([Proc|Procs]);
<a name="9080"/> 9080: 	{sync_test_procs, Kill, From} -&gt;
<a name="9081"/> 9081: 	    lists:foreach(fun (Proc) when From == Proc -&gt;
<a name="9082"/> 9082: 				  ok;
<a name="9083"/> 9083: 			      (Proc) -&gt;
<a name="9084"/> 9084: 				  Mon = erlang:monitor(process, Proc),
<a name="9085"/> 9085: 				  ok = receive
<a name="9086"/> 9086: 				      {'DOWN', Mon, _, _, _} -&gt;
<a name="9087"/> 9087: 					  ok
<a name="9088"/> 9088: 				  after 0 -&gt;
<a name="9089"/> 9089: 					  case Kill of
<a name="9090"/> 9090: 					      true -&gt; exit(Proc, kill);
<a name="9091"/> 9091: 					      _ -&gt; ok
<a name="9092"/> 9092: 					  end,
<a name="9093"/> 9093: 					  receive
<a name="9094"/> 9094: 					      {'DOWN', Mon, _, _, _} -&gt;
<a name="9095"/> 9095: 						  ok
<a name="9096"/> 9096:                                           after 5000 -&gt;
<a name="9097"/> 9097: 						  io:format(&quot;Waiting for 'DOWN' from ~w, status=~w\n&quot;
<a name="9098"/> 9098:                                                             &quot;info = ~p\n&quot;, [Proc,
<a name="9099"/> 9099:                                                                             pid_status(Proc),
<a name="9100"/> 9100:                                                                             process_info(Proc)]),
<a name="9101"/> 9101:                                                   timeout
<a name="9102"/> 9102: 					  end
<a name="9103"/> 9103: 				  end
<a name="9104"/> 9104: 			  end, Procs),
<a name="9105"/> 9105: 	    From ! test_procs_synced,
<a name="9106"/> 9106: 	    spawn_logger([From])
<a name="9107"/> 9107:     end.
<a name="9108"/> 9108: 
<a name="pid_status-1"/><a name="9109"/> 9109: <b>pid_status</b>(Pid) -&gt;
<a name="pid_status-last_expr"/><a name="9110"/> 9110:     try
<a name="9111"/> 9111: 	erts_debug:get_internal_state({process_status, Pid})
<a name="9112"/> 9112:     catch
<a name="9113"/> 9113: 	error:undef -&gt;
<a name="9114"/> 9114: 	    erts_debug:set_internal_state(available_internal_state, true),
<a name="9115"/> 9115: 	    pid_status(Pid)
<a name="9116"/> 9116:     end.
<a name="9117"/> 9117: 
<a name="start_spawn_logger-0"/><a name="9118"/> 9118: <b>start_spawn_logger</b>() -&gt;
<a name="start_spawn_logger-last_expr"/><a name="9119"/> 9119: <b>    case whereis</b>(ets_test_spawn_logger) of
<a name="9120"/> 9120: 	Pid when is_pid(Pid) -&gt; true;
<a name="9121"/> 9121: 	_ -&gt; register(ets_test_spawn_logger,
<a name="9122"/> 9122: 		      spawn_opt(fun () -&gt; spawn_logger([]) end,
<a name="9123"/> 9123: 				[{priority, max}]))
<a name="9124"/> 9124:     end.
<a name="9125"/> 9125: 
<a name="9126"/> 9126: <i>%% restart_spawn_logger() -&gt;</i>
<a name="9127"/> 9127: <i>%%     stop_spawn_logger(),</i>
<a name="9128"/> 9128: <i>%%     start_spawn_logger().</i>
<a name="9129"/> 9129: 
<a name="stop_spawn_logger-0"/><a name="9130"/> 9130: <b>stop_spawn_logger</b>() -&gt;
<a name="9131"/> 9131:     Mon = erlang:monitor(process, ets_test_spawn_logger),
<a name="9132"/> 9132:     (catch exit(whereis(ets_test_spawn_logger), kill)),
<a name="stop_spawn_logger-last_expr"/><a name="9133"/> 9133:     receive {'DOWN', Mon, _, _, _} -&gt; ok end.
<a name="9134"/> 9134: 
<a name="wait_for_test_procs-0"/><a name="9135"/> 9135: <b>wait_for_test_procs</b>() -&gt;
<a name="wait_for_test_procs-last_expr"/><a name="9136"/> 9136: <b>    wait_for_test_procs</b>(false).
<a name="9137"/> 9137: 
<a name="wait_for_test_procs-1"/><a name="9138"/> 9138: <b>wait_for_test_procs</b>(Kill) -&gt;
<a name="9139"/> 9139:     ets_test_spawn_logger ! {sync_test_procs, Kill, self()},
<a name="wait_for_test_procs-last_expr"/><a name="9140"/> 9140:     receive test_procs_synced -&gt; ok end.
<a name="9141"/> 9141: 
<a name="log_test_proc-1"/><a name="9142"/> 9142: <b>log_test_proc</b>(Proc) when is_pid(Proc) -&gt;
<a name="9143"/> 9143:     ets_test_spawn_logger ! {new_test_proc, Proc},
<a name="log_test_proc-last_expr"/><a name="9144"/> 9144:     Proc.
<a name="9145"/> 9145: 
<a name="my_spawn-1"/><a name="my_spawn-last_expr"/><a name="9146"/> 9146: <b>my_spawn</b>(Fun) -&gt; log_test_proc(spawn(Fun)).
<a name="9147"/> 9147: 
<a name="my_spawn_link-1"/><a name="my_spawn_link-last_expr"/><a name="9148"/> 9148: <b>my_spawn_link</b>(Fun) -&gt; log_test_proc(spawn_link(Fun)).
<a name="9149"/> 9149: 
<a name="my_spawn_opt-2"/><a name="9150"/> 9150: <b>my_spawn_opt</b>(Fun,Opts) -&gt;
<a name="my_spawn_opt-last_expr"/><a name="9151"/> 9151: <b>    case spawn_opt</b>(Fun,Opts) of
<a name="9152"/> 9152: 	Pid when is_pid(Pid) -&gt; log_test_proc(Pid);
<a name="9153"/> 9153: 	{Pid, _} = Res when is_pid(Pid) -&gt; log_test_proc(Pid), Res
<a name="9154"/> 9154:     end.
<a name="9155"/> 9155: 
<a name="my_spawn_monitor-1"/><a name="9156"/> 9156: <b>my_spawn_monitor</b>(Fun) -&gt;
<a name="9157"/> 9157:     Res = spawn_monitor(Fun),
<a name="9158"/> 9158:     {Pid, _} = Res,
<a name="9159"/> 9159:     log_test_proc(Pid),
<a name="my_spawn_monitor-last_expr"/><a name="9160"/> 9160:     Res.
<a name="9161"/> 9161: 
<a name="repeat-2"/><a name="9162"/> 9162: <b>repeat</b>(_Fun, 0) -&gt;
<a name="9163"/> 9163:     ok;
<a name="9164"/> 9164: <b>repeat</b>(Fun, N) -&gt;
<a name="9165"/> 9165:     Fun(),
<a name="repeat-last_expr"/><a name="9166"/> 9166: <b>    repeat</b>(Fun, N-1).
<a name="9167"/> 9167: 
<a name="repeat_while-1"/><a name="9168"/> 9168: <b>repeat_while</b>(Fun) -&gt;
<a name="repeat_while-last_expr"/><a name="9169"/> 9169: <b>    case Fun</b>() of
<a name="9170"/> 9170: 	true -&gt; repeat_while(Fun);
<a name="9171"/> 9171: 	false -&gt; false
<a name="9172"/> 9172:     end.
<a name="9173"/> 9173: 
<a name="repeat_while-2"/><a name="9174"/> 9174: <b>repeat_while</b>(Fun, Arg0) -&gt;
<a name="repeat_while-last_expr"/><a name="9175"/> 9175: <b>    case Fun</b>(Arg0) of
<a name="9176"/> 9176: 	{true,Arg1} -&gt; repeat_while(Fun,Arg1);
<a name="9177"/> 9177: 	{false,Ret} -&gt; Ret
<a name="9178"/> 9178:     end.
<a name="9179"/> 9179: 
<a name="9180"/> 9180: <i>%% Some (but not all) permutations of List</i>
<a name="repeat_for_permutations-2"/><a name="9181"/> 9181: <b>repeat_for_permutations</b>(Fun, List) -&gt;
<a name="repeat_for_permutations-last_expr"/><a name="9182"/> 9182: <b>    repeat_for_permutations</b>(Fun, List, length(List)-1).
<a name="repeat_for_permutations-3"/><a name="9183"/> 9183: <b>repeat_for_permutations</b>(Fun, List, 0) -&gt;
<a name="9184"/> 9184:     Fun(List);
<a name="9185"/> 9185: <b>repeat_for_permutations</b>(Fun, List, N) -&gt;
<a name="9186"/> 9186:     {A,B} = lists:split(N, List),
<a name="9187"/> 9187:     L1 = B++A,
<a name="9188"/> 9188:     L2 = lists:reverse(L1),
<a name="9189"/> 9189:     L3 = B++lists:reverse(A),
<a name="9190"/> 9190:     L4 = lists:reverse(B)++A,
<a name="9191"/> 9191:     Fun(L1), Fun(L2), Fun(L3), Fun(L4),
<a name="repeat_for_permutations-last_expr"/><a name="9192"/> 9192: <b>    repeat_for_permutations</b>(Fun, List, N-1).
<a name="9193"/> 9193: 
<a name="receive_any-0"/><a name="9194"/> 9194: <b>receive_any</b>() -&gt;
<a name="receive_any-last_expr"/><a name="9195"/> 9195:     receive M -&gt;
<a name="9196"/> 9196: 	    %%io:format(&quot;Process ~p got msg ~p\n&quot;, [self(),M]),
<a name="9197"/> 9197: 	    M
<a name="9198"/> 9198:     end.
<a name="9199"/> 9199: 
<a name="receive_any_spinning-0"/><a name="9200"/> 9200: <b>receive_any_spinning</b>() -&gt;
<a name="receive_any_spinning-last_expr"/><a name="9201"/> 9201: <b>    receive_any_spinning</b>(1000000).
<a name="receive_any_spinning-1"/><a name="9202"/> 9202: <b>receive_any_spinning</b>(Loops) -&gt;
<a name="receive_any_spinning-last_expr"/><a name="9203"/> 9203: <b>    receive_any_spinning</b>(Loops,Loops,1).
<a name="receive_any_spinning-3"/><a name="9204"/> 9204: <b>receive_any_spinning</b>(Loops,0,Tries) -&gt;
<a name="9205"/> 9205:     receive M -&gt;
<a name="9206"/> 9206: 	    io:format(&quot;Spinning process ~p got msg ~p after ~p tries\n&quot;, [self(),M,Tries]),
<a name="9207"/> 9207: 	    M
<a name="9208"/> 9208:     after 0 -&gt;
<a name="9209"/> 9209: 	    receive_any_spinning(Loops, Loops, Tries+1)
<a name="9210"/> 9210:     end;
<a name="9211"/> 9211: <b>receive_any_spinning</b>(Loops, N, Tries) when N&gt;0 -&gt;
<a name="receive_any_spinning-last_expr"/><a name="9212"/> 9212: <b>    receive_any_spinning</b>(Loops, N-1, Tries).
<a name="9213"/> 9213: 
<a name="9214"/> 9214: 
<a name="9215"/> 9215: 
<a name="spawn_monitor_with_pid-2"/><a name="9216"/> 9216: <b>spawn_monitor_with_pid</b>(Pid, Fun) when is_pid(Pid) -&gt;
<a name="spawn_monitor_with_pid-last_expr"/><a name="9217"/> 9217: <b>    spawn_monitor_with_pid</b>(Pid, Fun, 10).
<a name="9218"/> 9218: 
<a name="spawn_monitor_with_pid-3"/><a name="9219"/> 9219: <b>spawn_monitor_with_pid</b>(_, _, 0) -&gt;
<a name="9220"/> 9220:     failed;
<a name="9221"/> 9221: <b>spawn_monitor_with_pid</b>(Pid, Fun, N) -&gt;
<a name="spawn_monitor_with_pid-last_expr"/><a name="9222"/> 9222: <b>    case my_spawn</b>(fun()-&gt; case self() of
<a name="9223"/> 9223: 			      Pid -&gt; Fun();
<a name="9224"/> 9224: 			      _ -&gt; die
<a name="9225"/> 9225: 			  end
<a name="9226"/> 9226: 		  end) of
<a name="9227"/> 9227: 	Pid -&gt;
<a name="9228"/> 9228: 	    {Pid, erlang:monitor(process, Pid)};
<a name="9229"/> 9229: 	_Other -&gt;
<a name="9230"/> 9230: 	    spawn_monitor_with_pid(Pid,Fun,N-1)
<a name="9231"/> 9231:     end.
<a name="9232"/> 9232: 
<a name="9233"/> 9233: 
<a name="only_if_smp-1"/><a name="9234"/> 9234: <b>only_if_smp</b>(Func) -&gt;
<a name="only_if_smp-last_expr"/><a name="9235"/> 9235: <b>    only_if_smp</b>(2, Func).
<a name="only_if_smp-2"/><a name="9236"/> 9236: <b>only_if_smp</b>(Schedulers, Func) -&gt;
<a name="only_if_smp-last_expr"/><a name="9237"/> 9237: <b>    case erlang:system_info</b>(schedulers_online) of
<a name="9238"/> 9238: 	N when N &lt; Schedulers -&gt; {skip,&quot;Too few schedulers online&quot;};
<a name="9239"/> 9239: 	_ -&gt; Func()
<a name="9240"/> 9240:     end.
<a name="9241"/> 9241: 
<a name="9242"/> 9242: <i>%% Copy-paste from emulator/test/binary_SUITE.erl</i>
<a name="test_terms-2"/><a name="9243"/> 9243: <b>test_terms</b>(Test_Func, Mode) -&gt;
<a name="9244"/> 9244:     garbage_collect(),
<a name="9245"/> 9245:     Pib0 = process_info(self(),binary),
<a name="9246"/> 9246: 
<a name="9247"/> 9247:     Test_Func(atom),
<a name="9248"/> 9248:     Test_Func(''),
<a name="9249"/> 9249:     Test_Func('a'),
<a name="9250"/> 9250:     Test_Func('ab'),
<a name="9251"/> 9251:     Test_Func('abc'),
<a name="9252"/> 9252:     Test_Func('abcd'),
<a name="9253"/> 9253:     Test_Func('abcde'),
<a name="9254"/> 9254:     Test_Func('abcdef'),
<a name="9255"/> 9255:     Test_Func('abcdefg'),
<a name="9256"/> 9256:     Test_Func('abcdefgh'),
<a name="9257"/> 9257: 
<a name="9258"/> 9258:     Test_Func(fun() -&gt; ok end),
<a name="9259"/> 9259:     X = id([a,{b,c},c]),
<a name="9260"/> 9260:     Y = id({x,y,z}),
<a name="9261"/> 9261:     Z = id(1 bsl 8*257),
<a name="9262"/> 9262:     Test_Func(fun() -&gt; X end),
<a name="9263"/> 9263:     Test_Func(fun() -&gt; {X,Y} end),
<a name="9264"/> 9264:     Test_Func([fun() -&gt; {X,Y,Z} end,
<a name="9265"/> 9265: 	       fun() -&gt; {Z,X,Y} end,
<a name="9266"/> 9266: 	       fun() -&gt; {Y,Z,X} end]),
<a name="9267"/> 9267: 
<a name="9268"/> 9268:     Test_Func({trace_ts,{even_bigger,{some_data,fun() -&gt; ok end}},{1,2,3}}),
<a name="9269"/> 9269:     Test_Func({trace_ts,{even_bigger,{some_data,&lt;&lt;1,2,3,4,5,6,7,8,9,10&gt;&gt;}},
<a name="9270"/> 9270: 	       {1,2,3}}),
<a name="9271"/> 9271: 
<a name="9272"/> 9272:     Test_Func(1),
<a name="9273"/> 9273:     Test_Func(42),
<a name="9274"/> 9274:     Test_Func(-23),
<a name="9275"/> 9275:     Test_Func(256),
<a name="9276"/> 9276:     Test_Func(25555),
<a name="9277"/> 9277:     Test_Func(-3333),
<a name="9278"/> 9278: 
<a name="9279"/> 9279:     Test_Func(1.0),
<a name="9280"/> 9280: 
<a name="9281"/> 9281:     Test_Func(183749783987483978498378478393874),
<a name="9282"/> 9282:     Test_Func(-37894183749783987483978498378478393874),
<a name="9283"/> 9283:     Very_Big = very_big_num(),
<a name="9284"/> 9284:     Test_Func(Very_Big),
<a name="9285"/> 9285:     Test_Func(-Very_Big+1),
<a name="9286"/> 9286: 
<a name="9287"/> 9287:     Test_Func([]),
<a name="9288"/> 9288:     Test_Func(&quot;abcdef&quot;),
<a name="9289"/> 9289:     Test_Func([a, b, 1, 2]),
<a name="9290"/> 9290:     Test_Func([a|b]),
<a name="9291"/> 9291: 
<a name="9292"/> 9292:     Test_Func({}),
<a name="9293"/> 9293:     Test_Func({1}),
<a name="9294"/> 9294:     Test_Func({a, b}),
<a name="9295"/> 9295:     Test_Func({a, b, c}),
<a name="9296"/> 9296:     Test_Func(list_to_tuple(lists:seq(0, 255))),
<a name="9297"/> 9297:     Test_Func(list_to_tuple(lists:seq(0, 256))),
<a name="9298"/> 9298: 
<a name="9299"/> 9299:     Test_Func(make_ref()),
<a name="9300"/> 9300:     Test_Func([make_ref(), make_ref()]),
<a name="9301"/> 9301: 
<a name="9302"/> 9302:     Test_Func(make_port()),
<a name="9303"/> 9303: 
<a name="9304"/> 9304:     Test_Func(make_pid()),
<a name="9305"/> 9305:     Test_Func(make_ext_pid()),
<a name="9306"/> 9306:     Test_Func(make_ext_port()),
<a name="9307"/> 9307:     Test_Func(make_ext_ref()),
<a name="9308"/> 9308: 
<a name="9309"/> 9309:     Bin0 = list_to_binary(lists:seq(0, 14)),
<a name="9310"/> 9310:     Test_Func(Bin0),
<a name="9311"/> 9311:     Bin1 = list_to_binary(lists:seq(0, ?heap_binary_size)),
<a name="9312"/> 9312:     Test_Func(Bin1),
<a name="9313"/> 9313:     Bin2 = list_to_binary(lists:seq(0, ?heap_binary_size+1)),
<a name="9314"/> 9314:     Test_Func(Bin2),
<a name="9315"/> 9315:     Bin3 = list_to_binary(lists:seq(0, 255)),
<a name="9316"/> 9316:     %% Test an undersized refc binary. GH-8682
<a name="9317"/> 9317:     Bin4 = erts_debug:set_internal_state(binary, 61),
<a name="9318"/> 9318:     garbage_collect(),
<a name="9319"/> 9319:     Pib = process_info(self(),binary),
<a name="9320"/> 9320:     Test_Func(Bin3),
<a name="9321"/> 9321:     Test_Func(Bin4),
<a name="9322"/> 9322:     garbage_collect(),
<a name="9323"/> 9323:     case Mode of
<a name="9324"/> 9324: 	strict -&gt; Pib = process_info(self(),binary);
<a name="9325"/> 9325: 	skip_refc_check -&gt; ok
<a name="9326"/> 9326:     end,
<a name="9327"/> 9327: 
<a name="9328"/> 9328:     Test_Func(make_unaligned_sub_binary(Bin0)),
<a name="9329"/> 9329:     Test_Func(make_unaligned_sub_binary(Bin1)),
<a name="9330"/> 9330:     Test_Func(make_unaligned_sub_binary(Bin2)),
<a name="9331"/> 9331:     Test_Func(make_unaligned_sub_binary(Bin3)),
<a name="9332"/> 9332:     Test_Func(make_unaligned_sub_binary(Bin4)),
<a name="9333"/> 9333: 
<a name="9334"/> 9334:     Test_Func(make_sub_binary(lists:seq(42, 43))),
<a name="9335"/> 9335:     Test_Func(make_sub_binary([42,43,44])),
<a name="9336"/> 9336:     Test_Func(make_sub_binary([42,43,44,45])),
<a name="9337"/> 9337:     Test_Func(make_sub_binary([42,43,44,45,46])),
<a name="9338"/> 9338:     Test_Func(make_sub_binary([42,43,44,45,46,47])),
<a name="9339"/> 9339:     Test_Func(make_sub_binary([42,43,44,45,46,47,48])),
<a name="9340"/> 9340:     Test_Func(make_sub_binary(lists:seq(42, 49))),
<a name="9341"/> 9341:     Test_Func(make_sub_binary(lists:seq(0, 14))),
<a name="9342"/> 9342:     Test_Func(make_sub_binary(lists:seq(0, ?heap_binary_size))),
<a name="9343"/> 9343:     Test_Func(make_sub_binary(lists:seq(0, ?heap_binary_size+1))),
<a name="9344"/> 9344:     Test_Func(make_sub_binary(lists:seq(0, 255))),
<a name="9345"/> 9345: 
<a name="9346"/> 9346:     Test_Func(make_unaligned_sub_binary(lists:seq(42, 43))),
<a name="9347"/> 9347:     Test_Func(make_unaligned_sub_binary([42,43,44])),
<a name="9348"/> 9348:     Test_Func(make_unaligned_sub_binary([42,43,44,45])),
<a name="9349"/> 9349:     Test_Func(make_unaligned_sub_binary([42,43,44,45,46])),
<a name="9350"/> 9350:     Test_Func(make_unaligned_sub_binary([42,43,44,45,46,47])),
<a name="9351"/> 9351:     Test_Func(make_unaligned_sub_binary([42,43,44,45,46,47,48])),
<a name="9352"/> 9352:     Test_Func(make_unaligned_sub_binary(lists:seq(42, 49))),
<a name="9353"/> 9353:     Test_Func(make_unaligned_sub_binary(lists:seq(0, 14))),
<a name="9354"/> 9354:     Test_Func(make_unaligned_sub_binary(lists:seq(0, ?heap_binary_size))),
<a name="9355"/> 9355:     Test_Func(make_unaligned_sub_binary(lists:seq(0, ?heap_binary_size+1))),
<a name="9356"/> 9356:     Test_Func(make_unaligned_sub_binary(lists:seq(0, 255))),
<a name="9357"/> 9357: 
<a name="9358"/> 9358:     %% Bit level binaries.
<a name="9359"/> 9359:     Test_Func(&lt;&lt;1:1&gt;&gt;),
<a name="9360"/> 9360:     Test_Func(&lt;&lt;2:2&gt;&gt;),
<a name="9361"/> 9361:     Test_Func(&lt;&lt;42:10&gt;&gt;),
<a name="9362"/> 9362:     Test_Func(list_to_bitstring([&lt;&lt;5:6&gt;&gt;|lists:seq(0, 255)])),
<a name="9363"/> 9363: 
<a name="9364"/> 9364:     Test_Func(F = fun(A) -&gt; 42*A end),
<a name="9365"/> 9365:     Test_Func(lists:duplicate(32, F)),
<a name="9366"/> 9366: 
<a name="9367"/> 9367:     Test_Func(FF = fun binary_SUITE:all/1),
<a name="9368"/> 9368:     Test_Func(lists:duplicate(32, FF)),
<a name="9369"/> 9369: 
<a name="9370"/> 9370:     garbage_collect(),
<a name="9371"/> 9371:     case Mode of
<a name="9372"/> 9372: 	strict -&gt; Pib0 = process_info(self(),binary);
<a name="9373"/> 9373: 	skip_refc_check -&gt; ok
<a name="9374"/> 9374:     end,
<a name="test_terms-last_expr"/><a name="9375"/> 9375:     ok.
<a name="9376"/> 9376: 
<a name="error_info-1"/><a name="9377"/> 9377: <b>error_info</b>(_Config) -&gt;
<a name="9378"/> 9378:     Ms = [{{'$1','$2','$3'},[],['$$']}],
<a name="9379"/> 9379:     BagTab = fun(_Type) -&gt; ets:new(table, [set,bag,private]) end,
<a name="9380"/> 9380:     OneKeyTab = fun(Type) -&gt;
<a name="9381"/> 9381:                         T = ets:new(table, [Type, private]),
<a name="9382"/> 9382:                         true = ets:insert(T, {one,two,3}),
<a name="9383"/> 9383:                         T
<a name="9384"/> 9384:                 end,
<a name="9385"/> 9385:     Set = fun(_Type) -&gt; ets:new(table, [set, private]) end,
<a name="9386"/> 9386:     OrderedSet = fun(_Type) -&gt; ets:new(table, [ordered_set, private]) end,
<a name="9387"/> 9387:     NamedTable = fun(Type) -&gt; ets:new('$named_table', [Type, named_table, private]) end,
<a name="9388"/> 9388:     UnownedTable = fun(Type) -&gt;
<a name="9389"/> 9389:                            Parent = self(),
<a name="9390"/> 9390:                            spawn_link(fun() -&gt;
<a name="9391"/> 9391:                                               T = ets:new(table, [Type, public]),
<a name="9392"/> 9392:                                               Parent ! T,
<a name="9393"/> 9393:                                               receive ok -&gt; ok end
<a name="9394"/> 9394:                                       end),
<a name="9395"/> 9395:                            receive T -&gt; T end
<a name="9396"/> 9396:                    end,
<a name="9397"/> 9397:     _ = ets:new(name_already_exists, [named_table]),
<a name="9398"/> 9398: 
<a name="9399"/> 9399:     L = [{delete, ['$Tab']},
<a name="9400"/> 9400:          {delete, ['$Tab', no_key], [no_fail]},
<a name="9401"/> 9401:          {delete_all_objects, ['$Tab'], [renamed]},
<a name="9402"/> 9402:          {delete_object, ['$Tab', bad_object]},
<a name="9403"/> 9403:          {delete_object, ['$Tab', {tag,non_existing}], [no_fail]},
<a name="9404"/> 9404: 
<a name="9405"/> 9405:          {file2tab, 1},                          %Not BIF.
<a name="9406"/> 9406:          {file2tab, 2},                          %Not BIF.
<a name="9407"/> 9407: 
<a name="9408"/> 9408:          {first, ['$Tab']},
<a name="9409"/> 9409:          {first_lookup, ['$Tab']},
<a name="9410"/> 9410: 
<a name="9411"/> 9411:          {foldl, 3},                            %Not BIF.
<a name="9412"/> 9412:          {foldr, 3},                            %Not BIF.
<a name="9413"/> 9413: 
<a name="9414"/> 9414:          {from_dets, 2},                        %Not BIF.
<a name="9415"/> 9415: 
<a name="9416"/> 9416:          {fun2ms, 1},                           %Not BIF.
<a name="9417"/> 9417: 
<a name="9418"/> 9418:          {give_away, ['$Tab', not_a_pid, bad_pid]},
<a name="9419"/> 9419:          {give_away, ['$Tab', '$Self', already_owner], [{error_term,owner}]},
<a name="9420"/> 9420:          {give_away, ['$Tab', '$Living', living_process], [only_bad_table]},
<a name="9421"/> 9421:          {give_away, ['$Tab', '$Dead', dead_process]},
<a name="9422"/> 9422: 
<a name="9423"/> 9423:          {give_away, [UnownedTable, '$Living', gift_data], [{error_term,not_owner}]},
<a name="9424"/> 9424: 
<a name="9425"/> 9425:          {i, 1},                                %Not BIF.
<a name="9426"/> 9426:          {i, 2},                                %Not BIF.
<a name="9427"/> 9427:          {i, 3},                                %Not BIF.
<a name="9428"/> 9428: 
<a name="9429"/> 9429:          {info, ['$Tab']},
<a name="9430"/> 9430:          {info, ['$Tab', invalid_item]},
<a name="9431"/> 9431: 
<a name="9432"/> 9432:          {init_table, 2},                       %Not BIF.
<a name="9433"/> 9433: 
<a name="9434"/> 9434:          {insert, ['$Tab', bad_object]},
<a name="9435"/> 9435:          {insert, ['$Tab', {}]},
<a name="9436"/> 9436:          {insert, ['$Tab', [a,{a,b,c}]]},
<a name="9437"/> 9437:          {insert, ['$Tab', [a|b]]},
<a name="9438"/> 9438:          {insert, ['$Tab', {a,b,c}], [no_fail]},
<a name="9439"/> 9439:          {insert, ['$Tab', [{a,b,c}]], [no_fail]},
<a name="9440"/> 9440:          {insert, ['$Tab', [{a,b,c},{d,e,f}]], [no_fail]},
<a name="9441"/> 9441:          {insert, ['$Tab', [{I,b,c} || I &lt;- lists:seq(1,10_000)]], [no_fail]},
<a name="9442"/> 9442: 
<a name="9443"/> 9443:          {insert_new, ['$Tab', bad_object]},
<a name="9444"/> 9444:          {insert_new, ['$Tab', {a,b,c}], [no_fail]},
<a name="9445"/> 9445:          {insert_new, ['$Tab', [a,{a,b,c}]]},
<a name="9446"/> 9446:          {insert_new, ['$Tab', [a|b]]},
<a name="9447"/> 9447: 
<a name="9448"/> 9448:          {internal_delete_all, 2},              %Internal function.
<a name="9449"/> 9449:          {internal_select_delete, 2},           %Internal function.
<a name="9450"/> 9450: 
<a name="9451"/> 9451:          {is_compiled_ms, [bad_ms], [no_fail, no_table]},
<a name="9452"/> 9452: 
<a name="9453"/> 9453:          {last, ['$Tab']},
<a name="9454"/> 9454:          {last_lookup, ['$Tab']},
<a name="9455"/> 9455: 
<a name="9456"/> 9456:          {lookup, ['$Tab', no_key], [no_fail]},
<a name="9457"/> 9457: 
<a name="9458"/> 9458:          {lookup_element, ['$Tab', no_key, 0]},
<a name="9459"/> 9459:          {lookup_element, ['$Tab', no_key, 1], [{error_term,badkey}]},
<a name="9460"/> 9460:          {lookup_element, ['$Tab', no_key, bad_pos]},
<a name="9461"/> 9461: 
<a name="9462"/> 9462:          {lookup_element, [OneKeyTab, one, 4]},
<a name="9463"/> 9463: 
<a name="9464"/> 9464:          {lookup_element, ['$Tab', no_key, 1, default_value], [no_fail]},
<a name="9465"/> 9465:          {lookup_element, [OneKeyTab, one, 4, default_value]},
<a name="9466"/> 9466: 
<a name="9467"/> 9467:          {match, [bad_continuation], [no_table]},
<a name="9468"/> 9468: 
<a name="9469"/> 9469:          {match, ['$Tab', &lt;&lt;1,2,3&gt;&gt;], [no_fail]},
<a name="9470"/> 9470:          {match, ['$Tab', &lt;&lt;1,2,3&gt;&gt;, 0]},
<a name="9471"/> 9471:          {match, ['$Tab', &lt;&lt;1,2,3&gt;&gt;, bad_limit]},
<a name="9472"/> 9472:          {match_delete, ['$Tab', &lt;&lt;1,2,3&gt;&gt;], [no_fail,renamed]},
<a name="9473"/> 9473: 
<a name="9474"/> 9474:          {match_object, [bad_continuation], [no_table]},
<a name="9475"/> 9475: 
<a name="9476"/> 9476:          {match_object, ['$Tab', &lt;&lt;1,2,3&gt;&gt;], [no_fail]},
<a name="9477"/> 9477:          {match_object, ['$Tab', &lt;&lt;1,2,3&gt;&gt;, bad_limit]},
<a name="9478"/> 9478: 
<a name="9479"/> 9479:          {match_spec_compile, [bad_match_spec], [no_table]},
<a name="9480"/> 9480:          {match_spec_run, 2},                   %Not BIF.
<a name="9481"/> 9481:          {match_spec_run_r, 3},                 %Internal BIF.
<a name="9482"/> 9482: 
<a name="9483"/> 9483:          {member, ['$Tab', no_key], [no_fail]},
<a name="9484"/> 9484: 
<a name="9485"/> 9485:          {new, [name, not_list], [no_table]},
<a name="9486"/> 9486:          {new, [name, [a|b]], [no_table]},
<a name="9487"/> 9487:          {new, [name, [a,b]], [no_table]},
<a name="9488"/> 9488:          {new, [{bad,name}, [a,b]], [no_table]},
<a name="9489"/> 9489:          {new, [name_already_exists, [named_table]], [no_table,
<a name="9490"/> 9490:                                                       {error_term,already_exists}]},
<a name="9491"/> 9491: 
<a name="9492"/> 9492:          %% For a set, ets:next/2 and ets:prev/2 fails if the key does
<a name="9493"/> 9493:          %% not exist.
<a name="9494"/> 9494:          {next, [Set, no_key]},
<a name="9495"/> 9495:          {prev, [Set, no_key]},
<a name="9496"/> 9496:          {next_lookup, [Set, no_key]},
<a name="9497"/> 9497:          {prev_lookup, [Set, no_key]},
<a name="9498"/> 9498: 
<a name="9499"/> 9499:          % For an ordered set, ets:next/2 and ets:prev/2 succeeds
<a name="9500"/> 9500:          % even if the key does not exist.
<a name="9501"/> 9501:          {next, [OrderedSet, no_key], [no_fail]},
<a name="9502"/> 9502:          {prev, [OrderedSet, no_key], [no_fail]},
<a name="9503"/> 9503:          {next_lookup, [OrderedSet, no_key], [no_fail]},
<a name="9504"/> 9504:          {prev_lookup, [OrderedSet, no_key], [no_fail]},
<a name="9505"/> 9505: 
<a name="9506"/> 9506:          {rename, ['$Tab', {bad,name}]},
<a name="9507"/> 9507:          {rename, [NamedTable, '$named_table']},
<a name="9508"/> 9508:          {rename, [NamedTable, {bad,name}]},
<a name="9509"/> 9509: 
<a name="9510"/> 9510:          {repair_continuation, 2},              %Not BIF.
<a name="9511"/> 9511: 
<a name="9512"/> 9512:          {safe_fixtable, ['$Tab', true], [no_fail]},
<a name="9513"/> 9513:          {safe_fixtable, ['$Tab', not_boolean]},
<a name="9514"/> 9514: 
<a name="9515"/> 9515:          {select, [bad_continuation], [no_table]},
<a name="9516"/> 9516: 
<a name="9517"/> 9517:          {select, ['$Tab', Ms], [no_fail]},
<a name="9518"/> 9518:          {select, ['$Tab', bad_match_spec]},
<a name="9519"/> 9519:          {select, ['$Tab', Ms, bad_limit]},
<a name="9520"/> 9520:          {select, ['$Tab', Ms, 0]},
<a name="9521"/> 9521:          {select, ['$Tab', bad_match_spec, bad_limit]},
<a name="9522"/> 9522:          {select, ['$Tab', bad_match_spec, 1]},
<a name="9523"/> 9523: 
<a name="9524"/> 9524:          {select_count, ['$Tab', Ms], [no_fail]},
<a name="9525"/> 9525:          {select_count, ['$Tab', bad_match_spec]},
<a name="9526"/> 9526: 
<a name="9527"/> 9527:          {select_delete, ['$Tab', Ms], [no_fail,renamed]},
<a name="9528"/> 9528:          {select_delete, ['$Tab', bad_match_spec], [renamed]},
<a name="9529"/> 9529: 
<a name="9530"/> 9530:          {select_replace, ['$Tab', [{{'$1','$2','$3'},[],[{{'$1','$3','$2'}}]}]], [no_fail]},
<a name="9531"/> 9531:          {select_replace, ['$Tab', [{{'$1','$2','$3'},[],[{{'key_destroyed'}}]}]]},
<a name="9532"/> 9532:          {select_replace, ['$Tab', bad_match_spec]},
<a name="9533"/> 9533: 
<a name="9534"/> 9534:          {select_replace, [BagTab, [{{'$1','$2','$3'},[],[{{'$1','$3','$2'}}]}]], [{error_term,table_type}]},
<a name="9535"/> 9535: 
<a name="9536"/> 9536:          {select_reverse, [bad_continuation], [no_table]},
<a name="9537"/> 9537: 
<a name="9538"/> 9538:          {select_reverse, ['$Tab', Ms], [no_fail]},
<a name="9539"/> 9539:          {select_reverse, ['$Tab', bad_match_spec]},
<a name="9540"/> 9540: 
<a name="9541"/> 9541:          {select_reverse, ['$Tab', Ms, 0]},
<a name="9542"/> 9542:          {select_reverse, ['$Tab', Ms, bad_limit]},
<a name="9543"/> 9543:          {select_reverse, ['$Tab', bad_match_spec, bad_limit]},
<a name="9544"/> 9544: 
<a name="9545"/> 9545:          {setopts, ['$Tab', bad_opts]},
<a name="9546"/> 9546: 
<a name="9547"/> 9547:          {slot, ['$Tab', -1]},
<a name="9548"/> 9548:          {slot, ['$Tab', not_an_integer]},
<a name="9549"/> 9549: 
<a name="9550"/> 9550:          {tab2file, 2},                         %Not BIF.
<a name="9551"/> 9551:          {tab2file, 3},                         %Not BIF.
<a name="9552"/> 9552:          {tab2list, 1},                         %Not BIF.
<a name="9553"/> 9553:          {tabfile_info, 1},                     %Not BIF.
<a name="9554"/> 9554:          {table, 1},                            %Not BIF.
<a name="9555"/> 9555:          {table, 2},                            %Not BIF.
<a name="9556"/> 9556: 
<a name="9557"/> 9557:          {take, ['$Tab', no_key], [no_fail]},
<a name="9558"/> 9558: 
<a name="9559"/> 9559:          {test_ms, 2},                          %Not BIF.
<a name="9560"/> 9560:          {to_dets, 2},                          %Not BIF.
<a name="9561"/> 9561: 
<a name="9562"/> 9562:          {update_counter, ['$Tab', no_key, 1], [{error_term,badkey}]},
<a name="9563"/> 9563:          {update_counter, ['$Tab', no_key, bad_increment], [{error_term,badkey}]},
<a name="9564"/> 9564:          {update_counter, ['$Tab', no_key, {1, 42}], [{error_term,badkey}]},
<a name="9565"/> 9565:          {update_counter, ['$Tab', no_key, {1, bad_increment}], [{error_term,badkey}]},
<a name="9566"/> 9566: 
<a name="9567"/> 9567:          {update_counter, [OneKeyTab, one, {2, 1}]},
<a name="9568"/> 9568:          {update_counter, [OneKeyTab, one, {2, bad_increment}]},
<a name="9569"/> 9569:          {update_counter, [OneKeyTab, one, {3, bad_increment}]},
<a name="9570"/> 9570:          {update_counter, [OneKeyTab, one, {4, 1}], [{error_term,position}]},
<a name="9571"/> 9571:          {update_counter, [OneKeyTab, one, {4, bad_increment}]},
<a name="9572"/> 9572: 
<a name="9573"/> 9573:          {update_counter, [BagTab, bag_key, 1], [{error_term,table_type}]},
<a name="9574"/> 9574:          {update_counter, [BagTab, bag_key, bad_increment], [{error_term,table_type}]},
<a name="9575"/> 9575: 
<a name="9576"/> 9576:          {update_counter, ['$Tab', key, 2, {key,0}], [no_fail]},
<a name="9577"/> 9577:          {update_counter, ['$Tab', key, {1,42}, {key,0}], [{error_term,keypos}]},
<a name="9578"/> 9578:          {update_counter, ['$Tab', key, 2, {key,not_integer}]},
<a name="9579"/> 9579:          {update_counter, ['$Tab', key, 3, {key,whatever}]},
<a name="9580"/> 9580: 
<a name="9581"/> 9581:          {update_counter, ['$Tab', no_key, 1, default]},
<a name="9582"/> 9582:          {update_counter, ['$Tab', no_key, bad_increment, {tag,0}]},
<a name="9583"/> 9583:          {update_counter, ['$Tab', no_key, {1, bad_increment}, {tag,0}]},
<a name="9584"/> 9584:          {update_counter, ['$Tab', no_key, {1, 42}, {tag,0}], [{error_term,keypos}]},
<a name="9585"/> 9585:          {update_counter, ['$Tab', no_key, {2, 42}, {tag,not_integer}]},
<a name="9586"/> 9586:          {update_counter, ['$Tab', no_key, {3, 42}, {tag,not_integer}], [{error_term,position}]},
<a name="9587"/> 9587: 
<a name="9588"/> 9588:          {update_counter, [OneKeyTab, one, {2, 1}, {tag,val}]},
<a name="9589"/> 9589:          {update_counter, [OneKeyTab, one, {2, bad_increment}, {tag,val}]},
<a name="9590"/> 9590:          {update_counter, [OneKeyTab, one, {3, bad_increment}, {tag,val}]},
<a name="9591"/> 9591:          {update_counter, [OneKeyTab, one, {4, 1}, {tag,val}], [{error_term,position}]},
<a name="9592"/> 9592:          {update_counter, [OneKeyTab, one, {4, bad_increment}, {tag,val}]},
<a name="9593"/> 9593: 
<a name="9594"/> 9594:          {update_element, ['$Tab', no_key, {2, new}], [no_fail]},
<a name="9595"/> 9595:          {update_element, [BagTab, no_key, {2, bagged}]},
<a name="9596"/> 9596:          {update_element, [OneKeyTab, one, not_tuple]},
<a name="9597"/> 9597:          {update_element, [OneKeyTab, one, {0, new}], [{error_term, position}]},
<a name="9598"/> 9598:          {update_element, [OneKeyTab, one, {1, new}], [{error_term,keypos}]},
<a name="9599"/> 9599:          {update_element, [OneKeyTab, one, {4, new}], [{error_term, position}]},
<a name="9600"/> 9600: 
<a name="9601"/> 9601: 	 {update_element, ['$Tab', no_key, {2, new}, {no_key, old}], [no_fail]},
<a name="9602"/> 9602: 	 {update_element, ['$Tab', no_key, {0, new}, {no_key, old}], [{error_term, position}]},
<a name="9603"/> 9603: 	 {update_element, ['$Tab', no_key, {1, new}, {no_key, old}], [{error_term, keypos}]},
<a name="9604"/> 9604: 	 {update_element, ['$Tab', no_key, {4, new}, {no_key, old}], [{error_term, position}]},
<a name="9605"/> 9605: 	 {update_element, ['$Tab', no_key, {4, new}, not_tuple]},
<a name="9606"/> 9606: 	 {update_element, [BagTab, no_key, {1, bagged}, {no_key, old}], []},
<a name="9607"/> 9607: 	 {update_element, [OneKeyTab, no_key, {0, new}, {no_key, old}], [{error_term, position}]},
<a name="9608"/> 9608: 	 {update_element, [OneKeyTab, no_key, {1, new}, {no_key, old}], [{error_term, keypos}]},
<a name="9609"/> 9609: 	 {update_element, [OneKeyTab, no_key, {4, new}, {no_key, old}], [{error_term, position}]},
<a name="9610"/> 9610: 	 {update_element, [OneKeyTab, no_key, {4, new}, not_tuple]},
<a name="9611"/> 9611: 
<a name="9612"/> 9612:          {whereis, [{bad,name}], [no_table]}
<a name="9613"/> 9613:         ],
<a name="9614"/> 9614:     put(errors, []),
<a name="9615"/> 9615:     eval_ets_bif_errors(L),
<a name="9616"/> 9616:     io:nl(),
<a name="error_info-last_expr"/><a name="9617"/> 9617: <b>    case lists:sort</b>(get(errors)) of
<a name="9618"/> 9618:         [] -&gt;
<a name="9619"/> 9619:             ok;
<a name="9620"/> 9620:         [_|_]=Errors -&gt;
<a name="9621"/> 9621:             io:format(&quot;~P\n&quot;, [Errors, 100]),
<a name="9622"/> 9622:             ct:fail({length(Errors),errors})
<a name="9623"/> 9623:     end.
<a name="9624"/> 9624: 
<a name="eval_ets_bif_errors-1"/><a name="9625"/> 9625: <b>eval_ets_bif_errors</b>(L0) -&gt;
<a name="9626"/> 9626:     L1 = lists:foldl(fun({_,A}, Acc) when is_integer(A) -&gt; Acc;
<a name="9627"/> 9627:                         ({F,A}, Acc) -&gt; [{F,A,[]}|Acc];
<a name="9628"/> 9628:                         ({F,A,Opts}, Acc) -&gt; [{F,A,Opts}|Acc]
<a name="9629"/> 9629:                      end, [], L0),
<a name="9630"/> 9630:     Tests = ordsets:from_list([{F,length(A)} || {F,A,_} &lt;- L1] ++
<a name="9631"/> 9631:                                   [{F,A} || {F,A} &lt;- L0, is_integer(A)]),
<a name="9632"/> 9632:     Bifs0 = [{F,A} || {F,A} &lt;- ets:module_info(exports),
<a name="9633"/> 9633:                       A =/= 0,
<a name="9634"/> 9634:                       F =/= module_info],
<a name="9635"/> 9635:     Bifs = ordsets:from_list(Bifs0),
<a name="9636"/> 9636:     NYI = [{F,lists:duplicate(A, '*'),nyi} || {F,A} &lt;- Bifs -- Tests],
<a name="9637"/> 9637:     L = lists:sort(NYI ++ L1),
<a name="9638"/> 9638: 
<a name="9639"/> 9639:     spawn(fun() -&gt;
<a name="9640"/> 9640:                   true = register(living, self()),
<a name="9641"/> 9641:                   Ref = make_ref(),
<a name="9642"/> 9642:                   receive
<a name="9643"/> 9643:                       Ref -&gt;
<a name="9644"/> 9644:                           ok
<a name="9645"/> 9645:                   end
<a name="9646"/> 9646:           end),
<a name="9647"/> 9647: 
<a name="eval_ets_bif_errors-last_expr"/><a name="9648"/> 9648: <b>    do_eval_ets_bif_errors</b>(L).
<a name="9649"/> 9649: 
<a name="do_eval_ets_bif_errors-1"/><a name="9650"/> 9650: <b>do_eval_ets_bif_errors</b>([H|T]) -&gt;
<a name="9651"/> 9651:     case H of
<a name="9652"/> 9652:         {F, Args} -&gt;
<a name="9653"/> 9653:             eval_ets_bif_errors(F, Args, []);
<a name="9654"/> 9654:         {_, Args, nyi} -&gt;
<a name="9655"/> 9655:             case lists:all(fun(A) -&gt; A =:= '*' end, Args) of
<a name="9656"/> 9656:                 true -&gt;
<a name="9657"/> 9657:                     store_error(nyi, H, error);
<a name="9658"/> 9658:                 false -&gt;
<a name="9659"/> 9659:                     store_error(bad_nyi, H, error)
<a name="9660"/> 9660:             end;
<a name="9661"/> 9661:         {F, Args, Opts} when is_list(Opts) -&gt;
<a name="9662"/> 9662:             case lists:member(no_table, Opts) of
<a name="9663"/> 9663:                 true -&gt;
<a name="9664"/> 9664:                     ets_eval_bif_errors_once(F, Args, Opts);
<a name="9665"/> 9665:                 false -&gt;
<a name="9666"/> 9666:                     eval_ets_bif_errors(F, Args, Opts)
<a name="9667"/> 9667:             end
<a name="9668"/> 9668:     end,
<a name="9669"/> 9669:     do_eval_ets_bif_errors(T);
<a name="9670"/> 9670: <b>do_eval_ets_bif_errors</b>([]) -&gt;
<a name="do_eval_ets_bif_errors-last_expr"/><a name="9671"/> 9671:     ok.
<a name="9672"/> 9672: 
<a name="ets_eval_bif_errors_once-3"/><a name="9673"/> 9673: <b>ets_eval_bif_errors_once</b>(F, Args, Opts) -&gt;
<a name="9674"/> 9674:     MFA = {ets,F,Args},
<a name="9675"/> 9675:     io:format(&quot;\n\n*** ets:~p/~p&quot;, [F,length(Args)]),
<a name="9676"/> 9676: 
<a name="9677"/> 9677:     NoFail = lists:member(no_fail, Opts),
<a name="9678"/> 9678:     ErrorTerm = proplists:get_value(error_term, Opts, none),
<a name="ets_eval_bif_errors_once-last_expr"/><a name="9679"/> 9679: <b>    case ets_apply</b>(F, Args, Opts) of
<a name="9680"/> 9680:         {error,ErrorTerm} when not NoFail -&gt;
<a name="9681"/> 9681:             ok;
<a name="9682"/> 9682:         {error,Info} -&gt;
<a name="9683"/> 9683:             store_error(wrong_failure_reason, MFA, Info);
<a name="9684"/> 9684:         ok when NoFail -&gt;
<a name="9685"/> 9685:             ok;
<a name="9686"/> 9686:         ok when not NoFail -&gt;
<a name="9687"/> 9687:             %% This ETS function was supposed to fail.
<a name="9688"/> 9688:             store_error(expected_failure, MFA, ok)
<a name="9689"/> 9689:     end.
<a name="9690"/> 9690: 
<a name="eval_ets_bif_errors-3"/><a name="9691"/> 9691: <b>eval_ets_bif_errors</b>(F, Args0, Opts) -&gt;
<a name="9692"/> 9692:     MFA = {ets,F,Args0},
<a name="9693"/> 9693:     io:format(&quot;\n\n*** ets:~p/~p&quot;, [F,length(Args0)]),
<a name="9694"/> 9694: 
<a name="9695"/> 9695:     %% Test the ETS function with a valid table argument.
<a name="9696"/> 9696:     %% Test both for sets and ordered sets.
<a name="9697"/> 9697:     _ = eval_ets_valid_tid(F, Args0, Opts, set),
<a name="9698"/> 9698:     Args = eval_ets_valid_tid(F, Args0, Opts, ordered_set),
<a name="9699"/> 9699: 
<a name="9700"/> 9700:     %% Replace the table id with a plain ref to provoke a type error.
<a name="9701"/> 9701:     BadArgs = eval_expand_bad_args(Args),
<a name="eval_ets_bif_errors-last_expr"/><a name="9702"/> 9702: <b>    case ets_apply</b>(F, BadArgs, Opts) of
<a name="9703"/> 9703:         {error,type} -&gt;
<a name="9704"/> 9704:             ok;
<a name="9705"/> 9705:         BadIdResult -&gt;
<a name="9706"/> 9706:             store_error(bad_table_id, MFA, BadIdResult)
<a name="9707"/> 9707:     end.
<a name="9708"/> 9708: 
<a name="eval_ets_valid_tid-4"/><a name="9709"/> 9709: <b>eval_ets_valid_tid</b>(F, Args0, Opts, Type) -&gt;
<a name="9710"/> 9710:     MFA = {ets,F,Args0},
<a name="9711"/> 9711:     Args = eval_expand_args(Args0, Type),
<a name="9712"/> 9712:     case should_apply(Args, Opts) of
<a name="9713"/> 9713:         false -&gt;
<a name="9714"/> 9714:             %% Applying this function will never fail.
<a name="9715"/> 9715:             ok;
<a name="9716"/> 9716:         true -&gt;
<a name="9717"/> 9717:             NoFail = lists:member(no_fail, Opts),
<a name="9718"/> 9718:             ErrorTerm = proplists:get_value(error_term, Opts, none),
<a name="9719"/> 9719:             case ets_apply(F, Args, Opts) of
<a name="9720"/> 9720:                 {error,ErrorTerm} when not NoFail -&gt;
<a name="9721"/> 9721:                     ok;
<a name="9722"/> 9722:                 {error,Info} when not NoFail -&gt;
<a name="9723"/> 9723:                     store_error(wrong_failure_reason, MFA, Info);
<a name="9724"/> 9724:                 {error,Info} when NoFail -&gt;
<a name="9725"/> 9725:                     store_error(expected_success, MFA, Info);
<a name="9726"/> 9726:                 ok when NoFail -&gt;
<a name="9727"/> 9727:                     ok;
<a name="9728"/> 9728:                 ok when not NoFail -&gt;
<a name="9729"/> 9729:                     %% This ETS function was supposed to fail.
<a name="9730"/> 9730:                     store_error(expected_failure, MFA, ok)
<a name="9731"/> 9731:             end
<a name="9732"/> 9732:     end,
<a name="9733"/> 9733: 
<a name="9734"/> 9734:     %% Test the ETS function from another process to provoke an error
<a name="9735"/> 9735:     %% because of missing access rights. (The table is private.)
<a name="9736"/> 9736:     {Pid,Ref} = spawn_monitor(fun() -&gt; exit(ets_apply(F, Args, Opts)) end),
<a name="9737"/> 9737:     receive
<a name="9738"/> 9738:         {'DOWN',Ref,process,Pid,Result} -&gt;
<a name="9739"/> 9739:             case Result of
<a name="9740"/> 9740:                 {error,access} -&gt;
<a name="9741"/> 9741:                     ok;
<a name="9742"/> 9742:                 {error,not_owner} when F =:= give_away -&gt;
<a name="9743"/> 9743:                     ok;
<a name="9744"/> 9744:                 {error,none} when F =:= info -&gt;
<a name="9745"/> 9745:                     ok;
<a name="9746"/> 9746:                 ok when F =:= info -&gt;
<a name="9747"/> 9747:                     ok;
<a name="9748"/> 9748:                 Other -&gt;
<a name="9749"/> 9749:                     store_error(access, MFA, Other)
<a name="9750"/> 9750:             end
<a name="9751"/> 9751:     end,
<a name="9752"/> 9752: 
<a name="9753"/> 9753:     %% Delete the ETS table.
<a name="9754"/> 9754:     eval_delete_tab(Args),
<a name="9755"/> 9755:     case ets_apply(F, Args, Opts) of
<a name="9756"/> 9756:         {error,id} -&gt;
<a name="9757"/> 9757:             ok;
<a name="9758"/> 9758:         ok when F =:= info -&gt;
<a name="9759"/> 9759:             %% ets:info/1,2 returns `undefined` instead of failing if the
<a name="9760"/> 9760:             %% table has been deleted.
<a name="9761"/> 9761:             ok;
<a name="9762"/> 9762:         DeadTableResult -&gt;
<a name="9763"/> 9763:             store_error(dead_table, MFA, DeadTableResult)
<a name="9764"/> 9764:     end,
<a name="9765"/> 9765: 
<a name="eval_ets_valid_tid-last_expr"/><a name="9766"/> 9766:     Args.
<a name="9767"/> 9767: 
<a name="should_apply-2"/><a name="9768"/> 9768: <b>should_apply</b>([_], _Opts) -&gt;
<a name="9769"/> 9769:     %% An ETS function with a single argument can't fail if
<a name="9770"/> 9770:     %% the argument is valid.
<a name="9771"/> 9771:     false;
<a name="9772"/> 9772: <b>should_apply</b>([_,_|_], Opts) -&gt;
<a name="9773"/> 9773:     %% Applying the function on a valid table would have side effects
<a name="9774"/> 9774:     %% that would cause problems down the line (e.g. successfully
<a name="9775"/> 9775:     %% giving away a table).
<a name="should_apply-last_expr"/><a name="9776"/> 9776: <b>    not lists:member</b>(only_bad_table, Opts).
<a name="9777"/> 9777: 
<a name="store_error-3"/><a name="9778"/> 9778: <b>store_error</b>(What, MFA, Wrong) -&gt;
<a name="store_error-last_expr"/><a name="9779"/> 9779: <b>    put</b>(errors, [{What,MFA,Wrong}|get(errors)]).
<a name="9780"/> 9780: 
<a name="eval_expand_args-2"/><a name="9781"/> 9781: <b>eval_expand_args</b>(Args, Type) -&gt;
<a name="eval_expand_args-last_expr"/><a name="9782"/> 9782: <b>    [expand_arg</b>(A, Type) || A &lt;- Args].
<a name="9783"/> 9783: 
<a name="expand_arg-2"/><a name="9784"/> 9784: <b>expand_arg</b>('$Tab', Type) -&gt; ets:new(table, [Type, private]);
<a name="9785"/> 9785: <b>expand_arg</b>('$Self', _Type) -&gt; self();
<a name="9786"/> 9786: <b>expand_arg</b>('$Living', _Type) -&gt; whereis(living);
<a name="9787"/> 9787: <b>expand_arg</b>('$Dead', _Type) -&gt;
<a name="9788"/> 9788:     {Pid,Ref} = spawn_monitor(fun() -&gt; ok end),
<a name="9789"/> 9789:     receive
<a name="9790"/> 9790:         {'DOWN',Ref,process,Pid,normal} -&gt; Pid
<a name="9791"/> 9791:     end;
<a name="9792"/> 9792: <b>expand_arg</b>(Fun, Type) when is_function(Fun, 1) -&gt; Fun(Type);
<a name="expand_arg-last_expr"/><a name="9793"/> 9793: <b>expand_arg</b>(Arg, _Type) -&gt; Arg.
<a name="9794"/> 9794: 
<a name="eval_delete_tab-1"/><a name="9795"/> 9795: <b>eval_delete_tab</b>(['$named_table'=H|_]) -&gt;
<a name="9796"/> 9796:     ets:delete(H);
<a name="9797"/> 9797: <b>eval_delete_tab</b>([H|_]) when is_reference(H) -&gt;
<a name="9798"/> 9798:     ets:delete(H);
<a name="9799"/> 9799: <b>eval_delete_tab</b>([_|T]) -&gt;
<a name="eval_delete_tab-last_expr"/><a name="9800"/> 9800: <b>    eval_delete_tab</b>(T).
<a name="9801"/> 9801: 
<a name="eval_expand_bad_args-1"/><a name="9802"/> 9802: <b>eval_expand_bad_args</b>(['$named_table'|T]) -&gt;
<a name="9803"/> 9803:     [make_ref()|T];
<a name="9804"/> 9804: <b>eval_expand_bad_args</b>([H|T]) when is_reference(H) -&gt;
<a name="9805"/> 9805:     [make_ref()|T];
<a name="9806"/> 9806: <b>eval_expand_bad_args</b>([H|T]) -&gt;
<a name="eval_expand_bad_args-last_expr"/><a name="9807"/> 9807: <b>    [H|eval_expand_bad_args</b>(T)].
<a name="9808"/> 9808: 
<a name="ets_apply-3"/><a name="9809"/> 9809: <b>ets_apply</b>(F, Args, Opts) -&gt;
<a name="ets_apply-last_expr"/><a name="9810"/> 9810:     try
<a name="9811"/> 9811:         apply(ets, F, Args),
<a name="9812"/> 9812:         io:format(&quot;\nets:~p(~s) succeeded&quot;, [F,ets_format_args(Args)])
<a name="9813"/> 9813:     catch
<a name="9814"/> 9814:         C:R:Stk -&gt;
<a name="9815"/> 9815:             SF = fun(Mod, _, _) -&gt; Mod =:= test_server end,
<a name="9816"/> 9816:             Str = erl_error:format_exception(C, R, Stk, #{stack_trim_fun =&gt; SF}),
<a name="9817"/> 9817:             BinStr = iolist_to_binary(Str),
<a name="9818"/> 9818:             io:format(&quot;\nets:~p(~s)\n~ts&quot;, [F,ets_format_args(Args),BinStr]),
<a name="9819"/> 9819: 
<a name="9820"/> 9820:             {ets,ActualF,ActualArgs,Info} = hd(Stk),
<a name="9821"/> 9821: 
<a name="9822"/> 9822:             RE = &lt;&lt;&quot;[*][*][*] argument \\d+:&quot;&gt;&gt;,
<a name="9823"/> 9823:             case re:run(BinStr, RE, [{capture, none}]) of
<a name="9824"/> 9824:                 match -&gt;
<a name="9825"/> 9825:                     ok;
<a name="9826"/> 9826:                 nomatch -&gt;
<a name="9827"/> 9827:                     store_error(no_explanation, {ets,F,Args}, Info)
<a name="9828"/> 9828:             end,
<a name="9829"/> 9829: 
<a name="9830"/> 9830:             case {ActualF,ActualArgs} of
<a name="9831"/> 9831:                 {F,Args} -&gt;
<a name="9832"/> 9832:                     ok;
<a name="9833"/> 9833:                 _ -&gt;
<a name="9834"/> 9834:                     case lists:member(renamed, Opts) of
<a name="9835"/> 9835:                         true -&gt;
<a name="9836"/> 9836:                             ok;
<a name="9837"/> 9837:                         false -&gt;
<a name="9838"/> 9838:                             store_error(renamed, {ets,F,length(Args)}, {ActualF,ActualArgs})
<a name="9839"/> 9839:                     end
<a name="9840"/> 9840:             end,
<a name="9841"/> 9841:             [{error_info, ErrorInfoMap}] = Info,
<a name="9842"/> 9842:             Cause = maps:get(cause, ErrorInfoMap, none),
<a name="9843"/> 9843:             {error,Cause}
<a name="9844"/> 9844:     end.
<a name="9845"/> 9845: 
<a name="ets_format_args-1"/><a name="9846"/> 9846: <b>ets_format_args</b>(Args) -&gt;
<a name="ets_format_args-last_expr"/><a name="9847"/> 9847: <b>    lists:join</b>(&quot;, &quot;, [io_lib:format(&quot;~P&quot;, [A,10]) || A &lt;- Args]).
<a name="9848"/> 9848: 
<a name="bound_maps-1"/><a name="9849"/> 9849: <b>bound_maps</b>(_Config) -&gt;
<a name="9850"/> 9850:     T = ets:new('__bound_maps__', [ordered_set, public]),
<a name="9851"/> 9851:     Ref = make_ref(),
<a name="9852"/> 9852:     Attrs = [#{}, #{key =&gt; value}],
<a name="9853"/> 9853:     [ets:insert_new(T, {{Attr, Ref}, original}) || Attr &lt;- Attrs],
<a name="9854"/> 9854:     Attr = #{},
<a name="9855"/> 9855:     Key = {Attr, Ref},
<a name="9856"/> 9856:     MS = [{{Key, '$1'},[],[{{{element, 1, '$_'}, {const, new}}}]}],
<a name="9857"/> 9857:     2 = ets:select_replace(T, MS),
<a name="bound_maps-last_expr"/><a name="9858"/> 9858:     ok.
<a name="9859"/> 9859: 
<a name="9860"/> 9860: <i>%%%</i>
<a name="9861"/> 9861: <i>%%% Common utility functions.</i>
<a name="9862"/> 9862: <i>%%%</i>
<a name="9863"/> 9863: 
<a name="id-1"/><a name="id-last_expr"/><a name="9864"/> 9864: <b>id</b>(I) -&gt; I.
<a name="9865"/> 9865: 
<a name="very_big_num-0"/><a name="9866"/> 9866: <b>very_big_num</b>() -&gt;
<a name="very_big_num-last_expr"/><a name="9867"/> 9867: <b>    very_big_num</b>(33, 1).
<a name="9868"/> 9868: 
<a name="very_big_num-2"/><a name="9869"/> 9869: <b>very_big_num</b>(Left, Result) when Left &gt; 0 -&gt;
<a name="9870"/> 9870:     very_big_num(Left-1, Result*256);
<a name="9871"/> 9871: <b>very_big_num</b>(0, Result) -&gt;
<a name="very_big_num-last_expr"/><a name="9872"/> 9872:     Result.
<a name="9873"/> 9873: 
<a name="make_port-0"/><a name="9874"/> 9874: <b>make_port</b>() -&gt;
<a name="make_port-last_expr"/><a name="9875"/> 9875: <b>    hd</b>(erlang:ports()).
<a name="9876"/> 9876: 
<a name="make_pid-0"/><a name="9877"/> 9877: <b>make_pid</b>() -&gt;
<a name="make_pid-last_expr"/><a name="9878"/> 9878: <b>    spawn_link</b>(fun sleeper/0).
<a name="9879"/> 9879: 
<a name="sleeper-0"/><a name="9880"/> 9880: <b>sleeper</b>() -&gt;
<a name="sleeper-last_expr"/><a name="9881"/> 9881:     receive after infinity -&gt; ok end.
<a name="9882"/> 9882: 
<a name="make_ext_pid-0"/><a name="9883"/> 9883: <b>make_ext_pid</b>() -&gt;
<a name="9884"/> 9884:     {Pid, _, _} = get(externals),
<a name="make_ext_pid-last_expr"/><a name="9885"/> 9885:     Pid.
<a name="9886"/> 9886: 
<a name="make_ext_port-0"/><a name="9887"/> 9887: <b>make_ext_port</b>() -&gt;
<a name="9888"/> 9888:     {_, Port, _} = get(externals),
<a name="make_ext_port-last_expr"/><a name="9889"/> 9889:     Port.
<a name="make_ext_ref-0"/><a name="9890"/> 9890: <b>make_ext_ref</b>() -&gt;
<a name="9891"/> 9891:     {_, _, Ref} = get(externals),
<a name="make_ext_ref-last_expr"/><a name="9892"/> 9892:     Ref.
<a name="9893"/> 9893: 
<a name="init_externals-0"/><a name="9894"/> 9894: <b>init_externals</b>() -&gt;
<a name="init_externals-last_expr"/><a name="9895"/> 9895: <b>    case get</b>(externals) of
<a name="9896"/> 9896: 	undefined -&gt;
<a name="9897"/> 9897: 	    OtherNode = {gurka@sallad, 1},
<a name="9898"/> 9898: 	    Res = {mk_pid(OtherNode, 7645, 8123),
<a name="9899"/> 9899: 		   mk_port(OtherNode, 187489773),
<a name="9900"/> 9900: 		   mk_ref(OtherNode, [262143, 1293964255, 3291964278])},
<a name="9901"/> 9901: 	    put(externals, Res);
<a name="9902"/> 9902: 
<a name="9903"/> 9903: 	{_,_,_} -&gt; ok
<a name="9904"/> 9904:     end.
<a name="9905"/> 9905: 
<a name="9906"/> 9906: <i>%%</i>
<a name="9907"/> 9907: <i>%% Node container constructor functions</i>
<a name="9908"/> 9908: <i>%%</i>
<a name="9909"/> 9909: 
<a name="9910"/> 9910: <b>-define</b>(VERSION_MAGIC,       131).
<a name="9911"/> 9911: <b>-define</b>(PORT_EXT,            102).
<a name="9912"/> 9912: <b>-define</b>(PID_EXT,             103).
<a name="9913"/> 9913: <b>-define</b>(NEW_REFERENCE_EXT,   114).
<a name="9914"/> 9914: 
<a name="uint32_be-1"/><a name="9915"/> 9915: <b>uint32_be</b>(Uint) when is_integer(Uint), 0 =&lt; Uint, Uint &lt; 1 bsl 32 -&gt;
<a name="9916"/> 9916:     [(Uint bsr 24) band 16#ff,
<a name="9917"/> 9917:      (Uint bsr 16) band 16#ff,
<a name="9918"/> 9918:      (Uint bsr 8) band 16#ff,
<a name="9919"/> 9919:      Uint band 16#ff];
<a name="9920"/> 9920: <b>uint32_be</b>(Uint) -&gt;
<a name="uint32_be-last_expr"/><a name="9921"/> 9921: <b>    exit</b>({badarg, uint32_be, [Uint]}).
<a name="9922"/> 9922: 
<a name="uint16_be-1"/><a name="9923"/> 9923: <b>uint16_be</b>(Uint) when is_integer(Uint), 0 =&lt; Uint, Uint &lt; 1 bsl 16 -&gt;
<a name="9924"/> 9924:     [(Uint bsr 8) band 16#ff,
<a name="9925"/> 9925:      Uint band 16#ff];
<a name="9926"/> 9926: <b>uint16_be</b>(Uint) -&gt;
<a name="uint16_be-last_expr"/><a name="9927"/> 9927: <b>    exit</b>({badarg, uint16_be, [Uint]}).
<a name="9928"/> 9928: 
<a name="uint8-1"/><a name="9929"/> 9929: <b>uint8</b>(Uint) when is_integer(Uint), 0 =&lt; Uint, Uint &lt; 1 bsl 8 -&gt;
<a name="9930"/> 9930:     Uint band 16#ff;
<a name="9931"/> 9931: <b>uint8</b>(Uint) -&gt;
<a name="uint8-last_expr"/><a name="9932"/> 9932: <b>    exit</b>({badarg, uint8, [Uint]}).
<a name="9933"/> 9933: 
<a name="mk_pid-3"/><a name="9934"/> 9934: <b>mk_pid</b>({NodeName, Creation}, Number, Serial) when is_atom(NodeName) -&gt;
<a name="9935"/> 9935:     &lt;&lt;?VERSION_MAGIC, NodeNameExt/binary&gt;&gt; = term_to_binary(NodeName),
<a name="9936"/> 9936:     mk_pid({NodeNameExt, Creation}, Number, Serial);
<a name="9937"/> 9937: <b>mk_pid</b>({NodeNameExt, Creation}, Number, Serial) -&gt;
<a name="mk_pid-last_expr"/><a name="9938"/> 9938: <b>    case catch binary_to_term</b>(list_to_binary([?VERSION_MAGIC,
<a name="9939"/> 9939: 					      ?PID_EXT,
<a name="9940"/> 9940: 					      NodeNameExt,
<a name="9941"/> 9941: 					      uint32_be(Number),
<a name="9942"/> 9942: 					      uint32_be(Serial),
<a name="9943"/> 9943: 					      uint8(Creation)])) of
<a name="9944"/> 9944: 	Pid when is_pid(Pid) -&gt;
<a name="9945"/> 9945: 	    Pid;
<a name="9946"/> 9946: 	{'EXIT', {badarg, _}} -&gt;
<a name="9947"/> 9947: 	    exit({badarg, mk_pid, [{NodeNameExt, Creation}, Number, Serial]});
<a name="9948"/> 9948: 	Other -&gt;
<a name="9949"/> 9949: 	    exit({unexpected_binary_to_term_result, Other})
<a name="9950"/> 9950:     end.
<a name="9951"/> 9951: 
<a name="mk_port-2"/><a name="9952"/> 9952: <b>mk_port</b>({NodeName, Creation}, Number) when is_atom(NodeName) -&gt;
<a name="9953"/> 9953:     &lt;&lt;?VERSION_MAGIC, NodeNameExt/binary&gt;&gt; = term_to_binary(NodeName),
<a name="9954"/> 9954:     mk_port({NodeNameExt, Creation}, Number);
<a name="9955"/> 9955: <b>mk_port</b>({NodeNameExt, Creation}, Number) -&gt;
<a name="mk_port-last_expr"/><a name="9956"/> 9956: <b>    case catch binary_to_term</b>(list_to_binary([?VERSION_MAGIC,
<a name="9957"/> 9957: 					      ?PORT_EXT,
<a name="9958"/> 9958: 					      NodeNameExt,
<a name="9959"/> 9959: 					      uint32_be(Number),
<a name="9960"/> 9960: 					      uint8(Creation)])) of
<a name="9961"/> 9961: 	Port when is_port(Port) -&gt;
<a name="9962"/> 9962: 	    Port;
<a name="9963"/> 9963: 	{'EXIT', {badarg, _}} -&gt;
<a name="9964"/> 9964: 	    exit({badarg, mk_port, [{NodeNameExt, Creation}, Number]});
<a name="9965"/> 9965: 	Other -&gt;
<a name="9966"/> 9966: 	    exit({unexpected_binary_to_term_result, Other})
<a name="9967"/> 9967:     end.
<a name="9968"/> 9968: 
<a name="mk_ref-2"/><a name="9969"/> 9969: <b>mk_ref</b>({NodeName, Creation}, Numbers) when is_atom(NodeName),
<a name="9970"/> 9970: 					   is_integer(Creation),
<a name="9971"/> 9971: 					   is_list(Numbers) -&gt;
<a name="9972"/> 9972:     &lt;&lt;?VERSION_MAGIC, NodeNameExt/binary&gt;&gt; = term_to_binary(NodeName),
<a name="9973"/> 9973:     mk_ref({NodeNameExt, Creation}, Numbers);
<a name="9974"/> 9974: <b>mk_ref</b>({NodeNameExt, Creation}, Numbers) when is_binary(NodeNameExt),
<a name="9975"/> 9975: 					      is_integer(Creation),
<a name="9976"/> 9976: 					      is_list(Numbers) -&gt;
<a name="mk_ref-last_expr"/><a name="9977"/> 9977: <b>    case catch binary_to_term</b>(list_to_binary([?VERSION_MAGIC,
<a name="9978"/> 9978: 					      ?NEW_REFERENCE_EXT,
<a name="9979"/> 9979: 					      uint16_be(length(Numbers)),
<a name="9980"/> 9980: 					      NodeNameExt,
<a name="9981"/> 9981: 					      uint8(Creation),
<a name="9982"/> 9982: 					      lists:map(fun (N) -&gt;
<a name="9983"/> 9983: 								uint32_be(N)
<a name="9984"/> 9984: 							end,
<a name="9985"/> 9985: 							Numbers)])) of
<a name="9986"/> 9986: 	Ref when is_reference(Ref) -&gt;
<a name="9987"/> 9987: 	    Ref;
<a name="9988"/> 9988: 	{'EXIT', {badarg, _}} -&gt;
<a name="9989"/> 9989: 	    exit({badarg, mk_ref, [{NodeNameExt, Creation}, Numbers]});
<a name="9990"/> 9990: 	Other -&gt;
<a name="9991"/> 9991: 	    exit({unexpected_binary_to_term_result, Other})
<a name="9992"/> 9992:     end.
<a name="9993"/> 9993: 
<a name="9994"/> 9994: 
<a name="make_sub_binary-1"/><a name="9995"/> 9995: <b>make_sub_binary</b>(Bin) when is_binary(Bin) -&gt;
<a name="9996"/> 9996:     {_,B} = split_binary(list_to_binary([0,1,3,Bin]), 3),
<a name="9997"/> 9997:     B;
<a name="9998"/> 9998: <b>make_sub_binary</b>(List) -&gt;
<a name="make_sub_binary-last_expr"/><a name="9999"/> 9999: <b>    make_sub_binary</b>(list_to_binary(List)).
<a name="10000"/>10000: 
<a name="make_unaligned_sub_binary-1"/><a name="10001"/>10001: <b>make_unaligned_sub_binary</b>(Bin0) when is_binary(Bin0) -&gt;
<a name="10002"/>10002:     Bin1 = &lt;&lt;0:3,Bin0/binary,31:5&gt;&gt;,
<a name="10003"/>10003:     Sz = size(Bin0),
<a name="10004"/>10004:     &lt;&lt;0:3,Bin:Sz/binary,31:5&gt;&gt; = id(Bin1),
<a name="10005"/>10005:     Bin;
<a name="10006"/>10006: <b>make_unaligned_sub_binary</b>(List) -&gt;
<a name="make_unaligned_sub_binary-last_expr"/><a name="10007"/>10007: <b>    make_unaligned_sub_binary</b>(list_to_binary(List)).
<a name="10008"/>10008: 
<a name="replace_dbg_hash_fixed_nr_of_locks-1"/><a name="10009"/>10009: <b>replace_dbg_hash_fixed_nr_of_locks</b>(Opts) -&gt;
<a name="replace_dbg_hash_fixed_nr_of_locks-last_expr"/><a name="10010"/>10010:     [case X of
<a name="10011"/>10011:          {write_concurrency, {debug_hash_fixed_number_of_locks, _}} -&gt;
<a name="10012"/>10012:              {write_concurrency, true};
<a name="10013"/>10013:          _ -&gt; X
<a name="10014"/>10014:      end || X &lt;- Opts].
<a name="10015"/>10015: 
<a name="10016"/>10016: <i>%% Repeat test function with different combination of table options</i>
<a name="10017"/>10017: <i>%%</i>
<a name="repeat_for_opts_extra_opt-2"/><a name="10018"/>10018: <b>repeat_for_opts_extra_opt</b>(F, Extra) -&gt;
<a name="repeat_for_opts_extra_opt-last_expr"/><a name="10019"/>10019: <b>    repeat_for_opts</b>(
<a name="10020"/>10020:       fun(Opts) -&gt;
<a name="10021"/>10021:               WithExtra =
<a name="10022"/>10022:                   case erlang:is_list(Extra) of
<a name="10023"/>10023:                       true -&gt; Extra ++ Opts;
<a name="10024"/>10024:                       false -&gt;[Extra | Opts]
<a name="10025"/>10025:                   end,
<a name="10026"/>10026:               case is_invalid_opts_combo(WithExtra) of
<a name="10027"/>10027:                   true -&gt; ok;
<a name="10028"/>10028:                   false -&gt; F(WithExtra)
<a name="10029"/>10029:               end
<a name="10030"/>10030:       end,
<a name="10031"/>10031:       [write_concurrency, read_concurrency, compressed]).
<a name="10032"/>10032: 
<a name="repeat_for_opts-1"/><a name="10033"/>10033: <b>repeat_for_opts</b>(F) -&gt;
<a name="repeat_for_opts-last_expr"/><a name="10034"/>10034: <b>    repeat_for_opts</b>(F, [write_concurrency, read_concurrency, compressed]).
<a name="10035"/>10035: 
<a name="repeat_for_opts_all_table_types-1"/><a name="10036"/>10036: <b>repeat_for_opts_all_table_types</b>(F) -&gt;
<a name="repeat_for_opts_all_table_types-last_expr"/><a name="10037"/>10037: <b>    repeat_for_opts</b>(F, [all_types, write_concurrency, read_concurrency, compressed]).
<a name="10038"/>10038: 
<a name="repeat_for_opts_all_non_stim_table_types-1"/><a name="10039"/>10039: <b>repeat_for_opts_all_non_stim_table_types</b>(F) -&gt;
<a name="repeat_for_opts_all_non_stim_table_types-last_expr"/><a name="10040"/>10040: <b>    repeat_for_opts</b>(F, [all_non_stim_types, write_concurrency, read_concurrency, compressed]).
<a name="10041"/>10041: 
<a name="repeat_for_opts_all_set_table_types-1"/><a name="10042"/>10042: <b>repeat_for_opts_all_set_table_types</b>(F) -&gt;
<a name="repeat_for_opts_all_set_table_types-last_expr"/><a name="10043"/>10043: <b>    repeat_for_opts</b>(F, [set_types, write_concurrency, read_concurrency, compressed]).
<a name="10044"/>10044: 
<a name="repeat_for_all_set_table_types-1"/><a name="10045"/>10045: <b>repeat_for_all_set_table_types</b>(F) -&gt;
<a name="repeat_for_all_set_table_types-last_expr"/><a name="10046"/>10046: <b>    repeat_for_opts</b>(F, [set_types]).
<a name="10047"/>10047: 
<a name="repeat_for_all_ord_set_table_types-1"/><a name="10048"/>10048: <b>repeat_for_all_ord_set_table_types</b>(F) -&gt;
<a name="repeat_for_all_ord_set_table_types-last_expr"/><a name="10049"/>10049: <b>    repeat_for_opts</b>(F, [ord_set_types]).
<a name="10050"/>10050: 
<a name="repeat_for_all_non_stim_set_table_types-1"/><a name="10051"/>10051: <b>repeat_for_all_non_stim_set_table_types</b>(F) -&gt;
<a name="repeat_for_all_non_stim_set_table_types-last_expr"/><a name="10052"/>10052: <b>    repeat_for_opts</b>(F, [all_non_stim_set_types]).
<a name="10053"/>10053: 
<a name="repeat_for_opts_all_ord_set_table_types-1"/><a name="10054"/>10054: <b>repeat_for_opts_all_ord_set_table_types</b>(F) -&gt;
<a name="repeat_for_opts_all_ord_set_table_types-last_expr"/><a name="10055"/>10055: <b>    repeat_for_opts</b>(F, [ord_set_types, write_concurrency, read_concurrency, compressed]).
<a name="10056"/>10056: 
<a name="repeat_for_opts-2"/><a name="10057"/>10057: <b>repeat_for_opts</b>(F, OptGenList) when is_function(F, 1) -&gt;
<a name="repeat_for_opts-last_expr"/><a name="10058"/>10058: <b>    repeat_for_opts</b>(F, OptGenList, []).
<a name="10059"/>10059: 
<a name="repeat_for_opts-3"/><a name="10060"/>10060: <b>repeat_for_opts</b>(F, [], Acc) -&gt;
<a name="10061"/>10061:     lists:foldl(fun(Opts, RV_Acc) -&gt;
<a name="10062"/>10062: 			OptList = lists:filter(fun(E) -&gt; E =/= void end, Opts),
<a name="10063"/>10063:                         case is_redundant_opts_combo(OptList) of
<a name="10064"/>10064:                             true -&gt;
<a name="10065"/>10065:                                 %%io:format(&quot;Ignoring redundant options ~p\n&quot;,[OptList]),
<a name="10066"/>10066:                                 ok;
<a name="10067"/>10067:                             false -&gt;
<a name="10068"/>10068:                                 io:format(&quot;Calling with options ~p\n&quot;,[OptList]),
<a name="10069"/>10069:                                 RV = F(OptList),
<a name="10070"/>10070:                                 case RV_Acc of
<a name="10071"/>10071:                                     {comment,_} -&gt; RV_Acc;
<a name="10072"/>10072:                                     _ -&gt; case RV of
<a name="10073"/>10073:                                              {comment,_} -&gt; RV;
<a name="10074"/>10074:                                              _ -&gt; [RV | RV_Acc]
<a name="10075"/>10075:                                          end
<a name="10076"/>10076:                                 end
<a name="10077"/>10077:                         end
<a name="10078"/>10078:                 end, [], Acc);
<a name="10079"/>10079: <b>repeat_for_opts</b>(F, [OptList | Tail], []) when is_list(OptList) -&gt;
<a name="10080"/>10080:     repeat_for_opts(F, Tail, [[Opt] || Opt &lt;- OptList]);
<a name="10081"/>10081: <b>repeat_for_opts</b>(F, [OptList | Tail], AccList) when is_list(OptList) -&gt;
<a name="10082"/>10082:     repeat_for_opts(F, Tail, [[Opt|Acc] || Opt &lt;- OptList, Acc &lt;- AccList]);
<a name="10083"/>10083: <b>repeat_for_opts</b>(F, [Atom | Tail], AccList) when is_atom(Atom) -&gt;
<a name="repeat_for_opts-last_expr"/><a name="10084"/>10084: <b>    repeat_for_opts</b>(F, [repeat_for_opts_atom2list(Atom) | Tail ], AccList).
<a name="10085"/>10085: 
<a name="repeat_for_opts_atom2list-1"/><a name="10086"/>10086: <b>repeat_for_opts_atom2list</b>(set_types) -&gt; [set,ordered_set,stim_cat_ord_set,cat_ord_set];
<a name="10087"/>10087: <b>repeat_for_opts_atom2list</b>(hash_types) -&gt; [set,bag,duplicate_bag];
<a name="10088"/>10088: <b>repeat_for_opts_atom2list</b>(ord_set_types) -&gt; [ordered_set,stim_cat_ord_set,cat_ord_set];
<a name="10089"/>10089: <b>repeat_for_opts_atom2list</b>(all_types) -&gt; [set,ordered_set,stim_cat_ord_set,cat_ord_set,bag,duplicate_bag];
<a name="10090"/>10090: <b>repeat_for_opts_atom2list</b>(all_non_stim_types) -&gt; [set,ordered_set,cat_ord_set,bag,duplicate_bag];
<a name="10091"/>10091: <b>repeat_for_opts_atom2list</b>(all_non_stim_set_types) -&gt; [set,ordered_set,cat_ord_set];
<a name="10092"/>10092: <b>repeat_for_opts_atom2list</b>(write_concurrency) -&gt; [{write_concurrency,false},
<a name="10093"/>10093:                                                  {write_concurrency,true},
<a name="10094"/>10094:                                                  {write_concurrency, {debug_hash_fixed_number_of_locks, 2048}},
<a name="10095"/>10095:                                                  {write_concurrency,auto}];
<a name="10096"/>10096: <b>repeat_for_opts_atom2list</b>(read_concurrency) -&gt; [{read_concurrency,false},{read_concurrency,true}];
<a name="repeat_for_opts_atom2list-last_expr"/><a name="10097"/>10097: <b>repeat_for_opts_atom2list</b>(compressed) -&gt; [void,compressed].
<a name="10098"/>10098: 
<a name="has_fixed_number_of_locks-1"/><a name="10099"/>10099: <b>has_fixed_number_of_locks</b>(Opts) -&gt;
<a name="has_fixed_number_of_locks-last_expr"/><a name="10100"/>10100: <b>    lists:any</b>(
<a name="10101"/>10101:       fun({write_concurrency, {debug_hash_fixed_number_of_locks, _}}) -&gt;
<a name="10102"/>10102:               true;
<a name="10103"/>10103:          (_) -&gt;
<a name="10104"/>10104:               false
<a name="10105"/>10105:       end,
<a name="10106"/>10106:       Opts).
<a name="10107"/>10107: 
<a name="is_invalid_opts_combo-1"/><a name="10108"/>10108: <b>is_invalid_opts_combo</b>(Opts) -&gt;
<a name="10109"/>10109:     OrderedSet = lists:member(ordered_set, Opts) orelse
<a name="10110"/>10110:                  lists:member(stim_cat_ord_set, Opts) orelse
<a name="10111"/>10111:                  lists:member(cat_ord_set, Opts),
<a name="is_invalid_opts_combo-last_expr"/><a name="10112"/>10112: <b>    OrderedSet andalso has_fixed_number_of_locks</b>(Opts).
<a name="10113"/>10113: 
<a name="run_if_valid_opts-2"/><a name="10114"/>10114: <b>run_if_valid_opts</b>(Opts, F) -&gt;
<a name="run_if_valid_opts-last_expr"/><a name="10115"/>10115: <b>    case is_invalid_opts_combo</b>(Opts) of
<a name="10116"/>10116:         true -&gt; ignore;
<a name="10117"/>10117:         false -&gt; F(Opts)
<a name="10118"/>10118:     end.
<a name="10119"/>10119: 
<a name="is_redundant_opts_combo-1"/><a name="10120"/>10120: <b>is_redundant_opts_combo</b>(Opts) -&gt;
<a name="10121"/>10121:     IsRed1 =
<a name="10122"/>10122:         ((lists:member(stim_cat_ord_set, Opts) orelse
<a name="10123"/>10123:           lists:member(cat_ord_set, Opts))
<a name="10124"/>10124:          andalso
<a name="10125"/>10125:            (lists:member({write_concurrency, false}, Opts) orelse
<a name="10126"/>10126:             lists:member(private, Opts) orelse
<a name="10127"/>10127:             lists:member(protected, Opts))),
<a name="10128"/>10128:     IsRed2 = is_invalid_opts_combo(Opts),
<a name="is_redundant_opts_combo-last_expr"/><a name="10129"/>10129:     IsRed1 orelse IsRed2.
<a name="10130"/>10130: 
<a name="10131"/>10131: <i>%% Add fake table option with info about key range.</i>
<a name="10132"/>10132: <i>%% Will be consumed by ets_new and used for stim_cat_ord_set.</i>
<a name="key_range-2"/><a name="10133"/>10133: <b>key_range</b>(Opts, KeyRange) -&gt;
<a name="key_range-last_expr"/><a name="10134"/>10134:     [{key_range, KeyRange} | Opts].
<a name="10135"/>10135: 
<a name="ets_new-2"/><a name="10136"/>10136: <b>ets_new</b>(Name, Opts0) -&gt;
<a name="10137"/>10137:     {KeyRange, Opts1} = case lists:keytake(key_range, 1, Opts0) of
<a name="10138"/>10138:                             {value, {key_range, KR}, Rest1} -&gt;
<a name="10139"/>10139:                                 {KR, Rest1};
<a name="10140"/>10140:                             false -&gt;
<a name="10141"/>10141:                                 {1000*1000, Opts0}
<a name="10142"/>10142:                         end,
<a name="ets_new-last_expr"/><a name="10143"/>10143: <b>    ets_new</b>(Name, Opts1, KeyRange).
<a name="10144"/>10144: 
<a name="ets_new-3"/><a name="10145"/>10145: <b>ets_new</b>(Name, Opts, KeyRange) -&gt;
<a name="ets_new-last_expr"/><a name="10146"/>10146: <b>    ets_new</b>(Name, Opts, KeyRange, fun id/1).
<a name="10147"/>10147: 
<a name="ets_new-4"/><a name="10148"/>10148: <b>ets_new</b>(Name, Opts0, KeyRange, KeyFun) -&gt;
<a name="10149"/>10149:     {_Smp, CATree, Stimulate, RevOpts} =
<a name="10150"/>10150:         lists:foldl(fun(cat_ord_set, {Smp, false, false, Lacc}) -&gt;
<a name="10151"/>10151:                             {Smp, Smp, false, [ordered_set | Lacc]};
<a name="10152"/>10152:                        (stim_cat_ord_set, {Smp, false, false, Lacc}) -&gt;
<a name="10153"/>10153:                             {Smp, Smp, Smp, [ordered_set | Lacc]};
<a name="10154"/>10154:                        (Other, {Smp, CAT, STIM, Lacc}) -&gt;
<a name="10155"/>10155:                             {Smp, CAT, STIM, [Other | Lacc]}
<a name="10156"/>10156:                     end,
<a name="10157"/>10157:                     {erlang:system_info(schedulers) &gt; 1,false, false, []},
<a name="10158"/>10158:                     Opts0),
<a name="10159"/>10159:     Opts = lists:reverse(RevOpts),
<a name="10160"/>10160:     EtsNewHelper =
<a name="10161"/>10161:         fun (UseOpts) -&gt;
<a name="10162"/>10162:                 case get(ets_new_opts) of
<a name="10163"/>10163:                     UseOpts -&gt;
<a name="10164"/>10164:                         silence; %% suppress identical table opts spam
<a name="10165"/>10165:                     _ -&gt;
<a name="10166"/>10166:                         put(ets_new_opts, UseOpts),
<a name="10167"/>10167:                         io:format(&quot;ets:new(~p, ~p)~n&quot;, [Name, UseOpts])
<a name="10168"/>10168:                 end,
<a name="10169"/>10169:                 ets:new(Name, UseOpts)
<a name="10170"/>10170:         end,
<a name="ets_new-last_expr"/><a name="10171"/>10171:     case CATree andalso
<a name="10172"/>10172:         (not lists:member({write_concurrency, false}, Opts)) andalso
<a name="10173"/>10173:         (not lists:member(private, Opts)) andalso
<a name="10174"/>10174:         (not lists:member(protected, Opts)) of
<a name="10175"/>10175:         true -&gt;
<a name="10176"/>10176:             NewOpts1 =
<a name="10177"/>10177:                 case lists:member({write_concurrency, true}, Opts) of
<a name="10178"/>10178:                     true -&gt; Opts;
<a name="10179"/>10179:                     false -&gt; [{write_concurrency, true}|Opts]
<a name="10180"/>10180:                 end,
<a name="10181"/>10181:             NewOpts2 =
<a name="10182"/>10182:                 case lists:member(public, NewOpts1) of
<a name="10183"/>10183:                     true -&gt; NewOpts1;
<a name="10184"/>10184:                     false -&gt; [public|NewOpts1]
<a name="10185"/>10185:                 end,
<a name="10186"/>10186:             T = EtsNewHelper(NewOpts2),
<a name="10187"/>10187:             case Stimulate of
<a name="10188"/>10188:                 false -&gt; ok;
<a name="10189"/>10189:                 true -&gt; stimulate_contention(T, KeyRange, KeyFun)
<a name="10190"/>10190:             end,
<a name="10191"/>10191:             T;
<a name="10192"/>10192:         false -&gt;
<a name="10193"/>10193:             EtsNewHelper(Opts)
<a name="10194"/>10194:     end.
<a name="10195"/>10195: 
<a name="10196"/>10196: <i>% The purpose of this function is to stimulate fine grained locking in</i>
<a name="10197"/>10197: <i>% tables of types ordered_set with the write_concurrency options</i>
<a name="10198"/>10198: <i>% turned on. The erts_debug feature 'ets_force_split' is used to easier</i>
<a name="10199"/>10199: <i>% generate a routing tree with fine grained locking without having to</i>
<a name="10200"/>10200: <i>% provoke lots of actual lock contentions.</i>
<a name="stimulate_contention-3"/><a name="10201"/>10201: <b>stimulate_contention</b>(Tid, KeyRange, KeyFun) -&gt;
<a name="10202"/>10202:     T = case Tid of
<a name="10203"/>10203:             A when is_atom(A) -&gt; ets:whereis(A);
<a name="10204"/>10204:             _ -&gt; Tid
<a name="10205"/>10205:         end,
<a name="10206"/>10206:     erts_debug:set_internal_state(ets_force_split, {T, true}),
<a name="10207"/>10207:     Num = case KeyRange &gt; 50 of
<a name="10208"/>10208:               true -&gt; 50;
<a name="10209"/>10209:               false -&gt; KeyRange
<a name="10210"/>10210:           end,
<a name="10211"/>10211:     Seed = rand:uniform(KeyRange),
<a name="10212"/>10212:     %%io:format(&quot;prefill_table: Seed = ~p\n&quot;, [Seed]),
<a name="10213"/>10213:     RState = unique_rand_start(KeyRange, Seed),
<a name="10214"/>10214:     stim_inserter_loop(T, RState, Num, KeyFun),
<a name="10215"/>10215:     Num = ets:info(T, size),
<a name="10216"/>10216:     ets:match_delete(T, {'$1','$1','$1'}),
<a name="10217"/>10217:     0 = ets:info(T, size),
<a name="10218"/>10218:     erts_debug:set_internal_state(ets_force_split, {T, false}),
<a name="stimulate_contention-last_expr"/><a name="10219"/>10219: <b>    case ets:info</b>(T,stats) of
<a name="10220"/>10220:         {0, _, _} -&gt;
<a name="10221"/>10221:             io:format(&quot;No routing nodes in table?\n&quot;
<a name="10222"/>10222:                       &quot;Debug feature 'ets_force_split' does not seem to work.\n&quot;, []),
<a name="10223"/>10223:             ct:fail(&quot;No ets_force_split?&quot;);
<a name="10224"/>10224:         Stats -&gt;
<a name="10225"/>10225:             io:format(&quot;stimulated ordered_set: ~p\n&quot;, [Stats])
<a name="10226"/>10226:     end.
<a name="10227"/>10227: 
<a name="stim_inserter_loop-4"/><a name="10228"/>10228: <b>stim_inserter_loop</b>(_, _, 0, _) -&gt;
<a name="10229"/>10229:     ok;
<a name="10230"/>10230: <b>stim_inserter_loop</b>(T, RS0, N, KeyFun) -&gt;
<a name="10231"/>10231:     {K, RS1} = unique_rand_next(RS0),
<a name="10232"/>10232:     Key = KeyFun(K),
<a name="10233"/>10233:     ets:insert(T, {Key, Key, Key}),
<a name="stim_inserter_loop-last_expr"/><a name="10234"/>10234: <b>    stim_inserter_loop</b>(T, RS1, N-1, KeyFun).
<a name="10235"/>10235: 
<a name="do_tc-2"/><a name="10236"/>10236: <b>do_tc</b>(Do, Report) -&gt;
<a name="10237"/>10237:     T1 = erlang:monotonic_time(),
<a name="10238"/>10238:     Do(),
<a name="10239"/>10239:     T2 = erlang:monotonic_time(),
<a name="10240"/>10240:     Elapsed = erlang:convert_time_unit(T2 - T1, native, millisecond),
<a name="do_tc-last_expr"/><a name="10241"/>10241: <b>    Report</b>(Elapsed).
<a name="10242"/>10242: 
<a name="syrup_factor-0"/><a name="10243"/>10243: <b>syrup_factor</b>() -&gt;
<a name="syrup_factor-last_expr"/><a name="10244"/>10244: <b>    case erlang:system_info</b>(build_type) of
<a name="10245"/>10245:         valgrind -&gt; 20;
<a name="10246"/>10246:         _ -&gt; 1
<a name="10247"/>10247:     end.
<a name="10248"/>10248: 
<a name="10249"/>10249: 
<a name="10250"/>10250: <i>%%</i>
<a name="10251"/>10251: <i>%% This is a pseudo random number generator for UNIQUE integers.</i>
<a name="10252"/>10252: <i>%% All integers between 1 and Max will be generated before it repeat itself.</i>
<a name="10253"/>10253: <i>%% It's a variant of this one using quadratic residues by Jeff Preshing:</i>
<a name="10254"/>10254: <i>%% http://preshing.com/20121224/how-to-generate-a-sequence-of-unique-random-integers/</i>
<a name="10255"/>10255: <i>%%</i>
<a name="unique_rand_start-2"/><a name="10256"/>10256: <b>unique_rand_start</b>(Max, Seed) -&gt;
<a name="10257"/>10257:     L = lists:dropwhile(fun(P) -&gt; P &lt; Max end,
<a name="10258"/>10258:                         primes_3mod4()),
<a name="10259"/>10259:     [P | _] = case L of
<a name="10260"/>10260:                       [] -&gt;
<a name="10261"/>10261:                           error(&quot;Random range too large&quot;);
<a name="10262"/>10262:                       _ -&gt;
<a name="10263"/>10263:                           L
<a name="10264"/>10264:                   end,
<a name="10265"/>10265:     3 = P rem 4,
<a name="unique_rand_start-last_expr"/><a name="10266"/>10266:     {0, {Max, P, Seed}}.
<a name="10267"/>10267: 
<a name="unique_rand_next-1"/><a name="10268"/>10268: <b>unique_rand_next</b>({N, {Max, P, Seed}=Const}) -&gt;
<a name="unique_rand_next-last_expr"/><a name="10269"/>10269: <b>    case dquad</b>(P, N, Seed) + 1 of
<a name="10270"/>10270:         RND when RND &gt; Max -&gt;  % Too large, skip
<a name="10271"/>10271:             unique_rand_next({N+1, Const});
<a name="10272"/>10272:         RND -&gt;
<a name="10273"/>10273:             {RND, {N+1, Const}}
<a name="10274"/>10274:     end.
<a name="10275"/>10275: 
<a name="10276"/>10276: <i>%% A one-to-one relation between all integers 0 =&lt; X &lt; Prime</i>
<a name="10277"/>10277: <i>%% if Prime rem 4 == 3.</i>
<a name="quad-2"/><a name="10278"/>10278: <b>quad</b>(Prime, X) -&gt;
<a name="10279"/>10279:     Rem = X*X rem Prime,
<a name="quad-last_expr"/><a name="10280"/>10280:     case 2*X &lt; Prime of
<a name="10281"/>10281:         true -&gt;
<a name="10282"/>10282:             Rem;
<a name="10283"/>10283:         false -&gt;
<a name="10284"/>10284:             Prime - Rem
<a name="10285"/>10285:     end.
<a name="10286"/>10286: 
<a name="dquad-3"/><a name="10287"/>10287: <b>dquad</b>(Prime, X, Seed) -&gt;
<a name="dquad-last_expr"/><a name="10288"/>10288: <b>    quad</b>(Prime, (quad(Prime, X) + Seed) rem Prime).
<a name="10289"/>10289: 
<a name="10290"/>10290: <i>%% Primes where P rem 4 == 3.</i>
<a name="primes_3mod4-0"/><a name="10291"/>10291: <b>primes_3mod4</b>() -&gt;
<a name="primes_3mod4-last_expr"/><a name="10292"/>10292:     [103, 211, 503, 1019, 2003, 5003, 10007, 20011, 50023,
<a name="10293"/>10293:      100003, 200003, 500083, 1000003, 2000003, 5000011,
<a name="10294"/>10294:      10000019, 20000003, 50000047, 100000007].
</pre>
<script>
var hash = window.location.hash.substring(1);
var anchor = document.getElementsByName(hash);
anchor[0].style.backgroundColor="orange";
</script>
</body>
</html>
