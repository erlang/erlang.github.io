<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/lib/erl_interface/make_test_dir/erl_interface_test/ei_accept_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%</i>
<a name="2"/>    2: <i>%% %CopyrightBegin%</i>
<a name="3"/>    3: <i>%% </i>
<a name="4"/>    4: <i>%% Copyright Ericsson AB 2001-2023. All Rights Reserved.</i>
<a name="5"/>    5: <i>%% </i>
<a name="6"/>    6: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="7"/>    7: <i>%% you may not use this file except in compliance with the License.</i>
<a name="8"/>    8: <i>%% You may obtain a copy of the License at</i>
<a name="9"/>    9: <i>%%</i>
<a name="10"/>   10: <i>%%     http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="11"/>   11: <i>%%</i>
<a name="12"/>   12: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="13"/>   13: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="14"/>   14: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="15"/>   15: <i>%% See the License for the specific language governing permissions and</i>
<a name="16"/>   16: <i>%% limitations under the License.</i>
<a name="17"/>   17: <i>%% </i>
<a name="18"/>   18: <i>%% %CopyrightEnd%</i>
<a name="19"/>   19: <i>%%</i>
<a name="20"/>   20: 
<a name="21"/>   21: <i>%%</i>
<a name="22"/>   22: <b>-module</b>(ei_accept_SUITE).
<a name="23"/>   23: 
<a name="24"/>   24: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="25"/>   25: <b>-include</b>(&quot;ei_accept_SUITE_data/ei_accept_test_cases.hrl&quot;).
<a name="26"/>   26: 
<a name="27"/>   27: <b>-export</b>([all/0, suite/0,
<a name="28"/>   28:          init_per_suite/1,
<a name="29"/>   29:          end_per_suite/1,
<a name="30"/>   30:          init_per_testcase/2,
<a name="31"/>   31:          ei_accept/1,
<a name="32"/>   32:          hopeful_random/1,
<a name="33"/>   33:          ei_threaded_accept/1,
<a name="34"/>   34:          monitor_ei_process/1]).
<a name="35"/>   35: 
<a name="36"/>   36: <i>%% Internals</i>
<a name="37"/>   37: <b>-export</b>([id/1]).
<a name="38"/>   38: 
<a name="39"/>   39: <b>-import</b>(runner, [get_term/1,send_term/2]).
<a name="40"/>   40: 
<a name="41"/>   41: 
<a name="42"/>   42: <b>-define</b>(ERL_ONHEAP_BIN_LIMIT, 64).
<a name="43"/>   43: 
<a name="suite-0"/><a name="44"/>   44: <b>suite</b>() -&gt;
<a name="suite-last_expr"/><a name="45"/>   45:     [{ct_hooks,[ts_install_cth]},
<a name="46"/>   46:      {timetrap, {seconds, 30}}].
<a name="47"/>   47: 
<a name="all-0"/><a name="48"/>   48: <b>all</b>() -&gt; 
<a name="all-last_expr"/><a name="49"/>   49:     [ei_accept,
<a name="50"/>   50:      hopeful_random,
<a name="51"/>   51:      ei_threaded_accept,
<a name="52"/>   52:      monitor_ei_process].
<a name="53"/>   53: 
<a name="init_per_suite-1"/><a name="54"/>   54: <b>init_per_suite</b>(Config) when is_list(Config) -&gt;
<a name="55"/>   55: 
<a name="56"/>   56:     %% Trigger usage of large pids and ports in 64-bit case...
<a name="57"/>   57:     case erlang:system_info(wordsize) of
<a name="58"/>   58:         4 -&gt;
<a name="59"/>   59:             ok;
<a name="60"/>   60:         8 -&gt;
<a name="61"/>   61:             erts_debug:set_internal_state(available_internal_state,true),
<a name="62"/>   62:             erts_debug:set_internal_state(next_pid, 1 bsl 32),
<a name="63"/>   63:             erts_debug:set_internal_state(next_port, 1 bsl 32),
<a name="64"/>   64:             erts_debug:set_internal_state(available_internal_state,false),
<a name="65"/>   65:             ok
<a name="66"/>   66:     end,
<a name="67"/>   67: 
<a name="init_per_suite-last_expr"/><a name="68"/>   68:     Config.
<a name="69"/>   69: 
<a name="end_per_suite-1"/><a name="70"/>   70: <b>end_per_suite</b>(Config) when is_list(Config) -&gt;
<a name="end_per_suite-last_expr"/><a name="71"/>   71:     Config.
<a name="72"/>   72: 
<a name="init_per_testcase-2"/><a name="73"/>   73: <b>init_per_testcase</b>(Case, Config) -&gt;
<a name="74"/>   74:     rand:uniform(), % Make sure rand is initialized and seeded.
<a name="75"/>   75:     %%rand:seed({exsss, [61781477086241372|88832360391433009]}),
<a name="76"/>   76:     io:format(&quot;** rand seed = ~p\n&quot;, [rand:export_seed()]),
<a name="init_per_testcase-last_expr"/><a name="77"/>   77: <b>    runner:init_per_testcase</b>(?MODULE, Case, Config).
<a name="78"/>   78: 
<a name="ei_accept-1"/><a name="79"/>   79: <b>ei_accept</b>(Config) when is_list(Config) -&gt;
<a name="80"/>   80:     _ = [ei_accept_do(Config, SI) || SI &lt;- [default, ussi]],
<a name="ei_accept-last_expr"/><a name="81"/>   81:     ok.
<a name="82"/>   82: 
<a name="ei_accept_do-2"/><a name="83"/>   83: <b>ei_accept_do</b>(Config, SockImpl) -&gt;
<a name="84"/>   84:     io:format(&quot;SockImpl=~p\n&quot;, [SockImpl]),
<a name="85"/>   85:     P = runner:start(Config, ?interpret),
<a name="86"/>   86:     0 = ei_connect_init(P, 42, erlang:get_cookie(), 0, 0, SockImpl),
<a name="87"/>   87: 
<a name="88"/>   88:     Myname = hd(tl(string:tokens(atom_to_list(node()), &quot;@&quot;))),
<a name="89"/>   89:     io:format(&quot;Myname ~p ~n&quot;,  [Myname]),
<a name="90"/>   90:     EINode = list_to_atom(&quot;c42@&quot;++Myname),
<a name="91"/>   91:     io:format(&quot;EINode ~p ~n&quot;,  [EINode]),
<a name="92"/>   92: 
<a name="93"/>   93:     %% We take this opportunity to also test export-funs and bit-strings.
<a name="94"/>   94:     %% Test both toward pending connection and established connection.
<a name="95"/>   95:     %% OTP-25: This is a bit obsolete now as we no longer support
<a name="96"/>   96:     %%         tuple fallbacks for export-funs and bit-strings.
<a name="97"/>   97:     RealTerms =
<a name="98"/>   98:         [&lt;&lt;1:1&gt;&gt;,
<a name="99"/>   99:          fun lists:map/2,
<a name="100"/>  100:          fun_with_env(&lt;&lt;1:1&gt;&gt;),
<a name="101"/>  101:          fun_with_env(fun lists:map/2)],
<a name="102"/>  102: 
<a name="103"/>  103:     Self = self(),
<a name="104"/>  104:     Funny = fun() -&gt; hello end,
<a name="105"/>  105:     Terms = {call, Self, &quot;Test&quot;, Funny, RealTerms},
<a name="106"/>  106:     Port = 6543,
<a name="107"/>  107:     {ok, ListenFd} = ei_publish(P, Port),
<a name="108"/>  108:     {any, EINode} ! Terms,
<a name="109"/>  109: 
<a name="110"/>  110:     {ok, Fd, Node} = ei_accept(P, ListenFd),
<a name="111"/>  111:     Node = node(),
<a name="112"/>  112:     Got1 = ei_receive(P, Fd),
<a name="113"/>  113: 
<a name="114"/>  114:     %% Send again, now without auto-connect
<a name="115"/>  115:     {any, EINode} ! Terms,
<a name="116"/>  116:     Got2 = ei_receive(P, Fd),
<a name="117"/>  117: 
<a name="118"/>  118:     io:format(&quot;Sent ~p~nExp. ~p~nGot1 ~p~nGot2 ~p~n&quot;, [Terms, Terms, Got1, Got2]),
<a name="119"/>  119:     Terms = Got1,
<a name="120"/>  120:     Terms = Got2,
<a name="121"/>  121: 
<a name="122"/>  122:     runner:finish(P),
<a name="ei_accept_do-last_expr"/><a name="123"/>  123:     ok.
<a name="124"/>  124: 
<a name="fun_with_env-1"/><a name="125"/>  125: <b>fun_with_env</b>(Term) -&gt;
<a name="126"/>  126:     Env = ?MODULE:id(Term),
<a name="fun_with_env-last_expr"/><a name="127"/>  127: <b>    fun</b>() -&gt; Env end.
<a name="128"/>  128: 
<a name="id-1"/><a name="id-last_expr"/><a name="129"/>  129: <b>id</b>(X) -&gt; X.
<a name="130"/>  130: 
<a name="131"/>  131: 
<a name="132"/>  132: <i>%% Send random encoded terms from emulator to c-node</i>
<a name="133"/>  133: <i>%% and verify correct encoding.</i>
<a name="hopeful_random-1"/><a name="134"/>  134: <b>hopeful_random</b>(Config) when is_list(Config) -&gt;
<a name="135"/>  135:     [hopeful_random_do(Config, SI)
<a name="136"/>  136:      || SI &lt;- [default, ussi]],
<a name="hopeful_random-last_expr"/><a name="137"/>  137:     ok.
<a name="138"/>  138: 
<a name="139"/>  139: 
<a name="hopeful_random_do-2"/><a name="140"/>  140: <b>hopeful_random_do</b>(Config, SockImpl) -&gt;
<a name="141"/>  141:     io:format(&quot;SockImpl=~p\n&quot;, [SockImpl]),
<a name="142"/>  142:     P = runner:start(Config, ?interpret),
<a name="143"/>  143:     0 = ei_connect_init(P, 42, erlang:get_cookie(), 0, 0, SockImpl),
<a name="144"/>  144: 
<a name="145"/>  145:     Myname = hd(tl(string:tokens(atom_to_list(node()), &quot;@&quot;))),
<a name="146"/>  146:     io:format(&quot;Myname ~p ~n&quot;,  [Myname]),
<a name="147"/>  147:     EINode = list_to_atom(&quot;c42@&quot;++Myname),
<a name="148"/>  148:     io:format(&quot;EINode ~p ~n&quot;,  [EINode]),
<a name="149"/>  149: 
<a name="150"/>  150:     Port = 6543,
<a name="151"/>  151:     {ok, ListenFd} = ei_publish(P, Port),
<a name="152"/>  152: 
<a name="153"/>  153:     Terms = [random_term(20) || _ &lt;- lists:seq(1,10)],
<a name="154"/>  154: 
<a name="155"/>  155:     %% lists:foldl(fun(T,N) -&gt;
<a name="156"/>  156:     %%                     io:format(&quot;Term #~p = ~p\n&quot;, [N, printable(T)]),
<a name="157"/>  157:     %%                     N+1
<a name="158"/>  158:     %%             end,
<a name="159"/>  159:     %%             1,
<a name="160"/>  160:     %%             Terms),
<a name="161"/>  161: 
<a name="162"/>  162:     %% Send on pending connection (hopeful encoding)
<a name="163"/>  163:     [{any, EINode} ! T || T &lt;- Terms],
<a name="164"/>  164:     {ok, Fd, Node} = ei_accept(P, ListenFd),
<a name="165"/>  165:     Node = node(),
<a name="166"/>  166:     [match(T, ei_receive(P, Fd)) || T &lt;- Terms],
<a name="167"/>  167: 
<a name="168"/>  168:     %% Send again on established connection
<a name="169"/>  169:     [{any, EINode} ! T || T &lt;- Terms],
<a name="170"/>  170:     [match(T, ei_receive(P, Fd)) || T &lt;- Terms],
<a name="171"/>  171: 
<a name="172"/>  172:     runner:finish(P),
<a name="hopeful_random_do-last_expr"/><a name="173"/>  173:     ok.
<a name="174"/>  174: 
<a name="175"/>  175: 
<a name="match-2"/><a name="176"/>  176: <b>match</b>(A, A) -&gt; ok;
<a name="177"/>  177: <b>match</b>(A, B) -&gt;
<a name="178"/>  178:     io:format(&quot;match failed\nA = ~p\nB = ~p\n&quot;, [printable(A), printable(B)]),
<a name="match-last_expr"/><a name="179"/>  179: <b>    ct:fail</b>(&quot;match failed&quot;).
<a name="180"/>  180: 
<a name="random_term-1"/><a name="181"/>  181: <b>random_term</b>(MaxSize) -&gt;
<a name="random_term-last_expr"/><a name="182"/>  182: <b>    rand_term</b>(rand:uniform(MaxSize)).
<a name="183"/>  183: 
<a name="rand_term-1"/><a name="184"/>  184: <b>rand_term</b>(Arity) when Arity &gt; 0 -&gt;
<a name="185"/>  185:     List = rand_list(Arity, []),
<a name="186"/>  186:     case rand:uniform(6) of
<a name="187"/>  187:         1 -&gt; List;
<a name="188"/>  188:         2 -&gt; list_to_improper_list(List);
<a name="189"/>  189:         3 -&gt; list_to_tuple(List);
<a name="190"/>  190:         4 -&gt; list_to_flatmap(List);
<a name="191"/>  191:         5 -&gt; list_to_hashmap(List);
<a name="192"/>  192:         6 -&gt; list_to_fun(List)
<a name="193"/>  193:     end;
<a name="194"/>  194: <b>rand_term</b>(0) -&gt;
<a name="rand_term-last_expr"/><a name="195"/>  195: <b>    rand_leaf</b>().
<a name="196"/>  196: 
<a name="rand_list-2"/><a name="197"/>  197: <b>rand_list</b>(0, Acc) -&gt;
<a name="198"/>  198:     %% Shuffle result list to not favor tail heavy lists.
<a name="199"/>  199:     {_, MixedList} = lists:unzip(lists:sort(Acc)),
<a name="200"/>  200:     MixedList;
<a name="201"/>  201: <b>rand_list</b>(Budget, Acc) -&gt;
<a name="202"/>  202:     Depth = rand:uniform(Budget),
<a name="203"/>  203:     SortIx = rand:uniform(1 bsl 26),
<a name="rand_list-last_expr"/><a name="204"/>  204: <b>    rand_list</b>(Budget-Depth, [{SortIx, rand_term(Depth-1)} | Acc]).
<a name="205"/>  205: 
<a name="rand_leaf-0"/><a name="206"/>  206: <b>rand_leaf</b>() -&gt;
<a name="rand_leaf-last_expr"/><a name="207"/>  207: <b>    case rand:uniform</b>(19) of
<a name="208"/>  208:         1 -&gt; rand_integer();
<a name="209"/>  209:         2 -&gt; rand_float();
<a name="210"/>  210:         3 -&gt; rand_heapbin();
<a name="211"/>  211:         4 -&gt; rand_procbin();
<a name="212"/>  212:         5 -&gt; rand_subbin(rand_heapbin());
<a name="213"/>  213:         6 -&gt; rand_subbin(rand_procbin());
<a name="214"/>  214:         7 -&gt; atom;
<a name="215"/>  215:         8 -&gt; [];
<a name="216"/>  216:         9 -&gt; {};
<a name="217"/>  217:         10 -&gt; #{};
<a name="218"/>  218:         11 -&gt; fun lists:sort/1;
<a name="219"/>  219:         12 -&gt; fun() -&gt; ok end;
<a name="220"/>  220:         13 -&gt; self();
<a name="221"/>  221:         14 -&gt; lists:last(erlang:ports());
<a name="222"/>  222:         15 -&gt; make_ref();
<a name="223"/>  223:         16 -&gt; atomics:new(10,[]); % Magic ref
<a name="224"/>  224:         17 -&gt; mk_ext_pid({a@b, 17}, 17, 42);
<a name="225"/>  225:         18 -&gt; mk_ext_port({a@b, 21}, 13);
<a name="226"/>  226:         19 -&gt; mk_ext_ref({a@b, 42}, [42, 19, 11])
<a name="227"/>  227:     end.
<a name="228"/>  228: 
<a name="rand_integer-0"/><a name="229"/>  229: <b>rand_integer</b>() -&gt;
<a name="230"/>  230:     Bits = rand:uniform(150),
<a name="231"/>  231:     Uint = rand:uniform(1 bsl Bits),
<a name="rand_integer-last_expr"/><a name="232"/>  232: <b>    case rand:uniform</b>(2) of
<a name="233"/>  233:         1 -&gt; Uint;
<a name="234"/>  234:         2 -&gt; -Uint
<a name="235"/>  235:     end.
<a name="236"/>  236: 
<a name="rand_float-0"/><a name="237"/>  237: <b>rand_float</b>() -&gt;
<a name="rand_float-last_expr"/><a name="238"/>  238: <b>    rand:uniform</b>().
<a name="239"/>  239: 
<a name="rand_heapbin-0"/><a name="240"/>  240: <b>rand_heapbin</b>() -&gt;
<a name="241"/>  241:     HeapBinSz = rand:uniform(?ERL_ONHEAP_BIN_LIMIT + 1) - 1,
<a name="242"/>  242:     HeapBig = rand:uniform(1 bsl (HeapBinSz*8)),
<a name="rand_heapbin-last_expr"/><a name="243"/>  243:     &lt;&lt;HeapBig:HeapBinSz/unit:8&gt;&gt;.
<a name="244"/>  244: 
<a name="rand_procbin-0"/><a name="245"/>  245: <b>rand_procbin</b>() -&gt;
<a name="246"/>  246:     ProcBinSz = ?ERL_ONHEAP_BIN_LIMIT + rand:uniform(?ERL_ONHEAP_BIN_LIMIT),
<a name="247"/>  247:     ProcBig = rand:uniform(1 bsl (ProcBinSz*8)),
<a name="rand_procbin-last_expr"/><a name="248"/>  248:     &lt;&lt;ProcBig:ProcBinSz/unit:8&gt;&gt;.
<a name="249"/>  249: 
<a name="rand_subbin-1"/><a name="250"/>  250: <b>rand_subbin</b>(Bin) -&gt;
<a name="251"/>  251:     TotSz = bit_size(Bin),
<a name="252"/>  252:     Offs = rand:uniform(TotSz + 1) - 1,
<a name="253"/>  253:     Bits = rand:uniform(TotSz - Offs + 1) - 1,
<a name="254"/>  254:     &lt;&lt;_:Offs, BitStr:Bits/bits, _/bits&gt;&gt; = Bin,
<a name="rand_subbin-last_expr"/><a name="255"/>  255:     BitStr.
<a name="256"/>  256: 
<a name="list_to_improper_list-1"/><a name="257"/>  257: <b>list_to_improper_list</b>([A,B|T]) -&gt;
<a name="258"/>  258:     T ++ [A|B];
<a name="259"/>  259: <b>list_to_improper_list</b>([H]) -&gt;
<a name="list_to_improper_list-last_expr"/><a name="260"/>  260:     [[]|H].
<a name="261"/>  261: 
<a name="list_to_flatmap-1"/><a name="262"/>  262: <b>list_to_flatmap</b>(List) -&gt;
<a name="list_to_flatmap-last_expr"/><a name="263"/>  263: <b>    list_to_map</b>(List, #{}).
<a name="264"/>  264: 
<a name="list_to_hashmap-1"/><a name="265"/>  265: <b>list_to_hashmap</b>(List) -&gt;
<a name="266"/>  266:     HashMap = #{1=&gt;1, 2=&gt;2, 3=&gt;3, 4=&gt;4, 5=&gt;5, 6=&gt;6, 7=&gt;7, 8=&gt;8, 9=&gt;9,10=&gt;0,
<a name="267"/>  267:                 11=&gt;1,12=&gt;2,13=&gt;3,14=&gt;4,15=&gt;5,16=&gt;6,17=&gt;7,18=&gt;8,19=&gt;9,20=&gt;0,
<a name="268"/>  268:                 21=&gt;1,22=&gt;2,23=&gt;3,24=&gt;4,25=&gt;5,26=&gt;6,27=&gt;7,28=&gt;8,29=&gt;9,30=&gt;0,
<a name="269"/>  269:                 31=&gt;1,32=&gt;2,33=&gt;3},
<a name="list_to_hashmap-last_expr"/><a name="270"/>  270: <b>    list_to_map</b>(List, HashMap).
<a name="271"/>  271: 
<a name="list_to_map-2"/><a name="272"/>  272: <b>list_to_map</b>([], Map) -&gt;
<a name="273"/>  273:     Map;
<a name="274"/>  274: <b>list_to_map</b>([K], Map) -&gt;
<a name="275"/>  275:     Map#{K =&gt; K};
<a name="276"/>  276: <b>list_to_map</b>([K,V|T], Map) -&gt;
<a name="list_to_map-last_expr"/><a name="277"/>  277: <b>    list_to_map</b>(T, Map#{K =&gt; V}).
<a name="278"/>  278: 
<a name="list_to_fun-1"/><a name="279"/>  279: <b>list_to_fun</b>([X]) -&gt;
<a name="280"/>  280:     fun(A) -&gt; A + X end;
<a name="281"/>  281: <b>list_to_fun</b>([X, Y]) -&gt;
<a name="282"/>  282:     fun(A) -&gt; A + X + Y end;
<a name="283"/>  283: <b>list_to_fun</b>([X, Y | T]) -&gt;
<a name="list_to_fun-last_expr"/><a name="284"/>  284: <b>    fun</b>(A) -&gt; [A+X+Y | T] end.
<a name="285"/>  285: 
<a name="mk_ext_pid-3"/><a name="286"/>  286: <b>mk_ext_pid</b>({NodeName, Creation}, Number, Serial) -&gt;
<a name="mk_ext_pid-last_expr"/><a name="287"/>  287: <b>    erts_test_utils:mk_ext_pid</b>({NodeName, Creation}, Number, Serial).
<a name="288"/>  288: 
<a name="mk_ext_port-2"/><a name="289"/>  289: <b>mk_ext_port</b>({NodeName, Creation}, Number) -&gt;
<a name="mk_ext_port-last_expr"/><a name="290"/>  290: <b>    erts_test_utils:mk_ext_port</b>({NodeName, Creation}, Number).
<a name="291"/>  291: 
<a name="mk_ext_ref-2"/><a name="292"/>  292: <b>mk_ext_ref</b>({NodeName, Creation}, Numbers) -&gt;
<a name="mk_ext_ref-last_expr"/><a name="293"/>  293: <b>    erts_test_utils:mk_ext_ref</b>({NodeName, Creation}, Numbers).
<a name="294"/>  294: 
<a name="295"/>  295: <i>%% Convert local funs to maps to show fun environment</i>
<a name="printable-1"/><a name="296"/>  296: <b>printable</b>(Fun) when is_function(Fun) -&gt;
<a name="297"/>  297:     case erlang:fun_info(Fun, type) of
<a name="298"/>  298:         {type,local} -&gt;
<a name="299"/>  299:             {env, Env} = erlang:fun_info(Fun, env),
<a name="300"/>  300:             #{'fun' =&gt; [printable(T) || T &lt;- Env]};
<a name="301"/>  301:         {type,external} -&gt;
<a name="302"/>  302:             Fun
<a name="303"/>  303:     end;
<a name="304"/>  304: <b>printable</b>([H|T]) -&gt;
<a name="305"/>  305:     [printable(H)|printable(T)];
<a name="306"/>  306: <b>printable</b>(Tuple) when is_tuple(Tuple) -&gt;
<a name="307"/>  307:     list_to_tuple(printable(tuple_to_list(Tuple)));
<a name="308"/>  308: <b>printable</b>(Map) when is_map(Map) -&gt;
<a name="309"/>  309:     maps:from_list(printable(maps:to_list(Map)));
<a name="310"/>  310: <b>printable</b>(Leaf) -&gt;
<a name="printable-last_expr"/><a name="311"/>  311:     Leaf.
<a name="312"/>  312: 
<a name="313"/>  313: 
<a name="ei_threaded_accept-1"/><a name="314"/>  314: <b>ei_threaded_accept</b>(Config) when is_list(Config) -&gt;
<a name="315"/>  315:     Einode = filename:join(proplists:get_value(data_dir, Config), &quot;eiaccnode&quot;),
<a name="316"/>  316:     ei_threaded_accept_do(Einode, default),
<a name="317"/>  317:     ei_threaded_accept_do(Einode, ussi),
<a name="ei_threaded_accept-last_expr"/><a name="318"/>  318:     ok.
<a name="319"/>  319: 
<a name="ei_threaded_accept_do-2"/><a name="320"/>  320: <b>ei_threaded_accept_do</b>(Einode, SockImpl) -&gt;
<a name="321"/>  321:     N = 3,
<a name="322"/>  322:     wait_unreg_nodename([&quot;eiacc0&quot;, &quot;eiacc1&quot;, &quot;eiacc2&quot;], 10),
<a name="323"/>  323:     start_einode(Einode, N, SockImpl),
<a name="324"/>  324:     io:format(&quot;started eiaccnode&quot;),
<a name="325"/>  325:     TestServerPid = self(),
<a name="326"/>  326:     [spawn_link(fun() -&gt; send_rec_einode(I, TestServerPid) end) || I &lt;- lists:seq(0, N-1)],
<a name="327"/>  327:     [receive I -&gt; ok end || I &lt;- lists:seq(0, N-1) ],
<a name="ei_threaded_accept_do-last_expr"/><a name="328"/>  328:     ok.
<a name="329"/>  329: 
<a name="330"/>  330: 
<a name="331"/>  331: <i>%% Test erlang:monitor toward erl_interface &quot;processes&quot;</i>
<a name="monitor_ei_process-1"/><a name="332"/>  332: <b>monitor_ei_process</b>(Config) when is_list(Config) -&gt;
<a name="333"/>  333:     P = runner:start(Config, ?interpret),
<a name="334"/>  334:     0 = ei_connect_init(P, 42, erlang:get_cookie(), 0, 0, default),
<a name="335"/>  335: 
<a name="336"/>  336:     Myname = hd(tl(string:tokens(atom_to_list(node()), &quot;@&quot;))),
<a name="337"/>  337:     io:format(&quot;Myname ~p ~n&quot;,  [Myname]),
<a name="338"/>  338:     EINode = list_to_atom(&quot;c42@&quot;++Myname),
<a name="339"/>  339:     io:format(&quot;EINode ~p ~n&quot;,  [EINode]),
<a name="340"/>  340: 
<a name="341"/>  341:     Port = 6543,
<a name="342"/>  342:     {ok, ListenFd} = ei_publish(P, Port),
<a name="343"/>  343:     MRef1 = erlang:monitor(process, {any, EINode}),
<a name="344"/>  344:     {any, EINode} ! hello,
<a name="345"/>  345: 
<a name="346"/>  346:     {ok, Fd, _Node} = ei_accept(P, ListenFd),
<a name="347"/>  347:     hello = ei_receive(P, Fd),
<a name="348"/>  348: 
<a name="349"/>  349:     %% Again, now on an established connection.
<a name="350"/>  350:     MRef2 = erlang:monitor(process, {any, EINode}),
<a name="351"/>  351:     {any, EINode} ! hello,
<a name="352"/>  352:     hello = ei_receive(P, Fd),
<a name="353"/>  353: 
<a name="354"/>  354:     ok = receive M -&gt; M after 0 -&gt; ok end,
<a name="355"/>  355: 
<a name="356"/>  356:     runner:finish(P),
<a name="357"/>  357: 
<a name="358"/>  358:     ok  =receive
<a name="359"/>  359:              {'DOWN', MRef1, process, {any, EINode}, noconnection} -&gt;
<a name="360"/>  360:                  ok
<a name="361"/>  361:          after 1000 -&gt;
<a name="362"/>  362:                  timeout
<a name="363"/>  363:          end,
<a name="364"/>  364:     ok = receive
<a name="365"/>  365:              {'DOWN', MRef2, process, {any, EINode}, noconnection} -&gt;
<a name="366"/>  366:                  ok
<a name="367"/>  367:          after 1000 -&gt;
<a name="368"/>  368:                  timeout
<a name="369"/>  369:          end,
<a name="370"/>  370:     [] = flush(0, 1000),
<a name="monitor_ei_process-last_expr"/><a name="371"/>  371:     ok.
<a name="372"/>  372: 
<a name="wait_unreg_nodename-2"/><a name="373"/>  373: <b>wait_unreg_nodename</b>([], _) -&gt;
<a name="374"/>  374:     ok;
<a name="375"/>  375: <b>wait_unreg_nodename</b>(Names, 0) -&gt;
<a name="376"/>  376:     ct:fail({name_not_unregistered, Names});
<a name="377"/>  377: <b>wait_unreg_nodename</b>(Names, N) -&gt;
<a name="378"/>  378:     Registered = [X || {X,_} &lt;- element(2,erl_epmd:names())],
<a name="wait_unreg_nodename-last_expr"/><a name="379"/>  379: <b>    case lists:foldl</b>(fun (Name, Acc) -&gt;
<a name="380"/>  380:                              case lists:member(Name, Registered) of
<a name="381"/>  381:                                  true -&gt; [Name | Acc];
<a name="382"/>  382:                                  false -&gt; Acc
<a name="383"/>  383:                              end
<a name="384"/>  384:                      end,
<a name="385"/>  385:                      [],
<a name="386"/>  386:                      Names) of
<a name="387"/>  387:         [] -&gt;
<a name="388"/>  388:             ok;
<a name="389"/>  389:         NewNames -&gt;
<a name="390"/>  390:             timer:sleep(1000),
<a name="391"/>  391:             waitfornode(NewNames,N-1)
<a name="392"/>  392:     end.
<a name="393"/>  393: 
<a name="waitfornode-2"/><a name="394"/>  394: <b>waitfornode</b>(String,0) -&gt;
<a name="395"/>  395:     io:format(&quot;~s never published itself.~n&quot;,[String]),
<a name="396"/>  396:     false;
<a name="397"/>  397: <b>waitfornode</b>(String,N) -&gt;
<a name="398"/>  398:     Registered = [X || {X,_} &lt;- element(2,erl_epmd:names())],
<a name="waitfornode-last_expr"/><a name="399"/>  399: <b>    case lists:member</b>(String,Registered) of
<a name="400"/>  400:         true -&gt;
<a name="401"/>  401:             true;
<a name="402"/>  402:         false -&gt;
<a name="403"/>  403:             timer:sleep(1000),
<a name="404"/>  404:             waitfornode(String,N-1)
<a name="405"/>  405:     end.
<a name="406"/>  406: 
<a name="send_rec_einode-2"/><a name="407"/>  407: <b>send_rec_einode</b>(N, TestServerPid) -&gt;
<a name="408"/>  408:     Myname= hd(tl(string:tokens(atom_to_list(node()), &quot;@&quot;))),
<a name="409"/>  409:     FirstPart = &quot;eiacc&quot; ++ integer_to_list(N),
<a name="410"/>  410:     EINode= list_to_atom(FirstPart ++ &quot;@&quot; ++ Myname),
<a name="411"/>  411:     io:format(&quot;EINode ~p ~n&quot;,  [EINode]),
<a name="412"/>  412:     Self= self(),
<a name="413"/>  413:     case waitfornode(FirstPart,20) of
<a name="414"/>  414:         true -&gt; ok;
<a name="415"/>  415:         false -&gt; ct:fail({never_published,EINode})
<a name="416"/>  416:     end,
<a name="417"/>  417:     {any, EINode} ! Self,
<a name="send_rec_einode-last_expr"/><a name="418"/>  418:     receive
<a name="419"/>  419:         {N,_}=X -&gt;
<a name="420"/>  420:             io:format(&quot;Received by ~s ~p~n&quot;, [EINode, X]),
<a name="421"/>  421:             TestServerPid ! N,
<a name="422"/>  422:             X
<a name="423"/>  423:     after 10000 -&gt;
<a name="424"/>  424:               ct:fail(EINode)
<a name="425"/>  425:     end.
<a name="426"/>  426: 
<a name="start_einode-3"/><a name="427"/>  427: <b>start_einode</b>(Einode, N, SockImpl) -&gt;
<a name="428"/>  428:     Einodecmd = Einode ++ &quot; &quot; ++ atom_to_list(erlang:get_cookie())
<a name="429"/>  429:         ++ &quot; &quot; ++ integer_to_list(N)
<a name="430"/>  430:         ++ &quot; &quot; ++ atom_to_list(SockImpl),
<a name="431"/>  431:     io:format(&quot;Einodecmd  ~p ~n&quot;, [Einodecmd]),      
<a name="432"/>  432:     open_port({spawn, Einodecmd}, []),
<a name="start_einode-last_expr"/><a name="433"/>  433:     ok.
<a name="434"/>  434: 
<a name="435"/>  435: 
<a name="436"/>  436: <i>%%% Interface functions for ei (erl_interface) functions.</i>
<a name="437"/>  437: 
<a name="ei_connect_init-6"/><a name="438"/>  438: <b>ei_connect_init</b>(P, Num, Cookie, Creation, Compat, SockImpl) -&gt;
<a name="439"/>  439:     send_command(P, ei_connect_init, [Num,Cookie,Creation,Compat,SockImpl]),
<a name="ei_connect_init-last_expr"/><a name="440"/>  440: <b>    case get_term</b>(P) of
<a name="441"/>  441:         {term,Int} when is_integer(Int) -&gt; Int
<a name="442"/>  442:     end.
<a name="443"/>  443: 
<a name="ei_publish-2"/><a name="444"/>  444: <b>ei_publish</b>(P, PortNo) -&gt;
<a name="445"/>  445:     send_command(P, ei_publish, [PortNo]),
<a name="ei_publish-last_expr"/><a name="446"/>  446: <b>    case get_term</b>(P) of
<a name="447"/>  447:         {term,{ListenFd, EpmdFd, _}} when ListenFd &gt;= 0, EpmdFd &gt;= 0 -&gt; {ok, ListenFd};
<a name="448"/>  448:         {term,{_, _, Errno}} -&gt; {error,Errno}
<a name="449"/>  449:     end.
<a name="450"/>  450: 
<a name="ei_accept-2"/><a name="451"/>  451: <b>ei_accept</b>(P, ListenFd) -&gt;
<a name="452"/>  452:     send_command(P, ei_accept, [ListenFd]),
<a name="ei_accept-last_expr"/><a name="453"/>  453: <b>    case get_term</b>(P) of
<a name="454"/>  454:         {term,{Fd, _, Node}} when Fd &gt;= 0 -&gt; {ok, Fd, Node};
<a name="455"/>  455:         {term,{_Fd, Errno, _Node}} -&gt; {error,Errno}
<a name="456"/>  456:     end.
<a name="457"/>  457: 
<a name="ei_receive-2"/><a name="458"/>  458: <b>ei_receive</b>(P, Fd) -&gt;
<a name="459"/>  459:     send_command(P, ei_receive, [Fd]),
<a name="460"/>  460:     {term, T} = get_term(P),
<a name="ei_receive-last_expr"/><a name="461"/>  461:     T.
<a name="462"/>  462: 
<a name="send_command-3"/><a name="463"/>  463: <b>send_command</b>(P, Name, Args) -&gt;
<a name="send_command-last_expr"/><a name="464"/>  464: <b>    runner:send_term</b>(P, {Name,list_to_tuple(Args)}).
<a name="465"/>  465: 
<a name="flush-2"/><a name="466"/>  466: <b>flush</b>(0, Timeout) -&gt;
<a name="467"/>  467:     flush(1, Timeout div 10);
<a name="468"/>  468: <b>flush</b>(Expected, Timeout) -&gt;
<a name="flush-last_expr"/><a name="469"/>  469:     receive M -&gt;
<a name="470"/>  470:             [M | flush(Expected-1, Timeout)]
<a name="471"/>  471:     after Timeout -&gt;
<a name="472"/>  472:             []
<a name="473"/>  473:     end.
</pre>
<script>
var hash = window.location.hash.substring(1);
var anchor = document.getElementsByName(hash);
anchor[0].style.backgroundColor="orange";
</script>
</body>
</html>
