<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/lib/kernel/make_test_dir/kernel_test/prim_file_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%</i>
<a name="2"/>    2: <i>%% %CopyrightBegin%</i>
<a name="3"/>    3: <i>%%</i>
<a name="4"/>    4: <i>%% Copyright Ericsson AB 2000-2022. All Rights Reserved.</i>
<a name="5"/>    5: <i>%%</i>
<a name="6"/>    6: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="7"/>    7: <i>%% you may not use this file except in compliance with the License.</i>
<a name="8"/>    8: <i>%% You may obtain a copy of the License at</i>
<a name="9"/>    9: <i>%%</i>
<a name="10"/>   10: <i>%%     http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="11"/>   11: <i>%%</i>
<a name="12"/>   12: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="13"/>   13: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="14"/>   14: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="15"/>   15: <i>%% See the License for the specific language governing permissions and</i>
<a name="16"/>   16: <i>%% limitations under the License.</i>
<a name="17"/>   17: <i>%%</i>
<a name="18"/>   18: <i>%% %CopyrightEnd%</i>
<a name="19"/>   19: <i>%%</i>
<a name="20"/>   20: <b>-module</b>(prim_file_SUITE).
<a name="21"/>   21: <b>-export</b>([all/0, suite/0,groups/0,init_per_suite/1, end_per_suite/1, 
<a name="22"/>   22: 	 init_per_group/2,end_per_group/2, init_per_testcase/2, end_per_testcase/2,
<a name="23"/>   23: 	 read_write_file/1, free_memory/0]).
<a name="24"/>   24: <b>-export</b>([cur_dir_0/1, cur_dir_1/1,
<a name="25"/>   25: 	 make_del_dir/1, pos1/1, pos2/1]).
<a name="26"/>   26: <b>-export</b>([close/1, delete/1]).
<a name="27"/>   27: <b>-export</b>([open1/1, modes/1]).
<a name="28"/>   28: <b>-export</b>([file_info_basic_file/1, file_info_basic_directory/1, file_info_bad/1,
<a name="29"/>   29: 	 file_info_times/1, file_write_file_info/1,
<a name="30"/>   30:          file_read_file_info_opts/1, file_write_file_info_opts/1,
<a name="31"/>   31: 	 file_write_read_file_info_opts/1]).
<a name="32"/>   32: <b>-export</b>([rename/1, access/1, truncate/1, datasync/1, sync/1,
<a name="33"/>   33: 	 read_write/1, pread_write/1, append/1, exclusive/1,
<a name="34"/>   34: 	 read_file_rename_race/1]).
<a name="35"/>   35: <b>-export</b>([e_delete/1, e_rename/1, e_make_dir/1, e_del_dir/1]).
<a name="36"/>   36: 
<a name="37"/>   37: <b>-export</b>([make_link/1, read_link_info_for_non_link/1,
<a name="38"/>   38: 	 symlinks/1,
<a name="39"/>   39: 	 list_dir_limit/1,
<a name="40"/>   40: 	 list_dir_error/1,
<a name="41"/>   41: 	 list_dir/1]).
<a name="42"/>   42: 
<a name="43"/>   43: <b>-export</b>([advise/1]).
<a name="44"/>   44: <b>-export</b>([large_write/1]).
<a name="45"/>   45: 
<a name="46"/>   46: <i>%% System probe functions that might be handy to check from the shell</i>
<a name="47"/>   47: <b>-export</b>([unix_free/1]).
<a name="48"/>   48: 
<a name="49"/>   49: <b>-export</b>([allocate/1]).
<a name="50"/>   50: 
<a name="51"/>   51: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="52"/>   52: <b>-include_lib</b>(&quot;kernel/include/file.hrl&quot;).
<a name="53"/>   53: 
<a name="54"/>   54: <b>-define</b>(PRIM_FILE, prim_file).
<a name="55"/>   55: 
<a name="suite-0"/><a name="suite-last_expr"/><a name="56"/>   56: <b>suite</b>() -&gt; [].
<a name="57"/>   57: 
<a name="all-0"/><a name="58"/>   58: <b>all</b>() -&gt; 
<a name="all-last_expr"/><a name="59"/>   59:     [read_write_file, {group, dirs}, {group, files},
<a name="60"/>   60:      delete, rename, {group, errors}, {group, links},
<a name="61"/>   61:      list_dir_limit, list_dir].
<a name="62"/>   62: 
<a name="groups-0"/><a name="63"/>   63: <b>groups</b>() -&gt; 
<a name="groups-last_expr"/><a name="64"/>   64:     [{dirs, [],
<a name="65"/>   65:       [make_del_dir, cur_dir_0, cur_dir_1]},
<a name="66"/>   66:      {files, [],
<a name="67"/>   67:       [{group, open}, {group, pos}, {group, file_info},
<a name="68"/>   68:        truncate, sync, datasync, advise, large_write, allocate]},
<a name="69"/>   69:      {open, [],
<a name="70"/>   70:       [open1, modes, close, access, read_write, pread_write,
<a name="71"/>   71:        append, exclusive, read_file_rename_race]},
<a name="72"/>   72:      {pos, [], [pos1, pos2]},
<a name="73"/>   73:      {file_info, [],
<a name="74"/>   74:       [file_info_basic_file,file_info_basic_directory, file_info_bad,
<a name="75"/>   75:        file_info_times, file_write_file_info, file_read_file_info_opts,
<a name="76"/>   76:        file_write_file_info_opts, file_write_read_file_info_opts
<a name="77"/>   77:       ]},
<a name="78"/>   78:      {errors, [],
<a name="79"/>   79:       [e_delete, e_rename, e_make_dir, e_del_dir]},
<a name="80"/>   80:      {links, [],
<a name="81"/>   81:       [make_link, read_link_info_for_non_link, symlinks, list_dir_error]}].
<a name="82"/>   82: 
<a name="init_per_testcase-2"/><a name="83"/>   83: <b>init_per_testcase</b>(large_write, Config) -&gt;
<a name="84"/>   84:     {ok, Started} = application:ensure_all_started(os_mon),
<a name="85"/>   85:     [{started, Started}|Config];
<a name="86"/>   86: <b>init_per_testcase</b>(_TestCase, Config) -&gt;
<a name="init_per_testcase-last_expr"/><a name="87"/>   87:     Config.
<a name="88"/>   88: 
<a name="end_per_testcase-2"/><a name="89"/>   89: <b>end_per_testcase</b>(large_write, Config) -&gt;
<a name="90"/>   90:     [application:stop(App) || App &lt;- lists:reverse(proplists:get_value(started, Config))],
<a name="91"/>   91:     ok;
<a name="92"/>   92: <b>end_per_testcase</b>(_, _Config) -&gt;
<a name="end_per_testcase-last_expr"/><a name="93"/>   93:     ok.
<a name="94"/>   94: 
<a name="init_per_group-2"/><a name="95"/>   95: <b>init_per_group</b>(_GroupName, Config) -&gt;
<a name="init_per_group-last_expr"/><a name="96"/>   96:     Config.
<a name="97"/>   97: 
<a name="end_per_group-2"/><a name="98"/>   98: <b>end_per_group</b>(_GroupName, Config) -&gt;
<a name="end_per_group-last_expr"/><a name="99"/>   99:     Config.
<a name="100"/>  100: 
<a name="101"/>  101: 
<a name="init_per_suite-1"/><a name="102"/>  102: <b>init_per_suite</b>(Config) when is_list(Config) -&gt;
<a name="init_per_suite-last_expr"/><a name="103"/>  103: <b>    case os:type</b>() of
<a name="104"/>  104: 	{win32, _} -&gt;
<a name="105"/>  105: 	    Priv = proplists:get_value(priv_dir, Config),
<a name="106"/>  106: 	    HasAccessTime =
<a name="107"/>  107: 		case file:read_file_info(Priv) of
<a name="108"/>  108: 		    {ok, #file_info{atime={_, {0, 0, 0}}}} -&gt;
<a name="109"/>  109: 			%% This is a unfortunately a FAT file system.
<a name="110"/>  110: 			[no_access_time];
<a name="111"/>  111: 		    {ok, _} -&gt;
<a name="112"/>  112: 			[]
<a name="113"/>  113: 		end,
<a name="114"/>  114: 	    HasAccessTime++Config;
<a name="115"/>  115: 	_ -&gt;
<a name="116"/>  116: 	    Config
<a name="117"/>  117:     end.
<a name="118"/>  118: 
<a name="end_per_suite-1"/><a name="119"/>  119: <b>end_per_suite</b>(Config) when is_list(Config) -&gt;
<a name="120"/>  120:     case os:type() of
<a name="121"/>  121: 	{win32, _} -&gt;
<a name="122"/>  122: 	    os:cmd(&quot;subst z: /d&quot;);
<a name="123"/>  123: 	_ -&gt;
<a name="124"/>  124: 	    ok
<a name="125"/>  125:     end,
<a name="end_per_suite-last_expr"/><a name="126"/>  126:     Config.
<a name="127"/>  127: 
<a name="128"/>  128: <i>%% Matches a term (the last) against alternatives</i>
<a name="expect-3"/><a name="129"/>  129: <b>expect</b>(X, _, X) -&gt;
<a name="130"/>  130:     X;
<a name="131"/>  131: <b>expect</b>(_, X, X) -&gt;
<a name="expect-last_expr"/><a name="132"/>  132:     X.
<a name="133"/>  133: 
<a name="expect-4"/><a name="134"/>  134: <b>expect</b>(X, _, _, X) -&gt;
<a name="135"/>  135:     X;
<a name="136"/>  136: <b>expect</b>(_, X, _, X) -&gt;
<a name="137"/>  137:     X;
<a name="138"/>  138: <b>expect</b>(_, _, X, X) -&gt;
<a name="expect-last_expr"/><a name="139"/>  139:     X.
<a name="140"/>  140: 
<a name="expect-5"/><a name="141"/>  141: <b>expect</b>(X, _, _, _, X) -&gt;
<a name="142"/>  142:     X;
<a name="143"/>  143: <b>expect</b>(_, X, _, _, X) -&gt;
<a name="144"/>  144:     X;
<a name="145"/>  145: <b>expect</b>(_, _, X, _, X) -&gt;
<a name="146"/>  146:     X;
<a name="147"/>  147: <b>expect</b>(_, _, _, X, X) -&gt;
<a name="expect-last_expr"/><a name="148"/>  148:     X.
<a name="149"/>  149: 
<a name="150"/>  150: <i>%% Calculate the time difference</i>
<a name="time_dist-2"/><a name="151"/>  151: <b>time_dist</b>({YY, MM, DD, H, M, S}, DT) -&gt;
<a name="152"/>  152:     time_dist({{YY, MM, DD}, {H, M, S}}, DT);
<a name="153"/>  153: <b>time_dist</b>(DT, {YY, MM, DD, H, M, S}) -&gt;
<a name="154"/>  154:     time_dist(DT, {{YY, MM, DD}, {H, M, S}});
<a name="155"/>  155: <b>time_dist</b>({_D1, _T1} = DT1, {_D2, _T2} = DT2) -&gt;
<a name="156"/>  156:     calendar:datetime_to_gregorian_seconds(DT2)
<a name="time_dist-last_expr"/><a name="157"/>  157: <b>	- calendar:datetime_to_gregorian_seconds</b>(DT1).
<a name="158"/>  158: 
<a name="159"/>  159: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="160"/>  160: 
<a name="read_write_file-1"/><a name="161"/>  161: <b>read_write_file</b>(Config) when is_list(Config) -&gt;
<a name="162"/>  162:     RootDir = proplists:get_value(priv_dir,Config),
<a name="163"/>  163:     Name = filename:join(RootDir,
<a name="164"/>  164: 			 atom_to_list(?MODULE)
<a name="165"/>  165: 			 ++&quot;_read_write_file&quot;),
<a name="166"/>  166: 
<a name="167"/>  167:     %% Try writing and reading back some term
<a name="168"/>  168:     SomeTerm = {&quot;This term&quot;,{will,be},[written,$t,$o],1,file,[]},
<a name="169"/>  169:     ok = ?PRIM_FILE:write_file(Name,term_to_binary(SomeTerm)),
<a name="170"/>  170:     {ok,Bin1} = ?PRIM_FILE:read_file(Name),
<a name="171"/>  171:     SomeTerm = binary_to_term(Bin1),
<a name="172"/>  172: 
<a name="173"/>  173:     %% Try a &quot;null&quot; term
<a name="174"/>  174:     NullTerm = [],
<a name="175"/>  175:     ok = ?PRIM_FILE:write_file(Name,term_to_binary(NullTerm)),
<a name="176"/>  176:     {ok,Bin2} = ?PRIM_FILE:read_file(Name),
<a name="177"/>  177:     NullTerm = binary_to_term(Bin2),
<a name="178"/>  178: 
<a name="179"/>  179:     %% Try some &quot;complicated&quot; types
<a name="180"/>  180:     BigNum = 123456789012345678901234567890,
<a name="181"/>  181:     ComplTerm = {self(),make_ref(),BigNum,3.14159},
<a name="182"/>  182:     ok = ?PRIM_FILE:write_file(Name,term_to_binary(ComplTerm)),
<a name="183"/>  183:     {ok,Bin3} = ?PRIM_FILE:read_file(Name),
<a name="184"/>  184:     ComplTerm = binary_to_term(Bin3),
<a name="185"/>  185: 
<a name="186"/>  186:     %% Try reading a nonexistent file
<a name="187"/>  187:     Name2 = filename:join(RootDir,
<a name="188"/>  188: 			  atom_to_list(?MODULE)
<a name="189"/>  189: 			  ++&quot;_nonexistent_file&quot;),
<a name="190"/>  190:     {error, enoent} = ?PRIM_FILE:read_file(Name2),
<a name="191"/>  191:     {error, enoent} = ?PRIM_FILE:read_file(&quot;&quot;),
<a name="192"/>  192: 
<a name="193"/>  193:     %% Try writing to a bad filename
<a name="194"/>  194:     {error, enoent} =
<a name="195"/>  195: 	?PRIM_FILE:write_file(&quot;&quot;,term_to_binary(NullTerm)),
<a name="196"/>  196: 
<a name="197"/>  197:     %% Try writing something else than a binary
<a name="198"/>  198:     {error, badarg} = ?PRIM_FILE:write_file(Name,{1,2,3}),
<a name="199"/>  199:     {error, badarg} = ?PRIM_FILE:write_file(Name,self()),
<a name="200"/>  200: 
<a name="201"/>  201:     %% Some non-term binaries
<a name="202"/>  202:     ok = ?PRIM_FILE:write_file(Name,[]),
<a name="203"/>  203:     {ok,Bin4} = ?PRIM_FILE:read_file(Name),
<a name="204"/>  204:     0 = byte_size(Bin4),
<a name="205"/>  205: 
<a name="206"/>  206:     ok = ?PRIM_FILE:write_file(Name,[Bin1,[],[[Bin2]]]),
<a name="207"/>  207:     {ok,Bin5} = ?PRIM_FILE:read_file(Name),
<a name="208"/>  208:     {Bin1,Bin2} = split_binary(Bin5,byte_size(Bin1)),
<a name="209"/>  209: 
<a name="read_write_file-last_expr"/><a name="210"/>  210:     ok.
<a name="211"/>  211: 
<a name="212"/>  212: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="213"/>  213: 
<a name="make_del_dir-1"/><a name="214"/>  214: <b>make_del_dir</b>(Config) when is_list(Config) -&gt;
<a name="215"/>  215:     RootDir = proplists:get_value(priv_dir,Config),
<a name="216"/>  216:     NewDir = filename:join(RootDir,
<a name="217"/>  217: 			   atom_to_list(?MODULE)
<a name="218"/>  218: 			   ++&quot;_mk-dir&quot;),
<a name="219"/>  219:     ok = ?PRIM_FILE:make_dir(NewDir),
<a name="220"/>  220:     {error, eexist} = ?PRIM_FILE:make_dir(NewDir),
<a name="221"/>  221:     ok = ?PRIM_FILE:del_dir(NewDir),
<a name="222"/>  222:     {error, enoent} = ?PRIM_FILE:del_dir(NewDir),
<a name="223"/>  223: 
<a name="224"/>  224:     %% Make sure we are not in a directory directly under test_server
<a name="225"/>  225:     %% as that would result in eacces errors when trying to delete '..',
<a name="226"/>  226:     %% because there are processes having that directory as current.
<a name="227"/>  227:     ok = ?PRIM_FILE:make_dir(NewDir),
<a name="228"/>  228:     {ok, CurrentDir} = ?PRIM_FILE:get_cwd(),
<a name="229"/>  229:     case {os:type(), length(NewDir) &gt;= 260 } of
<a name="230"/>  230: 	{{win32,_}, true} -&gt;
<a name="231"/>  231: 	    io:format(&quot;Skip set_cwd for windows path longer than 260 (MAX_PATH)\n&quot;, []),
<a name="232"/>  232: 	    io:format(&quot;\nNewDir = ~p\n&quot;, [NewDir]);
<a name="233"/>  233: 	_ -&gt;
<a name="234"/>  234: 	    ok = ?PRIM_FILE:set_cwd(NewDir)
<a name="235"/>  235:     end,
<a name="236"/>  236:     try
<a name="237"/>  237: 	%% Check that we get an error when trying to create...
<a name="238"/>  238: 	%% a deep directory
<a name="239"/>  239: 	NewDir2 = filename:join(RootDir,
<a name="240"/>  240: 				atom_to_list(?MODULE)
<a name="241"/>  241: 				++&quot;_mk-dir-noexist/foo&quot;),
<a name="242"/>  242: 	{error, enoent} = ?PRIM_FILE:make_dir(NewDir2),
<a name="243"/>  243: 	%% a nameless directory
<a name="244"/>  244: 	{error, enoent} = ?PRIM_FILE:make_dir(&quot;&quot;),
<a name="245"/>  245: 	%% a directory with illegal name
<a name="246"/>  246: 	{error, badarg} = ?PRIM_FILE:make_dir('mk-dir'),
<a name="247"/>  247: 
<a name="248"/>  248: 	%% a directory with illegal name, even if it's a (bad) list
<a name="249"/>  249: 	{error, badarg} = ?PRIM_FILE:make_dir([1,2,3,{}]),
<a name="250"/>  250: 
<a name="251"/>  251: 	%% Maybe this isn't an error, exactly, but worth mentioning anyway:
<a name="252"/>  252: 	%% ok = ?PRIM_FILE:make_dir([$f,$o,$o,0,$b,$a,$r])),
<a name="253"/>  253: 	%% The above line works, and created a directory &quot;./foo&quot;
<a name="254"/>  254: 	%% More elegant would maybe have been to fail, or to really create
<a name="255"/>  255: 	%% a directory, but with a name that incorporates the &quot;bar&quot; part of
<a name="256"/>  256: 	%% the list, so that [$f,$o,$o,0,$f,$o,$o] wouldn't refer to the same
<a name="257"/>  257: 	%% dir. But this would slow it down.
<a name="258"/>  258: 
<a name="259"/>  259: 	%% Try deleting some bad directories
<a name="260"/>  260: 	%% Deleting the parent directory to the current, sounds dangerous, huh?
<a name="261"/>  261: 	%% Don't worry ;-) the parent directory should never be empty, right?
<a name="262"/>  262: 	case ?PRIM_FILE:del_dir(&quot;..&quot;) of
<a name="263"/>  263: 	    {error, eexist} -&gt; ok;
<a name="264"/>  264: 	    {error, eacces} -&gt; ok;	%OpenBSD
<a name="265"/>  265: 	    {error, einval} -&gt; ok		%FreeBSD
<a name="266"/>  266: 	end,
<a name="267"/>  267: 	{error, enoent} = ?PRIM_FILE:del_dir(&quot;&quot;),
<a name="268"/>  268: 	{error, badarg} = ?PRIM_FILE:del_dir([3,2,1,{}])
<a name="269"/>  269:     after
<a name="270"/>  270: 	ok = ?PRIM_FILE:set_cwd(CurrentDir)
<a name="271"/>  271:     end,
<a name="make_del_dir-last_expr"/><a name="272"/>  272:     ok.
<a name="273"/>  273: 
<a name="cur_dir_0-1"/><a name="274"/>  274: <b>cur_dir_0</b>(Config) when is_list(Config) -&gt;
<a name="275"/>  275:     %% Find out the current dir, and cd to it ;-)
<a name="276"/>  276:     {ok,BaseDir} = ?PRIM_FILE:get_cwd(),
<a name="277"/>  277:     Dir1 = BaseDir ++ &quot;&quot;, %% Check that it's a string
<a name="278"/>  278:     ok = ?PRIM_FILE:set_cwd(Dir1),
<a name="279"/>  279:     DirName = atom_to_list(?MODULE) ++ &quot;_curdir&quot;,
<a name="280"/>  280: 
<a name="281"/>  281:     %% Make a new dir, and cd to that
<a name="282"/>  282:     RootDir = proplists:get_value(priv_dir,Config),
<a name="283"/>  283:     NewDir = filename:join(RootDir, DirName),
<a name="284"/>  284:     ok = ?PRIM_FILE:make_dir(NewDir),
<a name="285"/>  285:     case {os:type(), length(NewDir) &gt;= 260} of
<a name="286"/>  286: 	{{win32,_}, true} -&gt;
<a name="287"/>  287: 	    io:format(&quot;Skip set_cwd for windows path longer than 260 (MAX_PATH):\n&quot;),
<a name="288"/>  288: 	    io:format(&quot;\nNewDir = ~p\n&quot;, [NewDir]);
<a name="289"/>  289: 	_ -&gt;
<a name="290"/>  290: 	    io:format(&quot;cd to ~s&quot;,[NewDir]),
<a name="291"/>  291: 	    ok = ?PRIM_FILE:set_cwd(NewDir),
<a name="292"/>  292: 
<a name="293"/>  293: 	    %% Create a file in the new current directory, and check that it
<a name="294"/>  294: 	    %% really is created there
<a name="295"/>  295: 	    UncommonName = &quot;uncommon.fil&quot;,
<a name="296"/>  296: 	    {ok,Fd} = ?PRIM_FILE:open(UncommonName, [read, write]),
<a name="297"/>  297: 	    ok = ?PRIM_FILE:close(Fd),
<a name="298"/>  298: 	    {ok,NewDirFiles} = ?PRIM_FILE:list_dir(&quot;.&quot;),
<a name="299"/>  299: 	    true = lists:member(UncommonName,NewDirFiles),
<a name="300"/>  300: 
<a name="301"/>  301: 	    %% Delete the directory and return to the old current directory
<a name="302"/>  302: 	    %% and check that the created file isn't there (too!)
<a name="303"/>  303: 	    expect({error, einval}, {error, eacces}, {error, eexist},
<a name="304"/>  304: 		   ?PRIM_FILE:del_dir(NewDir)),
<a name="305"/>  305: 	    ?PRIM_FILE:delete(UncommonName),
<a name="306"/>  306: 	    {ok,[]} = ?PRIM_FILE:list_dir(&quot;.&quot;),
<a name="307"/>  307: 	    ok = ?PRIM_FILE:set_cwd(Dir1),
<a name="308"/>  308: 	    io:format(&quot;cd back to ~s&quot;,[Dir1]),
<a name="309"/>  309: 	    ok = ?PRIM_FILE:del_dir(NewDir),
<a name="310"/>  310: 	    {error, enoent} = ?PRIM_FILE:set_cwd(NewDir),
<a name="311"/>  311: 	    ok = ?PRIM_FILE:set_cwd(Dir1),
<a name="312"/>  312: 	    io:format(&quot;cd back to ~s&quot;,[Dir1]),
<a name="313"/>  313: 	    {ok,OldDirFiles} = ?PRIM_FILE:list_dir(&quot;.&quot;),
<a name="314"/>  314: 	    false = lists:member(UncommonName,OldDirFiles)
<a name="315"/>  315:     end,
<a name="316"/>  316: 
<a name="317"/>  317:     %% Try doing some bad things
<a name="318"/>  318:     {error, badarg} =
<a name="319"/>  319: 	?PRIM_FILE:set_cwd({foo,bar}),
<a name="320"/>  320:     {error, enoent} =
<a name="321"/>  321: 	?PRIM_FILE:set_cwd(&quot;&quot;),
<a name="322"/>  322:     {error, enoent} =
<a name="323"/>  323: 	?PRIM_FILE:set_cwd(&quot;.......a......&quot;),
<a name="324"/>  324:     {ok,BaseDir} =
<a name="325"/>  325: 	?PRIM_FILE:get_cwd(), %% Still there?
<a name="326"/>  326: 
<a name="327"/>  327:     %% On Windows, there should only be slashes, no backslashes,
<a name="328"/>  328:     %% in the return value of get_cwd().
<a name="329"/>  329:     %% (The test is harmless on Unix, because filenames usually
<a name="330"/>  330:     %% don't contain backslashes.)
<a name="331"/>  331: 
<a name="332"/>  332:     {ok, BaseDir} = ?PRIM_FILE:get_cwd(),
<a name="333"/>  333:     false = lists:member($\\, BaseDir),
<a name="334"/>  334: 
<a name="cur_dir_0-last_expr"/><a name="335"/>  335:     ok.
<a name="336"/>  336: 
<a name="337"/>  337: <i>%% Tests ?PRIM_FILE:get_cwd/1.</i>
<a name="338"/>  338: 
<a name="cur_dir_1-1"/><a name="339"/>  339: <b>cur_dir_1</b>(Config) when is_list(Config) -&gt;
<a name="340"/>  340:     case os:type() of
<a name="341"/>  341: 	{win32, _} -&gt;
<a name="342"/>  342: 	    win_cur_dir_1(Config);
<a name="343"/>  343: 	_ -&gt;
<a name="344"/>  344: 	    {error, enotsup} =
<a name="345"/>  345: 		?PRIM_FILE:get_cwd(&quot;d:&quot;)
<a name="346"/>  346:     end,
<a name="cur_dir_1-last_expr"/><a name="347"/>  347:     ok.
<a name="348"/>  348: 
<a name="win_cur_dir_1-1"/><a name="349"/>  349: <b>win_cur_dir_1</b>(_Config) -&gt;
<a name="350"/>  350:     {ok, BaseDir} = ?PRIM_FILE:get_cwd(),
<a name="351"/>  351: 
<a name="352"/>  352:     %% Get the drive letter from the current directory,
<a name="353"/>  353:     %% and try to get current directory for that drive.
<a name="354"/>  354: 
<a name="355"/>  355:     [Drive, $:|_] = BaseDir,
<a name="356"/>  356:     {ok, BaseDir} = ?PRIM_FILE:get_cwd([Drive, $:]),
<a name="357"/>  357:     io:format(&quot;BaseDir = ~s\n&quot;, [BaseDir]),
<a name="358"/>  358: 
<a name="359"/>  359:     %% Unfortunately, there is no way to move away from the
<a name="360"/>  360:     %% current drive as we can't use the &quot;subst&quot; command from
<a name="361"/>  361:     %% a SSH connection. We can't test any more. Too bad.
<a name="362"/>  362: 
<a name="win_cur_dir_1-last_expr"/><a name="363"/>  363:     ok.
<a name="364"/>  364: 
<a name="365"/>  365: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="366"/>  366: 
<a name="367"/>  367: 
<a name="368"/>  368: 
<a name="open1-1"/><a name="369"/>  369: <b>open1</b>(Config) when is_list(Config) -&gt;
<a name="370"/>  370:     RootDir = proplists:get_value(priv_dir,Config),
<a name="371"/>  371:     NewDir = filename:join(RootDir,
<a name="372"/>  372: 			   atom_to_list(?MODULE)
<a name="373"/>  373: 			   ++&quot;_files&quot;),
<a name="374"/>  374:     ok = ?PRIM_FILE:make_dir(NewDir),
<a name="375"/>  375:     Name = filename:join(NewDir, &quot;foo1.fil&quot;),
<a name="376"/>  376:     {ok,Fd1} = ?PRIM_FILE:open(Name, [read, write]),
<a name="377"/>  377:     {ok,Fd2} = ?PRIM_FILE:open(Name, [read]),
<a name="378"/>  378:     Bin = list_to_binary(&quot;{a,tuple}.\n&quot;),
<a name="379"/>  379:     Length = byte_size(Bin),
<a name="380"/>  380:     ?PRIM_FILE:write(Fd1,Bin),
<a name="381"/>  381:     {ok,0} = ?PRIM_FILE:position(Fd1,bof),
<a name="382"/>  382:     {ok, Bin} = ?PRIM_FILE:read(Fd1,Length),
<a name="383"/>  383:     {ok, Bin} = ?PRIM_FILE:read(Fd2,Length),
<a name="384"/>  384:     ok = ?PRIM_FILE:close(Fd2),
<a name="385"/>  385:     {ok,0} = ?PRIM_FILE:position(Fd1,bof),
<a name="386"/>  386:     ok = ?PRIM_FILE:truncate(Fd1),
<a name="387"/>  387:     eof = ?PRIM_FILE:read(Fd1,Length),
<a name="388"/>  388:     ok = ?PRIM_FILE:close(Fd1),
<a name="389"/>  389:     {ok,Fd3} = ?PRIM_FILE:open(Name, [read]),
<a name="390"/>  390:     eof = ?PRIM_FILE:read(Fd3,Length),
<a name="391"/>  391:     ok = ?PRIM_FILE:close(Fd3),
<a name="open1-last_expr"/><a name="392"/>  392:     ok.
<a name="393"/>  393: 
<a name="394"/>  394: <i>%% Tests all open modes.</i>
<a name="395"/>  395: 
<a name="modes-1"/><a name="396"/>  396: <b>modes</b>(Config) when is_list(Config) -&gt;
<a name="397"/>  397:     RootDir = proplists:get_value(priv_dir, Config),
<a name="398"/>  398:     NewDir = filename:join(RootDir,
<a name="399"/>  399: 			   atom_to_list(?MODULE)
<a name="400"/>  400: 			   ++&quot;_open_modes&quot;),
<a name="401"/>  401:     ok = ?PRIM_FILE:make_dir(NewDir),
<a name="402"/>  402:     Name1 = filename:join(NewDir, &quot;foo1.fil&quot;),
<a name="403"/>  403:     Marker = &lt;&lt;&quot;hello, world&quot;&gt;&gt;,
<a name="404"/>  404:     Length = byte_size(Marker),
<a name="405"/>  405: 
<a name="406"/>  406:     %% write
<a name="407"/>  407:     {ok, Fd1} = ?PRIM_FILE:open(Name1, [write]),
<a name="408"/>  408:     ok = ?PRIM_FILE:write(Fd1, Marker),
<a name="409"/>  409:     ok = ?PRIM_FILE:write(Fd1, &lt;&lt;&quot;.\n&quot;&gt;&gt;),
<a name="410"/>  410:     ok = ?PRIM_FILE:close(Fd1),
<a name="411"/>  411: 
<a name="412"/>  412:     %% read
<a name="413"/>  413:     {ok, Fd2} = ?PRIM_FILE:open(Name1, [read]),
<a name="414"/>  414:     {ok, Marker} = ?PRIM_FILE:read(Fd2, Length),
<a name="415"/>  415:     ok = ?PRIM_FILE:close(Fd2),
<a name="416"/>  416: 
<a name="417"/>  417:     %% read and write
<a name="418"/>  418:     {ok, Fd3} = ?PRIM_FILE:open(Name1, [read, write]),
<a name="419"/>  419:     {ok, Marker} = ?PRIM_FILE:read(Fd3, Length),
<a name="420"/>  420:     ok = ?PRIM_FILE:write(Fd3, Marker),
<a name="421"/>  421:     ok = ?PRIM_FILE:close(Fd3),
<a name="422"/>  422: 
<a name="423"/>  423:     %% read by default
<a name="424"/>  424:     {ok, Fd4} = ?PRIM_FILE:open(Name1, []),
<a name="425"/>  425:     {ok, Marker} = ?PRIM_FILE:read(Fd4, Length),
<a name="426"/>  426:     ok = ?PRIM_FILE:close(Fd4),
<a name="427"/>  427: 
<a name="modes-last_expr"/><a name="428"/>  428:     ok.
<a name="429"/>  429: 
<a name="close-1"/><a name="430"/>  430: <b>close</b>(Config) when is_list(Config) -&gt;
<a name="431"/>  431:     RootDir = proplists:get_value(priv_dir,Config),
<a name="432"/>  432:     Name = filename:join(RootDir,
<a name="433"/>  433: 			 atom_to_list(?MODULE)
<a name="434"/>  434: 			 ++&quot;_close.fil&quot;),
<a name="435"/>  435:     {ok,Fd1} = ?PRIM_FILE:open(Name, [read, write]),
<a name="436"/>  436:     %% Just closing it is no fun, we did that a million times already
<a name="437"/>  437:     %% This is a common error, for code written before Erlang 4.3
<a name="438"/>  438:     %% because then ?PRIM_FILE:open just returned a Pid, and not everyone
<a name="439"/>  439:     %% really checked what they got.
<a name="440"/>  440:     {'EXIT',_Msg} = (catch ok = ?PRIM_FILE:close({ok,Fd1})),
<a name="441"/>  441:     ok = ?PRIM_FILE:close(Fd1),
<a name="442"/>  442: 
<a name="443"/>  443:     %% Try closing one more time
<a name="444"/>  444:     Val = ?PRIM_FILE:close(Fd1),
<a name="445"/>  445:     io:format(&quot;Second close gave: ~p&quot;, [Val]),
<a name="446"/>  446: 
<a name="close-last_expr"/><a name="447"/>  447:     ok.
<a name="448"/>  448: 
<a name="access-1"/><a name="449"/>  449: <b>access</b>(Config) when is_list(Config) -&gt;
<a name="450"/>  450:     RootDir = proplists:get_value(priv_dir,Config),
<a name="451"/>  451:     Name = filename:join(RootDir,
<a name="452"/>  452: 			 atom_to_list(?MODULE)
<a name="453"/>  453: 			 ++&quot;_access.fil&quot;),
<a name="454"/>  454:     Bin = &lt;&lt;&quot;ABCDEFGH&quot;&gt;&gt;,
<a name="455"/>  455:     {ok,Fd1} = ?PRIM_FILE:open(Name, [write]),
<a name="456"/>  456:     ?PRIM_FILE:write(Fd1,Bin),
<a name="457"/>  457:     ok = ?PRIM_FILE:close(Fd1),
<a name="458"/>  458:     %% Check that we can't write when in read only mode
<a name="459"/>  459:     {ok,Fd2} = ?PRIM_FILE:open(Name, [read]),
<a name="460"/>  460:     case catch ?PRIM_FILE:write(Fd2,&quot;XXXX&quot;) of
<a name="461"/>  461: 	ok -&gt;
<a name="462"/>  462: 	    ct:fail({access,write});
<a name="463"/>  463: 	_ -&gt;
<a name="464"/>  464: 	    ok
<a name="465"/>  465:     end,
<a name="466"/>  466:     ok = ?PRIM_FILE:close(Fd2),
<a name="467"/>  467:     {ok, Fd3} = ?PRIM_FILE:open(Name, [read]),
<a name="468"/>  468:     {ok, Bin} = ?PRIM_FILE:read(Fd3,byte_size(Bin)),
<a name="469"/>  469:     ok = ?PRIM_FILE:close(Fd3),
<a name="470"/>  470: 
<a name="access-last_expr"/><a name="471"/>  471:     ok.
<a name="472"/>  472: 
<a name="473"/>  473: <i>%% Tests ?PRIM_FILE:read/2 and ?PRIM_FILE:write/2.</i>
<a name="474"/>  474: 
<a name="read_write-1"/><a name="475"/>  475: <b>read_write</b>(Config) when is_list(Config) -&gt;
<a name="476"/>  476:     RootDir = proplists:get_value(priv_dir, Config),
<a name="477"/>  477:     NewDir = filename:join(RootDir,
<a name="478"/>  478: 			   atom_to_list(?MODULE)
<a name="479"/>  479: 			   ++&quot;_read_write&quot;),
<a name="480"/>  480:     ok = ?PRIM_FILE:make_dir(NewDir),
<a name="481"/>  481: 
<a name="482"/>  482:     %% Raw file.
<a name="483"/>  483:     Name = filename:join(NewDir, &quot;raw.fil&quot;),
<a name="484"/>  484:     {ok, Fd} = ?PRIM_FILE:open(Name, [read, write]),
<a name="485"/>  485:     read_write_test(Fd),
<a name="486"/>  486: 
<a name="read_write-last_expr"/><a name="487"/>  487:     ok.
<a name="488"/>  488: 
<a name="read_write_test-1"/><a name="489"/>  489: <b>read_write_test</b>(File) -&gt;
<a name="490"/>  490:     Marker = &lt;&lt;&quot;hello, world&quot;&gt;&gt;,
<a name="491"/>  491:     ok = ?PRIM_FILE:write(File, Marker),
<a name="492"/>  492:     {ok, 0} = ?PRIM_FILE:position(File, 0),
<a name="493"/>  493:     {ok, Marker} = ?PRIM_FILE:read(File, 100),
<a name="494"/>  494:     eof = ?PRIM_FILE:read(File, 100),
<a name="495"/>  495:     ok = ?PRIM_FILE:close(File),
<a name="read_write_test-last_expr"/><a name="496"/>  496:     ok.
<a name="497"/>  497: 
<a name="498"/>  498: 
<a name="499"/>  499: <i>%% Tests ?PRIM_FILE:pread/2 and ?PRIM_FILE:pwrite/2.</i>
<a name="500"/>  500: 
<a name="pread_write-1"/><a name="501"/>  501: <b>pread_write</b>(Config) when is_list(Config) -&gt;
<a name="502"/>  502:     RootDir = proplists:get_value(priv_dir, Config),
<a name="503"/>  503:     NewDir = filename:join(RootDir,
<a name="504"/>  504: 			   atom_to_list(?MODULE)
<a name="505"/>  505: 			   ++&quot;_pread_write&quot;),
<a name="506"/>  506:     ok = ?PRIM_FILE:make_dir(NewDir),
<a name="507"/>  507: 
<a name="508"/>  508:     %% Raw file.
<a name="509"/>  509:     Name = filename:join(NewDir, &quot;raw.fil&quot;),
<a name="510"/>  510:     {ok, Fd} = ?PRIM_FILE:open(Name, [read, write]),
<a name="511"/>  511:     pread_write_test(Fd),
<a name="512"/>  512: 
<a name="pread_write-last_expr"/><a name="513"/>  513:     ok.
<a name="514"/>  514: 
<a name="pread_write_test-1"/><a name="515"/>  515: <b>pread_write_test</b>(File) -&gt;
<a name="516"/>  516:     Marker = &lt;&lt;&quot;hello, world&quot;&gt;&gt;,
<a name="517"/>  517:     Len = byte_size(Marker),
<a name="518"/>  518:     ok = ?PRIM_FILE:write(File, Marker),
<a name="519"/>  519:     {ok, Marker} = ?PRIM_FILE:pread(File, 0, 100),
<a name="520"/>  520:     eof = ?PRIM_FILE:pread(File, 100, 1),
<a name="521"/>  521:     ok = ?PRIM_FILE:pwrite(File, Len, Marker),
<a name="522"/>  522:     {ok, Marker} = ?PRIM_FILE:pread(File, Len, 100),
<a name="523"/>  523:     eof = ?PRIM_FILE:pread(File, 100, 1),
<a name="524"/>  524:     MM = &lt;&lt;Marker/binary,Marker/binary&gt;&gt;,
<a name="525"/>  525:     {ok, MM} = ?PRIM_FILE:pread(File, 0, 100),
<a name="526"/>  526:     ok = ?PRIM_FILE:close(File),
<a name="pread_write_test-last_expr"/><a name="527"/>  527:     ok.
<a name="528"/>  528: 
<a name="529"/>  529: <i>%% Test appending to a file.</i>
<a name="append-1"/><a name="530"/>  530: <b>append</b>(Config) when is_list(Config) -&gt;
<a name="531"/>  531:     RootDir = proplists:get_value(priv_dir, Config),
<a name="532"/>  532:     NewDir = filename:join(RootDir,
<a name="533"/>  533: 			   atom_to_list(?MODULE)
<a name="534"/>  534: 			   ++&quot;_append&quot;),
<a name="535"/>  535:     ok = ?PRIM_FILE:make_dir(NewDir),
<a name="536"/>  536: 
<a name="537"/>  537:     First = &quot;First line\n&quot;,
<a name="538"/>  538:     Second = &quot;Second lines comes here\n&quot;,
<a name="539"/>  539:     Third = &quot;And here is the third line\n&quot;,
<a name="540"/>  540: 
<a name="541"/>  541:     %% Write a small text file.
<a name="542"/>  542:     Name1 = filename:join(NewDir, &quot;a_file.txt&quot;),
<a name="543"/>  543:     {ok, Fd1} = ?PRIM_FILE:open(Name1, [write]),
<a name="544"/>  544:     ok = ?PRIM_FILE:write(Fd1, First),
<a name="545"/>  545:     ok = ?PRIM_FILE:write(Fd1, Second),
<a name="546"/>  546:     ok = ?PRIM_FILE:close(Fd1),
<a name="547"/>  547: 
<a name="548"/>  548:     %% Open it a again and a append a line to it.
<a name="549"/>  549:     {ok, Fd2} = ?PRIM_FILE:open(Name1, [append]),
<a name="550"/>  550:     ok = ?PRIM_FILE:write(Fd2, Third),
<a name="551"/>  551:     ok = ?PRIM_FILE:close(Fd2),
<a name="552"/>  552: 
<a name="553"/>  553:     %% Read it back and verify.
<a name="554"/>  554:     Expected = list_to_binary([First, Second, Third]),
<a name="555"/>  555:     {ok, Expected} = ?PRIM_FILE:read_file(Name1),
<a name="556"/>  556: 
<a name="append-last_expr"/><a name="557"/>  557:     ok.
<a name="558"/>  558: 
<a name="559"/>  559: <i>%% Test exclusive access to a file.</i>
<a name="exclusive-1"/><a name="560"/>  560: <b>exclusive</b>(Config) when is_list(Config) -&gt;
<a name="561"/>  561:     RootDir = proplists:get_value(priv_dir,Config),
<a name="562"/>  562:     NewDir = filename:join(RootDir,
<a name="563"/>  563: 			   atom_to_list(?MODULE)
<a name="564"/>  564: 			   ++&quot;_exclusive&quot;),
<a name="565"/>  565:     ok = ?PRIM_FILE:make_dir(NewDir),
<a name="566"/>  566:     Name = filename:join(NewDir, &quot;ex_file.txt&quot;),
<a name="567"/>  567:     {ok,Fd} = ?PRIM_FILE:open(Name, [write, exclusive]),
<a name="568"/>  568:     {error, eexist} = ?PRIM_FILE:open(Name, [write, exclusive]),
<a name="569"/>  569:     ok = ?PRIM_FILE:close(Fd),
<a name="exclusive-last_expr"/><a name="570"/>  570:     ok.
<a name="571"/>  571: 
<a name="572"/>  572: <i>%% Test read_file with concurrent renames and size changes.</i>
<a name="573"/>  573: 
<a name="574"/>  574: <b>-define</b>(RFRR_DATA1, &lt;&lt;&quot;gazonk&quot;&gt;&gt;).
<a name="575"/>  575: <b>-define</b>(RFRR_DATA2, &lt;&lt;&quot;fubar&quot;&gt;&gt;). % shorter than and not a prefix of DATA1
<a name="576"/>  576: 
<a name="read_file_rename_race-1"/><a name="577"/>  577: <b>read_file_rename_race</b>(Config) when is_list(Config) -&gt;
<a name="578"/>  578:     %% This test reportedly fails on Windows and Darwin 9.8.0.
<a name="579"/>  579:     Supported =
<a name="580"/>  580: 	case os:type() of
<a name="581"/>  581: 	    {win32, _} -&gt; false;
<a name="582"/>  582: 	    {unix, darwin} -&gt; os:version() &gt; {9,8,0};
<a name="583"/>  583: 	    {unix, _} -&gt; true
<a name="584"/>  584: 	end,
<a name="read_file_rename_race-last_expr"/><a name="585"/>  585:     if Supported -&gt;
<a name="586"/>  586: 	Dir = proplists:get_value(priv_dir, Config),
<a name="587"/>  587: 	Name = filename:join(Dir, &quot;filename&quot;),
<a name="588"/>  588: 	rfrr_write_file(Name, ?RFRR_DATA2),
<a name="589"/>  589: 	Mutator = spawn_link(fun() -&gt; rfrr_mutator(Name, ?RFRR_DATA1, ?RFRR_DATA2) end),
<a name="590"/>  590: 	Result = rfrr_reader(Name, 1, _N = 5000),
<a name="591"/>  591: 	unlink(Mutator),
<a name="592"/>  592: 	exit(Mutator, kill),
<a name="593"/>  593: 	ok = Result;
<a name="594"/>  594:        true -&gt;
<a name="595"/>  595: 	{skipped, &quot;Not supported on Windows, or Darwin =&lt; 9.8.0&quot;}
<a name="596"/>  596:     end.
<a name="597"/>  597: 
<a name="rfrr_reader-3"/><a name="598"/>  598: <b>rfrr_reader</b>(Name, I, N) when I &lt; N -&gt;
<a name="599"/>  599:     case rfrr_read_file(Name, I) of
<a name="600"/>  600: 	ok -&gt; rfrr_reader(Name, I + 1, N);
<a name="601"/>  601: 	error -&gt; error
<a name="602"/>  602:     end;
<a name="rfrr_reader-last_expr"/><a name="603"/>  603: <b>rfrr_reader</b>(_Name, _I, _N) -&gt; ok.
<a name="604"/>  604: 
<a name="rfrr_read_file-2"/><a name="605"/>  605: <b>rfrr_read_file</b>(Name, I) -&gt;
<a name="rfrr_read_file-last_expr"/><a name="606"/>  606: <b>    case prim_file:read_file</b>(Name) of
<a name="607"/>  607: 	{ok, ?RFRR_DATA1} -&gt; ok;
<a name="608"/>  608: 	{ok, ?RFRR_DATA2} -&gt; ok;
<a name="609"/>  609: 	Other -&gt;
<a name="610"/>  610: 	    io:format(standard_error, &quot;rfrr_read_file #~p got ~p\n&quot;, [I, Other]),
<a name="611"/>  611: 	    error
<a name="612"/>  612:     end.
<a name="613"/>  613: 
<a name="614"/>  614: <i>%% Correctness of read_file must not depend on the mutator using the</i>
<a name="615"/>  615: <i>%% file server in the reader's Erlang VM, so we use prim_file here.</i>
<a name="rfrr_mutator-3"/><a name="616"/>  616: <b>rfrr_mutator</b>(Name, Data1, Data2) -&gt;
<a name="617"/>  617:     rfrr_write_file(Name, Data1),
<a name="rfrr_mutator-last_expr"/><a name="618"/>  618: <b>    rfrr_mutator</b>(Name, Data2, Data1).
<a name="619"/>  619: 
<a name="620"/>  620: <i>%% Atomically replace Name with a new file containing Data.</i>
<a name="rfrr_write_file-2"/><a name="621"/>  621: <b>rfrr_write_file</b>(Name, Data) -&gt;
<a name="622"/>  622:     NameTmp = Name ++ &quot;.tmp&quot;, % must be in same volume as Name
<a name="623"/>  623:     ok = prim_file:write_file(NameTmp, Data),
<a name="rfrr_write_file-last_expr"/><a name="624"/>  624: <b>    ok = prim_file:rename</b>(NameTmp, Name).
<a name="625"/>  625: 
<a name="626"/>  626: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="627"/>  627: 
<a name="628"/>  628: 
<a name="pos1-1"/><a name="629"/>  629: <b>pos1</b>(Config) when is_list(Config) -&gt;
<a name="630"/>  630:     RootDir = proplists:get_value(priv_dir,Config),
<a name="631"/>  631:     Name = filename:join(RootDir,
<a name="632"/>  632: 			 atom_to_list(?MODULE)
<a name="633"/>  633: 			 ++&quot;_pos1.fil&quot;),
<a name="634"/>  634:     {ok, Fd1} = ?PRIM_FILE:open(Name, [write]),
<a name="635"/>  635:     ?PRIM_FILE:write(Fd1,&lt;&lt;&quot;ABCDEFGH&quot;&gt;&gt;),
<a name="636"/>  636:     ok        = ?PRIM_FILE:close(Fd1),
<a name="637"/>  637:     {ok, Fd2} = ?PRIM_FILE:open(Name, [read]),
<a name="638"/>  638: 
<a name="639"/>  639:     %% Start pos is first char
<a name="640"/>  640:     io:format(&quot;Relative positions&quot;),
<a name="641"/>  641:     {ok, &lt;&lt;&quot;A&quot;&gt;&gt;} = ?PRIM_FILE:read(Fd2,1),
<a name="642"/>  642:     {ok, 2}   = ?PRIM_FILE:position(Fd2,{cur,1}),
<a name="643"/>  643:     {ok, &lt;&lt;&quot;C&quot;&gt;&gt;} = ?PRIM_FILE:read(Fd2,1),
<a name="644"/>  644:     {ok, 0}   = ?PRIM_FILE:position(Fd2,{cur,-3}),
<a name="645"/>  645:     {ok, &lt;&lt;&quot;A&quot;&gt;&gt;} = ?PRIM_FILE:read(Fd2,1),
<a name="646"/>  646:     %% Backwards from first char should be an error
<a name="647"/>  647:     {ok,0}    = ?PRIM_FILE:position(Fd2,{cur,-1}),
<a name="648"/>  648:     {error, einval} = ?PRIM_FILE:position(Fd2,{cur,-1}),
<a name="649"/>  649:     %% Reset position and move again
<a name="650"/>  650:     {ok, 0}   = ?PRIM_FILE:position(Fd2,0),
<a name="651"/>  651:     {ok, 2}   = ?PRIM_FILE:position(Fd2,{cur,2}),
<a name="652"/>  652:     {ok, &lt;&lt;&quot;C&quot;&gt;&gt;} = ?PRIM_FILE:read(Fd2,1),
<a name="653"/>  653:     %% Go a lot forwards
<a name="654"/>  654:     {ok, 13}  = ?PRIM_FILE:position(Fd2,{cur,10}),
<a name="655"/>  655:     eof       = ?PRIM_FILE:read(Fd2,1),
<a name="656"/>  656: 
<a name="657"/>  657:     %% Try some fixed positions
<a name="658"/>  658:     io:format(&quot;Fixed positions&quot;),
<a name="659"/>  659:     {ok, 8}   = ?PRIM_FILE:position(Fd2,8),
<a name="660"/>  660:     eof = ?PRIM_FILE:read(Fd2,1),
<a name="661"/>  661:     {ok, 8}   = ?PRIM_FILE:position(Fd2,cur),
<a name="662"/>  662:     eof = ?PRIM_FILE:read(Fd2,1),
<a name="663"/>  663:     {ok, 7}   = ?PRIM_FILE:position(Fd2,7),
<a name="664"/>  664:     {ok, &lt;&lt;&quot;H&quot;&gt;&gt;} = ?PRIM_FILE:read(Fd2,1),
<a name="665"/>  665:     {ok, 0}   = ?PRIM_FILE:position(Fd2,0),
<a name="666"/>  666:     {ok, &lt;&lt;&quot;A&quot;&gt;&gt;} = ?PRIM_FILE:read(Fd2,1),
<a name="667"/>  667:     {ok, 3}   = ?PRIM_FILE:position(Fd2,3),
<a name="668"/>  668:     {ok, &lt;&lt;&quot;D&quot;&gt;&gt;} = ?PRIM_FILE:read(Fd2,1),
<a name="669"/>  669:     {ok, 12}  = ?PRIM_FILE:position(Fd2,12),
<a name="670"/>  670:     eof       = ?PRIM_FILE:read(Fd2,1),
<a name="671"/>  671:     {ok, 3}   = ?PRIM_FILE:position(Fd2,3),
<a name="672"/>  672:     {ok, &lt;&lt;&quot;D&quot;&gt;&gt;} = ?PRIM_FILE:read(Fd2,1),
<a name="673"/>  673:     %% Try the {bof,X} notation
<a name="674"/>  674:     {ok, 3}   = ?PRIM_FILE:position(Fd2,{bof,3}),
<a name="675"/>  675:     {ok, &lt;&lt;&quot;D&quot;&gt;&gt;} = ?PRIM_FILE:read(Fd2,1),
<a name="676"/>  676: 
<a name="677"/>  677:     %% Try eof positions
<a name="678"/>  678:     io:format(&quot;EOF positions&quot;),
<a name="679"/>  679:     {ok, 8}   = ?PRIM_FILE:position(Fd2,{eof,0}),
<a name="680"/>  680:     eof       = ?PRIM_FILE:read(Fd2,1),
<a name="681"/>  681:     {ok, 7}   = ?PRIM_FILE:position(Fd2,{eof,-1}),
<a name="682"/>  682:     {ok, &lt;&lt;&quot;H&quot;&gt;&gt;} = ?PRIM_FILE:read(Fd2,1),
<a name="683"/>  683:     {ok, 0}   = ?PRIM_FILE:position(Fd2,{eof,-8}),
<a name="684"/>  684:     {ok, &lt;&lt;&quot;A&quot;&gt;&gt;} = ?PRIM_FILE:read(Fd2,1),
<a name="685"/>  685:     {error, einval} = ?PRIM_FILE:position(Fd2,{eof,-9}),
<a name="pos1-last_expr"/><a name="686"/>  686:     ok.
<a name="687"/>  687: 
<a name="pos2-1"/><a name="688"/>  688: <b>pos2</b>(Config) when is_list(Config) -&gt;
<a name="689"/>  689:     RootDir = proplists:get_value(priv_dir,Config),
<a name="690"/>  690:     Name = filename:join(RootDir,
<a name="691"/>  691: 			 atom_to_list(?MODULE)
<a name="692"/>  692: 			 ++&quot;_pos2.fil&quot;),
<a name="693"/>  693:     {ok,Fd1} = ?PRIM_FILE:open(Name, [write]),
<a name="694"/>  694:     ?PRIM_FILE:write(Fd1,&lt;&lt;&quot;ABCDEFGH&quot;&gt;&gt;),
<a name="695"/>  695:     ok = ?PRIM_FILE:close(Fd1),
<a name="696"/>  696:     {ok, Fd2} = ?PRIM_FILE:open(Name, [read]),
<a name="697"/>  697:     {error, einval} = ?PRIM_FILE:position(Fd2,-1),
<a name="698"/>  698: 
<a name="699"/>  699:     %% Make sure that we still can search after an error.
<a name="700"/>  700:     {ok, 0}   = ?PRIM_FILE:position(Fd2, 0),
<a name="701"/>  701:     {ok, 3}   = ?PRIM_FILE:position(Fd2, {bof,3}),
<a name="702"/>  702:     {ok, &lt;&lt;&quot;D&quot;&gt;&gt;} = ?PRIM_FILE:read(Fd2,1),
<a name="703"/>  703: 
<a name="704"/>  704:     io:format(&quot;DONE&quot;),
<a name="pos2-last_expr"/><a name="705"/>  705:     ok.
<a name="706"/>  706: 
<a name="file_info_basic_file-1"/><a name="707"/>  707: <b>file_info_basic_file</b>(Config) when is_list(Config) -&gt;
<a name="708"/>  708:     RootDir = proplists:get_value(priv_dir, Config),
<a name="709"/>  709: 
<a name="710"/>  710:     %% Create a short file.
<a name="711"/>  711:     Name = filename:join(RootDir,
<a name="712"/>  712: 			 atom_to_list(?MODULE)
<a name="713"/>  713: 			 ++&quot;_basic_test&quot;&quot;.fil&quot;),
<a name="714"/>  714:     {ok,Fd1} = ?PRIM_FILE:open(Name, [write]),
<a name="715"/>  715:     ?PRIM_FILE:write(Fd1, &quot;foo bar&quot;),
<a name="716"/>  716:     ok = ?PRIM_FILE:close(Fd1),
<a name="717"/>  717: 
<a name="718"/>  718:     %% Test that the file has the expected attributes.
<a name="719"/>  719:     %% The times are tricky, so we will save them to a separate test case.
<a name="720"/>  720:     {ok, FileInfo} = ?PRIM_FILE:read_file_info(Name),
<a name="721"/>  721:     #file_info{size = Size, type = Type, access = Access,
<a name="722"/>  722: 	       atime = AccessTime, mtime = ModifyTime} =
<a name="723"/>  723: 	FileInfo,
<a name="724"/>  724:     io:format(&quot;Access ~p, Modify ~p&quot;, [AccessTime, ModifyTime]),
<a name="725"/>  725:     Size = 7,
<a name="726"/>  726:     Type = regular,
<a name="727"/>  727:     Access = read_write,
<a name="728"/>  728:     true = abs(time_dist(filter_atime(AccessTime, Config),
<a name="729"/>  729: 			 filter_atime(ModifyTime,
<a name="730"/>  730: 				      Config))) &lt; 2,
<a name="731"/>  731:     {AD, AT} = AccessTime,
<a name="732"/>  732:     all_integers(tuple_to_list(AD) ++ tuple_to_list(AT)),
<a name="733"/>  733:     {MD, MT} = ModifyTime,
<a name="734"/>  734:     all_integers(tuple_to_list(MD) ++ tuple_to_list(MT)),
<a name="735"/>  735: 
<a name="file_info_basic_file-last_expr"/><a name="736"/>  736:     ok.
<a name="737"/>  737: 
<a name="file_info_basic_directory-1"/><a name="738"/>  738: <b>file_info_basic_directory</b>(Config) when is_list(Config) -&gt;
<a name="739"/>  739:     %% Note: filename:join/1 removes any trailing slash,
<a name="740"/>  740:     %% which is essential for ?PRIM_FILE:read_file_info/1 to work on
<a name="741"/>  741:     %% platforms such as Windows95.
<a name="742"/>  742:     RootDir = filename:join([proplists:get_value(priv_dir, Config)]),
<a name="743"/>  743: 
<a name="744"/>  744:     %% Test that the RootDir directory has the expected attributes.
<a name="745"/>  745:     test_directory(RootDir, read_write),
<a name="746"/>  746: 
<a name="747"/>  747:     %% Note that on Windows file systems, &quot;/&quot; or &quot;c:/&quot; are *NOT* directories.
<a name="748"/>  748:     %% Therefore, test that ?PRIM_FILE:read_file_info/1 behaves 
<a name="749"/>  749:     %% as if they were directories.
<a name="750"/>  750:     case os:type() of
<a name="751"/>  751: 	{win32, _} -&gt;
<a name="752"/>  752: 	    test_directory(&quot;/&quot;, read_write),
<a name="753"/>  753: 	    test_directory(&quot;c:/&quot;, read_write),
<a name="754"/>  754: 	    test_directory(&quot;c:\\&quot;, read_write);
<a name="755"/>  755: 	_ -&gt;
<a name="756"/>  756: 	    test_directory(&quot;/&quot;, read)
<a name="757"/>  757:     end,
<a name="file_info_basic_directory-last_expr"/><a name="758"/>  758:     ok.
<a name="759"/>  759: 
<a name="test_directory-2"/><a name="760"/>  760: <b>test_directory</b>(Name, ExpectedAccess) -&gt;
<a name="761"/>  761:     {ok, FileInfo} = ?PRIM_FILE:read_file_info(Name),
<a name="762"/>  762:     #file_info{size = Size, type = Type, access = Access,
<a name="763"/>  763: 	       atime = AccessTime, mtime = ModifyTime} =
<a name="764"/>  764: 	FileInfo,
<a name="765"/>  765:     io:format(&quot;Testing directory ~s&quot;, [Name]),
<a name="766"/>  766:     io:format(&quot;Directory size is ~p&quot;, [Size]),
<a name="767"/>  767:     io:format(&quot;Access ~p&quot;, [Access]),
<a name="768"/>  768:     io:format(&quot;Access time ~p; Modify time~p&quot;,
<a name="769"/>  769: 	      [AccessTime, ModifyTime]),
<a name="770"/>  770:     Type = directory,
<a name="771"/>  771:     Access = ExpectedAccess,
<a name="772"/>  772:     {AD, AT} = AccessTime,
<a name="773"/>  773:     all_integers(tuple_to_list(AD) ++ tuple_to_list(AT)),
<a name="774"/>  774:     {MD, MT} = ModifyTime,
<a name="775"/>  775:     all_integers(tuple_to_list(MD) ++ tuple_to_list(MT)),
<a name="test_directory-last_expr"/><a name="776"/>  776:     ok.
<a name="777"/>  777: 
<a name="all_integers-1"/><a name="778"/>  778: <b>all_integers</b>([Int|Rest]) when is_integer(Int) -&gt;
<a name="779"/>  779:     all_integers(Rest);
<a name="780"/>  780: <b>all_integers</b>([]) -&gt;
<a name="all_integers-last_expr"/><a name="781"/>  781:     ok.
<a name="782"/>  782: 
<a name="783"/>  783: <i>%% Try something nonexistent.</i>
<a name="784"/>  784: 
<a name="file_info_bad-1"/><a name="785"/>  785: <b>file_info_bad</b>(Config) when is_list(Config) -&gt;
<a name="786"/>  786:     RootDir = filename:join([proplists:get_value(priv_dir, Config)]),
<a name="787"/>  787:     NonExistent = filename:join(RootDir, atom_to_list(?MODULE)++&quot;_nonexistent&quot;),
<a name="788"/>  788:     {error, enoent} = ?PRIM_FILE:read_file_info(NonExistent),
<a name="file_info_bad-last_expr"/><a name="789"/>  789:     ok.
<a name="790"/>  790: 
<a name="791"/>  791: <i>%% Test that the file times behave as they should.</i>
<a name="792"/>  792: 
<a name="file_info_times-1"/><a name="793"/>  793: <b>file_info_times</b>(Config) when is_list(Config) -&gt;
<a name="794"/>  794:     %% We have to try this twice, since if the test runs across the change
<a name="795"/>  795:     %% of a month the time diff calculations will fail. But it won't happen
<a name="796"/>  796:     %% if you run it twice in succession.
<a name="797"/>  797:     test_server:m_out_of_n(
<a name="798"/>  798:       1,2,
<a name="799"/>  799:       fun() -&gt; file_info_int(Config) end),
<a name="file_info_times-last_expr"/><a name="800"/>  800:     ok.
<a name="801"/>  801: 
<a name="file_info_int-1"/><a name="802"/>  802: <b>file_info_int</b>(Config) -&gt;
<a name="803"/>  803:     %% Note: filename:join/1 removes any trailing slash,
<a name="804"/>  804:     %% which is essential for ?PRIM_FILE:read_file_info/1 to work on
<a name="805"/>  805:     %% platforms such as Windows95.
<a name="806"/>  806: 
<a name="807"/>  807:     RootDir = filename:join([proplists:get_value(priv_dir, Config)]),
<a name="808"/>  808:     io:format(&quot;RootDir = ~p&quot;, [RootDir]),
<a name="809"/>  809: 
<a name="810"/>  810:     Name = filename:join(RootDir,
<a name="811"/>  811: 			 atom_to_list(?MODULE)
<a name="812"/>  812: 			 ++&quot;_file_info.fil&quot;),
<a name="813"/>  813:     {ok,Fd1} = ?PRIM_FILE:open(Name, [write]),
<a name="814"/>  814:     ?PRIM_FILE:write(Fd1,&quot;foo&quot;),
<a name="815"/>  815: 
<a name="816"/>  816:     %% check that the file got a modify date max a few seconds away from now
<a name="817"/>  817:     {ok, #file_info{type = regular,
<a name="818"/>  818: 		    atime = AccTime1, mtime = ModTime1}} =
<a name="819"/>  819: 	?PRIM_FILE:read_file_info(Name),
<a name="820"/>  820:     Now = erlang:localtime(),
<a name="821"/>  821:     io:format(&quot;Now ~p&quot;,[Now]),
<a name="822"/>  822:     io:format(&quot;Open file Acc ~p Mod ~p&quot;,[AccTime1,ModTime1]),
<a name="823"/>  823:     true = abs(time_dist(filter_atime(Now, Config),
<a name="824"/>  824: 			 filter_atime(AccTime1,
<a name="825"/>  825: 				      Config))) &lt; 8,
<a name="826"/>  826:     true = abs(time_dist(Now, ModTime1)) &lt; 8,
<a name="827"/>  827: 
<a name="828"/>  828:     %% Sleep until we can be sure the seconds value has changed.
<a name="829"/>  829:     %% Note: FAT-based filesystem (like on Windows 95) have
<a name="830"/>  830:     %% a resolution of 2 seconds.
<a name="831"/>  831:     ct:sleep({seconds,2.2}),
<a name="832"/>  832: 
<a name="833"/>  833:     %% close the file, and watch the modify date change
<a name="834"/>  834:     ok = ?PRIM_FILE:close(Fd1),
<a name="835"/>  835:     {ok, #file_info{size = Size, type = regular, access = Access,
<a name="836"/>  836: 		    atime = AccTime2, mtime = ModTime2}} =
<a name="837"/>  837: 	?PRIM_FILE:read_file_info(Name),
<a name="838"/>  838:     io:format(&quot;Closed file Acc ~p Mod ~p&quot;,[AccTime2,ModTime2]),
<a name="839"/>  839:     true = time_dist(ModTime1, ModTime2) &gt;= 0,
<a name="840"/>  840: 
<a name="841"/>  841:     %% this file is supposed to be binary, so it'd better keep it's size
<a name="842"/>  842:     Size = 3,
<a name="843"/>  843:     Access = read_write,
<a name="844"/>  844: 
<a name="845"/>  845:     %% Do some directory checking
<a name="846"/>  846:     {ok, #file_info{size = DSize, type = directory,
<a name="847"/>  847: 		    access = DAccess,
<a name="848"/>  848: 		    atime = AccTime3, mtime = ModTime3}} =
<a name="849"/>  849: 	?PRIM_FILE:read_file_info(RootDir),
<a name="850"/>  850:     %% this dir was modified only a few secs ago
<a name="851"/>  851:     io:format(&quot;Dir Acc ~p; Mod ~p; Now ~p&quot;,
<a name="852"/>  852: 	      [AccTime3, ModTime3, Now]),
<a name="853"/>  853:     true = abs(time_dist(Now, ModTime3)) &lt; 5,
<a name="854"/>  854:     DAccess = read_write,
<a name="855"/>  855:     io:format(&quot;Dir size is ~p&quot;,[DSize]),
<a name="file_info_int-last_expr"/><a name="856"/>  856:     ok.
<a name="857"/>  857: 
<a name="858"/>  858: <i>%% Filter access times, to cope with a deficiency of FAT file systems</i>
<a name="859"/>  859: <i>%% (on Windows): The access time is actually only a date.</i>
<a name="860"/>  860: 
<a name="filter_atime-2"/><a name="861"/>  861: <b>filter_atime</b>(Atime, Config) -&gt;
<a name="filter_atime-last_expr"/><a name="862"/>  862: <b>    case lists:member</b>(no_access_time, Config) of
<a name="863"/>  863: 	true -&gt;
<a name="864"/>  864: 	    case Atime of
<a name="865"/>  865: 	    	{Date, _} -&gt;
<a name="866"/>  866: 		    {Date, {0, 0, 0}};
<a name="867"/>  867: 		{Y, M, D, _, _, _} -&gt;
<a name="868"/>  868: 		    {Y, M, D, 0, 0, 0}
<a name="869"/>  869: 	    end;
<a name="870"/>  870: 	false -&gt;
<a name="871"/>  871: 	    Atime
<a name="872"/>  872:     end.
<a name="873"/>  873: 
<a name="874"/>  874: <i>%% Test the write_file_info/2 function.</i>
<a name="875"/>  875: 
<a name="file_write_file_info-1"/><a name="876"/>  876: <b>file_write_file_info</b>(Config) when is_list(Config) -&gt;
<a name="877"/>  877:     RootDir = get_good_directory(Config),
<a name="878"/>  878:     io:format(&quot;RootDir = ~p&quot;, [RootDir]),
<a name="879"/>  879: 
<a name="880"/>  880:     %% Set the file to read only AND update the file times at the same time.
<a name="881"/>  881:     %% (This used to fail on Windows NT/95 for a local filesystem.)
<a name="882"/>  882:     %% Note: Seconds must be even; see note in file_info_times/1.
<a name="883"/>  883: 
<a name="884"/>  884:     Name = filename:join(RootDir,
<a name="885"/>  885: 			 atom_to_list(?MODULE)
<a name="886"/>  886: 			 ++&quot;_write_file_info_ro&quot;),
<a name="887"/>  887:     ok = ?PRIM_FILE:write_file(Name, &quot;hello&quot;),
<a name="888"/>  888:     Time = {{1997, 01, 02}, {12, 35, 42}},
<a name="889"/>  889:     Info = #file_info{mode=8#400, atime=Time, mtime=Time, ctime=Time},
<a name="890"/>  890:     ok = ?PRIM_FILE:write_file_info(Name, Info),
<a name="891"/>  891: 
<a name="892"/>  892:     %% Read back the times.
<a name="893"/>  893: 
<a name="894"/>  894:     {ok, ActualInfo} =
<a name="895"/>  895: 	?PRIM_FILE:read_file_info(Name),
<a name="896"/>  896:     #file_info{mode=_Mode, atime=ActAtime, mtime=Time,
<a name="897"/>  897: 	       ctime=ActCtime} = ActualInfo,
<a name="898"/>  898:     FilteredAtime = filter_atime(Time, Config),
<a name="899"/>  899:     FilteredAtime = filter_atime(ActAtime, Config),
<a name="900"/>  900:     case os:type() of
<a name="901"/>  901: 	{win32, _} -&gt;
<a name="902"/>  902: 	    %% On Windows, &quot;ctime&quot; means creation time and it can
<a name="903"/>  903: 	    %% be set.
<a name="904"/>  904: 	    ActCtime = Time;
<a name="905"/>  905: 	_ -&gt;
<a name="906"/>  906: 	    ok
<a name="907"/>  907:     end,
<a name="908"/>  908:     {error, eacces} = ?PRIM_FILE:write_file(Name, &quot;hello again&quot;),
<a name="909"/>  909: 
<a name="910"/>  910:     %% Make the file writable again.
<a name="911"/>  911:     ?PRIM_FILE:write_file_info(Name, #file_info{mode=8#600}),
<a name="912"/>  912:     ok = ?PRIM_FILE:write_file(Name, &quot;hello again&quot;),
<a name="913"/>  913: 
<a name="914"/>  914:     %% And unwritable.
<a name="915"/>  915:     ?PRIM_FILE:write_file_info(Name, #file_info{mode=8#400}),
<a name="916"/>  916:     {error, eacces} = ?PRIM_FILE:write_file(Name, &quot;hello again&quot;),
<a name="917"/>  917: 
<a name="918"/>  918:     %% Write the times again.
<a name="919"/>  919:     %% Note: Seconds must be even; see note in file_info_times/1.
<a name="920"/>  920: 
<a name="921"/>  921:     NewTime = {{1997, 02, 15}, {13, 18, 20}},
<a name="922"/>  922:     NewInfo = #file_info{atime=NewTime, mtime=NewTime, ctime=NewTime},
<a name="923"/>  923:     ok = ?PRIM_FILE:write_file_info(Name, NewInfo),
<a name="924"/>  924:     {ok, ActualInfo2} =
<a name="925"/>  925: 	?PRIM_FILE:read_file_info(Name),
<a name="926"/>  926:     #file_info{atime=NewActAtime, mtime=NewTime,
<a name="927"/>  927: 	       ctime=NewActCtime} = ActualInfo2,
<a name="928"/>  928:     NewFilteredAtime = filter_atime(NewTime, Config),
<a name="929"/>  929:     NewFilteredAtime = filter_atime(NewActAtime, Config),
<a name="930"/>  930:     case os:type() of
<a name="931"/>  931: 	{win32, _} -&gt; NewActCtime = NewTime;
<a name="932"/>  932: 	_ -&gt; ok
<a name="933"/>  933:     end,
<a name="934"/>  934: 
<a name="935"/>  935:     %% The file should still be unwritable.
<a name="936"/>  936:     {error, eacces} = ?PRIM_FILE:write_file(Name, &quot;hello again&quot;),
<a name="937"/>  937: 
<a name="938"/>  938:     %% Make the file writeable again, so that we can remove the
<a name="939"/>  939:     %% test suites ... :-)
<a name="940"/>  940:     ?PRIM_FILE:write_file_info(Name, #file_info{mode=8#600}),
<a name="file_write_file_info-last_expr"/><a name="941"/>  941:     ok.
<a name="942"/>  942: 
<a name="943"/>  943: <i>%% Test the write_file_info/3 function.</i>
<a name="944"/>  944: 
<a name="file_write_file_info_opts-1"/><a name="945"/>  945: <b>file_write_file_info_opts</b>(Config) when is_list(Config) -&gt;
<a name="946"/>  946:     RootDir = get_good_directory(Config),
<a name="947"/>  947:     io:format(&quot;RootDir = ~p&quot;, [RootDir]),
<a name="948"/>  948: 
<a name="949"/>  949:     Name = filename:join(RootDir, atom_to_list(?MODULE) ++&quot;_write_file_info_opts&quot;),
<a name="950"/>  950:     ok   = ?PRIM_FILE:write_file(Name, &quot;hello_opts&quot;),
<a name="951"/>  951: 
<a name="952"/>  952:     lists:foreach(fun
<a name="953"/>  953: 		      ({FI, Opts}) -&gt;
<a name="954"/>  954: 			 ok = ?PRIM_FILE:write_file_info(Name, FI, Opts)
<a name="955"/>  955: 		 end, [
<a name="956"/>  956: 			{#file_info{ mode=8#600, atime = Time, mtime = Time, ctime = Time}, Opts} ||
<a name="957"/>  957: 			  Opts &lt;- [[{time, posix}]],
<a name="958"/>  958: 			  Time &lt;- [ 0,1,-1,100,-100,1000,-1000,10000,-10000 ]
<a name="959"/>  959: 		      ]),
<a name="960"/>  960: 
<a name="961"/>  961:     %% REM: determine date range dependent on time_t = Uint32 | Sint32 | Sint64 | Uint64
<a name="962"/>  962:     %% Determine time_t on os:type()?
<a name="963"/>  963:     lists:foreach(fun ({FI, Opts}) -&gt;
<a name="964"/>  964: 			 ok = ?PRIM_FILE:write_file_info(Name, FI, Opts)
<a name="965"/>  965: 		 end, [ {#file_info{ mode=8#400, atime = Time, mtime = Time, ctime = Time}, Opts} ||
<a name="966"/>  966: 			  Opts &lt;- [[{time, universal}],[{time, local}]],
<a name="967"/>  967: 			  Time &lt;- [
<a name="968"/>  968: 				   {{1970,1,1},{0,0,0}},
<a name="969"/>  969: 				   {{1970,1,1},{0,0,1}},
<a name="970"/>  970: 			%	   {{1969,12,31},{23,59,59}},
<a name="971"/>  971: 			%	   {{1908,2,3},{23,59,59}},
<a name="972"/>  972: 				   {{2012,2,3},{23,59,59}},
<a name="973"/>  973: 				   {{2037,2,3},{23,59,59}},
<a name="974"/>  974: 				   erlang:localtime()
<a name="975"/>  975: 				  ]]),
<a name="file_write_file_info_opts-last_expr"/><a name="976"/>  976:     ok.
<a name="977"/>  977: 
<a name="file_read_file_info_opts-1"/><a name="978"/>  978: <b>file_read_file_info_opts</b>(Config) when is_list(Config) -&gt;
<a name="979"/>  979:     RootDir = get_good_directory(Config),
<a name="980"/>  980:     io:format(&quot;RootDir = ~p&quot;, [RootDir]),
<a name="981"/>  981: 
<a name="982"/>  982:     Name = filename:join(RootDir, atom_to_list(?MODULE) ++&quot;_read_file_info_opts&quot;),
<a name="983"/>  983:     ok   = ?PRIM_FILE:write_file(Name, &quot;hello_opts&quot;),
<a name="984"/>  984: 
<a name="985"/>  985:     lists:foreach(fun
<a name="986"/>  986: 		      (Opts) -&gt;
<a name="987"/>  987: 			 {ok,_} = ?PRIM_FILE:read_file_info(Name, Opts)
<a name="988"/>  988: 		 end, [[{time, Type}] || Type &lt;- [local, universal, posix]]),
<a name="file_read_file_info_opts-last_expr"/><a name="989"/>  989:     ok.
<a name="990"/>  990: 
<a name="991"/>  991: <i>%% Test the write and read back *_file_info/3 functions.</i>
<a name="992"/>  992: 
<a name="file_write_read_file_info_opts-1"/><a name="993"/>  993: <b>file_write_read_file_info_opts</b>(Config) when is_list(Config) -&gt;
<a name="994"/>  994:     RootDir = get_good_directory(Config),
<a name="995"/>  995:     io:format(&quot;RootDir = ~p&quot;, [RootDir]),
<a name="996"/>  996: 
<a name="997"/>  997:     Name = filename:join(RootDir, atom_to_list(?MODULE) ++&quot;_read_write_file_info_opts&quot;),
<a name="998"/>  998:     ok   = ?PRIM_FILE:write_file(Name, &quot;hello_opts2&quot;),
<a name="999"/>  999: 
<a name="1000"/> 1000:     ok = file_write_read_file_info_opts(Name, {{1989, 04, 28}, {19,30,22}}, [{time, local}]),
<a name="1001"/> 1001:     ok = file_write_read_file_info_opts(Name, {{1989, 04, 28}, {19,30,22}}, [{time, universal}]),
<a name="1002"/> 1002:     %% will not work on platforms with unsigned time_t
<a name="1003"/> 1003:     %ok = file_write_read_file_info_opts(Name, {{1930, 04, 28}, {19,30,22}}, [{time, local}]),
<a name="1004"/> 1004:     %ok = file_write_read_file_info_opts(Name, {{1930, 04, 28}, {19,30,22}}, [{time, universal}]),
<a name="1005"/> 1005:     ok = file_write_read_file_info_opts(Name, 1, [{time, posix}]),
<a name="1006"/> 1006:     %% will not work on platforms with unsigned time_t
<a name="1007"/> 1007:     %ok = file_write_read_file_info_opts(Name, -1, [{time, posix}]),
<a name="1008"/> 1008:     %ok = file_write_read_file_info_opts(Name, -300000, [{time, posix}]),
<a name="1009"/> 1009:     ok = file_write_read_file_info_opts(Name, 300000, [{time, posix}]),
<a name="1010"/> 1010:     ok = file_write_read_file_info_opts(Name, 0, [{time, posix}]),
<a name="1011"/> 1011: 
<a name="file_write_read_file_info_opts-last_expr"/><a name="1012"/> 1012:     ok.
<a name="1013"/> 1013: 
<a name="file_write_read_file_info_opts-3"/><a name="1014"/> 1014: <b>file_write_read_file_info_opts</b>(Name, Mtime, Opts) -&gt;
<a name="1015"/> 1015:     {ok, FI} = ?PRIM_FILE:read_file_info(Name, Opts),
<a name="1016"/> 1016:     FI2 = FI#file_info{ mtime = Mtime },
<a name="1017"/> 1017:     ok = ?PRIM_FILE:write_file_info(Name, FI2, Opts),
<a name="1018"/> 1018:     {ok, FI3} = ?PRIM_FILE:read_file_info(Name, Opts),
<a name="1019"/> 1019:     io:format(&quot;Expecting mtime = ~p, got ~p~n&quot;, [FI2#file_info.mtime, FI3#file_info.mtime]),
<a name="1020"/> 1020:     FI2 = FI3,
<a name="file_write_read_file_info_opts-last_expr"/><a name="1021"/> 1021:     ok.
<a name="1022"/> 1022: 
<a name="1023"/> 1023: 
<a name="1024"/> 1024: 
<a name="1025"/> 1025: <i>%% Returns a directory on a file system that has correct file times.</i>
<a name="1026"/> 1026: 
<a name="get_good_directory-1"/><a name="1027"/> 1027: <b>get_good_directory</b>(Config) -&gt;
<a name="get_good_directory-last_expr"/><a name="1028"/> 1028: <b>    proplists:get_value</b>(priv_dir, Config).
<a name="1029"/> 1029: 
<a name="truncate-1"/><a name="1030"/> 1030: <b>truncate</b>(Config) when is_list(Config) -&gt;
<a name="1031"/> 1031:     RootDir = proplists:get_value(priv_dir,Config),
<a name="1032"/> 1032:     Name = filename:join(RootDir,
<a name="1033"/> 1033: 			 atom_to_list(?MODULE)
<a name="1034"/> 1034: 			 ++&quot;_truncate.fil&quot;),
<a name="1035"/> 1035: 
<a name="1036"/> 1036:     %% Create a file with some data.
<a name="1037"/> 1037:     MyData = &quot;0123456789abcdefghijklmnopqrstuvxyz&quot;,
<a name="1038"/> 1038:     ok = ?PRIM_FILE:write_file(Name, MyData),
<a name="1039"/> 1039: 
<a name="1040"/> 1040:     %% Truncate the file to 10 characters.
<a name="1041"/> 1041:     {ok, Fd} = ?PRIM_FILE:open(Name, [read, write]),
<a name="1042"/> 1042:     {ok, 10} = ?PRIM_FILE:position(Fd, 10),
<a name="1043"/> 1043:     ok = ?PRIM_FILE:truncate(Fd),
<a name="1044"/> 1044:     ok = ?PRIM_FILE:close(Fd),
<a name="1045"/> 1045: 
<a name="1046"/> 1046:     %% Read back the file and check that it has been truncated.
<a name="1047"/> 1047:     Expected = list_to_binary(&quot;0123456789&quot;),
<a name="1048"/> 1048:     {ok, Expected} = ?PRIM_FILE:read_file(Name),
<a name="1049"/> 1049: 
<a name="1050"/> 1050:     %% Open the file read only and verify that it is not possible to
<a name="1051"/> 1051:     %% truncate it, OTP-1960
<a name="1052"/> 1052:     {ok, Fd2} = ?PRIM_FILE:open(Name, [read]),
<a name="1053"/> 1053:     {ok, 5} = ?PRIM_FILE:position(Fd2, 5),
<a name="1054"/> 1054:     {error, _} = ?PRIM_FILE:truncate(Fd2),
<a name="1055"/> 1055: 
<a name="truncate-last_expr"/><a name="1056"/> 1056:     ok.
<a name="1057"/> 1057: 
<a name="1058"/> 1058: 
<a name="1059"/> 1059: <i>%% Tests that ?PRIM_FILE:datasync/1 at least doesn't crash.</i>
<a name="datasync-1"/><a name="1060"/> 1060: <b>datasync</b>(Config) when is_list(Config) -&gt;
<a name="1061"/> 1061:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="1062"/> 1062:     Sync = filename:join(PrivDir,
<a name="1063"/> 1063: 			 atom_to_list(?MODULE)
<a name="1064"/> 1064: 			 ++&quot;_sync.fil&quot;),
<a name="1065"/> 1065: 
<a name="1066"/> 1066:     %% Raw open.
<a name="1067"/> 1067:     {ok, Fd} = ?PRIM_FILE:open(Sync, [write]),
<a name="1068"/> 1068:     ok = ?PRIM_FILE:datasync(Fd),
<a name="1069"/> 1069:     ok = ?PRIM_FILE:close(Fd),
<a name="1070"/> 1070: 
<a name="datasync-last_expr"/><a name="1071"/> 1071:     ok.
<a name="1072"/> 1072: 
<a name="1073"/> 1073: 
<a name="1074"/> 1074: <i>%% Tests that ?PRIM_FILE:sync/1 at least doesn't crash.</i>
<a name="sync-1"/><a name="1075"/> 1075: <b>sync</b>(Config) when is_list(Config) -&gt;
<a name="1076"/> 1076:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="1077"/> 1077:     Sync = filename:join(PrivDir,
<a name="1078"/> 1078: 			 atom_to_list(?MODULE)
<a name="1079"/> 1079: 			 ++&quot;_sync.fil&quot;),
<a name="1080"/> 1080: 
<a name="1081"/> 1081:     %% Raw open.
<a name="1082"/> 1082:     {ok, Fd} = ?PRIM_FILE:open(Sync, [write]),
<a name="1083"/> 1083:     ok = ?PRIM_FILE:sync(Fd),
<a name="1084"/> 1084:     ok = ?PRIM_FILE:close(Fd),
<a name="1085"/> 1085: 
<a name="sync-last_expr"/><a name="1086"/> 1086:     ok.
<a name="1087"/> 1087: 
<a name="1088"/> 1088: 
<a name="1089"/> 1089: <i>%% Tests that ?PRIM_FILE:advise/4 at least doesn't crash.</i>
<a name="advise-1"/><a name="1090"/> 1090: <b>advise</b>(Config) when is_list(Config) -&gt;
<a name="1091"/> 1091:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="1092"/> 1092:     Advise = filename:join(PrivDir,
<a name="1093"/> 1093: 			   atom_to_list(?MODULE)
<a name="1094"/> 1094: 			   ++&quot;_advise.fil&quot;),
<a name="1095"/> 1095: 
<a name="1096"/> 1096:     Line1 = &lt;&lt;&quot;Hello\n&quot;&gt;&gt;,
<a name="1097"/> 1097:     Line2 = &lt;&lt;&quot;World!\n&quot;&gt;&gt;,
<a name="1098"/> 1098: 
<a name="1099"/> 1099:     {ok, Fd} = ?PRIM_FILE:open(Advise, [write]),
<a name="1100"/> 1100:     ok = ?PRIM_FILE:advise(Fd, 0, 0, normal),
<a name="1101"/> 1101:     ok = ?PRIM_FILE:write(Fd, Line1),
<a name="1102"/> 1102:     ok = ?PRIM_FILE:write(Fd, Line2),
<a name="1103"/> 1103:     ok = ?PRIM_FILE:close(Fd),
<a name="1104"/> 1104: 
<a name="1105"/> 1105:     {ok, Fd2} = ?PRIM_FILE:open(Advise, [write]),
<a name="1106"/> 1106:     ok = ?PRIM_FILE:advise(Fd2, 0, 0, random),
<a name="1107"/> 1107:     ok = ?PRIM_FILE:write(Fd2, Line1),
<a name="1108"/> 1108:     ok = ?PRIM_FILE:write(Fd2, Line2),
<a name="1109"/> 1109:     ok = ?PRIM_FILE:close(Fd2),
<a name="1110"/> 1110: 
<a name="1111"/> 1111:     {ok, Fd3} = ?PRIM_FILE:open(Advise, [write]),
<a name="1112"/> 1112:     ok = ?PRIM_FILE:advise(Fd3, 0, 0, sequential),
<a name="1113"/> 1113:     ok = ?PRIM_FILE:write(Fd3, Line1),
<a name="1114"/> 1114:     ok = ?PRIM_FILE:write(Fd3, Line2),
<a name="1115"/> 1115:     ok = ?PRIM_FILE:close(Fd3),
<a name="1116"/> 1116: 
<a name="1117"/> 1117:     {ok, Fd4} = ?PRIM_FILE:open(Advise, [write]),
<a name="1118"/> 1118:     ok = ?PRIM_FILE:advise(Fd4, 0, 0, will_need),
<a name="1119"/> 1119:     ok = ?PRIM_FILE:write(Fd4, Line1),
<a name="1120"/> 1120:     ok = ?PRIM_FILE:write(Fd4, Line2),
<a name="1121"/> 1121:     ok = ?PRIM_FILE:close(Fd4),
<a name="1122"/> 1122: 
<a name="1123"/> 1123:     {ok, Fd5} = ?PRIM_FILE:open(Advise, [write]),
<a name="1124"/> 1124:     ok = ?PRIM_FILE:advise(Fd5, 0, 0, dont_need),
<a name="1125"/> 1125:     ok = ?PRIM_FILE:write(Fd5, Line1),
<a name="1126"/> 1126:     ok = ?PRIM_FILE:write(Fd5, Line2),
<a name="1127"/> 1127:     ok = ?PRIM_FILE:close(Fd5),
<a name="1128"/> 1128: 
<a name="1129"/> 1129:     {ok, Fd6} = ?PRIM_FILE:open(Advise, [write]),
<a name="1130"/> 1130:     ok = ?PRIM_FILE:advise(Fd6, 0, 0, no_reuse),
<a name="1131"/> 1131:     ok = ?PRIM_FILE:write(Fd6, Line1),
<a name="1132"/> 1132:     ok = ?PRIM_FILE:write(Fd6, Line2),
<a name="1133"/> 1133:     ok = ?PRIM_FILE:close(Fd6),
<a name="1134"/> 1134: 
<a name="1135"/> 1135:     {ok, Fd7} = ?PRIM_FILE:open(Advise, [write]),
<a name="1136"/> 1136:     {error, einval} = ?PRIM_FILE:advise(Fd7, 0, 0, bad_advise),
<a name="1137"/> 1137:     ok = ?PRIM_FILE:close(Fd7),
<a name="1138"/> 1138: 
<a name="1139"/> 1139:     %% test write without advise, then a read after an advise
<a name="1140"/> 1140:     {ok, Fd8} = ?PRIM_FILE:open(Advise, [write]),
<a name="1141"/> 1141:     ok = ?PRIM_FILE:write(Fd8, Line1),
<a name="1142"/> 1142:     ok = ?PRIM_FILE:write(Fd8, Line2),
<a name="1143"/> 1143:     ok = ?PRIM_FILE:close(Fd8),
<a name="1144"/> 1144:     {ok, Fd9} = ?PRIM_FILE:open(Advise, [read]),
<a name="1145"/> 1145:     Offset = 0,
<a name="1146"/> 1146:     %% same as a 0 length in some implementations
<a name="1147"/> 1147:     Length = byte_size(Line1) + byte_size(Line2),
<a name="1148"/> 1148:     ok = ?PRIM_FILE:advise(Fd9, Offset, Length, sequential),
<a name="1149"/> 1149:     {ok, Line1} = ?PRIM_FILE:read_line(Fd9),
<a name="1150"/> 1150:     {ok, Line2} = ?PRIM_FILE:read_line(Fd9),
<a name="1151"/> 1151:     eof = ?PRIM_FILE:read_line(Fd9),
<a name="1152"/> 1152:     ok = ?PRIM_FILE:close(Fd9),
<a name="1153"/> 1153: 
<a name="advise-last_expr"/><a name="1154"/> 1154:     ok.
<a name="1155"/> 1155: 
<a name="1156"/> 1156: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="1157"/> 1157: 
<a name="large_write-1"/><a name="1158"/> 1158: <b>large_write</b>(Config) when is_list(Config) -&gt;
<a name="large_write-last_expr"/><a name="1159"/> 1159: <b>    run_large_file_test</b>(Config,
<a name="1160"/> 1160: 			fun(Name) -&gt; do_large_write(Name) end,
<a name="1161"/> 1161: 			&quot;_large_write&quot;).
<a name="1162"/> 1162: 
<a name="do_large_write-1"/><a name="1163"/> 1163: <b>do_large_write</b>(Name) -&gt;
<a name="1164"/> 1164:     ChunkSize = (256 bsl 20) + 1,	% 256 M + 1
<a name="1165"/> 1165:     Chunks = 16,			% times 16 -&gt; 4 G + 16
<a name="1166"/> 1166:     Base = 100,
<a name="1167"/> 1167:     Interleave = lists:seq(Base+1, Base+Chunks),
<a name="1168"/> 1168:     Chunk = &lt;&lt;0:ChunkSize/unit:8&gt;&gt;,
<a name="1169"/> 1169:     Data = zip_data(lists:duplicate(Chunks, Chunk), Interleave),
<a name="1170"/> 1170:     Size = Chunks * ChunkSize + Chunks,	% 4 G + 32
<a name="1171"/> 1171:     ok = ?PRIM_FILE:write_file(Name, Data),
<a name="1172"/> 1172:     {ok,#file_info{size=Size}} = file:read_file_info(Name),
<a name="1173"/> 1173:     {ok,Fd} = ?PRIM_FILE:open(Name, [read]),
<a name="do_large_write-last_expr"/><a name="1174"/> 1174: <b>    check_large_write</b>(Fd, ChunkSize, 0, Interleave).
<a name="1175"/> 1175: 
<a name="check_large_write-4"/><a name="1176"/> 1176: <b>check_large_write</b>(Fd, ChunkSize, Pos, [X|Interleave]) -&gt;
<a name="1177"/> 1177:     Pos1 = Pos + ChunkSize,
<a name="1178"/> 1178:     {ok,Pos1} = ?PRIM_FILE:position(Fd, {cur,ChunkSize}),
<a name="1179"/> 1179:     {ok,&lt;&lt;X&gt;&gt;} = ?PRIM_FILE:read(Fd, 1),
<a name="1180"/> 1180:     check_large_write(Fd, ChunkSize, Pos1+1, Interleave);
<a name="1181"/> 1181: <b>check_large_write</b>(Fd, _, _, []) -&gt;
<a name="1182"/> 1182:     eof = ?PRIM_FILE:read(Fd, 1),
<a name="check_large_write-last_expr"/><a name="1183"/> 1183:     ok.
<a name="1184"/> 1184: 
<a name="1185"/> 1185: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="1186"/> 1186: 
<a name="1187"/> 1187: <i>%% Tests that ?PRIM_FILE:allocate/3 at least doesn't crash.</i>
<a name="allocate-1"/><a name="1188"/> 1188: <b>allocate</b>(Config) when is_list(Config) -&gt;
<a name="1189"/> 1189:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="1190"/> 1190:     Allocate = filename:join(PrivDir,
<a name="1191"/> 1191: 			     atom_to_list(?MODULE)
<a name="1192"/> 1192: 			     ++&quot;_allocate.fil&quot;),
<a name="1193"/> 1193: 
<a name="1194"/> 1194:     Line1 = &quot;Hello\n&quot;,
<a name="1195"/> 1195:     Line2 = &quot;World!\n&quot;,
<a name="1196"/> 1196: 
<a name="1197"/> 1197:     {ok, Fd} = ?PRIM_FILE:open(Allocate, [write, binary]),
<a name="1198"/> 1198:     allocate_and_assert(Fd, 1, iolist_size([Line1, Line2])),
<a name="1199"/> 1199:     ok = ?PRIM_FILE:write(Fd, Line1),
<a name="1200"/> 1200:     ok = ?PRIM_FILE:write(Fd, Line2),
<a name="1201"/> 1201:     ok = ?PRIM_FILE:close(Fd),
<a name="1202"/> 1202: 
<a name="1203"/> 1203:     {ok, Fd2} = ?PRIM_FILE:open(Allocate, [write, binary]),
<a name="1204"/> 1204:     allocate_and_assert(Fd2, 1, iolist_size(Line1)),
<a name="1205"/> 1205:     ok = ?PRIM_FILE:write(Fd2, Line1),
<a name="1206"/> 1206:     ok = ?PRIM_FILE:write(Fd2, Line2),
<a name="1207"/> 1207:     ok = ?PRIM_FILE:close(Fd2),
<a name="1208"/> 1208: 
<a name="1209"/> 1209:     {ok, Fd3} = ?PRIM_FILE:open(Allocate, [write, binary]),
<a name="1210"/> 1210:     allocate_and_assert(Fd3, 1, iolist_size(Line1) + 1),
<a name="1211"/> 1211:     ok = ?PRIM_FILE:write(Fd3, Line1),
<a name="1212"/> 1212:     ok = ?PRIM_FILE:write(Fd3, Line2),
<a name="1213"/> 1213:     ok = ?PRIM_FILE:close(Fd3),
<a name="1214"/> 1214: 
<a name="1215"/> 1215:     {ok, Fd4} = ?PRIM_FILE:open(Allocate, [write, binary]),
<a name="1216"/> 1216:     allocate_and_assert(Fd4, 1, 4 * iolist_size([Line1, Line2])),
<a name="1217"/> 1217:     ok = ?PRIM_FILE:write(Fd4, Line1),
<a name="1218"/> 1218:     ok = ?PRIM_FILE:write(Fd4, Line2),
<a name="1219"/> 1219:     ok = ?PRIM_FILE:close(Fd4),
<a name="1220"/> 1220: 
<a name="allocate-last_expr"/><a name="1221"/> 1221:     ok.
<a name="1222"/> 1222: 
<a name="allocate_and_assert-3"/><a name="1223"/> 1223: <b>allocate_and_assert</b>(Fd, Offset, Length) -&gt;
<a name="1224"/> 1224:     %% Just verify that calls to ?PRIM_FILE:allocate/3 don't crash or have
<a name="1225"/> 1225:     %% any other negative side effect. We can't really assert against a
<a name="1226"/> 1226:     %% specific return value, because support for file space pre-allocation
<a name="1227"/> 1227:     %% depends on the OS, OS version and underlying filesystem.
<a name="1228"/> 1228:     %%
<a name="1229"/> 1229:     %% The Linux kernel added support for fallocate() in version 2.6.23,
<a name="1230"/> 1230:     %% which currently works only for the ext4, ocfs2, xfs and btrfs file
<a name="1231"/> 1231:     %% systems. posix_fallocate() is available in glibc as of version
<a name="1232"/> 1232:     %% 2.1.94, but it was buggy until glibc version 2.7.
<a name="1233"/> 1233:     %%
<a name="1234"/> 1234:     %% Mac OS X, as of version 10.3, supports the fcntl operation F_PREALLOCATE.
<a name="1235"/> 1235:     %%
<a name="1236"/> 1236:     %% Solaris supports posix_fallocate() but only for the UFS file system
<a name="1237"/> 1237:     %% apparently (not supported for ZFS).
<a name="1238"/> 1238:     %%
<a name="1239"/> 1239:     %% FreeBSD 9.0 is the first FreeBSD release supporting posix_fallocate().
<a name="1240"/> 1240:     %%
<a name="1241"/> 1241:     %% For Windows there's apparently no way to pre-allocate file space, at
<a name="1242"/> 1242:     %% least with similar API/semantics as posix_fallocate(), fallocate() or
<a name="1243"/> 1243:     %% fcntl F_PREALLOCATE.
<a name="1244"/> 1244:     Result = ?PRIM_FILE:allocate(Fd, Offset, Length),
<a name="allocate_and_assert-last_expr"/><a name="1245"/> 1245: <b>    case os:type</b>() of
<a name="1246"/> 1246:         {win32, _} -&gt;
<a name="1247"/> 1247:             {error, enotsup} = Result;
<a name="1248"/> 1248:         _ -&gt;
<a name="1249"/> 1249:             _ = Result
<a name="1250"/> 1250:     end.
<a name="1251"/> 1251: 
<a name="1252"/> 1252: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="1253"/> 1253: 
<a name="delete-1"/><a name="1254"/> 1254: <b>delete</b>(Config) when is_list(Config) -&gt;
<a name="1255"/> 1255:     RootDir = proplists:get_value(priv_dir,Config),
<a name="1256"/> 1256:     Name = filename:join(RootDir,
<a name="1257"/> 1257: 			 atom_to_list(?MODULE)
<a name="1258"/> 1258: 			 ++&quot;_delete.fil&quot;),
<a name="1259"/> 1259:     {ok, Fd1} = ?PRIM_FILE:open(Name, [write]),
<a name="1260"/> 1260:     ?PRIM_FILE:write(Fd1,&quot;ok.\n&quot;),
<a name="1261"/> 1261:     ok = ?PRIM_FILE:close(Fd1),
<a name="1262"/> 1262:     %% Check that the file is readable
<a name="1263"/> 1263:     {ok, Fd2} = ?PRIM_FILE:open(Name, [read]),
<a name="1264"/> 1264:     ok = ?PRIM_FILE:close(Fd2),
<a name="1265"/> 1265:     ok = ?PRIM_FILE:delete(Name),
<a name="1266"/> 1266:     %% Check that the file is not readable anymore
<a name="1267"/> 1267:     {error, _} = ?PRIM_FILE:open(Name, [read]),
<a name="1268"/> 1268:     %% Try deleting a nonexistent file
<a name="1269"/> 1269:     {error, enoent} = ?PRIM_FILE:delete(Name),
<a name="delete-last_expr"/><a name="1270"/> 1270:     ok.
<a name="1271"/> 1271: 
<a name="rename-1"/><a name="1272"/> 1272: <b>rename</b>(Config) when is_list(Config) -&gt;
<a name="1273"/> 1273:     RootDir = proplists:get_value(priv_dir,Config),
<a name="1274"/> 1274:     FileName1 = atom_to_list(?MODULE)++&quot;_rename.fil&quot;,
<a name="1275"/> 1275:     FileName2 = atom_to_list(?MODULE)++&quot;_rename.ful&quot;,
<a name="1276"/> 1276:     Name1 = filename:join(RootDir, FileName1),
<a name="1277"/> 1277:     Name2 = filename:join(RootDir, FileName2),
<a name="1278"/> 1278:     {ok,Fd1} = ?PRIM_FILE:open(Name1, [write]),
<a name="1279"/> 1279:     ok = ?PRIM_FILE:close(Fd1),
<a name="1280"/> 1280:     %% Rename, and check that it really changed name
<a name="1281"/> 1281:     ok = ?PRIM_FILE:rename(Name1, Name2),
<a name="1282"/> 1282:     {error, _} = ?PRIM_FILE:open(Name1, [read]),
<a name="1283"/> 1283:     {ok, Fd2} = ?PRIM_FILE:open(Name2, [read]),
<a name="1284"/> 1284:     ok = ?PRIM_FILE:close(Fd2),
<a name="1285"/> 1285:     %% Try renaming something to itself
<a name="1286"/> 1286:     ok = ?PRIM_FILE:rename(Name2, Name2),
<a name="1287"/> 1287:     %% Try renaming something that doesn't exist
<a name="1288"/> 1288:     {error, enoent} =
<a name="1289"/> 1289: 	?PRIM_FILE:rename(Name1, Name2),
<a name="1290"/> 1290:     %% Try renaming to something else than a string
<a name="1291"/> 1291:     {error, badarg} =
<a name="1292"/> 1292: 	?PRIM_FILE:rename(Name1, foobar),
<a name="1293"/> 1293: 
<a name="1294"/> 1294:     %% Move between directories
<a name="1295"/> 1295:     DirName1 = filename:join(RootDir,
<a name="1296"/> 1296: 			     atom_to_list(?MODULE)
<a name="1297"/> 1297: 			     ++&quot;_rename_dir&quot;),
<a name="1298"/> 1298:     DirName2 = filename:join(RootDir,
<a name="1299"/> 1299: 			     atom_to_list(?MODULE)
<a name="1300"/> 1300: 			     ++&quot;_second_rename_dir&quot;),
<a name="1301"/> 1301:     Name1foo = filename:join(DirName1, &quot;foo.fil&quot;),
<a name="1302"/> 1302:     Name2foo = filename:join(DirName2, &quot;foo.fil&quot;),
<a name="1303"/> 1303:     Name2bar = filename:join(DirName2, &quot;bar.dir&quot;),
<a name="1304"/> 1304:     ok = ?PRIM_FILE:make_dir(DirName1),
<a name="1305"/> 1305:     %% The name has to include the full file name, path is not enough
<a name="1306"/> 1306:     expect(
<a name="1307"/> 1307:       {error, eexist}, {error, eisdir},
<a name="1308"/> 1308:       ?PRIM_FILE:rename(Name2, DirName1)),
<a name="1309"/> 1309:     ok =
<a name="1310"/> 1310: 	?PRIM_FILE:rename(Name2, Name1foo),
<a name="1311"/> 1311:     %% Now rename the directory
<a name="1312"/> 1312:     ok = ?PRIM_FILE:rename(DirName1, DirName2),
<a name="1313"/> 1313:     %% And check that the file is there now
<a name="1314"/> 1314:     {ok,Fd3} = ?PRIM_FILE:open(Name2foo, [read]),
<a name="1315"/> 1315:     ok = ?PRIM_FILE:close(Fd3),
<a name="1316"/> 1316:     %% Try some dirty things now: move the directory into itself
<a name="1317"/> 1317:     {error, Msg1} =
<a name="1318"/> 1318: 	?PRIM_FILE:rename(DirName2, Name2bar),
<a name="1319"/> 1319:     io:format(&quot;Errmsg1: ~p&quot;,[Msg1]),
<a name="1320"/> 1320:     %% move dir into a file in itself
<a name="1321"/> 1321:     {error, Msg2} =
<a name="1322"/> 1322: 	?PRIM_FILE:rename(DirName2, Name2foo),
<a name="1323"/> 1323:     io:format(&quot;Errmsg2: ~p&quot;,[Msg2]),
<a name="1324"/> 1324: 
<a name="rename-last_expr"/><a name="1325"/> 1325:     ok.
<a name="1326"/> 1326: 
<a name="1327"/> 1327: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="1328"/> 1328: 
<a name="1329"/> 1329: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="1330"/> 1330: 
<a name="1331"/> 1331: 
<a name="e_delete-1"/><a name="1332"/> 1332: <b>e_delete</b>(Config) when is_list(Config) -&gt;
<a name="1333"/> 1333:     RootDir = proplists:get_value(priv_dir, Config),
<a name="1334"/> 1334:     Base = filename:join(RootDir,
<a name="1335"/> 1335: 			 atom_to_list(?MODULE)++&quot;_e_delete&quot;),
<a name="1336"/> 1336:     ok = ?PRIM_FILE:make_dir(Base),
<a name="1337"/> 1337: 
<a name="1338"/> 1338:     %% Delete a non-existing file.
<a name="1339"/> 1339:     {error, enoent} =
<a name="1340"/> 1340: 	?PRIM_FILE:delete(filename:join(Base, &quot;non_existing&quot;)),
<a name="1341"/> 1341: 
<a name="1342"/> 1342:     %% Delete a directory.
<a name="1343"/> 1343:     {error, eperm} = ?PRIM_FILE:delete(Base),
<a name="1344"/> 1344: 
<a name="1345"/> 1345:     %% Use a path-name with a non-directory component.
<a name="1346"/> 1346:     Afile = filename:join(Base, &quot;a_file&quot;),
<a name="1347"/> 1347:     ok = ?PRIM_FILE:write_file(Afile, &quot;hello\n&quot;),
<a name="1348"/> 1348:     {error, E} =
<a name="1349"/> 1349: 	expect(
<a name="1350"/> 1350: 	  {error, enotdir}, {error, enoent}, 
<a name="1351"/> 1351: 	  ?PRIM_FILE:delete(filename:join(Afile, &quot;another_file&quot;))),
<a name="1352"/> 1352:     io:format(&quot;Result: ~p~n&quot;, [E]),
<a name="1353"/> 1353: 
<a name="1354"/> 1354:     %% No permission.
<a name="1355"/> 1355:     case os:type() of
<a name="1356"/> 1356: 	{win32, _} -&gt;
<a name="1357"/> 1357: 	    %% Remove a character device.
<a name="1358"/> 1358: 	    expect({error, eacces}, {error, einval},
<a name="1359"/> 1359:                    ?PRIM_FILE:delete(&quot;nul&quot;));
<a name="1360"/> 1360: 	_ -&gt;
<a name="1361"/> 1361: 	    ?PRIM_FILE:write_file_info(
<a name="1362"/> 1362: 	       Base, #file_info {mode=0}),
<a name="1363"/> 1363: 	    {error, eacces} = ?PRIM_FILE:delete(Afile),
<a name="1364"/> 1364: 	    ?PRIM_FILE:write_file_info(
<a name="1365"/> 1365: 	       Base, #file_info {mode=8#700})
<a name="1366"/> 1366:     end,
<a name="1367"/> 1367: 
<a name="e_delete-last_expr"/><a name="1368"/> 1368:     ok.
<a name="1369"/> 1369: 
<a name="1370"/> 1370: <i>%%% FreeBSD gives EEXIST when renaming a file to an empty dir, although the</i>
<a name="1371"/> 1371: <i>%%% manual page can be interpreted as saying that EISDIR should be given.</i>
<a name="1372"/> 1372: <i>%%% (What about FreeBSD? We store our nightly build results on a FreeBSD</i>
<a name="1373"/> 1373: <i>%%% file system, that's what.)</i>
<a name="1374"/> 1374: 
<a name="e_rename-1"/><a name="1375"/> 1375: <b>e_rename</b>(Config) when is_list(Config) -&gt;
<a name="1376"/> 1376:     RootDir = proplists:get_value(priv_dir, Config),
<a name="1377"/> 1377:     Base = filename:join(RootDir,
<a name="1378"/> 1378: 			 atom_to_list(?MODULE)++&quot;_e_rename&quot;),
<a name="1379"/> 1379:     ok = ?PRIM_FILE:make_dir(Base),
<a name="1380"/> 1380: 
<a name="1381"/> 1381:     %% Create an empty directory.
<a name="1382"/> 1382:     EmptyDir = filename:join(Base, &quot;empty_dir&quot;),
<a name="1383"/> 1383:     ok = ?PRIM_FILE:make_dir(EmptyDir),
<a name="1384"/> 1384: 
<a name="1385"/> 1385:     %% Create a non-empty directory.
<a name="1386"/> 1386:     NonEmptyDir = filename:join(Base, &quot;non_empty_dir&quot;),
<a name="1387"/> 1387:     ok = ?PRIM_FILE:make_dir(NonEmptyDir),
<a name="1388"/> 1388:     ok = ?PRIM_FILE:write_file(
<a name="1389"/> 1389: 	    filename:join(NonEmptyDir, &quot;a_file&quot;),
<a name="1390"/> 1390: 	    &quot;hello\n&quot;),
<a name="1391"/> 1391: 
<a name="1392"/> 1392:     %% Create another non-empty directory.
<a name="1393"/> 1393:     ADirectory = filename:join(Base, &quot;a_directory&quot;),
<a name="1394"/> 1394:     ok = ?PRIM_FILE:make_dir(ADirectory),
<a name="1395"/> 1395:     ok = ?PRIM_FILE:write_file(
<a name="1396"/> 1396: 	    filename:join(ADirectory, &quot;a_file&quot;),
<a name="1397"/> 1397: 	    &quot;howdy\n\n&quot;),
<a name="1398"/> 1398: 
<a name="1399"/> 1399:     %% Create a data file.
<a name="1400"/> 1400:     File = filename:join(Base, &quot;just_a_file&quot;),
<a name="1401"/> 1401:     ok = ?PRIM_FILE:write_file(File, &quot;anything goes\n\n&quot;),
<a name="1402"/> 1402: 
<a name="1403"/> 1403:     %% Move an existing directory to a non-empty directory.
<a name="1404"/> 1404:     {error, eexist} =
<a name="1405"/> 1405: 	?PRIM_FILE:rename(ADirectory, NonEmptyDir),
<a name="1406"/> 1406: 
<a name="1407"/> 1407:     %% Move a root directory.
<a name="1408"/> 1408:     {error, einval} = ?PRIM_FILE:rename(&quot;/&quot;, &quot;arne&quot;),
<a name="1409"/> 1409: 
<a name="1410"/> 1410:     %% Move Base into Base/new_name.
<a name="1411"/> 1411:     {error, einval} =
<a name="1412"/> 1412: 	?PRIM_FILE:rename(Base, filename:join(Base, &quot;new_name&quot;)),
<a name="1413"/> 1413: 
<a name="1414"/> 1414:     %% Overwrite a directory with a file.
<a name="1415"/> 1415:     expect({error, eexist}, % FreeBSD (?)
<a name="1416"/> 1416: 	   {error, eisdir},
<a name="1417"/> 1417: 	   ?PRIM_FILE:rename(File, EmptyDir)),
<a name="1418"/> 1418:     expect({error, eexist}, % FreeBSD (?)
<a name="1419"/> 1419: 	   {error, eisdir},
<a name="1420"/> 1420: 	   ?PRIM_FILE:rename(File, NonEmptyDir)),
<a name="1421"/> 1421: 
<a name="1422"/> 1422:     %% Move a non-existing file.
<a name="1423"/> 1423:     NonExistingFile = filename:join(
<a name="1424"/> 1424: 			Base, &quot;non_existing_file&quot;),
<a name="1425"/> 1425:     {error, enoent} =
<a name="1426"/> 1426: 	?PRIM_FILE:rename(NonExistingFile, NonEmptyDir),
<a name="1427"/> 1427: 
<a name="1428"/> 1428:     %% Overwrite a file with a directory.
<a name="1429"/> 1429:     expect({error, eexist}, % FreeBSD (?)
<a name="1430"/> 1430: 	   {error, enotdir},
<a name="1431"/> 1431: 	   ?PRIM_FILE:rename(ADirectory, File)),
<a name="1432"/> 1432: 
<a name="1433"/> 1433:     %% Move a file to another filesystem.
<a name="1434"/> 1434:     %% XXX - This test case is bogus. We cannot be guaranteed that
<a name="1435"/> 1435:     %%       the source and destination are on 
<a name="1436"/> 1436:     %%       different filesystems.
<a name="1437"/> 1437:     %%
<a name="1438"/> 1438:     %% XXX - Gross hack!
<a name="1439"/> 1439:     Comment =
<a name="1440"/> 1440: 	case os:type() of
<a name="1441"/> 1441: 	    {win32, _} -&gt;
<a name="1442"/> 1442: 		%% At least Windows NT can
<a name="1443"/> 1443: 		%% successfully move a file to
<a name="1444"/> 1444: 		%% another drive.
<a name="1445"/> 1445: 		ok;
<a name="1446"/> 1446: 	    _ -&gt;
<a name="1447"/> 1447: 		OtherFs = &quot;/tmp&quot;,
<a name="1448"/> 1448: 		NameOnOtherFs =
<a name="1449"/> 1449: 		    filename:join(OtherFs,
<a name="1450"/> 1450: 				  filename:basename(File)),
<a name="1451"/> 1451: 		{ok, Com} =
<a name="1452"/> 1452: 		    case ?PRIM_FILE:rename(
<a name="1453"/> 1453: 			    File, NameOnOtherFs) of
<a name="1454"/> 1454: 			{error, exdev} -&gt;
<a name="1455"/> 1455: 			    %% The file could be in
<a name="1456"/> 1456: 			    %% the same filesystem!
<a name="1457"/> 1457: 			    {ok, ok};
<a name="1458"/> 1458: 			ok -&gt;
<a name="1459"/> 1459: 			    {ok, {comment,
<a name="1460"/> 1460: 				  &quot;Moving between filesystems &quot;
<a name="1461"/> 1461: 				  &quot;succeeded, files are probably &quot;
<a name="1462"/> 1462: 				  &quot;in the same filesystem!&quot;}};
<a name="1463"/> 1463: 			{error, eperm} -&gt;
<a name="1464"/> 1464: 			    {ok, {comment, &quot;SBS! You don't &quot;
<a name="1465"/> 1465: 				  &quot;have the permission to do &quot;
<a name="1466"/> 1466: 				  &quot;this test!&quot;}};
<a name="1467"/> 1467: 			Else -&gt;
<a name="1468"/> 1468: 			    Else
<a name="1469"/> 1469: 		    end,
<a name="1470"/> 1470: 		Com
<a name="1471"/> 1471: 	end,
<a name="e_rename-last_expr"/><a name="1472"/> 1472:     Comment.
<a name="1473"/> 1473: 
<a name="e_make_dir-1"/><a name="1474"/> 1474: <b>e_make_dir</b>(Config) when is_list(Config) -&gt;
<a name="1475"/> 1475:     RootDir = proplists:get_value(priv_dir, Config),
<a name="1476"/> 1476:     Base = filename:join(RootDir,
<a name="1477"/> 1477: 			 atom_to_list(?MODULE)++&quot;_e_make_dir&quot;),
<a name="1478"/> 1478:     ok = ?PRIM_FILE:make_dir(Base),
<a name="1479"/> 1479: 
<a name="1480"/> 1480:     %% A component of the path does not exist.
<a name="1481"/> 1481:     {error, enoent} =
<a name="1482"/> 1482: 	?PRIM_FILE:make_dir(filename:join([Base, &quot;a&quot;, &quot;b&quot;])),
<a name="1483"/> 1483: 
<a name="1484"/> 1484:     %% Use a path-name with a non-directory component.
<a name="1485"/> 1485:     Afile = filename:join(Base, &quot;a_directory&quot;),
<a name="1486"/> 1486:     ok = ?PRIM_FILE:write_file(Afile, &quot;hello\n&quot;),
<a name="1487"/> 1487:     case ?PRIM_FILE:make_dir(
<a name="1488"/> 1488: 	    filename:join(Afile, &quot;another_directory&quot;)) of
<a name="1489"/> 1489: 	{error, enotdir} -&gt; io:format(&quot;Result: enotdir&quot;);
<a name="1490"/> 1490: 	{error, enoent} -&gt; io:format(&quot;Result: enoent&quot;)
<a name="1491"/> 1491:     end,
<a name="1492"/> 1492: 
<a name="1493"/> 1493:     %% No permission (on Unix only).
<a name="1494"/> 1494:     case os:type() of
<a name="1495"/> 1495: 	{win32, _} -&gt;
<a name="1496"/> 1496: 	    ok;
<a name="1497"/> 1497: 	_ -&gt;
<a name="1498"/> 1498: 	    ?PRIM_FILE:write_file_info(Base, #file_info {mode=0}),
<a name="1499"/> 1499: 	    {error, eacces} =
<a name="1500"/> 1500: 		?PRIM_FILE:make_dir(filename:join(Base, &quot;xxxx&quot;)),
<a name="1501"/> 1501: 	    ?PRIM_FILE:write_file_info(Base, #file_info {mode=8#700})
<a name="1502"/> 1502:     end,
<a name="e_make_dir-last_expr"/><a name="1503"/> 1503:     ok.
<a name="1504"/> 1504: 
<a name="e_del_dir-1"/><a name="1505"/> 1505: <b>e_del_dir</b>(Config) when is_list(Config) -&gt;
<a name="1506"/> 1506:     RootDir = proplists:get_value(priv_dir, Config),
<a name="1507"/> 1507:     Base = filename:join(RootDir,
<a name="1508"/> 1508: 			 atom_to_list(?MODULE)++&quot;_e_del_dir&quot;),
<a name="1509"/> 1509:     io:format(&quot;Base: ~p&quot;, [Base]),
<a name="1510"/> 1510:     ok = ?PRIM_FILE:make_dir(Base),
<a name="1511"/> 1511: 
<a name="1512"/> 1512:     %% Delete a non-existent directory.
<a name="1513"/> 1513:     {error, enoent} =
<a name="1514"/> 1514: 	?PRIM_FILE:del_dir(filename:join(Base, &quot;non_existing&quot;)),
<a name="1515"/> 1515: 
<a name="1516"/> 1516:     %% Use a path-name with a non-directory component.
<a name="1517"/> 1517:     Afile = filename:join(Base, &quot;a_directory&quot;),
<a name="1518"/> 1518:     ok = ?PRIM_FILE:write_file(Afile, &quot;hello\n&quot;),
<a name="1519"/> 1519:     {error, E1} =
<a name="1520"/> 1520: 	expect({error, enotdir}, {error, enoent},
<a name="1521"/> 1521: 	       ?PRIM_FILE:del_dir(
<a name="1522"/> 1522: 		  filename:join(Afile, &quot;another_directory&quot;))),
<a name="1523"/> 1523:     io:format(&quot;Result: ~p&quot;, [E1]),
<a name="1524"/> 1524: 
<a name="1525"/> 1525:     %% Delete a non-empty directory.
<a name="1526"/> 1526:     %% Delete a non-empty directory.
<a name="1527"/> 1527:     {error, E2} =
<a name="1528"/> 1528: 	expect({error, enotempty}, {error, eexist}, {error, eacces},
<a name="1529"/> 1529: 	       ?PRIM_FILE:del_dir(Base)),
<a name="1530"/> 1530:     io:format(&quot;Result: ~p&quot;, [E2]),
<a name="1531"/> 1531: 
<a name="1532"/> 1532:     %% Remove the current directory.
<a name="1533"/> 1533:     {error, E3} =
<a name="1534"/> 1534: 	expect({error, einval}, 
<a name="1535"/> 1535: 	       {error, eperm}, % Linux and DUX
<a name="1536"/> 1536: 	       {error, eacces},
<a name="1537"/> 1537: 	       {error, ebusy},
<a name="1538"/> 1538: 	       ?PRIM_FILE:del_dir(&quot;.&quot;)),
<a name="1539"/> 1539:     io:format(&quot;Result: ~p&quot;, [E3]),
<a name="1540"/> 1540: 
<a name="1541"/> 1541:     %% No permission.
<a name="1542"/> 1542:     case os:type() of
<a name="1543"/> 1543: 	{win32, _} -&gt;
<a name="1544"/> 1544: 	    ok;
<a name="1545"/> 1545: 	_ -&gt;
<a name="1546"/> 1546: 	    ADirectory = filename:join(Base, &quot;no_perm&quot;),
<a name="1547"/> 1547: 	    ok = ?PRIM_FILE:make_dir(ADirectory),
<a name="1548"/> 1548: 	    ?PRIM_FILE:write_file_info(Base, #file_info {mode=0}),
<a name="1549"/> 1549: 	    {error, eacces} = ?PRIM_FILE:del_dir(ADirectory),
<a name="1550"/> 1550: 	    ?PRIM_FILE:write_file_info(
<a name="1551"/> 1551: 	       Base, #file_info {mode=8#700})
<a name="1552"/> 1552:     end,
<a name="e_del_dir-last_expr"/><a name="1553"/> 1553:     ok.
<a name="1554"/> 1554: 
<a name="1555"/> 1555: 
<a name="make_link-1"/><a name="1556"/> 1556: <b>make_link</b>(Config) when is_list(Config) -&gt;
<a name="1557"/> 1557:     RootDir = proplists:get_value(priv_dir, Config),
<a name="1558"/> 1558:     NewDir = filename:join(RootDir,
<a name="1559"/> 1559: 			   atom_to_list(?MODULE)
<a name="1560"/> 1560: 			   ++&quot;_make_link&quot;),
<a name="1561"/> 1561:     ok = ?PRIM_FILE:make_dir(NewDir),
<a name="1562"/> 1562: 
<a name="1563"/> 1563:     Name = filename:join(NewDir, &quot;a_file&quot;),
<a name="1564"/> 1564:     ok = ?PRIM_FILE:write_file(Name, &quot;some contents\n&quot;),
<a name="1565"/> 1565: 
<a name="1566"/> 1566:     Alias = filename:join(NewDir, &quot;an_alias&quot;),
<a name="1567"/> 1567:     Result =
<a name="1568"/> 1568: 	case ?PRIM_FILE:make_link(Name, Alias) of
<a name="1569"/> 1569: 	    {error, enotsup} -&gt;
<a name="1570"/> 1570: 		{skipped, &quot;Links not supported on this platform&quot;};
<a name="1571"/> 1571: 	    ok -&gt;
<a name="1572"/> 1572: 		%% Note: We take the opportunity to test 
<a name="1573"/> 1573: 		%% ?PRIM_FILE:read_link_info/1,
<a name="1574"/> 1574: 		%% which should in behave exactly as 
<a name="1575"/> 1575: 		%% ?PRIM_FILE:read_file_info/1
<a name="1576"/> 1576: 		%% since they are not used on symbolic links.
<a name="1577"/> 1577: 
<a name="1578"/> 1578: 		{ok, Info} =
<a name="1579"/> 1579: 		    ?PRIM_FILE:read_link_info(Name),
<a name="1580"/> 1580: 		{ok, Info} =
<a name="1581"/> 1581: 		    ?PRIM_FILE:read_link_info(Alias),
<a name="1582"/> 1582: 		#file_info{links = 2, type = regular} = Info,
<a name="1583"/> 1583: 		{error, eexist} =
<a name="1584"/> 1584: 		    ?PRIM_FILE:make_link(Name, Alias),
<a name="1585"/> 1585: 		ok
<a name="1586"/> 1586: 	end,
<a name="1587"/> 1587: 
<a name="make_link-last_expr"/><a name="1588"/> 1588:     Result.
<a name="1589"/> 1589: 
<a name="1590"/> 1590: <i>%% Test that reading link info for an ordinary file or directory works</i>
<a name="1591"/> 1591: <i>%% (on all platforms).</i>
<a name="read_link_info_for_non_link-1"/><a name="1592"/> 1592: <b>read_link_info_for_non_link</b>(Config) when is_list(Config) -&gt;
<a name="1593"/> 1593:     {ok, #file_info{type=directory}} = ?PRIM_FILE:read_link_info(&quot;.&quot;),
<a name="read_link_info_for_non_link-last_expr"/><a name="1594"/> 1594:     ok.
<a name="1595"/> 1595: 
<a name="symlinks-1"/><a name="1596"/> 1596: <b>symlinks</b>(Config) when is_list(Config)  -&gt;
<a name="1597"/> 1597:     RootDir = proplists:get_value(priv_dir, Config),
<a name="1598"/> 1598:     NewDir = filename:join(RootDir,
<a name="1599"/> 1599: 			   atom_to_list(?MODULE)
<a name="1600"/> 1600: 			   ++&quot;_make_symlink&quot;),
<a name="1601"/> 1601:     ok = ?PRIM_FILE:make_dir(NewDir),
<a name="1602"/> 1602: 
<a name="1603"/> 1603:     Name = filename:join(NewDir, &quot;a_plain_file&quot;),
<a name="1604"/> 1604:     ok = ?PRIM_FILE:write_file(Name, &quot;some stupid content\n&quot;),
<a name="1605"/> 1605: 
<a name="1606"/> 1606:     Alias = filename:join(NewDir, &quot;a_symlink_alias&quot;),
<a name="1607"/> 1607:     Result =
<a name="1608"/> 1608: 	case ?PRIM_FILE:make_symlink(Name, Alias) of
<a name="1609"/> 1609: 	    {error, enotsup} -&gt;
<a name="1610"/> 1610: 		{skipped, &quot;Links not supported on this platform&quot;};
<a name="1611"/> 1611: 	    {error, eperm} -&gt;
<a name="1612"/> 1612: 		{win32,_} = os:type(),
<a name="1613"/> 1613: 		{skipped, &quot;Windows user not privileged to create links&quot;};
<a name="1614"/> 1614: 	    ok -&gt;
<a name="1615"/> 1615: 		{ok, Info1} =
<a name="1616"/> 1616: 		    ?PRIM_FILE:read_file_info(Name),
<a name="1617"/> 1617: 		{ok, Info1} =
<a name="1618"/> 1618: 		    ?PRIM_FILE:read_file_info(Alias),
<a name="1619"/> 1619: 		{ok, Info1} =
<a name="1620"/> 1620: 		    ?PRIM_FILE:read_link_info(Name),
<a name="1621"/> 1621: 		#file_info{links = 1, type = regular} = Info1,
<a name="1622"/> 1622: 
<a name="1623"/> 1623: 		{ok, Info2} =
<a name="1624"/> 1624: 		    ?PRIM_FILE:read_link_info(Alias),
<a name="1625"/> 1625: 		#file_info{links=1, type=symlink} = Info2,
<a name="1626"/> 1626: 		{ok, Name} =
<a name="1627"/> 1627: 		    ?PRIM_FILE:read_link(Alias),
<a name="1628"/> 1628: 		{ok, Name} =
<a name="1629"/> 1629: 		    ?PRIM_FILE:read_link_all(Alias),
<a name="1630"/> 1630: 		%% If all is good, delete dir again (avoid hanging dir on windows)
<a name="1631"/> 1631: 		rm_rf(?PRIM_FILE,NewDir),
<a name="1632"/> 1632: 		ok
<a name="1633"/> 1633: 	end,
<a name="1634"/> 1634: 
<a name="symlinks-last_expr"/><a name="1635"/> 1635:     Result.
<a name="1636"/> 1636: 
<a name="1637"/> 1637: <i>%% Creates as many files as possible during a certain time, </i>
<a name="1638"/> 1638: <i>%% periodically calls list_dir/2 to check if it works,</i>
<a name="1639"/> 1639: <i>%% then deletes all files.</i>
<a name="1640"/> 1640: 
<a name="1641"/> 1641: <i>%% Tests if large directories can be read.</i>
<a name="list_dir_limit-1"/><a name="1642"/> 1642: <b>list_dir_limit</b>(Config) when is_list(Config) -&gt;
<a name="1643"/> 1643:     MaxTime = 120,
<a name="1644"/> 1644:     MaxNumber = 20000,
<a name="1645"/> 1645:     ct:timetrap({seconds,2*MaxTime + MaxTime}),
<a name="1646"/> 1646:     RootDir = proplists:get_value(priv_dir, Config),
<a name="1647"/> 1647:     NewDir = filename:join(RootDir,
<a name="1648"/> 1648: 			   atom_to_list(?MODULE)++&quot;_list_dir_limit&quot;),
<a name="1649"/> 1649:     ok = ?PRIM_FILE:make_dir(NewDir),
<a name="1650"/> 1650:     Ref = erlang:start_timer(MaxTime*1000, self(), []),
<a name="1651"/> 1651:     Result = list_dir_limit_loop(NewDir, Ref, MaxNumber, 0),
<a name="1652"/> 1652:     Time = case erlang:cancel_timer(Ref) of
<a name="1653"/> 1653: 	       false -&gt; MaxTime;
<a name="1654"/> 1654: 	       T -&gt; MaxTime - (T div 1000)
<a name="1655"/> 1655: 	   end,
<a name="1656"/> 1656:     Number = case Result of
<a name="1657"/> 1657: 		 {ok, N} -&gt; N;
<a name="1658"/> 1658: 		 {error, _Reason, N} -&gt; N;
<a name="1659"/> 1659: 		 _ -&gt; 0
<a name="1660"/> 1660: 	     end,
<a name="1661"/> 1661:     list_dir_limit_cleanup(NewDir, Number, 0),
<a name="1662"/> 1662:     {ok, Number} = Result,
<a name="list_dir_limit-last_expr"/><a name="1663"/> 1663:     {comment, 
<a name="1664"/> 1664:      &quot;Created &quot; ++ integer_to_list(Number) ++ &quot; files in &quot; 
<a name="1665"/> 1665:      ++ integer_to_list(Time) ++ &quot; seconds.&quot;}.
<a name="1666"/> 1666: 
<a name="list_dir_limit_loop-4"/><a name="1667"/> 1667: <b>list_dir_limit_loop</b>(Dir, _Ref, N, Cnt) when Cnt &gt;= N -&gt;
<a name="1668"/> 1668:     list_dir_check(Dir, Cnt);
<a name="1669"/> 1669: <b>list_dir_limit_loop</b>(Dir, Ref, N, Cnt) -&gt;
<a name="list_dir_limit_loop-last_expr"/><a name="1670"/> 1670:     receive 
<a name="1671"/> 1671: 	{timeout, Ref, []} -&gt; 
<a name="1672"/> 1672: 	    list_dir_check(Dir, Cnt)
<a name="1673"/> 1673:     after 0 -&gt;
<a name="1674"/> 1674: 	    Name = integer_to_list(Cnt),
<a name="1675"/> 1675: 	    case ?PRIM_FILE:write_file(filename:join(Dir, Name), Name) of
<a name="1676"/> 1676: 		ok -&gt;
<a name="1677"/> 1677: 		    Next = Cnt + 1,
<a name="1678"/> 1678: 		    case Cnt rem 100 of
<a name="1679"/> 1679: 			0 -&gt;
<a name="1680"/> 1680: 			    case list_dir_check(Dir, Next) of
<a name="1681"/> 1681: 				{ok, Next} -&gt;
<a name="1682"/> 1682: 				    list_dir_limit_loop(
<a name="1683"/> 1683: 				      Dir, Ref, N, Next);
<a name="1684"/> 1684: 				Other -&gt;
<a name="1685"/> 1685: 				    Other
<a name="1686"/> 1686: 			    end;
<a name="1687"/> 1687: 			_ -&gt;
<a name="1688"/> 1688: 			    list_dir_limit_loop(Dir, Ref, N, Next)
<a name="1689"/> 1689: 		    end;
<a name="1690"/> 1690: 		{error, Reason} -&gt;
<a name="1691"/> 1691: 		    {error, Reason, Cnt}
<a name="1692"/> 1692: 	    end
<a name="1693"/> 1693:     end.
<a name="1694"/> 1694: 
<a name="list_dir_check-2"/><a name="1695"/> 1695: <b>list_dir_check</b>(Dir, Cnt) -&gt;
<a name="list_dir_check-last_expr"/><a name="1696"/> 1696: <b>    case ?PRIM_FILE:list_dir</b>(Dir) of
<a name="1697"/> 1697: 	{ok, ListDir} -&gt;
<a name="1698"/> 1698: 	    case length(ListDir) of
<a name="1699"/> 1699: 		Cnt -&gt;
<a name="1700"/> 1700: 		    {ok, Cnt};
<a name="1701"/> 1701: 		X -&gt;
<a name="1702"/> 1702: 		    {error, 
<a name="1703"/> 1703: 		     {wrong_nof_files, X, ?LINE},
<a name="1704"/> 1704: 		     Cnt}
<a name="1705"/> 1705: 	    end;
<a name="1706"/> 1706: 	{error, Reason} -&gt;
<a name="1707"/> 1707: 	    {error, Reason, Cnt}
<a name="1708"/> 1708:     end.
<a name="1709"/> 1709: 
<a name="1710"/> 1710: <i>%% Deletes N files while ignoring errors, then continues deleting</i>
<a name="1711"/> 1711: <i>%% as long as they exist.</i>
<a name="1712"/> 1712: 
<a name="list_dir_limit_cleanup-3"/><a name="1713"/> 1713: <b>list_dir_limit_cleanup</b>(Dir, N, Cnt) when Cnt &gt;= N -&gt;
<a name="1714"/> 1714:     Name = integer_to_list(Cnt),
<a name="1715"/> 1715:     case ?PRIM_FILE:delete(filename:join(Dir, Name)) of
<a name="1716"/> 1716: 	ok -&gt;
<a name="1717"/> 1717: 	    list_dir_limit_cleanup(Dir, N, Cnt+1);
<a name="1718"/> 1718: 	_ -&gt;
<a name="1719"/> 1719: 	    ok
<a name="1720"/> 1720:     end;
<a name="1721"/> 1721: <b>list_dir_limit_cleanup</b>(Dir, N, Cnt) -&gt;
<a name="1722"/> 1722:     Name = integer_to_list(Cnt),
<a name="1723"/> 1723:     ?PRIM_FILE:delete(filename:join(Dir, Name)),
<a name="list_dir_limit_cleanup-last_expr"/><a name="1724"/> 1724: <b>    list_dir_limit_cleanup</b>(Dir, N, Cnt+1).
<a name="1725"/> 1725: 
<a name="1726"/> 1726: <i>%%%</i>
<a name="1727"/> 1727: <i>%%% Test list_dir() on a non-existing pathname.</i>
<a name="1728"/> 1728: <i>%%%</i>
<a name="1729"/> 1729: 
<a name="list_dir_error-1"/><a name="1730"/> 1730: <b>list_dir_error</b>(Config) -&gt;
<a name="1731"/> 1731:     Priv = proplists:get_value(priv_dir, Config),
<a name="1732"/> 1732:     NonExisting = filename:join(Priv, &quot;non-existing-dir&quot;),
<a name="1733"/> 1733:     {error,enoent} = ?PRIM_FILE:list_dir(NonExisting),
<a name="list_dir_error-last_expr"/><a name="1734"/> 1734:     ok.
<a name="1735"/> 1735: 
<a name="1736"/> 1736: <i>%%%</i>
<a name="1737"/> 1737: <i>%%% Test list_dir() and list_dir_all().</i>
<a name="1738"/> 1738: <i>%%%</i>
<a name="1739"/> 1739: 
<a name="list_dir-1"/><a name="1740"/> 1740: <b>list_dir</b>(Config) -&gt;
<a name="1741"/> 1741:     RootDir = proplists:get_value(priv_dir, Config),
<a name="1742"/> 1742:     TestDir = filename:join(RootDir, ?MODULE_STRING++&quot;_list_dir&quot;),
<a name="1743"/> 1743:     ?PRIM_FILE:make_dir(TestDir),
<a name="list_dir-last_expr"/><a name="1744"/> 1744: <b>    list_dir_1</b>(TestDir, 42, []).
<a name="1745"/> 1745: 
<a name="list_dir_1-3"/><a name="1746"/> 1746: <b>list_dir_1</b>(TestDir, 0, Sorted) -&gt;
<a name="1747"/> 1747:     [ok = ?PRIM_FILE:delete(filename:join(TestDir, F)) ||
<a name="1748"/> 1748: 	F &lt;- Sorted],
<a name="1749"/> 1749:     ok = ?PRIM_FILE:del_dir(TestDir);
<a name="1750"/> 1750: <b>list_dir_1</b>(TestDir, Cnt, Sorted0) -&gt;
<a name="1751"/> 1751:     Base = &quot;file&quot; ++ integer_to_list(Cnt),
<a name="1752"/> 1752:     Name = filename:join(TestDir, Base),
<a name="1753"/> 1753:     ok = ?PRIM_FILE:write_file(Name, Base),
<a name="1754"/> 1754:     Sorted = lists:merge([Base], Sorted0),
<a name="1755"/> 1755:     {ok,DirList0} = ?PRIM_FILE:list_dir(TestDir),
<a name="1756"/> 1756:     {ok,DirList1} = ?PRIM_FILE:list_dir_all(TestDir),
<a name="1757"/> 1757:     Sorted = lists:sort(DirList0),
<a name="1758"/> 1758:     Sorted = lists:sort(DirList1),
<a name="list_dir_1-last_expr"/><a name="1759"/> 1759: <b>    list_dir_1</b>(TestDir, Cnt-1, Sorted).
<a name="1760"/> 1760: 
<a name="1761"/> 1761: <i>%%%</i>
<a name="1762"/> 1762: <i>%%% Support for testing large files.</i>
<a name="1763"/> 1763: <i>%%%</i>
<a name="1764"/> 1764: 
<a name="run_large_file_test-3"/><a name="1765"/> 1765: <b>run_large_file_test</b>(Config, Run, Name) -&gt;
<a name="run_large_file_test-last_expr"/><a name="1766"/> 1766: <b>    case {erlang:system_info</b>(wordsize),os:type(),os:version()} of
<a name="1767"/> 1767: 	{8,{win32,nt},_} -&gt;
<a name="1768"/> 1768: 	    do_run_large_file_test(Config, Run, Name);
<a name="1769"/> 1769: 	{8,{unix,sunos},OsVersion} when OsVersion &lt; {5,5,1} -&gt;
<a name="1770"/> 1770: 	    {skip,&quot;Only supported on Win32, Unix or SunOS &gt;= 5.5.1&quot;};
<a name="1771"/> 1771: 	{8,{unix,_},_} -&gt;
<a name="1772"/> 1772: 	    DiscFree = unix_free(proplists:get_value(priv_dir, Config)),
<a name="1773"/> 1773:             MemFree = free_memory(),
<a name="1774"/> 1774: 	    io:format(&quot;Free disk: ~w KByte~n&quot;, [DiscFree]),
<a name="1775"/> 1775: 	    io:format(&quot;Free mem: ~w MByte~n&quot;, [MemFree]),
<a name="1776"/> 1776: 	    if DiscFree &lt; 5 bsl 20; MemFree &lt; 5 bsl 10 -&gt;
<a name="1777"/> 1777: 		    %% Less than 5 GByte free
<a name="1778"/> 1778: 		    {skip,&quot;Less than 5 GByte free disk/mem&quot;};
<a name="1779"/> 1779: 	       true -&gt;
<a name="1780"/> 1780: 		    do_run_large_file_test(Config, Run, Name)
<a name="1781"/> 1781: 	    end;
<a name="1782"/> 1782: 	_ -&gt; 
<a name="1783"/> 1783: 	    {skip,&quot;Only supported on Win32, Unix or SunOS &gt;= 5.5.1&quot;}
<a name="1784"/> 1784:     end.
<a name="1785"/> 1785: 
<a name="1786"/> 1786: 
<a name="do_run_large_file_test-3"/><a name="1787"/> 1787: <b>do_run_large_file_test</b>(Config, Run, Name0) -&gt;
<a name="1788"/> 1788:     Name = filename:join(proplists:get_value(priv_dir, Config),
<a name="1789"/> 1789: 			 ?MODULE_STRING ++ Name0),
<a name="1790"/> 1790: 
<a name="1791"/> 1791:     %% Set up a process that will delete this file.
<a name="1792"/> 1792:     Tester = self(),
<a name="1793"/> 1793:     Deleter = 
<a name="1794"/> 1794: 	spawn(
<a name="1795"/> 1795: 	  fun() -&gt;
<a name="1796"/> 1796: 		  Mref = erlang:monitor(process, Tester),
<a name="1797"/> 1797: 		  receive
<a name="1798"/> 1798: 		      {'DOWN',Mref,_,_,_} -&gt; ok;
<a name="1799"/> 1799: 		      {Tester,done} -&gt; ok
<a name="1800"/> 1800: 		  end,
<a name="1801"/> 1801: 		  ?PRIM_FILE:delete(Name)
<a name="1802"/> 1802: 	  end),
<a name="1803"/> 1803: 
<a name="1804"/> 1804:     %% Run the test case.
<a name="1805"/> 1805:     Res = Run(Name),
<a name="1806"/> 1806: 
<a name="1807"/> 1807:     %% Delete file and finish deleter process.
<a name="1808"/> 1808:     Mref = erlang:monitor(process, Deleter),
<a name="1809"/> 1809:     Deleter ! {Tester,done},
<a name="1810"/> 1810:     receive {'DOWN',Mref,_,_,_} -&gt; ok end,
<a name="1811"/> 1811: 
<a name="do_run_large_file_test-last_expr"/><a name="1812"/> 1812:     Res.
<a name="1813"/> 1813: 
<a name="unix_free-1"/><a name="1814"/> 1814: <b>unix_free</b>(Path) -&gt;
<a name="1815"/> 1815:     Cmd = [&quot;df -k '&quot;,Path,&quot;'&quot;],
<a name="1816"/> 1816:     DF0 = os:cmd(Cmd),
<a name="1817"/> 1817:     io:format(&quot;$ ~s~n~s&quot;, [Cmd,DF0]),
<a name="1818"/> 1818:     Lines = re:split(DF0, &quot;\n&quot;, [trim,{return,list}]),
<a name="1819"/> 1819:     Last = lists:last(Lines),
<a name="1820"/> 1820:     RE = &quot;^[^\\s]*\\s+\\d+\\s+\\d+\\s+(\\d+)&quot;,
<a name="1821"/> 1821:     {match,[Avail]} = re:run(Last, RE, [{capture,all_but_first,list}]),
<a name="unix_free-last_expr"/><a name="1822"/> 1822: <b>    list_to_integer</b>(Avail).
<a name="1823"/> 1823: 
<a name="zip_data-2"/><a name="1824"/> 1824: <b>zip_data</b>([A|As], [B|Bs]) -&gt;
<a name="1825"/> 1825:     [[A,B]|zip_data(As, Bs)];
<a name="1826"/> 1826: <b>zip_data</b>([], Bs) -&gt;
<a name="1827"/> 1827:     Bs;
<a name="1828"/> 1828: <b>zip_data</b>(As, []) -&gt;
<a name="zip_data-last_expr"/><a name="1829"/> 1829:     As.
<a name="1830"/> 1830: 
<a name="1831"/> 1831: <i>%% Stolen from emulator -&gt; alloc_SUITE</i>
<a name="free_memory-0"/><a name="1832"/> 1832: <b>free_memory</b>() -&gt;
<a name="1833"/> 1833:     %% Free memory in MB.
<a name="free_memory-last_expr"/><a name="1834"/> 1834:     try
<a name="1835"/> 1835: 	SMD = memsup:get_system_memory_data(),
<a name="1836"/> 1836: 	{value, {free_memory, Free}} = lists:keysearch(free_memory, 1, SMD),
<a name="1837"/> 1837: 	TotFree = (Free +
<a name="1838"/> 1838: 		   case lists:keysearch(cached_memory, 1, SMD) of
<a name="1839"/> 1839: 		       {value, {cached_memory, Cached}} -&gt; Cached;
<a name="1840"/> 1840: 		       false -&gt; 0
<a name="1841"/> 1841: 		   end +
<a name="1842"/> 1842: 		   case lists:keysearch(buffered_memory, 1, SMD) of
<a name="1843"/> 1843: 		       {value, {buffered_memory, Buffed}} -&gt; Buffed;
<a name="1844"/> 1844: 		       false -&gt; 0
<a name="1845"/> 1845: 		   end),
<a name="1846"/> 1846: 	usable_mem(TotFree) div (1024*1024)
<a name="1847"/> 1847:     catch
<a name="1848"/> 1848: 	error : undef -&gt;
<a name="1849"/> 1849: 	    ct:fail({&quot;os_mon not built&quot;})
<a name="1850"/> 1850:     end.
<a name="1851"/> 1851: 
<a name="usable_mem-1"/><a name="1852"/> 1852: <b>usable_mem</b>(Memory) -&gt;
<a name="usable_mem-last_expr"/><a name="1853"/> 1853: <b>    case test_server:is_valgrind</b>() of
<a name="1854"/> 1854:         true -&gt;
<a name="1855"/> 1855:             %% Valgrind uses extra memory for the V- and A-bits.
<a name="1856"/> 1856:             %% http://valgrind.org/docs/manual/mc-manual.html#mc-manual.value
<a name="1857"/> 1857:             %% Docs says it uses &quot;compression to represent the V bits compactly&quot;
<a name="1858"/> 1858:             %% but let's be conservative and cut usable memory in half.
<a name="1859"/> 1859:             Memory div 2;
<a name="1860"/> 1860:         false -&gt;
<a name="1861"/> 1861:             Memory
<a name="1862"/> 1862:     end.
<a name="1863"/> 1863: 
<a name="1864"/> 1864: 
<a name="1865"/> 1865: <i>%%%-----------------------------------------------------------------</i>
<a name="1866"/> 1866: <i>%%% Utilities</i>
<a name="rm_rf-2"/><a name="1867"/> 1867: <b>rm_rf</b>(Mod,Dir) -&gt;
<a name="rm_rf-last_expr"/><a name="1868"/> 1868: <b>    case  Mod:read_link_info</b>(Dir) of
<a name="1869"/> 1869: 	{ok, #file_info{type = directory}} -&gt;
<a name="1870"/> 1870: 	    {ok, Content} = Mod:list_dir_all(Dir),
<a name="1871"/> 1871: 	    [ rm_rf(Mod,filename:join(Dir,C)) || C &lt;- Content ],
<a name="1872"/> 1872: 	    Mod:del_dir(Dir),
<a name="1873"/> 1873: 	    ok;
<a name="1874"/> 1874: 	{ok, #file_info{}} -&gt;
<a name="1875"/> 1875: 	    Mod:delete(Dir);
<a name="1876"/> 1876: 	_ -&gt;
<a name="1877"/> 1877: 	    ok
<a name="1878"/> 1878:     end.
</pre>
</body>
</html>
