<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/lib/stdlib/make_test_dir/stdlib_test/peer_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%% @doc</i>
<a name="2"/>    2: <i>%%% Smoke tests for peer node controller</i>
<a name="3"/>    3: <i>%%% @end</i>
<a name="4"/>    4: <b>-module</b>(peer_SUITE).
<a name="5"/>    5: <b>-author</b>(&quot;maximfca@gmail.com&quot;).
<a name="6"/>    6: 
<a name="7"/>    7: <i>%% Common Test headers</i>
<a name="8"/>    8: <b>-include_lib</b>(&quot;stdlib/include/assert.hrl&quot;).
<a name="9"/>    9: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="10"/>   10: 
<a name="11"/>   11: <i>%% Test server callbacks</i>
<a name="12"/>   12: <b>-export</b>([
<a name="13"/>   13:     suite/0,
<a name="14"/>   14:     all/0,
<a name="15"/>   15:     groups/0,
<a name="16"/>   16:     init_per_suite/1,
<a name="17"/>   17:     end_per_suite/1,
<a name="18"/>   18:     init_per_group/2,
<a name="19"/>   19:     end_per_group/2
<a name="20"/>   20: ]).
<a name="21"/>   21: 
<a name="22"/>   22: <i>%% Test cases</i>
<a name="23"/>   23: <b>-export</b>([
<a name="24"/>   24:     dist/0, dist/1,
<a name="25"/>   25:     peer_down_crash/0, peer_down_crash/1,
<a name="26"/>   26:     peer_down_crash_tcp/1,
<a name="27"/>   27:     peer_down_continue/0, peer_down_continue/1,
<a name="28"/>   28:     peer_down_boot/0, peer_down_boot/1,
<a name="29"/>   29:     dist_io_redirect/0, dist_io_redirect/1,
<a name="30"/>   30:     dist_localhost/0, dist_localhost/1,
<a name="31"/>   31:     errors/0, errors/1,
<a name="32"/>   32:     basic/0, basic/1,
<a name="33"/>   33:     peer_states/0, peer_states/1,
<a name="34"/>   34:     cast/0, cast/1,
<a name="35"/>   35:     detached/0, detached/1,
<a name="36"/>   36:     dyn_peer/0, dyn_peer/1,
<a name="37"/>   37:     stop_peer/0, stop_peer/1,
<a name="38"/>   38:     shutdown_halt/0, shutdown_halt/1,
<a name="39"/>   39:     shutdown_halt_timeout/0, shutdown_halt_timeout/1,
<a name="40"/>   40:     shutdown_stop/0, shutdown_stop/1,
<a name="41"/>   41:     shutdown_stop_timeout/0, shutdown_stop_timeout/1,
<a name="42"/>   42:     shutdown_close/0, shutdown_close/1,
<a name="43"/>   43:     init_debug/0, init_debug/1,
<a name="44"/>   44:     io_redirect/0, io_redirect/1,
<a name="45"/>   45:     multi_node/0, multi_node/1,
<a name="46"/>   46:     dist_up_down/0, dist_up_down/1,
<a name="47"/>   47:     duplicate_name/0, duplicate_name/1,
<a name="48"/>   48:     old_release/0, old_release/1,
<a name="49"/>   49:     ssh/0, ssh/1,
<a name="50"/>   50:     docker/0, docker/1,
<a name="51"/>   51:     post_process_args/0, post_process_args/1,
<a name="52"/>   52:     attached/0, attached/1,
<a name="53"/>   53:     attached_cntrl_channel_handler_crash/0, attached_cntrl_channel_handler_crash/1,
<a name="54"/>   54:     cntrl_channel_handler_crash/0, cntrl_channel_handler_crash/1,
<a name="55"/>   55:     cntrl_channel_handler_crash_old_release/0, cntrl_channel_handler_crash_old_release/1
<a name="56"/>   56: ]).
<a name="57"/>   57: 
<a name="suite-0"/><a name="58"/>   58: <b>suite</b>() -&gt;
<a name="suite-last_expr"/><a name="59"/>   59:     [{timetrap, {minutes, 1}}].
<a name="60"/>   60: 
<a name="init_per_suite-1"/><a name="61"/>   61: <b>init_per_suite</b>(Config) -&gt;
<a name="62"/>   62:     %% Restrict number of schedulers so that we do not run out of
<a name="63"/>   63:     %% file descriptors during test
<a name="64"/>   64:     os:putenv(&quot;ERL_FLAGS&quot;,&quot;+S1 +SDio 1&quot;),
<a name="init_per_suite-last_expr"/><a name="65"/>   65:     Config.
<a name="66"/>   66: 
<a name="end_per_suite-1"/><a name="67"/>   67: <b>end_per_suite</b>(_Config) -&gt;
<a name="68"/>   68:     os:unsetenv(&quot;ERL_FLAGS&quot;),
<a name="end_per_suite-last_expr"/><a name="69"/>   69:     ok.
<a name="70"/>   70: 
<a name="shutdown_alternatives-0"/><a name="71"/>   71: <b>shutdown_alternatives</b>() -&gt;
<a name="shutdown_alternatives-last_expr"/><a name="72"/>   72:     [shutdown_halt, shutdown_halt_timeout, shutdown_stop, shutdown_stop_timeout, shutdown_close].
<a name="73"/>   73: 
<a name="alternative-0"/><a name="74"/>   74: <b>alternative</b>() -&gt;
<a name="alternative-last_expr"/><a name="75"/>   75:     [basic, peer_states, cast, detached, dyn_peer, stop_peer,
<a name="76"/>   76:      io_redirect, multi_node, duplicate_name, attached, attached_cntrl_channel_handler_crash,
<a name="77"/>   77:      cntrl_channel_handler_crash, cntrl_channel_handler_crash_old_release | shutdown_alternatives()].
<a name="78"/>   78: 
<a name="groups-0"/><a name="79"/>   79: <b>groups</b>() -&gt;
<a name="groups-last_expr"/><a name="80"/>   80:     [
<a name="81"/>   81:         {dist, [parallel], [errors, dist, peer_down_crash, peer_down_continue, peer_down_boot,
<a name="82"/>   82:                             dist_up_down, dist_localhost, post_process_args, attached,
<a name="83"/>   83:                             attached_cntrl_channel_handler_crash, cntrl_channel_handler_crash,
<a name="84"/>   84:                             cntrl_channel_handler_crash_old_release | shutdown_alternatives()]},
<a name="85"/>   85:         {dist_seq, [], [dist_io_redirect,      %% Cannot be run in parallel in dist group
<a name="86"/>   86:                         peer_down_crash_tcp]},
<a name="87"/>   87:         {tcp, [parallel], alternative()},
<a name="88"/>   88:         {standard_io, [parallel], [init_debug | alternative()]},
<a name="89"/>   89:         {compatibility, [parallel], [old_release]},
<a name="90"/>   90:         {remote, [parallel], [ssh]}
<a name="91"/>   91:     ].
<a name="92"/>   92: 
<a name="all-0"/><a name="93"/>   93: <b>all</b>() -&gt;
<a name="all-last_expr"/><a name="94"/>   94:     [{group, dist}, {group, dist_seq}, {group, tcp}, {group, standard_io},
<a name="95"/>   95:      {group, compatibility}, {group, remote}].
<a name="96"/>   96: 
<a name="init_per_group-2"/><a name="97"/>   97: <b>init_per_group</b>(remote, Config) -&gt;
<a name="98"/>   98:     %% check that SSH can connect to localhost, skip the test if not
<a name="99"/>   99:     try os:cmd(&quot;timeout 10s ssh localhost echo ok&quot;) of
<a name="100"/>  100:         &quot;ok\n&quot; -&gt; Config;
<a name="101"/>  101:         _ -&gt; {skip, &quot;'ssh localhost echo ok' did not return ok&quot;}
<a name="102"/>  102:     catch
<a name="103"/>  103:         Class:Reason -&gt;
<a name="104"/>  104:             SkipReason = io_lib:format(&quot;'ssh localhost echo ok' failed with ~s:~p&quot;, [Class, Reason]),
<a name="105"/>  105:             {skip, SkipReason}
<a name="106"/>  106:     end;
<a name="107"/>  107: <b>init_per_group</b>(dist, Config) -&gt;
<a name="108"/>  108:     case erlang:is_alive() of
<a name="109"/>  109:         true -&gt; Config;
<a name="110"/>  110:         false -&gt; {skip, &quot;origin is not distributed&quot;}
<a name="111"/>  111:     end;
<a name="112"/>  112: <b>init_per_group</b>(tcp, Config) -&gt;
<a name="113"/>  113:     [{connection, 0} | Config];
<a name="114"/>  114: <b>init_per_group</b>(standard_io, Config) -&gt;
<a name="115"/>  115:     [{connection, standard_io} | Config];
<a name="116"/>  116: <b>init_per_group</b>(_Group, Config) -&gt;
<a name="init_per_group-last_expr"/><a name="117"/>  117:     Config.
<a name="118"/>  118: 
<a name="end_per_group-2"/><a name="119"/>  119: <b>end_per_group</b>(_TestCase, Config) -&gt;
<a name="end_per_group-last_expr"/><a name="120"/>  120: <b>    proplists:delete</b>(connection, Config).
<a name="121"/>  121: 
<a name="122"/>  122: <i>%% -------------------------------------------------------------------</i>
<a name="123"/>  123: <i>%% Distribution-enabled cases</i>
<a name="124"/>  124: 
<a name="errors-0"/><a name="125"/>  125: <b>errors</b>() -&gt;
<a name="errors-last_expr"/><a name="126"/>  126:     [{doc, &quot;Verify that invalid command line is rejected immediately&quot;}].
<a name="127"/>  127: 
<a name="errors-1"/><a name="128"/>  128: <b>errors</b>(Config) when is_list(Config) -&gt;
<a name="129"/>  129:     ?assertException(error, {invalid_arg, atom}, peer:start(#{args =&gt; atom})),
<a name="130"/>  130:     ?assertException(error, {invalid_arg, $s}, peer:start(#{args =&gt; &quot;string&quot;})),
<a name="131"/>  131:     ?assertException(error, {invalid_arg, [&quot;2&quot;]}, peer:start(#{args =&gt; [&quot;1&quot;, [&quot;2&quot;]]})),
<a name="132"/>  132:     ?assertException(error, {exec, atom}, peer:start(#{exec =&gt; atom, name =&gt; name})),
<a name="133"/>  133:     ?assertException(error, {exec, atom}, peer:start(#{exec =&gt; {atom, []}, name =&gt; name})),
<a name="134"/>  134:     ?assertException(error, {exec, atom}, peer:start(#{exec =&gt; {&quot;erl&quot;, [atom]}, name =&gt; name})),
<a name="errors-last_expr"/><a name="135"/>  135: <b>    ?assertException</b>(error, not_alive, peer:start(#{})). %% peer node won't start - it's not alive
<a name="136"/>  136: 
<a name="dist-0"/><a name="137"/>  137: <b>dist</b>() -&gt;
<a name="dist-last_expr"/><a name="138"/>  138:     [{doc, &quot;Classic behaviour: detached peer with no alternative, connects via dist&quot;}].
<a name="139"/>  139: 
<a name="140"/>  140: <i>%% Classic 'slave': start new node locally, with random name, ask peer control process to exit normally</i>
<a name="dist-1"/><a name="141"/>  141: <b>dist</b>(Config) when is_list(Config) -&gt;
<a name="142"/>  142:     {ok, Peer, Node} = peer:start_link(),
<a name="143"/>  143:     %% distribution is expected to be connected
<a name="144"/>  144:     ?assertEqual(Node, erpc:call(Node, erlang, node, [])),
<a name="145"/>  145:     %% but not alternative...
<a name="146"/>  146:     ?assertException(error, noconnection, peer:call(Peer, erlang, node, [])),
<a name="147"/>  147:     ?assertEqual(true, net_kernel:disconnect(Node)),
<a name="148"/>  148:     %% ^^^ this makes the node go down, but we also need to ensure that net_kernel
<a name="149"/>  149:     %%  finished processing
<a name="150"/>  150:     ct:sleep(500),
<a name="151"/>  151:     _ = sys:get_state(net_kernel),
<a name="dist-last_expr"/><a name="152"/>  152: <b>    ?assertException</b>(exit, {noproc, _}, peer:get_state(Peer)).
<a name="153"/>  153: 
<a name="peer_down_crash-0"/><a name="154"/>  154: <b>peer_down_crash</b>() -&gt;
<a name="peer_down_crash-last_expr"/><a name="155"/>  155:     [{doc, &quot;Tests peer_down handling when crash mode is requested&quot;}].
<a name="156"/>  156: 
<a name="peer_down_crash-1"/><a name="157"/>  157: <b>peer_down_crash</b>(Config) when is_list(Config) -&gt;
<a name="158"/>  158:     %% two-way link: &quot;crash&quot; mode
<a name="159"/>  159:     {ok, Peer, Node} = peer:start_link(#{name =&gt; peer:random_name(?FUNCTION_NAME),
<a name="160"/>  160:         args =&gt; [&quot;-connect_all&quot;, &quot;false&quot;], peer_down =&gt; crash}),
<a name="161"/>  161:     %% verify node started locally
<a name="162"/>  162:     ?assertEqual(Node, erpc:call(Node, erlang, node, [])),
<a name="163"/>  163:     %% verify there is no alternative connection
<a name="164"/>  164:     ?assertException(error, noconnection, peer:call(Peer, erlang, node, [])),
<a name="165"/>  165:     %% unlink and monitor
<a name="166"/>  166:     unlink(Peer),
<a name="167"/>  167:     MRef = monitor(process, Peer),
<a name="168"/>  168:     ?assertEqual(true, net_kernel:disconnect(Node)),
<a name="169"/>  169:     %% ^^^ this makes the node go down
<a name="170"/>  170:     %% since two-way link is requested, it triggers peer to stop
<a name="peer_down_crash-last_expr"/><a name="171"/>  171:     receive
<a name="172"/>  172:         {'DOWN', MRef, process, Peer, {nodedown, Node}} -&gt;
<a name="173"/>  173:             ok
<a name="174"/>  174:     after 2000 -&gt;
<a name="175"/>  175:         link(Peer),
<a name="176"/>  176:         {fail, disconnect_timeout}
<a name="177"/>  177:     end.
<a name="178"/>  178: 
<a name="179"/>  179: <i>%% Verify option combo #{peer_down=&gt;crash, connection=&gt;0}</i>
<a name="180"/>  180: <i>%% exits control process abnormally.</i>
<a name="peer_down_crash_tcp-1"/><a name="181"/>  181: <b>peer_down_crash_tcp</b>(Config) when is_list(Config) -&gt;
<a name="182"/>  182:     %% two-way link: &quot;crash&quot; mode
<a name="183"/>  183:     {ok, Peer, Node} = peer:start_link(#{name =&gt; peer:random_name(?FUNCTION_NAME),
<a name="184"/>  184:                                          peer_down =&gt; crash,
<a name="185"/>  185:                                          connection =&gt; 0}),
<a name="186"/>  186:     %% verify node started locally
<a name="187"/>  187:     ?assertEqual(Node, peer:call(Peer, erlang, node, [])),
<a name="188"/>  188:     %% verify there is no distribution connection
<a name="189"/>  189:     ?assertEqual([], erlang:nodes(connected)),
<a name="190"/>  190:     %% unlink and monitor
<a name="191"/>  191:     unlink(Peer),
<a name="192"/>  192:     MRef = monitor(process, Peer),
<a name="193"/>  193:     %% Make the node go down
<a name="194"/>  194:     ok = erpc:cast(Node, erlang, halt, [0]),
<a name="195"/>  195: 
<a name="196"/>  196:     %% since two-way link is requested, it triggers peer to stop
<a name="peer_down_crash_tcp-last_expr"/><a name="197"/>  197:     receive
<a name="198"/>  198:         {'DOWN', MRef, process, Peer, tcp_closed} -&gt;
<a name="199"/>  199:             ok
<a name="200"/>  200:     after 5000 -&gt;
<a name="201"/>  201:         link(Peer),
<a name="202"/>  202:         {fail, disconnect_timeout}
<a name="203"/>  203:     end.
<a name="204"/>  204: 
<a name="peer_down_continue-0"/><a name="205"/>  205: <b>peer_down_continue</b>() -&gt;
<a name="peer_down_continue-last_expr"/><a name="206"/>  206:     [{doc, &quot;Tests peer_down handling for continue setting&quot;}].
<a name="207"/>  207: 
<a name="peer_down_continue-1"/><a name="208"/>  208: <b>peer_down_continue</b>(Config) when is_list(Config) -&gt;
<a name="209"/>  209:     {ok, Peer, Node} = peer:start_link(#{name =&gt; peer:random_name(?FUNCTION_NAME),
<a name="210"/>  210:         args =&gt; [&quot;-connect_all&quot;, &quot;false&quot;], peer_down =&gt; continue}),
<a name="211"/>  211:     ?assertEqual(ok, erpc:cast(Node, erlang, halt, [])),
<a name="212"/>  212:     ct:sleep(500),
<a name="213"/>  213:     sys:replace_state(net_kernel, fun(S) -&gt; sys:get_state(Peer), S end),
<a name="214"/>  214:     ?assertMatch({down, _}, peer:get_state(Peer)),
<a name="peer_down_continue-last_expr"/><a name="215"/>  215: <b>    peer:stop</b>(Peer).
<a name="216"/>  216: 
<a name="peer_down_boot-0"/><a name="217"/>  217: <b>peer_down_boot</b>() -&gt;
<a name="peer_down_boot-last_expr"/><a name="218"/>  218:     [{doc, &quot;Tests that peer node failing boot fails start_link correctly&quot;}].
<a name="219"/>  219: 
<a name="peer_down_boot-1"/><a name="220"/>  220: <b>peer_down_boot</b>(Config) when is_list(Config) -&gt;
<a name="peer_down_boot-last_expr"/><a name="221"/>  221: <b>    ?assertException</b>(exit, {boot_failed, {exit_status, 1}},
<a name="222"/>  222:         peer:start_link(#{connection =&gt; standard_io, name =&gt; peer:random_name(), args =&gt; [&quot;-no_epmd&quot;]})).
<a name="223"/>  223: 
<a name="dist_io_redirect-0"/><a name="224"/>  224: <b>dist_io_redirect</b>() -&gt;
<a name="dist_io_redirect-last_expr"/><a name="225"/>  225:     [{doc, &quot;Tests i/o redirection working for dist&quot;}].
<a name="226"/>  226: 
<a name="dist_io_redirect-1"/><a name="227"/>  227: <b>dist_io_redirect</b>(Config) when is_list(Config) -&gt;
<a name="228"/>  228:     %% Common Test changes group leader process to capture output.
<a name="229"/>  229:     %% 'peer' relays output via control process group leader.
<a name="230"/>  230:     ct:capture_start(),
<a name="231"/>  231:     {ok, Peer, Node} = peer:start_link(#{name =&gt; peer:random_name(?FUNCTION_NAME),
<a name="232"/>  232:         args =&gt; [&quot;-connect_all&quot;, &quot;false&quot;, &quot;-eval&quot;, &quot;io:format(\&quot;out\&quot;).&quot;]}),
<a name="233"/>  233:     %% RPC is smart enough to set the group leader, so force 'user' output
<a name="234"/>  234:     %% to check that peer node redirects 'user' to the current process group
<a name="235"/>  235:     %% leader.
<a name="236"/>  236:     ?assertEqual(ok, erpc:call(Node, io, format, [user, &quot;STRONGFLOUR.&quot;, []])),
<a name="237"/>  237:     %% verify that 'send' is ignored when no alternative connection is done
<a name="238"/>  238:     ?assertEqual(ok, peer:send(Peer, init, {stop, stop})),
<a name="239"/>  239:     %% check that RPC sets the group leader, even via 'apply'
<a name="240"/>  240:     ?assertEqual(ok, erpc:call(Node, erlang, apply, [io, format, [&quot;second.&quot;]])),
<a name="241"/>  241:     %% 'eval' at the end may be quite slow, so have to wait here
<a name="242"/>  242:     ct:sleep(500),
<a name="243"/>  243:     peer:stop(Peer),
<a name="244"/>  244:     ct:capture_stop(),
<a name="245"/>  245:     Texts = ct:capture_get(),
<a name="246"/>  246:     %% order is not guaranteed, so sort explicitly
<a name="dist_io_redirect-last_expr"/><a name="247"/>  247: <b>    ?assertEqual</b>(lists:sort([&quot;STRONGFLOUR.&quot;, &quot;second.&quot;, &quot;out&quot;]), lists:sort(Texts)).
<a name="248"/>  248: 
<a name="dist_up_down-0"/><a name="249"/>  249: <b>dist_up_down</b>() -&gt;
<a name="dist_up_down-last_expr"/><a name="250"/>  250: <b>    [{doc, &quot;Test that Erlang distribution can go up and down </b>(with TCP alternative)&quot;}].
<a name="251"/>  251: 
<a name="dist_up_down-1"/><a name="252"/>  252: <b>dist_up_down</b>(Config) when is_list(Config) -&gt;
<a name="253"/>  253:     %% skip establishing full mesh, for it makes 'global' hang
<a name="254"/>  254:     %% TODO: fix 'global.erl' locker process so it does not hang
<a name="255"/>  255:     {ok, Peer, Node} = peer:start_link(#{name =&gt; peer:random_name(?FUNCTION_NAME),
<a name="256"/>  256:         connection =&gt; {{127, 0, 0, 1}, 0}, args =&gt; [&quot;-connect_all&quot;, &quot;false&quot;]}),
<a name="257"/>  257:     ?assertEqual(true, net_kernel:connect_node(Node)),
<a name="258"/>  258:     ?assertEqual(true, net_kernel:disconnect(Node)),
<a name="259"/>  259:     ?assertEqual(true, net_kernel:connect_node(Node)),
<a name="dist_up_down-last_expr"/><a name="260"/>  260: <b>    peer:stop</b>(Peer).
<a name="261"/>  261: 
<a name="dist_localhost-0"/><a name="262"/>  262: <b>dist_localhost</b>() -&gt;
<a name="dist_localhost-last_expr"/><a name="263"/>  263:     [{doc, &quot;Test that localhost and gethostname operate together&quot;}].
<a name="264"/>  264: 
<a name="dist_localhost-1"/><a name="265"/>  265: <b>dist_localhost</b>(Config) when is_list(Config) -&gt;
<a name="266"/>  266:     {ok, Peer, Node} = peer:start_link(#{name =&gt; peer:random_name(?FUNCTION_NAME), host =&gt; &quot;localhost&quot;}),
<a name="267"/>  267:     ?assertMatch([_, &quot;localhost&quot;], string:lexemes(atom_to_list(Node), &quot;@&quot;)),
<a name="268"/>  268:     %% start second peer, ensure they see each other
<a name="269"/>  269:     {ok, Host} = inet:gethostname(),
<a name="270"/>  270:     {ok, Peer2, Node2} = peer:start_link(#{name =&gt; peer:random_name(?FUNCTION_NAME), host =&gt; Host}),
<a name="271"/>  271:     true = erpc:call(Node, net_kernel, connect_node, [Node2]),
<a name="272"/>  272:     peer:stop(Peer),
<a name="dist_localhost-last_expr"/><a name="273"/>  273: <b>    peer:stop</b>(Peer2).
<a name="274"/>  274: 
<a name="275"/>  275: <i>%% -------------------------------------------------------------------</i>
<a name="276"/>  276: <i>%% alternative connection cases</i>
<a name="277"/>  277: 
<a name="278"/>  278: <i>%% Runs in the peer node context, forward a message from peer node to origin</i>
<a name="279"/>  279: <i>%%  node via alternative connection.</i>
<a name="280"/>  280: <b>-spec forward</b>(Dest :: pid() | atom(), Message :: term()) -&gt; term().
<a name="forward-2"/><a name="281"/>  281: <b>forward</b>(Dest, Message) -&gt;
<a name="forward-last_expr"/><a name="282"/>  282: <b>    group_leader</b>() ! {message, Dest, Message}.
<a name="283"/>  283: 
<a name="basic-0"/><a name="284"/>  284: <b>basic</b>() -&gt;
<a name="basic-last_expr"/><a name="285"/>  285:     [{doc, &quot;Tests peer node start, and do some RPC via stdin/stdout&quot;}].
<a name="286"/>  286: 
<a name="basic-1"/><a name="287"/>  287: <b>basic</b>(Config) when is_list(Config) -&gt;
<a name="288"/>  288:     Conn = proplists:get_value(connection, Config),
<a name="289"/>  289:     {ok, Peer, _Node} = peer:start_link(#{connection =&gt; Conn}),
<a name="290"/>  290:     %% test the alternative connection
<a name="291"/>  291:     ?assertEqual('nonode@nohost', peer:call(Peer, erlang, node, [])),
<a name="292"/>  292:     ?assertException(throw, ball, peer:call(Peer, erlang, throw, [ball])),
<a name="293"/>  293:     %% setup code path to this module (needed to &quot;fancy RPC&quot;)
<a name="294"/>  294:     Path = filename:dirname(code:which(?MODULE)),
<a name="295"/>  295:     ?assertEqual(true, peer:call(Peer, code, add_path, [Path])),
<a name="296"/>  296:     %% fancy RPC via message exchange (uses forwarding from the peer)
<a name="297"/>  297:     Control = self(),
<a name="298"/>  298:     RFun = fun() -&gt; receive do -&gt; forward(Control, done) end end,
<a name="299"/>  299:     RemotePid = peer:call(Peer, erlang, spawn, [RFun]),
<a name="300"/>  300:     peer:send(Peer, RemotePid, do),
<a name="301"/>  301:     %% wait back from that process
<a name="302"/>  302:     receive done -&gt; ok end,
<a name="303"/>  303:     %% shutdown the node
<a name="304"/>  304:     ?assertEqual(ok, peer:stop(Peer)),
<a name="basic-last_expr"/><a name="305"/>  305: <b>    ?assertNot</b>(is_process_alive(Peer)).
<a name="306"/>  306: 
<a name="peer_states-0"/><a name="307"/>  307: <b>peer_states</b>() -&gt;
<a name="peer_states-last_expr"/><a name="308"/>  308:     [{doc, &quot;Tests peer node states&quot;}].
<a name="309"/>  309: 
<a name="peer_states-1"/><a name="310"/>  310: <b>peer_states</b>(Config) when is_list(Config) -&gt;
<a name="311"/>  311:     Conn = proplists:get_value(connection, Config),
<a name="312"/>  312:     {ok, Peer} = peer:start_link(#{connection =&gt; Conn, wait_boot =&gt; {self(), ?FUNCTION_NAME},
<a name="313"/>  313:         peer_down =&gt; continue}),
<a name="314"/>  314:     ?assertEqual(booting, peer:get_state(Peer)),
<a name="315"/>  315:     %% running
<a name="316"/>  316:     receive {?FUNCTION_NAME, {started, _Node, Peer}} -&gt; ok end,
<a name="317"/>  317:     ?assertEqual(running, peer:get_state(Peer)),
<a name="318"/>  318:     peer:cast(Peer, erlang, halt, []),
<a name="319"/>  319:     ct:sleep(1000), %% source of flakiness, should switch to some better notification mechanism
<a name="320"/>  320:     %% down
<a name="321"/>  321:     ?assertMatch({down, _}, peer:get_state(Peer)),
<a name="peer_states-last_expr"/><a name="322"/>  322: <b>    peer:stop</b>(Peer).
<a name="323"/>  323: 
<a name="cast-0"/><a name="324"/>  324: <b>cast</b>() -&gt;
<a name="cast-last_expr"/><a name="325"/>  325:     [{doc, &quot;Tests casts via alternative connections&quot;}].
<a name="326"/>  326: 
<a name="cast-1"/><a name="327"/>  327: <b>cast</b>(Config) when is_list(Config) -&gt;
<a name="328"/>  328:     Conn = proplists:get_value(connection, Config),
<a name="329"/>  329:     {ok, Peer, _Node} = peer:start_link(#{connection =&gt; Conn}),
<a name="330"/>  330:     %% cast RPC
<a name="331"/>  331:     ?assertEqual(undefined, peer:call(Peer, application, get_env, [kernel, foo])),
<a name="332"/>  332:     peer:cast(Peer, application, set_env, [kernel, foo, bar]),
<a name="333"/>  333:     %% this is only to ensure application_controller completed processing
<a name="334"/>  334:     peer:call(Peer, sys, get_state, [application_controller]),
<a name="335"/>  335:     ?assertEqual({ok, bar}, peer:call(Peer, application, get_env, [kernel, foo])),
<a name="cast-last_expr"/><a name="336"/>  336: <b>    peer:stop</b>(Peer).
<a name="337"/>  337: 
<a name="detached-0"/><a name="338"/>  338: <b>detached</b>() -&gt;
<a name="detached-last_expr"/><a name="339"/>  339: <b>    [{doc, &quot;Tests detached node </b>(RPC via alternative connection)&quot;}].
<a name="340"/>  340: 
<a name="detached-1"/><a name="341"/>  341: <b>detached</b>(Config) when is_list(Config) -&gt;
<a name="342"/>  342:     Conn = proplists:get_value(connection, Config),
<a name="343"/>  343:     {ok, Peer, _Node} = peer:start_link(#{connection =&gt; Conn}),
<a name="344"/>  344:     ?assertEqual('nonode@nohost', peer:call(Peer, erlang, node, [])),
<a name="345"/>  345:     %% check exceptions
<a name="346"/>  346:     ?assertException(throw, ball, peer:call(Peer, erlang, throw, [ball])),
<a name="347"/>  347:     %% check tcp forwarding
<a name="348"/>  348:     Path = filename:dirname(code:which(?MODULE)),
<a name="349"/>  349:     ?assertEqual(true, peer:call(Peer, code, add_path, [Path])),
<a name="350"/>  350:     %% fancy RPC via message exchange (uses forwarding from the peer)
<a name="351"/>  351:     Control = self(),
<a name="352"/>  352:     RFun = fun() -&gt; receive do -&gt; forward(Control, done) end end,
<a name="353"/>  353:     RemotePid = peer:call(Peer, erlang, spawn, [RFun]),
<a name="354"/>  354:     %% test that sending message over alternative TCP connection works
<a name="355"/>  355:     peer:send(Peer, RemotePid, do),
<a name="356"/>  356:     %% wait back from that process
<a name="357"/>  357:     receive done -&gt; ok end,
<a name="358"/>  358:     %% logging via TCP
<a name="359"/>  359:     ct:capture_start(),
<a name="360"/>  360:     peer:call(Peer, io, format, [&quot;one.&quot;]),
<a name="361"/>  361:     peer:call(Peer, erlang, apply, [io, format, [&quot;two.&quot;]]),
<a name="362"/>  362:     peer:stop(Peer),
<a name="363"/>  363:     ct:capture_stop(),
<a name="364"/>  364:     Texts = ct:capture_get(),
<a name="365"/>  365:     %% just stop
<a name="detached-last_expr"/><a name="366"/>  366: <b>    ?assertEqual</b>([&quot;one.&quot;, &quot;two.&quot;], Texts).
<a name="367"/>  367: 
<a name="dyn_peer-0"/><a name="368"/>  368: <b>dyn_peer</b>() -&gt;
<a name="dyn_peer-last_expr"/><a name="369"/>  369:     [{doc, &quot;Origin is not distributed, and peer becomes distributed dynamically&quot;}].
<a name="370"/>  370: 
<a name="dyn_peer-1"/><a name="371"/>  371: <b>dyn_peer</b>(Config) when is_list(Config) -&gt;
<a name="372"/>  372:     Conn = proplists:get_value(connection, Config),
<a name="373"/>  373:     {ok, Peer, 'nonode@nohost'} = peer:start_link(#{connection =&gt; Conn}), %% start not distributed
<a name="374"/>  374:     Node = list_to_atom(lists:concat([peer:random_name(?FUNCTION_NAME), &quot;@forced.host&quot;])),
<a name="375"/>  375:     {ok, _} = peer:call(Peer, net_kernel, start, [[Node, longnames]]),
<a name="376"/>  376:     ?assertEqual(Node, peer:call(Peer, erlang, node, [])),
<a name="dyn_peer-last_expr"/><a name="377"/>  377: <b>    peer:stop</b>(Peer).
<a name="378"/>  378: 
<a name="stop_peer-0"/><a name="379"/>  379: <b>stop_peer</b>() -&gt;
<a name="stop_peer-last_expr"/><a name="380"/>  380:     [{doc, &quot;Test that peer shuts down even when node sleeps, but control connection closed&quot;}].
<a name="381"/>  381: 
<a name="stop_peer-1"/><a name="382"/>  382: <b>stop_peer</b>(Config) when is_list(Config) -&gt;
<a name="383"/>  383:     Conn = proplists:get_value(connection, Config),
<a name="384"/>  384:     {ok, Peer, _Node} = peer:start_link(#{name =&gt; peer:random_name(?FUNCTION_NAME),
<a name="385"/>  385:         connection =&gt; Conn, args =&gt; [&quot;-eval&quot;, &quot;timer:sleep(60000).&quot;]}),
<a name="386"/>  386:     %% shutdown node
<a name="stop_peer-last_expr"/><a name="387"/>  387: <b>    peer:stop</b>(Peer).
<a name="388"/>  388: 
<a name="shutdown_halt-0"/><a name="389"/>  389: <b>shutdown_halt</b>() -&gt;
<a name="shutdown_halt-last_expr"/><a name="390"/>  390:     [{doc, &quot;Test that peer shutdown halt wait until node connection is down&quot;}].
<a name="shutdown_halt-1"/><a name="391"/>  391: <b>shutdown_halt</b>(Config) when is_list(Config) -&gt;
<a name="392"/>  392:     false = shutdown_test(Config, ?FUNCTION_NAME, halt, 500, false, 1000),
<a name="shutdown_halt-last_expr"/><a name="393"/>  393:     ok.
<a name="394"/>  394: 
<a name="shutdown_halt_timeout-0"/><a name="395"/>  395: <b>shutdown_halt_timeout</b>() -&gt;
<a name="shutdown_halt_timeout-last_expr"/><a name="396"/>  396:     [{doc, &quot;Test that peer shutdown halt forcefully takes down connection on timeout&quot;}].
<a name="shutdown_halt_timeout-1"/><a name="397"/>  397: <b>shutdown_halt_timeout</b>(Config) when is_list(Config) -&gt;
<a name="398"/>  398:     false = shutdown_test(Config, ?FUNCTION_NAME, {halt, 1000}, 5000, true, 1500),
<a name="shutdown_halt_timeout-last_expr"/><a name="399"/>  399:     ok.
<a name="400"/>  400: 
<a name="shutdown_stop-0"/><a name="401"/>  401: <b>shutdown_stop</b>() -&gt;
<a name="shutdown_stop-last_expr"/><a name="402"/>  402:     [{doc, &quot;Test that peer shutdown stop wait until node connection is down&quot;}].
<a name="shutdown_stop-1"/><a name="403"/>  403: <b>shutdown_stop</b>(Config) when is_list(Config) -&gt;
<a name="404"/>  404:     false = shutdown_test(Config, ?FUNCTION_NAME, infinity, 500, false, 2000),
<a name="shutdown_stop-last_expr"/><a name="405"/>  405:     ok.
<a name="406"/>  406: 
<a name="shutdown_stop_timeout-0"/><a name="407"/>  407: <b>shutdown_stop_timeout</b>() -&gt;
<a name="shutdown_stop_timeout-last_expr"/><a name="408"/>  408:     [{doc, &quot;Test that peer shutdown stop forcefully takes down connection on timeout&quot;}].
<a name="shutdown_stop_timeout-1"/><a name="409"/>  409: <b>shutdown_stop_timeout</b>(Config) when is_list(Config) -&gt;
<a name="410"/>  410:     false = shutdown_test(Config, ?FUNCTION_NAME, 1000, 5000, true, 2500),
<a name="shutdown_stop_timeout-last_expr"/><a name="411"/>  411:     ok.
<a name="412"/>  412: 
<a name="shutdown_close-0"/><a name="413"/>  413: <b>shutdown_close</b>() -&gt;
<a name="shutdown_close-last_expr"/><a name="414"/>  414:     [{doc, &quot;Test that peer shutdown close does not wait for dist connection&quot;}].
<a name="shutdown_close-1"/><a name="415"/>  415: <b>shutdown_close</b>(Config) when is_list(Config) -&gt;
<a name="416"/>  416:     _ = shutdown_test(Config, ?FUNCTION_NAME, close, 5000, true, 200),
<a name="shutdown_close-last_expr"/><a name="417"/>  417:     ok.
<a name="418"/>  418: 
<a name="shutdown_test-6"/><a name="419"/>  419: <b>shutdown_test</b>(Config, TC, Shutdown, BlockTime, StopWhileBlocked, MaxWaitTime) -&gt;
<a name="420"/>  420:     Options0 = #{name =&gt; ?CT_PEER_NAME(TC),
<a name="421"/>  421:                  shutdown =&gt; Shutdown,
<a name="422"/>  422:                  args =&gt; [&quot;-hidden&quot;, &quot;-pa&quot;, filename:dirname(code:which(?MODULE)),
<a name="423"/>  423:                           &quot;-setcookie&quot;, atom_to_list(erlang:get_cookie())]},
<a name="424"/>  424:     Options = case proplists:get_value(connection, Config) of
<a name="425"/>  425:                   undefined -&gt; Options0;
<a name="426"/>  426:                   Conn -&gt; maps:put(connection, Conn, Options0)
<a name="427"/>  427:               end,
<a name="428"/>  428:     {ok, Peer, Node} = peer:start_link(Options),
<a name="429"/>  429:     EnsureBlockedWait = 500,
<a name="430"/>  430:     BlockStart = erlang:monotonic_time(millisecond),
<a name="431"/>  431:     erpc:cast(Node,
<a name="432"/>  432:               fun () -&gt;
<a name="433"/>  433:                       erts_debug:set_internal_state(available_internal_state, true),
<a name="434"/>  434:                       erts_debug:set_internal_state(block, BlockTime+EnsureBlockedWait)
<a name="435"/>  435:               end),
<a name="436"/>  436:     receive after EnsureBlockedWait -&gt; ok end, %% Ensure blocked...
<a name="437"/>  437:     Start = erlang:monotonic_time(millisecond),
<a name="438"/>  438:     peer:stop(Peer),
<a name="439"/>  439:     End = erlang:monotonic_time(millisecond),
<a name="440"/>  440:     WaitTime = End - Start,
<a name="441"/>  441:     BlockTimeLeft = BlockTime + EnsureBlockedWait - (Start - BlockStart),
<a name="442"/>  442:     Connected = lists:member(Node, nodes(connected)),
<a name="443"/>  443:     ct:pal(&quot;Connected = ~p~nWaitTime = ~p~nBlockTimeLeft = ~p~n&quot;,
<a name="444"/>  444:            [Connected, WaitTime, BlockTimeLeft]),
<a name="445"/>  445:     true = WaitTime =&lt; MaxWaitTime,
<a name="446"/>  446:     case StopWhileBlocked of
<a name="447"/>  447:         true -&gt; ok;
<a name="448"/>  448:         false -&gt; true = WaitTime &gt;= BlockTimeLeft, ok
<a name="449"/>  449:     end,
<a name="shutdown_test-last_expr"/><a name="450"/>  450:     Connected.
<a name="451"/>  451: 
<a name="init_debug-0"/><a name="452"/>  452: <b>init_debug</b>() -&gt;
<a name="init_debug-last_expr"/><a name="453"/>  453:     [{doc, &quot;Test that debug messages in init work&quot;}].
<a name="454"/>  454: 
<a name="init_debug-1"/><a name="455"/>  455: <b>init_debug</b>(Config) when is_list(Config) -&gt;
<a name="456"/>  456:     ct:capture_start(),
<a name="457"/>  457:     {ok, Peer, _Node} = peer:start_link(#{name =&gt; peer:random_name(?FUNCTION_NAME), shutdown =&gt; 1000,
<a name="458"/>  458:         connection =&gt; standard_io, args =&gt; [&quot;-init_debug&quot;]}),
<a name="459"/>  459:     ct:sleep(200), %% without this sleep, peer is not fast enough to print
<a name="460"/>  460:     peer:stop(Peer),
<a name="461"/>  461:     ct:capture_stop(),
<a name="462"/>  462:     Texts = lists:append([string:trim(Str, trailing, &quot;\r\n&quot;) || Str &lt;- ct:capture_get()]),
<a name="463"/>  463:     %% every boot script starts with this
<a name="464"/>  464:     Expected = &quot;{progress,preloaded}&quot;,
<a name="465"/>  465:     Actual = lists:sublist(Texts, 1, length(Expected)),
<a name="init_debug-last_expr"/><a name="466"/>  466: <b>    ?assertEqual</b>(Expected, Actual).
<a name="467"/>  467: 
<a name="io_redirect-0"/><a name="468"/>  468: <b>io_redirect</b>() -&gt;
<a name="io_redirect-last_expr"/><a name="469"/>  469:     [{doc, &quot;Tests i/o redirection working for std&quot;}].
<a name="470"/>  470: 
<a name="io_redirect-1"/><a name="471"/>  471: <b>io_redirect</b>(Config) when is_list(Config) -&gt;
<a name="472"/>  472:     Conn = proplists:get_value(connection, Config),
<a name="473"/>  473:     {ok, Peer, _Node} = peer:start_link(#{connection =&gt; Conn}),
<a name="474"/>  474:     ct:capture_start(),
<a name="475"/>  475:     peer:call(Peer, io, format, [user, &quot;test.&quot;, []]),
<a name="476"/>  476:     peer:call(Peer, erlang, apply, [io, format, [&quot;second.&quot;]]),
<a name="477"/>  477:     %% ensure no dist connection is set up
<a name="478"/>  478:     ?assertNot(lists:member(Peer, nodes()), {dist_connected, Peer, nodes()}),
<a name="479"/>  479:     ct:capture_stop(),
<a name="480"/>  480:     Texts = ct:capture_get(),
<a name="481"/>  481:     peer:stop(Peer),
<a name="io_redirect-last_expr"/><a name="482"/>  482: <b>    ?assertEqual</b>([&quot;test.&quot;, &quot;second.&quot;], Texts).
<a name="483"/>  483: 
<a name="multi_node-0"/><a name="484"/>  484: <b>multi_node</b>() -&gt;
<a name="multi_node-last_expr"/><a name="485"/>  485:     [{doc, &quot;Tests several nodes starting concurrently&quot;}].
<a name="486"/>  486: 
<a name="multi_node-1"/><a name="487"/>  487: <b>multi_node</b>(Config) when is_list(Config) -&gt;
<a name="488"/>  488:     Conn = proplists:get_value(connection, Config),
<a name="489"/>  489:     Peers = [
<a name="490"/>  490:         peer:start_link(#{name =&gt; peer:random_name(?FUNCTION_NAME),
<a name="491"/>  491:             wait_boot =&gt; {self(), tag}, connection =&gt; Conn})
<a name="492"/>  492:         || _ &lt;- lists:seq(1, 4)],
<a name="493"/>  493:     Nodes = [receive {tag, {started, Node, Peer}} -&gt; Node end || {ok, Peer} &lt;- Peers],
<a name="494"/>  494:     ?assertEqual(4, length(Nodes)),
<a name="multi_node-last_expr"/><a name="495"/>  495: <b>    [?assertEqual</b>(ok, peer:stop(Peer)) || {ok, Peer} &lt;- Peers].
<a name="496"/>  496: 
<a name="duplicate_name-0"/><a name="497"/>  497: <b>duplicate_name</b>() -&gt;
<a name="duplicate_name-last_expr"/><a name="498"/>  498:     [{doc, &quot;Tests that a node with the same name fails to start&quot;}].
<a name="499"/>  499: 
<a name="duplicate_name-1"/><a name="500"/>  500: <b>duplicate_name</b>(Config) when is_list(Config) -&gt;
<a name="501"/>  501:     Conn = proplists:get_value(connection, Config),
<a name="502"/>  502:     {ok, Peer, _Node} = peer:start_link(#{connection =&gt; Conn, name =&gt; ?FUNCTION_NAME, register =&gt; false}),
<a name="503"/>  503:     ?assertException(exit, _, peer:start_link(#{connection =&gt; standard_io, name =&gt; ?FUNCTION_NAME})),
<a name="duplicate_name-last_expr"/><a name="504"/>  504: <b>    peer:stop</b>(Peer).
<a name="505"/>  505: 
<a name="post_process_args-0"/><a name="506"/>  506: <b>post_process_args</b>() -&gt;
<a name="post_process_args-last_expr"/><a name="507"/>  507:     [{doc, &quot;Test that the post_process_args option works&quot;}].
<a name="508"/>  508: 
<a name="post_process_args-1"/><a name="509"/>  509: <b>post_process_args</b>(Config) when is_list(Config) -&gt;
<a name="post_process_args-last_expr"/><a name="510"/>  510: <b>    case {os:type</b>(),os:find_executable(&quot;bash&quot;)} of
<a name="511"/>  511:         {{win32,_}, _Bash} -&gt;
<a name="512"/>  512:             {skip,&quot;Test does not work on windows&quot;};
<a name="513"/>  513:         {_, false} -&gt;
<a name="514"/>  514:             {skip,&quot;Test needs bash to run&quot;};
<a name="515"/>  515:         {_, Bash} -&gt;
<a name="516"/>  516:             Erl = string:split(ct:get_progname(),&quot; &quot;,all),
<a name="517"/>  517:             [throw({skip, &quot;Needs bash to run&quot;}) || Bash =:= false],
<a name="518"/>  518:             {ok, Peer, _Node} =
<a name="519"/>  519:                 peer:start_link(
<a name="520"/>  520:                   #{ name =&gt; ?CT_PEER_NAME(),
<a name="521"/>  521:                      exec =&gt; {Bash,[&quot;-c&quot;|Erl]},
<a name="522"/>  522:                      post_process_args =&gt;
<a name="523"/>  523:                          fun([&quot;-c&quot;|Args]) -&gt;
<a name="524"/>  524:                                  [&quot;-c&quot;, lists:flatten(lists:join($\s, Args))]
<a name="525"/>  525:                          end }),
<a name="526"/>  526:             peer:stop(Peer)
<a name="527"/>  527:     end.
<a name="528"/>  528: 
<a name="529"/>  529: <i>%% -------------------------------------------------------------------</i>
<a name="530"/>  530: <i>%% Compatibility: old releases</i>
<a name="old_release-0"/><a name="531"/>  531: <b>old_release</b>() -&gt;
<a name="old_release-last_expr"/><a name="532"/>  532:     [{doc, &quot;Verity running with previous OTP release&quot;}].
<a name="533"/>  533: 
<a name="old_release-1"/><a name="534"/>  534: <b>old_release</b>(Config) when is_list(Config) -&gt;
<a name="535"/>  535:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="536"/>  536:     %% don't expect OTP 10 to be available
<a name="537"/>  537:     ?assertEqual(not_available, ?CT_PEER_REL([], &quot;10&quot;, PrivDir)),
<a name="538"/>  538:     PrevRel = integer_to_list(list_to_integer(erlang:system_info(otp_release)) - 2),
<a name="old_release-last_expr"/><a name="539"/>  539: <b>    case ?CT_PEER_REL</b>([], PrevRel, PrivDir) of
<a name="540"/>  540:         not_available -&gt;
<a name="541"/>  541:             {skip, &quot;OTP &quot; ++ PrevRel ++ &quot; not found&quot;};
<a name="542"/>  542:         {ok, Peer, Node} -&gt;
<a name="543"/>  543:             ?assertEqual(PrevRel, rpc:call(Node, erlang, system_info, [otp_release])),
<a name="544"/>  544:             peer:stop(Peer)
<a name="545"/>  545:     end.
<a name="546"/>  546: 
<a name="547"/>  547: <i>%% -------------------------------------------------------------------</i>
<a name="548"/>  548: <i>%% SSH/Docker cases</i>
<a name="549"/>  549: 
<a name="ssh-0"/><a name="550"/>  550: <b>ssh</b>() -&gt;
<a name="ssh-last_expr"/><a name="551"/>  551: <b>    [{doc, &quot;Tests ssh </b>(localhost) node support&quot;}].
<a name="552"/>  552: 
<a name="ssh-1"/><a name="553"/>  553: <b>ssh</b>(Config) when is_list(Config) -&gt;
<a name="554"/>  554:     %% figure out path to 'erl' locally ('erl' may not be in path via SSH)
<a name="ssh-last_expr"/><a name="555"/>  555: <b>    case {os:find_executable</b>(&quot;erl&quot;), os:find_executable(&quot;ssh&quot;)} of
<a name="556"/>  556:         {false, _} -&gt;
<a name="557"/>  557:             {skip, &quot;erl not found&quot;};
<a name="558"/>  558:         {ErlPath, SshPath} -&gt;
<a name="559"/>  559:             Name = peer:random_name(?FUNCTION_NAME),
<a name="560"/>  560:             {OsName, _} = os:type(),
<a name="561"/>  561:             Options = #{exec =&gt; {SshPath, [&quot;localhost&quot;, ErlPath]},
<a name="562"/>  562:                         connection =&gt; standard_io, name =&gt; Name, host =&gt; &quot;localhost&quot;},
<a name="563"/>  563:             {ok, Peer, _Node} =
<a name="564"/>  564:                 try peer:start_link(Options) of
<a name="565"/>  565:                     Result -&gt; Result
<a name="566"/>  566:                 catch error:{boot_failed, normal} when OsName =:= win32 -&gt;
<a name="567"/>  567:                         %% If the boot fails on windows, ssh may have ended up
<a name="568"/>  568:                         %% in wsl, so we try to boot using a wsl path
<a name="569"/>  569:                         WslPath = string:trim(os:cmd(&quot;wsl wslpath -u &quot; ++ ErlPath)),
<a name="570"/>  570:                         peer:start_link(
<a name="571"/>  571:                           Options#{ exec =&gt; {SshPath, [&quot;localhost&quot;, WslPath]}})
<a name="572"/>  572:                 end,
<a name="573"/>  573: 
<a name="574"/>  574:             %% TODO: how to check it really goes over SSH?
<a name="575"/>  575:             %% ssh-ed node is not distributed
<a name="576"/>  576:             ?assertEqual(list_to_atom(Name ++ &quot;@localhost&quot;), peer:call(Peer, erlang, node, [])),
<a name="577"/>  577:             peer:stop(Peer)
<a name="578"/>  578:     end.
<a name="579"/>  579: 
<a name="docker-0"/><a name="580"/>  580: <b>docker</b>() -&gt;
<a name="docker-last_expr"/><a name="581"/>  581:     [{doc, &quot;Tests starting peer node in Docker container&quot;}, {timetrap, {seconds, 60}}].
<a name="582"/>  582: 
<a name="build_release-1"/><a name="583"/>  583: <b>build_release</b>(Dir) -&gt;
<a name="584"/>  584:     application:load(sasl), %% otherwise application:get_key will fail
<a name="585"/>  585:     %% build release (tarball)
<a name="586"/>  586:     RelFile = filename:join(Dir, &quot;lambda.rel&quot;),
<a name="587"/>  587:     Release = {release, {&quot;lambda&quot;, &quot;1.0.0&quot;}, {erts, erlang:system_info(version)},
<a name="588"/>  588:         [{App, begin {ok, Vsn} = application:get_key(App, vsn), Vsn end} || App &lt;- [kernel, stdlib, sasl]]},
<a name="589"/>  589:     ok = file:write_file(RelFile, list_to_binary(lists:flatten(io_lib:format(&quot;~tp.&quot;, [Release])))),
<a name="590"/>  590:     RelFileNoExt = filename:join(Dir, &quot;lambda&quot;),
<a name="591"/>  591:     {ok, systools_make, []} = systools:make_script(RelFileNoExt, [silent, {outdir, Dir}]),
<a name="build_release-last_expr"/><a name="592"/>  592: <b>    ok = systools:make_tar</b>(RelFileNoExt, [{erts, code:root_dir()}]).
<a name="593"/>  593: 
<a name="build_image-1"/><a name="594"/>  594: <b>build_image</b>(Dir) -&gt;
<a name="595"/>  595:     %% build docker image
<a name="596"/>  596:     BuildScript = filename:join(Dir, &quot;Dockerfile&quot;),
<a name="597"/>  597:     Dockerfile =
<a name="598"/>  598:         &quot;FROM ubuntu:20.04 as runner\n&quot;
<a name="599"/>  599:         &quot;WORKDIR /opt/lambda\n&quot;
<a name="600"/>  600:         &quot;COPY lambda.tar.gz /tmp\n&quot;
<a name="601"/>  601:         &quot;RUN tar -zxvf /tmp/lambda.tar.gz -C /opt/lambda\n&quot;
<a name="602"/>  602:         &quot;ENTRYPOINT [\&quot;/opt/lambda/erts-&quot; ++ erlang:system_info(version) ++ &quot;/bin/dyn_erl\&quot;, \&quot;-boot\&quot;, \&quot;/opt/lambda/releases/1.0.0/start\&quot;]\n&quot;,
<a name="603"/>  603:     ok = file:write_file(BuildScript, Dockerfile),
<a name="604"/>  604:     Output = os:cmd(&quot;docker build -t lambda &quot; ++ Dir),
<a name="build_image-last_expr"/><a name="605"/>  605: <b>    ct:pal</b>(&quot;Build result: ~s~n&quot;, [Output]).
<a name="606"/>  606: 
<a name="docker-1"/><a name="607"/>  607: <b>docker</b>(Config) when is_list(Config) -&gt;
<a name="docker-last_expr"/><a name="608"/>  608: <b>    case os:find_executable</b>(&quot;docker&quot;) of
<a name="609"/>  609:         false -&gt;
<a name="610"/>  610:             {skip, &quot;Docker not found&quot;};
<a name="611"/>  611:         Docker -&gt;
<a name="612"/>  612:             PrivDir = proplists:get_value(priv_dir, Config),
<a name="613"/>  613:             build_release(PrivDir),
<a name="614"/>  614:             build_image(PrivDir),
<a name="615"/>  615: 
<a name="616"/>  616:             {ok, Peer, Node} = peer:start_link(#{name =&gt; ?CT_PEER_NAME(),
<a name="617"/>  617:                 exec =&gt; {Docker, [&quot;run&quot;, &quot;-i&quot;, &quot;lambda&quot;]}, connection =&gt; standard_io}),
<a name="618"/>  618:             ?assertEqual(Node, peer:call(Peer, erlang, node, [])),
<a name="619"/>  619:             peer:stop(Peer)
<a name="620"/>  620:     end.
<a name="621"/>  621: 
<a name="attached-0"/><a name="622"/>  622: <b>attached</b>() -&gt;
<a name="attached-last_expr"/><a name="623"/>  623:     [{doc, &quot;Test that it is possible to start a peer node using run_erl aka attached&quot;}].
<a name="624"/>  624: 
<a name="attached-1"/><a name="625"/>  625: <b>attached</b>(Config) -&gt;
<a name="attached-last_expr"/><a name="626"/>  626: <b>    attached_test</b>(false, Config).
<a name="627"/>  627: 
<a name="attached_cntrl_channel_handler_crash-0"/><a name="628"/>  628: <b>attached_cntrl_channel_handler_crash</b>() -&gt;
<a name="attached_cntrl_channel_handler_crash-last_expr"/><a name="629"/>  629:     [{doc, &quot;Test that peer node is halted if peer control channel handler process crashes and peer node is attached&quot;}].
<a name="630"/>  630: 
<a name="attached_cntrl_channel_handler_crash-1"/><a name="631"/>  631: <b>attached_cntrl_channel_handler_crash</b>(Config) -&gt;
<a name="attached_cntrl_channel_handler_crash-last_expr"/><a name="632"/>  632: <b>    attached_test</b>(true, Config).
<a name="633"/>  633: 
<a name="attached_test-2"/><a name="634"/>  634: <b>attached_test</b>(CrashConnectionHandler, Config) -&gt;
<a name="635"/>  635:     RunErl = os:find_executable(&quot;run_erl&quot;),
<a name="636"/>  636:     [throw({skip, &quot;Could not find run_erl&quot;}) || RunErl =:= false],
<a name="637"/>  637:     Erl = string:split(ct:get_progname(),&quot; &quot;,all),
<a name="638"/>  638:     RunErlDir = filename:join(proplists:get_value(priv_dir, Config),?FUNCTION_NAME),
<a name="639"/>  639:     filelib:ensure_path(RunErlDir),
<a name="640"/>  640:     Connection = proplists:get_value(connection, Config),
<a name="641"/>  641:     Conn = if Connection =:= undefined -&gt; #{ name =&gt; ?CT_PEER_NAME() };
<a name="642"/>  642:               true -&gt;
<a name="643"/>  643:                    case CrashConnectionHandler of
<a name="644"/>  644:                        false -&gt;
<a name="645"/>  645:                            #{ connection =&gt; Connection };
<a name="646"/>  646:                        true -&gt;
<a name="647"/>  647:                            #{name =&gt; ?CT_PEER_NAME(),
<a name="648"/>  648:                              connection =&gt; Connection}
<a name="649"/>  649:                    end
<a name="650"/>  650:            end,
<a name="attached_test-last_expr"/><a name="651"/>  651: <b>    try peer:start</b>(
<a name="652"/>  652:            Conn#{
<a name="653"/>  653:                  exec =&gt; {RunErl, Erl},
<a name="654"/>  654:                  detached =&gt; false,
<a name="655"/>  655:                  post_process_args =&gt;
<a name="656"/>  656:                      fun(Args) -&gt;
<a name="657"/>  657:                              [RunErlDir ++ &quot;/&quot;, RunErlDir,
<a name="658"/>  658:                               lists:flatten(lists:join(&quot; &quot;,[[$',A,$'] || A &lt;- Args]))]
<a name="659"/>  659:                      end
<a name="660"/>  660:                 }) of
<a name="661"/>  661:         {ok, Peer, Node} when Connection =:= undefined; Connection =:= 0 -&gt;
<a name="662"/>  662:             case CrashConnectionHandler of
<a name="663"/>  663:                 false -&gt; peer:stop(Peer);
<a name="664"/>  664:                 true -&gt; cntrl_channel_handler_crash_test(Node)
<a name="665"/>  665:             end
<a name="666"/>  666:     catch error:{detached,_} when Connection =:= standard_io -&gt;
<a name="667"/>  667:             ok
<a name="668"/>  668:     end.
<a name="669"/>  669: 
<a name="cntrl_channel_handler_crash-0"/><a name="670"/>  670: <b>cntrl_channel_handler_crash</b>() -&gt;
<a name="cntrl_channel_handler_crash-last_expr"/><a name="671"/>  671:     [{doc, &quot;Test that peer node is halted if peer control channel handler process crashes&quot;}].
<a name="672"/>  672: 
<a name="cntrl_channel_handler_crash-1"/><a name="673"/>  673: <b>cntrl_channel_handler_crash</b>(Config) -&gt;
<a name="674"/>  674:     NameOpts = #{name =&gt; ?CT_PEER_NAME()},
<a name="675"/>  675:     Opts = case proplists:get_value(connection, Config) of
<a name="676"/>  676:                undefined -&gt; NameOpts;
<a name="677"/>  677:                Conn -&gt; NameOpts#{connection =&gt; Conn}
<a name="678"/>  678:            end,
<a name="679"/>  679:     {ok, _Peer, Node} = peer:start_link(Opts),
<a name="cntrl_channel_handler_crash-last_expr"/><a name="680"/>  680: <b>    cntrl_channel_handler_crash_test</b>(Node).
<a name="681"/>  681: 
<a name="cntrl_channel_handler_crash_old_release-0"/><a name="682"/>  682: <b>cntrl_channel_handler_crash_old_release</b>() -&gt;
<a name="cntrl_channel_handler_crash_old_release-last_expr"/><a name="683"/>  683:     [{doc, &quot;Test that peer node running an old release is halted if peer control channel handler process crashes&quot;}].
<a name="684"/>  684: 
<a name="cntrl_channel_handler_crash_old_release-1"/><a name="685"/>  685: <b>cntrl_channel_handler_crash_old_release</b>(Config) -&gt;
<a name="686"/>  686:     NameOpts = #{name =&gt; ?CT_PEER_NAME()},
<a name="687"/>  687:     Opts = case proplists:get_value(connection, Config) of
<a name="688"/>  688:                undefined -&gt; NameOpts;
<a name="689"/>  689:                Conn -&gt; NameOpts#{connection =&gt; Conn}
<a name="690"/>  690:            end,
<a name="691"/>  691:     PrivDir = proplists:get_value(priv_dir, Config),
<a name="692"/>  692:     OldRel = integer_to_list(list_to_integer(erlang:system_info(otp_release)) - 2),
<a name="cntrl_channel_handler_crash_old_release-last_expr"/><a name="693"/>  693: <b>    case ?CT_PEER_REL</b>(Opts, OldRel, PrivDir) of
<a name="694"/>  694:         not_available -&gt;
<a name="695"/>  695:             {skip, &quot;No OTP &quot; ++ OldRel ++ &quot; installation found&quot;};
<a name="696"/>  696:         {ok, _Peer, Node} -&gt;
<a name="697"/>  697:             cntrl_channel_handler_crash_test(Node)
<a name="698"/>  698:     end.
<a name="699"/>  699: 
<a name="cntrl_channel_handler_crash_test-1"/><a name="700"/>  700: <b>cntrl_channel_handler_crash_test</b>(Node) -&gt;
<a name="701"/>  701:     true = monitor_node(Node, true),
<a name="702"/>  702:     ChkStck = fun ChkStck (_Pid, []) -&gt;
<a name="703"/>  703:                       ok;
<a name="704"/>  704:                   ChkStck (Pid, [{peer, io_server_loop, _, _} | _]) -&gt;
<a name="705"/>  705:                       throw(Pid);
<a name="706"/>  706:                   ChkStck (Pid, [{peer, origin_link, _, _} | _]) -&gt;
<a name="707"/>  707:                       throw(Pid);
<a name="708"/>  708:                   ChkStck (Pid, [_SF|SFs]) -&gt;
<a name="709"/>  709:                       ChkStck(Pid, SFs)
<a name="710"/>  710:               end,
<a name="711"/>  711:     ChkConnHandler = fun (undefined) -&gt;
<a name="712"/>  712:                              ok;
<a name="713"/>  713:                          (Pid) when is_pid(Pid) -&gt;
<a name="714"/>  714:                              case erpc:call(Node, erlang, process_info,
<a name="715"/>  715:                                             [Pid, current_stacktrace]) of
<a name="716"/>  716:                                  {current_stacktrace, STrace} -&gt;
<a name="717"/>  717:                                      ChkStck(Pid, STrace);
<a name="718"/>  718:                                  _ -&gt;
<a name="719"/>  719:                                      ok
<a name="720"/>  720:                              end
<a name="721"/>  721:                      end,
<a name="722"/>  722:     ConnHandler = try
<a name="723"/>  723:                       ChkConnHandler(erpc:call(Node, erlang, whereis, [user])),
<a name="724"/>  724:                       lists:foreach(fun (Pid) -&gt;
<a name="725"/>  725:                                             ChkConnHandler(Pid)
<a name="726"/>  726:                                     end, erpc:call(Node, erlang, processes, [])),
<a name="727"/>  727:                       error(no_cntrl_channel_handler_found)
<a name="728"/>  728:                   catch
<a name="729"/>  729:                       throw:Pid when is_pid(Pid) -&gt; Pid
<a name="730"/>  730:                   end,
<a name="731"/>  731:     PeerSup = erpc:call(Node, erlang, whereis, [peer_supervision]),
<a name="732"/>  732:     ct:log(&quot;peer_supervision state: ~p~n&quot;, [erpc:call(Node, sys, get_state, [PeerSup])]),
<a name="733"/>  733:     {links, Links} = erpc:call(Node, erlang, process_info, [PeerSup, links]),
<a name="734"/>  734:     true = lists:member(ConnHandler, Links),
<a name="735"/>  735:     ok = erpc:cast(Node, erlang, exit, [ConnHandler, kill]),
<a name="cntrl_channel_handler_crash_test-last_expr"/><a name="736"/>  736:     receive
<a name="737"/>  737:         {nodedown, Node} -&gt;
<a name="738"/>  738:             ok
<a name="739"/>  739:     after
<a name="740"/>  740:         5000 -&gt;
<a name="741"/>  741:             ct:fail(peer_did_not_halt)
<a name="742"/>  742:     end.
</pre>
<script>
var hash = window.location.hash.substring(1);
var anchor = document.getElementsByName(hash);
anchor[0].style.backgroundColor="orange";
</script>
</body>
</html>
