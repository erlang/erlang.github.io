<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/lib/compiler/make_test_dir/compiler_test/inline_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%</i>
<a name="2"/>    2: <i>%% %CopyrightBegin%</i>
<a name="3"/>    3: <i>%% </i>
<a name="4"/>    4: <i>%% Copyright Ericsson AB 2000-2022. All Rights Reserved.</i>
<a name="5"/>    5: <i>%% </i>
<a name="6"/>    6: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="7"/>    7: <i>%% you may not use this file except in compliance with the License.</i>
<a name="8"/>    8: <i>%% You may obtain a copy of the License at</i>
<a name="9"/>    9: <i>%%</i>
<a name="10"/>   10: <i>%%     http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="11"/>   11: <i>%%</i>
<a name="12"/>   12: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="13"/>   13: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="14"/>   14: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="15"/>   15: <i>%% See the License for the specific language governing permissions and</i>
<a name="16"/>   16: <i>%% limitations under the License.</i>
<a name="17"/>   17: <i>%% </i>
<a name="18"/>   18: <i>%% %CopyrightEnd%</i>
<a name="19"/>   19: <i>%%</i>
<a name="20"/>   20: <i>%%% Purpose : Tests inlining.</i>
<a name="21"/>   21: 
<a name="22"/>   22: <b>-module</b>(inline_SUITE).
<a name="23"/>   23: 
<a name="24"/>   24: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="25"/>   25: 
<a name="26"/>   26: <b>-compile</b>(export_all).
<a name="27"/>   27: <b>-compile</b>({inline,[badarg/2]}).
<a name="28"/>   28: 
<a name="29"/>   29: <i>%% Needed by test case `lists'.</i>
<a name="30"/>   30: <b>-compile</b>(inline_list_funcs).
<a name="31"/>   31: 
<a name="suite-0"/><a name="suite-last_expr"/><a name="32"/>   32: <b>suite</b>() -&gt; [{ct_hooks,[ts_install_cth]}].
<a name="33"/>   33: 
<a name="all-0"/><a name="34"/>   34: <b>all</b>() -&gt; 
<a name="all-last_expr"/><a name="35"/>   35:     [{group,p}].
<a name="36"/>   36: 
<a name="groups-0"/><a name="37"/>   37: <b>groups</b>() -&gt; 
<a name="groups-last_expr"/><a name="38"/>   38: <b>    [{p,test_lib:parallel</b>(),
<a name="39"/>   39:       [attribute,bsdecode,bsdes,barnes2,decode1,smith,fname,
<a name="40"/>   40:        itracer,pseudoknot,maps_inline_test,comma_splitter,lists,really_inlined,otp_7223,
<a name="41"/>   41:        coverage]}].
<a name="42"/>   42: 
<a name="init_per_suite-1"/><a name="43"/>   43: <b>init_per_suite</b>(Config) -&gt;
<a name="44"/>   44:     test_lib:recompile(?MODULE),
<a name="init_per_suite-last_expr"/><a name="45"/>   45:     Config.
<a name="46"/>   46: 
<a name="end_per_suite-1"/><a name="47"/>   47: <b>end_per_suite</b>(_Config) -&gt;
<a name="end_per_suite-last_expr"/><a name="48"/>   48:     ok.
<a name="49"/>   49: 
<a name="init_per_group-2"/><a name="50"/>   50: <b>init_per_group</b>(_GroupName, Config) -&gt;
<a name="init_per_group-last_expr"/><a name="51"/>   51:     Config.
<a name="52"/>   52: 
<a name="end_per_group-2"/><a name="53"/>   53: <b>end_per_group</b>(_GroupName, Config) -&gt;
<a name="end_per_group-last_expr"/><a name="54"/>   54:     Config.
<a name="55"/>   55: 
<a name="56"/>   56: 
<a name="attribute-1"/><a name="57"/>   57: <b>attribute</b>(Config) when is_list(Config) -&gt;
<a name="58"/>   58:     Name = &quot;attribute&quot;,
<a name="59"/>   59:     Src = filename:join(proplists:get_value(data_dir, Config), Name),
<a name="60"/>   60:     Out = proplists:get_value(priv_dir,Config),
<a name="61"/>   61: 
<a name="62"/>   62:     {ok,attribute=Mod} = compile:file(Src, [{outdir,Out},report,time]),
<a name="63"/>   63:     Outfile = filename:join(Out, Name++&quot;.beam&quot;),
<a name="64"/>   64:     {ok,{Mod,[{locals,Locals}]}} = beam_lib:chunks(Outfile, [locals]),
<a name="65"/>   65:     io:format(&quot;locals: ~p\n&quot;, [Locals]),
<a name="66"/>   66: 
<a name="67"/>   67:     %% The inliner should have removed all local functions.
<a name="68"/>   68:     [] = Locals,
<a name="69"/>   69: 
<a name="attribute-last_expr"/><a name="70"/>   70:     ok.
<a name="71"/>   71: 
<a name="72"/>   72: <b>-define</b>(comp(Name),
<a name="73"/>   73: 	Name(Config) when is_list(Config) -&gt;
<a name="74"/>   74: 	       try_inline(Name, Config)).
<a name="75"/>   75: 
<a name="bsdecode-1"/><a name="bsdecode-last_expr"/><a name="76"/>   76: <b>?comp</b>(bsdecode).
<a name="bsdes-1"/><a name="bsdes-last_expr"/><a name="77"/>   77: <b>?comp</b>(bsdes).
<a name="barnes2-1"/><a name="barnes2-last_expr"/><a name="78"/>   78: <b>?comp</b>(barnes2).
<a name="decode1-1"/><a name="decode1-last_expr"/><a name="79"/>   79: <b>?comp</b>(decode1).
<a name="smith-1"/><a name="smith-last_expr"/><a name="80"/>   80: <b>?comp</b>(smith).
<a name="itracer-1"/><a name="itracer-last_expr"/><a name="81"/>   81: <b>?comp</b>(itracer).
<a name="pseudoknot-1"/><a name="pseudoknot-last_expr"/><a name="82"/>   82: <b>?comp</b>(pseudoknot).
<a name="comma_splitter-1"/><a name="comma_splitter-last_expr"/><a name="83"/>   83: <b>?comp</b>(comma_splitter).
<a name="fname-1"/><a name="fname-last_expr"/><a name="84"/>   84: <b>?comp</b>(fname).
<a name="maps_inline_test-1"/><a name="maps_inline_test-last_expr"/><a name="85"/>   85: <b>?comp</b>(maps_inline_test).
<a name="86"/>   86: 
<a name="try_inline-2"/><a name="87"/>   87: <b>try_inline</b>(Mod, Config) -&gt;
<a name="88"/>   88:     Src = filename:join(proplists:get_value(data_dir, Config),
<a name="89"/>   89: 			atom_to_list(Mod)),
<a name="90"/>   90:     Out = proplists:get_value(priv_dir,Config),
<a name="91"/>   91: 
<a name="92"/>   92:     %% Normal compilation.
<a name="93"/>   93:     io:format(&quot;Compiling: ~s\n&quot;, [Src]),
<a name="94"/>   94:     {ok,Mod} = compile:file(Src, [{outdir,Out},report,
<a name="95"/>   95:                                   bin_opt_info,recv_opt_info,clint,ssalint]),
<a name="96"/>   96: 
<a name="97"/>   97:     ct:timetrap({minutes,10}),
<a name="98"/>   98:     NormalResult = load_and_call(Out, Mod),
<a name="99"/>   99: 
<a name="100"/>  100:     %% Inlining.
<a name="101"/>  101:     io:format(&quot;Compiling with old inliner: ~s\n&quot;, [Src]),
<a name="102"/>  102:     {ok,Mod} = compile:file(Src, [{outdir,Out},report,bin_opt_info,
<a name="103"/>  103:                                   recv_opt_info,{inline,1000},clint,ssalint]),
<a name="104"/>  104: 
<a name="105"/>  105:     %% Run inlined code.
<a name="106"/>  106:     ct:timetrap({minutes,10}),
<a name="107"/>  107:     OldInlinedResult = load_and_call(Out, Mod),
<a name="108"/>  108: 
<a name="109"/>  109:     %% Compare results.
<a name="110"/>  110:     compare(NormalResult, OldInlinedResult),
<a name="111"/>  111:     NormalResult = OldInlinedResult,
<a name="112"/>  112: 
<a name="113"/>  113:     %% Inlining.
<a name="114"/>  114:     io:format(&quot;Compiling with new inliner: ~s\n&quot;, [Src]),
<a name="115"/>  115:     {ok,Mod} = compile:file(Src, [{outdir,Out},report,bin_opt_info,
<a name="116"/>  116:                                   inline,recv_opt_info,clint,ssalint]),
<a name="117"/>  117: 
<a name="118"/>  118:     %% Run inlined code.
<a name="119"/>  119:     ct:timetrap({minutes,10}),
<a name="120"/>  120:     InlinedResult = load_and_call(Out, Mod),
<a name="121"/>  121: 
<a name="122"/>  122:     %% Compare results.
<a name="123"/>  123:     compare(NormalResult, InlinedResult),
<a name="124"/>  124:     NormalResult = InlinedResult,
<a name="125"/>  125: 
<a name="126"/>  126:     %% Delete Beam file.
<a name="127"/>  127:     ok = file:delete(filename:join(Out, atom_to_list(Mod)++code:objfile_extension())),
<a name="128"/>  128: 
<a name="129"/>  129:     %% Delete loaded module.
<a name="130"/>  130:     _ = code:purge(Mod),
<a name="131"/>  131:     _ = code:delete(Mod),
<a name="132"/>  132:     _ = code:purge(Mod),
<a name="133"/>  133: 
<a name="try_inline-last_expr"/><a name="134"/>  134:     ok.
<a name="135"/>  135: 
<a name="compare-2"/><a name="136"/>  136: <b>compare</b>(Same, Same) -&gt; ok;
<a name="137"/>  137: <b>compare</b>([Same|T1], [Same|T2]) -&gt;
<a name="138"/>  138:     compare(T1, T2);
<a name="139"/>  139: <b>compare</b>([{X,Y,RGB1}|T1], [{X,Y,RGB2}|T2]) -&gt;
<a name="140"/>  140:     io:format(&quot;X = ~p, Y = ~p, RGB normal = ~p, RGB inlined ~p\n&quot;, [X,Y,RGB1,RGB2]),
<a name="141"/>  141:     compare(T1, T2);
<a name="142"/>  142: <b>compare</b>([H1|_], [H2|_]) -&gt;
<a name="143"/>  143:     io:format(&quot;Normal = ~p, Inlined = ~p\n&quot;, [H1,H2]),
<a name="144"/>  144:     ct:fail(different);
<a name="compare-last_expr"/><a name="145"/>  145: <b>compare</b>([], []) -&gt; ok.
<a name="146"/>  146: 
<a name="load_and_call-2"/><a name="147"/>  147: <b>load_and_call</b>(Out, Module) -&gt;
<a name="148"/>  148:     io:format(&quot;Loading...\n&quot;,[]),
<a name="149"/>  149:     code:purge(Module),
<a name="150"/>  150:     LoadRc = code:load_abs(filename:join(Out, Module)),
<a name="151"/>  151:     {module,Module} = LoadRc,
<a name="152"/>  152: 
<a name="153"/>  153:     io:format(&quot;Calling...\n&quot;,[]),
<a name="154"/>  154:     {Time,CallResult} = timer:tc(Module, Module, []),
<a name="155"/>  155:     io:format(&quot;Time: ~p\n&quot;, [Time]),
<a name="load_and_call-last_expr"/><a name="156"/>  156:     CallResult.
<a name="157"/>  157: 
<a name="158"/>  158: <i>%% Macros used by lists/1 below.</i>
<a name="159"/>  159: 
<a name="160"/>  160: <b>-define</b>(TestHighOrder_2(Name, Body, List),
<a name="161"/>  161: 	begin
<a name="162"/>  162: 	    put(?MODULE, []),
<a name="163"/>  163: 	    (fun({Res,Res2}) -&gt;
<a name="164"/>  164: 		     {Res,Res2} = my_apply(lists, Name, [Body,List], [])
<a name="165"/>  165: 	     end)(begin
<a name="166"/>  166: 		      (fun(R) -&gt;
<a name="167"/>  167: 			       {R,get(?MODULE)}
<a name="168"/>  168: 		       end)(lists:Name(Body, List))
<a name="169"/>  169: 		  end)
<a name="170"/>  170: 	 end).
<a name="171"/>  171: 
<a name="172"/>  172: <b>-define</b>(TestHighOrder_3(Name, Body, Init, List),
<a name="173"/>  173: 	begin
<a name="174"/>  174: 	    put(?MODULE, []),
<a name="175"/>  175: 	    (fun({Res,Res2}) -&gt;
<a name="176"/>  176: 		     {Res,Res2} = my_apply(lists, Name, [Body,Init,List], [])
<a name="177"/>  177: 	     end)(begin
<a name="178"/>  178: 		      (fun(R) -&gt;
<a name="179"/>  179: 			       {R,get(?MODULE)}
<a name="180"/>  180: 		       end)(lists:Name(Body, Init, List))
<a name="181"/>  181: 		  end)
<a name="182"/>  182: 	 end).
<a name="183"/>  183: 
<a name="184"/>  184: <i>%% For each high order function in the lists module, verify</i>
<a name="185"/>  185: <i>%% that the inlined version produces the same result and is evaluated</i>
<a name="186"/>  186: <i>%% in the same order as the function in the lists module.</i>
<a name="187"/>  187: <i>%%</i>
<a name="188"/>  188: <i>%% Note: This module must be compiled with the inline_lists_funcs option.</i>
<a name="189"/>  189: 
<a name="lists-1"/><a name="190"/>  190: <b>lists</b>(Config) when is_list(Config) -&gt;
<a name="191"/>  191:     List = lists:seq(1, 20),
<a name="192"/>  192: 
<a name="193"/>  193:     %% lists:map/2
<a name="194"/>  194:     ?TestHighOrder_2(map,
<a name="195"/>  195: 		     (fun(E) -&gt;
<a name="196"/>  196: 			      R = E band 16#ff,
<a name="197"/>  197: 			      put(?MODULE, [E|get(?MODULE)]),
<a name="198"/>  198: 			      R
<a name="199"/>  199: 		      end), List),
<a name="200"/>  200: 
<a name="201"/>  201:     %% lists:flatmap/2
<a name="202"/>  202:     ?TestHighOrder_2(flatmap,
<a name="203"/>  203: 		     (fun(E) -&gt;
<a name="204"/>  204: 			      R = lists:duplicate(E, E),
<a name="205"/>  205: 			      put(?MODULE, [E|get(?MODULE)]),
<a name="206"/>  206: 			      R
<a name="207"/>  207: 		      end), List),
<a name="208"/>  208: 
<a name="209"/>  209:     %% lists:foreach/2
<a name="210"/>  210:     ?TestHighOrder_2(foreach,
<a name="211"/>  211: 		     (fun(E) -&gt;
<a name="212"/>  212: 			      put(?MODULE, [E bor 7|get(?MODULE)])
<a name="213"/>  213: 		      end), List),
<a name="214"/>  214: 
<a name="215"/>  215:     %% lists:filter/2
<a name="216"/>  216:     ?TestHighOrder_2(filter,
<a name="217"/>  217: 		     (fun(E) -&gt;
<a name="218"/>  218: 			      put(?MODULE, [E|get(?MODULE)]),
<a name="219"/>  219: 			      (E bsr 1) band 1 =/= 0
<a name="220"/>  220: 		      end), List),
<a name="221"/>  221: 
<a name="222"/>  222:     %% lists:any/2
<a name="223"/>  223:     ?TestHighOrder_2(any,
<a name="224"/>  224: 		     (fun(E) -&gt;
<a name="225"/>  225: 			      put(?MODULE, [E|get(?MODULE)]),
<a name="226"/>  226: 			      false	  %Force it to go through all.
<a name="227"/>  227: 		      end), List),
<a name="228"/>  228: 
<a name="229"/>  229:     %% lists:all/2
<a name="230"/>  230:     ?TestHighOrder_2(all,
<a name="231"/>  231: 		     (fun(E) -&gt;
<a name="232"/>  232: 			      put(?MODULE, [E|get(?MODULE)]),
<a name="233"/>  233: 			      true	  %Force it to go through all.
<a name="234"/>  234: 		      end), List),
<a name="235"/>  235: 
<a name="236"/>  236:     %% lists:foldl/3
<a name="237"/>  237:     ?TestHighOrder_3(foldl,
<a name="238"/>  238: 		     (fun(E, A) -&gt;
<a name="239"/>  239: 			      put(?MODULE, [E|get(?MODULE)]),
<a name="240"/>  240: 			      A bxor E
<a name="241"/>  241: 		      end), 0, List),
<a name="242"/>  242: 
<a name="243"/>  243:     %% lists:foldr/3
<a name="244"/>  244:     ?TestHighOrder_3(foldr,
<a name="245"/>  245: 		     (fun(E, A) -&gt;
<a name="246"/>  246: 			      put(?MODULE, [E|get(?MODULE)]),
<a name="247"/>  247: 			      A bxor (bnot E)
<a name="248"/>  248: 		      end), 0, List),
<a name="249"/>  249: 
<a name="250"/>  250:     %% lists:mapfoldl/3
<a name="251"/>  251:     ?TestHighOrder_3(mapfoldl,
<a name="252"/>  252: 		     (fun(E, A) -&gt;
<a name="253"/>  253: 			      put(?MODULE, [E|get(?MODULE)]),
<a name="254"/>  254: 			      {bnot E,A bxor (bnot E)}
<a name="255"/>  255: 		      end), 0, List),
<a name="256"/>  256: 
<a name="257"/>  257:     %% lists:mapfoldr/3
<a name="258"/>  258:     ?TestHighOrder_3(mapfoldr,
<a name="259"/>  259: 		     (fun(E, A) -&gt;
<a name="260"/>  260: 			      put(?MODULE, [E|get(?MODULE)]),
<a name="261"/>  261: 			      {bnot E,A bxor (bnot E)}
<a name="262"/>  262: 		      end), 0, List),
<a name="263"/>  263: 
<a name="264"/>  264:     %% Cleanup.
<a name="265"/>  265:     erase(?MODULE),
<a name="266"/>  266: 
<a name="267"/>  267:     {'EXIT',{function_clause,[{?MODULE,_,[_,not_a_list],_}|_]}} =
<a name="268"/>  268:         (catch lists:map(fun (X) -&gt; X end, not_a_list)),
<a name="269"/>  269:     {'EXIT',{function_clause,[{?MODULE,_,[_,not_a_list],_}|_]}} =
<a name="270"/>  270:         (catch lists:flatmap(fun (X) -&gt; X end, not_a_list)),
<a name="271"/>  271:     {'EXIT',{function_clause,[{?MODULE,_,[_,not_a_list],_}|_]}} =
<a name="272"/>  272:         (catch lists:foreach(fun (X) -&gt; X end, not_a_list)),
<a name="273"/>  273:     {'EXIT',{function_clause,[{?MODULE,_,[_,not_a_list],_}|_]}} =
<a name="274"/>  274:         (catch lists:filter(fun (_) -&gt; true end, not_a_list)),
<a name="275"/>  275:     {'EXIT',{function_clause,[{?MODULE,_,[_,not_a_list],_}|_]}} =
<a name="276"/>  276:         (catch lists:any(fun (_) -&gt; false end, not_a_list)),
<a name="277"/>  277:     {'EXIT',{function_clause,[{?MODULE,_,[_,not_a_list],_}|_]}} =
<a name="278"/>  278:         (catch lists:all(fun (_) -&gt; true end, not_a_list)),
<a name="279"/>  279:     {'EXIT',{function_clause,[{?MODULE,_,[_,acc,not_a_list],_}|_]}} =
<a name="280"/>  280:         (catch lists:foldl(fun (X, Acc) -&gt; {X,Acc} end, acc, not_a_list)),
<a name="281"/>  281:     {'EXIT',{function_clause,[{?MODULE,_,[_,acc,not_a_list],_}|_]}} =
<a name="282"/>  282:         (catch lists:foldr(fun (X, Acc) -&gt; {X,Acc} end, acc, not_a_list)),
<a name="283"/>  283:     {'EXIT',{function_clause,[{?MODULE,_,[_,acc,not_a_list],_}|_]}} =
<a name="284"/>  284:         (catch lists:mapfoldl(fun (X, Acc) -&gt; {X,Acc} end, acc, not_a_list)),
<a name="285"/>  285:     {'EXIT',{function_clause,[{?MODULE,_,[_,acc,not_a_list],_}|_]}} =
<a name="286"/>  286:         (catch lists:mapfoldr(fun (X, Acc) -&gt; {X,Acc} end, acc, not_a_list)),
<a name="287"/>  287: 
<a name="288"/>  288:     {'EXIT',{function_clause,[{?MODULE,_,[not_a_function,[]],_}|_]}} =
<a name="289"/>  289:         (catch lists:map(not_a_function, [])),
<a name="290"/>  290:     {'EXIT',{function_clause,[{?MODULE,_,[not_a_function,[]],_}|_]}} =
<a name="291"/>  291:         (catch lists:flatmap(not_a_function, [])),
<a name="292"/>  292:     {'EXIT',{function_clause,[{?MODULE,_,[not_a_function,[]],_}|_]}} =
<a name="293"/>  293:         (catch lists:foreach(not_a_function, [])),
<a name="294"/>  294:     {'EXIT',{function_clause,[{?MODULE,_,[not_a_function,[]],_}|_]}} =
<a name="295"/>  295:         (catch lists:filter(not_a_function, [])),
<a name="296"/>  296:     {'EXIT',{function_clause,[{?MODULE,_,[not_a_function,[]],_}|_]}} =
<a name="297"/>  297:         (catch lists:any(not_a_function, [])),
<a name="298"/>  298:     {'EXIT',{function_clause,[{?MODULE,_,[not_a_function,[]],_}|_]}} =
<a name="299"/>  299:         (catch lists:all(not_a_function, [])),
<a name="300"/>  300:     {'EXIT',{function_clause,[{?MODULE,_,[not_a_function,acc,[]],_}|_]}} =
<a name="301"/>  301:         (catch lists:foldl(not_a_function, acc, [])),
<a name="302"/>  302:     {'EXIT',{function_clause,[{?MODULE,_,[not_a_function,acc,[]],_}|_]}} =
<a name="303"/>  303:         (catch lists:foldr(not_a_function, acc, [])),
<a name="304"/>  304:     {'EXIT',{function_clause,[{?MODULE,_,[not_a_function,acc,[]],_}|_]}} =
<a name="305"/>  305:         (catch lists:mapfoldl(not_a_function, acc, [])),
<a name="306"/>  306:     {'EXIT',{function_clause,[{?MODULE,_,[not_a_function,acc,[]],_}|_]}} =
<a name="307"/>  307:         (catch lists:mapfoldr(not_a_function, acc, [])),
<a name="308"/>  308: 
<a name="lists-last_expr"/><a name="309"/>  309:     ok.
<a name="310"/>  310: 		       
<a name="my_apply-4"/><a name="311"/>  311: <b>my_apply</b>(M, F, A, Init) -&gt;
<a name="312"/>  312:     put(?MODULE, Init),
<a name="313"/>  313:     Res = apply(M, F, A),
<a name="my_apply-last_expr"/><a name="314"/>  314: <b>    {Res,get</b>(?MODULE)}.
<a name="315"/>  315: 
<a name="really_inlined-1"/><a name="316"/>  316: <b>really_inlined</b>(Config) when is_list(Config) -&gt;
<a name="317"/>  317:     %% Make sure that badarg/2 really gets inlined.
<a name="318"/>  318:     {'EXIT',{badarg,[{?MODULE,fail_me_now,[],_}|_]}} =
<a name="319"/>  319: 	(catch fail_me_now()),
<a name="really_inlined-last_expr"/><a name="320"/>  320:     ok.
<a name="321"/>  321: 
<a name="fail_me_now-0"/><a name="322"/>  322: <b>fail_me_now</b>() -&gt;
<a name="fail_me_now-last_expr"/><a name="323"/>  323: <b>    badarg</b>(foo(bar), []).
<a name="324"/>  324: 
<a name="foo-1"/><a name="325"/>  325: <b>foo</b>(_X) -&gt;
<a name="foo-last_expr"/><a name="326"/>  326:     badarg.
<a name="327"/>  327: 
<a name="328"/>  328: <i>%% Inlined.</i>
<a name="badarg-2"/><a name="329"/>  329: <b>badarg</b>(badarg, A) -&gt;
<a name="330"/>  330:     erlang:error(badarg, A);
<a name="331"/>  331: <b>badarg</b>(Reply, _A) -&gt;
<a name="badarg-last_expr"/><a name="332"/>  332:     Reply.
<a name="333"/>  333: 
<a name="otp_7223-1"/><a name="334"/>  334: <b>otp_7223</b>(Config) when is_list(Config) -&gt;
<a name="335"/>  335:     {'EXIT', {function_clause, [{?MODULE,_,[1],_}|_]}} = (catch otp_7223_1(1)),
<a name="otp_7223-last_expr"/><a name="336"/>  336:     ok.
<a name="337"/>  337: 
<a name="338"/>  338: <b>-compile</b>({inline,[{otp_7223_1,1}]}).
<a name="otp_7223_1-1"/><a name="339"/>  339: <b>otp_7223_1</b>(X) -&gt;
<a name="otp_7223_1-last_expr"/><a name="340"/>  340: <b>    otp_7223_2</b>(X).
<a name="341"/>  341: 
<a name="342"/>  342: <b>-compile</b>({inline,[{otp_7223_2,1}]}).
<a name="otp_7223_2-1"/><a name="343"/>  343: <b>otp_7223_2</b>({a}) -&gt;
<a name="otp_7223_2-last_expr"/><a name="344"/>  344:     1.
<a name="345"/>  345: 
<a name="coverage-1"/><a name="346"/>  346: <b>coverage</b>(Config) when is_list(Config) -&gt;
<a name="347"/>  347:     Mod = attribute,
<a name="348"/>  348:     Src = filename:join(proplists:get_value(data_dir, Config), Mod),
<a name="349"/>  349:     {ok,Mod,_} = compile:file(Src, [binary,report,{inline,0},
<a name="350"/>  350:                                     clint,ssalint]),
<a name="coverage-last_expr"/><a name="351"/>  351:     ok.
</pre>
</body>
</html>
