<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/lib/kernel/make_test_dir/kernel_test/pg_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%</i>
<a name="2"/>    2: <i>%%</i>
<a name="3"/>    3: <i>%% Copyright WhatsApp Inc. and its affiliates. All rights reserved.</i>
<a name="4"/>    4: <i>%%</i>
<a name="5"/>    5: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="6"/>    6: <i>%% you may not use this file except in compliance with the License.</i>
<a name="7"/>    7: <i>%% You may obtain a copy of the License at</i>
<a name="8"/>    8: <i>%%</i>
<a name="9"/>    9: <i>%%     http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="10"/>   10: <i>%%</i>
<a name="11"/>   11: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="12"/>   12: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="13"/>   13: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="14"/>   14: <i>%% See the License for the specific language governing permissions and</i>
<a name="15"/>   15: <i>%% limitations under the License.</i>
<a name="16"/>   16: <i>%%</i>
<a name="17"/>   17: <i>%%-------------------------------------------------------------------</i>
<a name="18"/>   18: <i>%% @author Maxim Fedorov &lt;maximfca@gmail.com&gt;</i>
<a name="19"/>   19: <i>%%     Process Groups smoke test.</i>
<a name="20"/>   20: <b>-module</b>(pg_SUITE).
<a name="21"/>   21: <b>-author</b>(&quot;maximfca@gmail.com&quot;).
<a name="22"/>   22: 
<a name="23"/>   23: <i>%% Test server callbacks</i>
<a name="24"/>   24: <b>-export</b>([
<a name="25"/>   25:     suite/0,
<a name="26"/>   26:     all/0,
<a name="27"/>   27:     groups/0,
<a name="28"/>   28:     init_per_testcase/2,
<a name="29"/>   29:     end_per_testcase/2,
<a name="30"/>   30:     init_per_group/2,
<a name="31"/>   31:     end_per_group/2,
<a name="32"/>   32:     stop_proc/1,
<a name="33"/>   33:     ensure_peers_info/2
<a name="34"/>   34: ]).
<a name="35"/>   35: 
<a name="36"/>   36: <i>%% Test cases exports</i>
<a name="37"/>   37: <b>-export</b>([
<a name="38"/>   38:     pg/0, pg/1,
<a name="39"/>   39:     errors/0, errors/1,
<a name="40"/>   40:     leave_exit_race/0, leave_exit_race/1,
<a name="41"/>   41:     dyn_distribution/0, dyn_distribution/1,
<a name="42"/>   42:     process_owner_check/0, process_owner_check/1,
<a name="43"/>   43:     overlay_missing/0, overlay_missing/1,
<a name="44"/>   44:     single/0, single/1,
<a name="45"/>   45:     two/1,
<a name="46"/>   46:     empty_group_by_remote_leave/0, empty_group_by_remote_leave/1,
<a name="47"/>   47:     thundering_herd/0, thundering_herd/1,
<a name="48"/>   48:     initial/1,
<a name="49"/>   49:     netsplit/1,
<a name="50"/>   50:     trisplit/1,
<a name="51"/>   51:     foursplit/1,
<a name="52"/>   52:     exchange/1,
<a name="53"/>   53:     nolocal/1,
<a name="54"/>   54:     double/1,
<a name="55"/>   55:     scope_restart/1,
<a name="56"/>   56:     missing_scope_join/1,
<a name="57"/>   57:     disconnected_start/1,
<a name="58"/>   58:     forced_sync/0, forced_sync/1,
<a name="59"/>   59:     group_leave/1,
<a name="60"/>   60:     monitor_nonempty_scope/0, monitor_nonempty_scope/1,
<a name="61"/>   61:     monitor_scope/0, monitor_scope/1,
<a name="62"/>   62:     monitor/1,
<a name="63"/>   63:     monitor_self/1,
<a name="64"/>   64:     multi_monitor/1,
<a name="65"/>   65:     protocol_upgrade/1,
<a name="66"/>   66:     e2e/1
<a name="67"/>   67: ]).
<a name="68"/>   68: 
<a name="69"/>   69: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="70"/>   70: <b>-include_lib</b>(&quot;stdlib/include/assert.hrl&quot;).
<a name="71"/>   71: 
<a name="suite-0"/><a name="72"/>   72: <b>suite</b>() -&gt;
<a name="suite-last_expr"/><a name="73"/>   73:     [{timetrap, {seconds, 60}}].
<a name="74"/>   74: 
<a name="init_per_testcase-2"/><a name="75"/>   75: <b>init_per_testcase</b>(TestCase, Config) -&gt;
<a name="76"/>   76:     {ok, Pid} = pg:start_link(TestCase),
<a name="init_per_testcase-last_expr"/><a name="77"/>   77: <b>    trace_start</b>(TestCase, Config, Pid).
<a name="78"/>   78: 
<a name="end_per_testcase-2"/><a name="79"/>   79: <b>end_per_testcase</b>(TestCase, Config) -&gt;
<a name="80"/>   80:     gen_server:stop(TestCase),
<a name="81"/>   81:     trace_end(Config),
<a name="end_per_testcase-last_expr"/><a name="82"/>   82:     ok.
<a name="83"/>   83: 
<a name="all-0"/><a name="84"/>   84: <b>all</b>() -&gt;
<a name="all-last_expr"/><a name="85"/>   85:     [dyn_distribution,
<a name="86"/>   86:      {group, basic},
<a name="87"/>   87:      {group, cluster},
<a name="88"/>   88:      {group, performance},
<a name="89"/>   89:      {group, monitor},
<a name="90"/>   90:      {group, old_release}].
<a name="91"/>   91: 
<a name="groups-0"/><a name="92"/>   92: <b>groups</b>() -&gt;
<a name="groups-last_expr"/><a name="93"/>   93:     [
<a name="94"/>   94:         {basic, [parallel], [errors, pg, leave_exit_race, single, overlay_missing,
<a name="95"/>   95:                              protocol_upgrade, monitor_self, multi_monitor]},
<a name="96"/>   96:         {performance, [], [thundering_herd]},
<a name="97"/>   97:         {cluster, [parallel], [process_owner_check, two, initial, netsplit, trisplit, foursplit,
<a name="98"/>   98:             exchange, nolocal, double, scope_restart, missing_scope_join, empty_group_by_remote_leave,
<a name="99"/>   99:             disconnected_start, forced_sync, group_leave]},
<a name="100"/>  100:         {monitor, [parallel], [monitor_nonempty_scope, monitor_scope, monitor]},
<a name="101"/>  101:         {old_release, [parallel], [process_owner_check, two, overlay_missing,
<a name="102"/>  102:                                    empty_group_by_remote_leave, initial, netsplit,
<a name="103"/>  103:                                    nolocal, e2e]}
<a name="104"/>  104:     ].
<a name="105"/>  105: 
<a name="init_per_group-2"/><a name="106"/>  106: <b>init_per_group</b>(old_release, Config) -&gt;
<a name="107"/>  107:     PrevRel = integer_to_list(list_to_integer(erlang:system_info(otp_release)) - 1),
<a name="108"/>  108:     case test_server:is_release_available(PrevRel) of
<a name="109"/>  109:         true -&gt;
<a name="110"/>  110:             [{otp_release, PrevRel} | Config];
<a name="111"/>  111:         false -&gt;
<a name="112"/>  112:             {skip, &quot;No OTP &quot;++PrevRel++&quot; release found&quot;}
<a name="113"/>  113:     end;
<a name="114"/>  114: <b>init_per_group</b>(_, Config) -&gt;
<a name="init_per_group-last_expr"/><a name="115"/>  115:     Config.
<a name="116"/>  116: 
<a name="end_per_group-2"/><a name="end_per_group-last_expr"/><a name="117"/>  117: <b>end_per_group</b>(_,_) -&gt; ok.
<a name="118"/>  118: 
<a name="119"/>  119: 
<a name="120"/>  120: <i>%%--------------------------------------------------------------------</i>
<a name="121"/>  121: <i>%% TEST CASES</i>
<a name="122"/>  122: 
<a name="pg-0"/><a name="123"/>  123: <b>pg</b>() -&gt;
<a name="pg-last_expr"/><a name="124"/>  124:     [{doc, &quot;This test must be names pg, to stay inline with default scope&quot;}].
<a name="125"/>  125: 
<a name="pg-1"/><a name="126"/>  126: <b>pg</b>(_Config) -&gt;
<a name="127"/>  127:     ?assertNotEqual(undefined, whereis(?FUNCTION_NAME)), %% ensure scope was started
<a name="128"/>  128:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, self())),
<a name="129"/>  129:     ?assertEqual([self()], pg:get_local_members(?FUNCTION_NAME)),
<a name="130"/>  130:     ?assertEqual([?FUNCTION_NAME], pg:which_groups()),
<a name="131"/>  131:     ?assertEqual([?FUNCTION_NAME], pg:which_local_groups()),
<a name="132"/>  132:     ?assertEqual(ok, pg:leave(?FUNCTION_NAME, self())),
<a name="133"/>  133:     ?assertEqual([], pg:get_members(?FUNCTION_NAME)),
<a name="134"/>  134:     ?assertEqual([], pg:which_groups(?FUNCTION_NAME)),
<a name="pg-last_expr"/><a name="135"/>  135: <b>    ?assertEqual</b>([], pg:which_local_groups(?FUNCTION_NAME)).
<a name="136"/>  136: 
<a name="errors-0"/><a name="137"/>  137: <b>errors</b>() -&gt;
<a name="errors-last_expr"/><a name="138"/>  138:     [{doc, &quot;Tests that errors are handled as expected, for example pg server crashes when it needs to&quot;}].
<a name="139"/>  139: 
<a name="errors-1"/><a name="140"/>  140: <b>errors</b>(_Config) -&gt;
<a name="141"/>  141:     %% kill with 'info' and 'cast'
<a name="142"/>  142:     ?assertException(error, badarg, pg:handle_info(garbage, garbage)),
<a name="143"/>  143:     ?assertException(error, badarg, pg:handle_cast(garbage, garbage)),
<a name="144"/>  144:     %% kill with call
<a name="145"/>  145:     {ok, _Pid} = pg:start(second),
<a name="errors-last_expr"/><a name="146"/>  146: <b>    ?assertException</b>(exit, {{badarg, _}, _}, gen_server:call(second, garbage, infinity)).
<a name="147"/>  147: 
<a name="leave_exit_race-0"/><a name="148"/>  148: <b>leave_exit_race</b>() -&gt;
<a name="leave_exit_race-last_expr"/><a name="149"/>  149:     [{doc, &quot;Tests that pg correctly handles situation when leave and 'DOWN' messages are both in pg queue&quot;}].
<a name="150"/>  150: 
<a name="leave_exit_race-1"/><a name="151"/>  151: <b>leave_exit_race</b>(Config) when is_list(Config) -&gt;
<a name="152"/>  152:     process_flag(priority, high),
<a name="leave_exit_race-last_expr"/><a name="153"/>  153:     [
<a name="154"/>  154:         begin
<a name="155"/>  155:             Pid = spawn(fun () -&gt; ok end),
<a name="156"/>  156:             pg:join(leave_exit_race, test, Pid),
<a name="157"/>  157:             pg:leave(leave_exit_race, test, Pid)
<a name="158"/>  158:         end
<a name="159"/>  159:         || _ &lt;- lists:seq(1, 100)].
<a name="160"/>  160: 
<a name="single-0"/><a name="161"/>  161: <b>single</b>() -&gt;
<a name="single-last_expr"/><a name="162"/>  162:     [{doc, &quot;Tests single node groups&quot;}, {timetrap, {seconds, 5}}].
<a name="163"/>  163: 
<a name="single-1"/><a name="164"/>  164: <b>single</b>(Config) when is_list(Config) -&gt;
<a name="165"/>  165:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, self())),
<a name="166"/>  166:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [self(), self()])),
<a name="167"/>  167:     ?assertEqual([self(), self(), self()], pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="168"/>  168:     ?assertEqual([self(), self(), self()], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="169"/>  169:     ?assertEqual(not_joined, pg:leave(?FUNCTION_NAME, '$missing$', self())),
<a name="170"/>  170:     ?assertEqual(ok, pg:leave(?FUNCTION_NAME, ?FUNCTION_NAME, [self(), self()])),
<a name="171"/>  171:     ?assertEqual(ok, pg:leave(?FUNCTION_NAME, ?FUNCTION_NAME, self())),
<a name="172"/>  172:     ?assertEqual([], pg:which_groups(?FUNCTION_NAME)),
<a name="173"/>  173:     ?assertEqual([], pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="174"/>  174:     ?assertEqual([], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="175"/>  175:     %% double
<a name="176"/>  176:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, self())),
<a name="177"/>  177:     Pid = erlang:spawn(forever()),
<a name="178"/>  178:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, Pid)),
<a name="179"/>  179:     Expected = lists:sort([Pid, self()]),
<a name="180"/>  180:     ?assertEqual(Expected, lists:sort(pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="181"/>  181:     ?assertEqual(Expected, lists:sort(pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="182"/>  182: 
<a name="183"/>  183:     stop_proc(Pid),
<a name="184"/>  184:     sync(?FUNCTION_NAME),
<a name="185"/>  185:     ?assertEqual([self()], pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="186"/>  186:     ?assertEqual(ok, pg:leave(?FUNCTION_NAME, ?FUNCTION_NAME, self())),
<a name="single-last_expr"/><a name="187"/>  187:     ok.
<a name="188"/>  188: 
<a name="dyn_distribution-0"/><a name="189"/>  189: <b>dyn_distribution</b>() -&gt;
<a name="dyn_distribution-last_expr"/><a name="190"/>  190:     [{doc, &quot;Tests that local node when distribution is started dynamically is not treated as remote node&quot;}].
<a name="191"/>  191: 
<a name="dyn_distribution-1"/><a name="192"/>  192: <b>dyn_distribution</b>(Config) when is_list(Config) -&gt;
<a name="193"/>  193:     %% When distribution is started or stopped dynamically,
<a name="194"/>  194:     %%  there is a nodeup/nodedown message delivered to pg
<a name="195"/>  195:     %% It is possible but non-trivial to simulate this
<a name="196"/>  196:     %%  behaviour with starting slave nodes being not
<a name="197"/>  197:     %%  distributed, and calling net_kernel:start/1, however
<a name="198"/>  198:     %%  the effect is still the same as simply sending nodeup,
<a name="199"/>  199:     %%  which is also documented.
<a name="200"/>  200:     ?FUNCTION_NAME ! {nodeup, node()},
<a name="201"/>  201:     %%
<a name="202"/>  202:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, self())),
<a name="203"/>  203:     ?assertEqual([self()], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="dyn_distribution-last_expr"/><a name="204"/>  204:     ok.
<a name="205"/>  205: 
<a name="process_owner_check-0"/><a name="206"/>  206: <b>process_owner_check</b>() -&gt;
<a name="process_owner_check-last_expr"/><a name="207"/>  207:     [{doc, &quot;Tests that process owner is local node&quot;}].
<a name="208"/>  208: 
<a name="process_owner_check-1"/><a name="209"/>  209: <b>process_owner_check</b>(Config) when is_list(Config) -&gt;
<a name="210"/>  210:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="211"/>  211:     %% spawn remote process
<a name="212"/>  212:     LocalPid = erlang:spawn(forever()),
<a name="213"/>  213:     RemotePid = spawn_sleeper_at(Node),
<a name="214"/>  214:     %% check they can't be joined locally
<a name="215"/>  215:     ?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid)),
<a name="216"/>  216:     ?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [RemotePid, RemotePid])),
<a name="217"/>  217:     ?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [LocalPid, RemotePid])),
<a name="218"/>  218:     %% check that non-pid also triggers error
<a name="219"/>  219:     ?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, undefined)),
<a name="220"/>  220:     ?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [undefined])),
<a name="221"/>  221:     %% stop the peer
<a name="222"/>  222:     peer:stop(Peer),
<a name="process_owner_check-last_expr"/><a name="223"/>  223:     ok.
<a name="224"/>  224: 
<a name="overlay_missing-0"/><a name="225"/>  225: <b>overlay_missing</b>() -&gt;
<a name="overlay_missing-last_expr"/><a name="226"/>  226:     [{doc, &quot;Tests that scope process that is not a part of overlay network does not change state&quot;}].
<a name="227"/>  227: 
<a name="overlay_missing-1"/><a name="228"/>  228: <b>overlay_missing</b>(Config) -&gt;
<a name="229"/>  229:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="230"/>  230:     %% join self (sanity check)
<a name="231"/>  231:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, group, self())),
<a name="232"/>  232:     %% remember pid from remote
<a name="233"/>  233:     PgPid = rpc:call(Node, erlang, whereis, [?FUNCTION_NAME]),
<a name="234"/>  234:     RemotePid = spawn_sleeper_at(Node),
<a name="235"/>  235:     %% stop remote scope
<a name="236"/>  236:     gen_server:stop(PgPid),
<a name="237"/>  237:     %% craft white-box request: ensure it's rejected
<a name="238"/>  238:     ?FUNCTION_NAME ! {join, PgPid, group, RemotePid},
<a name="239"/>  239:     %% rejected!
<a name="240"/>  240:     ?assertEqual([self()], pg:get_members(?FUNCTION_NAME, group)),
<a name="241"/>  241:     %% ... reject leave too
<a name="242"/>  242:     ?FUNCTION_NAME ! {leave, PgPid, RemotePid, [group]},
<a name="243"/>  243:     ?assertEqual([self()], pg:get_members(?FUNCTION_NAME, group)),
<a name="244"/>  244:     %% join many times on remote
<a name="245"/>  245:     %RemotePids = [erlang:spawn(TwoPeer, forever()) || _ &lt;- lists:seq(1, 1024)],
<a name="246"/>  246:     %?assertEqual(ok, rpc:call(TwoPeer, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, Pid2])),
<a name="247"/>  247:     %% check they can't be joined locally
<a name="248"/>  248:     %?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid)),
<a name="249"/>  249:     %?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [RemotePid, RemotePid])),
<a name="250"/>  250:     %?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [LocalPid, RemotePid])),
<a name="251"/>  251:     %% check that non-pid also triggers error
<a name="252"/>  252:     %?assertException(error, function_clause, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, undefined)),
<a name="253"/>  253:     %?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [undefined])),
<a name="254"/>  254:     %% stop the peer
<a name="overlay_missing-last_expr"/><a name="255"/>  255: <b>    peer:stop</b>(Peer).
<a name="256"/>  256: 
<a name="257"/>  257: 
<a name="two-1"/><a name="258"/>  258: <b>two</b>(Config) when is_list(Config) -&gt;
<a name="259"/>  259:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="260"/>  260:     Pid = erlang:spawn(forever()),
<a name="261"/>  261:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, Pid)),
<a name="262"/>  262:     ?assertEqual([Pid], pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="263"/>  263:     %% first RPC must be serialised 3 times
<a name="264"/>  264:     sync({?FUNCTION_NAME, Node}),
<a name="265"/>  265:     sync(?FUNCTION_NAME),
<a name="266"/>  266:     sync({?FUNCTION_NAME, Node}),
<a name="267"/>  267:     ?assertEqual([Pid], rpc:call(Node, pg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
<a name="268"/>  268:     ?assertEqual([], rpc:call(Node, pg, get_local_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
<a name="269"/>  269:     stop_proc(Pid),
<a name="270"/>  270:     %% again, must be serialised
<a name="271"/>  271:     sync(?FUNCTION_NAME),
<a name="272"/>  272:     sync({?FUNCTION_NAME, Node}),
<a name="273"/>  273:     ?assertEqual([], pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="274"/>  274:     ?assertEqual([], rpc:call(Node, pg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
<a name="275"/>  275: 
<a name="276"/>  276:     Pid2 = spawn_sleeper_at(Node),
<a name="277"/>  277:     Pid3 = spawn_sleeper_at(Node),
<a name="278"/>  278:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, Pid2])),
<a name="279"/>  279:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, Pid3])),
<a name="280"/>  280:     %% serialise through the *other* node
<a name="281"/>  281:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="282"/>  282:     ?assertEqual(lists:sort([Pid2, Pid3]),
<a name="283"/>  283:         lists:sort(pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="284"/>  284:     %% stop the peer
<a name="285"/>  285:     peer:stop(Peer),
<a name="286"/>  286:     %% hope that 'nodedown' comes before we route our request
<a name="287"/>  287:     sync(?FUNCTION_NAME),
<a name="two-last_expr"/><a name="288"/>  288:     ok.
<a name="289"/>  289: 
<a name="empty_group_by_remote_leave-0"/><a name="290"/>  290: <b>empty_group_by_remote_leave</b>() -&gt;
<a name="empty_group_by_remote_leave-last_expr"/><a name="291"/>  291:     [{doc, &quot;Empty group should be deleted from nodes.&quot;}].
<a name="292"/>  292: 
<a name="empty_group_by_remote_leave-1"/><a name="293"/>  293: <b>empty_group_by_remote_leave</b>(Config) when is_list(Config) -&gt;
<a name="294"/>  294:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="295"/>  295:     RemoteNode = rpc:call(Node, erlang, whereis, [?FUNCTION_NAME]),
<a name="296"/>  296:     RemotePid = spawn_sleeper_at(Node),
<a name="297"/>  297:     % remote join
<a name="298"/>  298:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
<a name="299"/>  299:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="300"/>  300:     ?assertEqual([RemotePid], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="301"/>  301:     % inspecting internal state is not best practice, but there's no other way to check if the state is correct.
<a name="302"/>  302:     {_, _, RemoteTree} = maps:get(RemoteNode, element(7, sys:get_state(?FUNCTION_NAME))),
<a name="303"/>  303:     ?assertEqual([RemotePid], gb_trees:get({?FUNCTION_NAME, singleton}, RemoteTree)),
<a name="304"/>  304:     % remote leave
<a name="305"/>  305:     ?assertEqual(ok, rpc:call(Node, pg, leave, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
<a name="306"/>  306:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="307"/>  307:     ?assertEqual([], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="308"/>  308:     {_, _, NewRemoteTree} = maps:get(RemoteNode, element(7, sys:get_state(?FUNCTION_NAME))),
<a name="309"/>  309:     % empty group should be deleted.
<a name="310"/>  310:     ?assertEqual(gb_trees:empty(), NewRemoteTree),
<a name="311"/>  311: 
<a name="312"/>  312:     %% another variant of emptying a group remotely: join([Pi1, Pid2]) and leave ([Pid2, Pid1])
<a name="313"/>  313:     RemotePid2 = spawn_sleeper_at(Node),
<a name="314"/>  314:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, [RemotePid, RemotePid2]])),
<a name="315"/>  315:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="316"/>  316:     ?assertEqual([RemotePid, RemotePid2], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="317"/>  317:     %% now leave
<a name="318"/>  318:     ?assertEqual(ok, rpc:call(Node, pg, leave, [?FUNCTION_NAME, ?FUNCTION_NAME, [RemotePid2, RemotePid]])),
<a name="319"/>  319:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="320"/>  320:     ?assertEqual([], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="321"/>  321:     {_, _, NewRemoteTree} = maps:get(RemoteNode, element(7, sys:get_state(?FUNCTION_NAME))),
<a name="322"/>  322:     peer:stop(Peer),
<a name="empty_group_by_remote_leave-last_expr"/><a name="323"/>  323:     ok.
<a name="324"/>  324: 
<a name="thundering_herd-0"/><a name="325"/>  325: <b>thundering_herd</b>() -&gt;
<a name="thundering_herd-last_expr"/><a name="326"/>  326:     [{doc, &quot;Thousands of overlay network nodes sending sync to us, and we time out!&quot;}, {timetrap, {seconds, 5}}].
<a name="327"/>  327: 
<a name="thundering_herd-1"/><a name="328"/>  328: <b>thundering_herd</b>(Config) when is_list(Config) -&gt;
<a name="329"/>  329:     GroupCount = 10000,
<a name="330"/>  330:     SyncCount = 2000,
<a name="331"/>  331:     %% make up a large amount of groups
<a name="332"/>  332:     [pg:join(?FUNCTION_NAME, {group, Seq}, self()) || Seq &lt;- lists:seq(1, GroupCount)],
<a name="333"/>  333:     %% initiate a few syncs - and those are really slow...
<a name="334"/>  334:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="335"/>  335:     PeerPid = erlang:spawn(Node, forever()),
<a name="336"/>  336:     PeerPg = rpc:call(Node, erlang, whereis, [?FUNCTION_NAME], 1000),
<a name="337"/>  337:     %% WARNING: code below acts for white-box! %% WARNING
<a name="338"/>  338:     FakeSync = [{{group, 1}, [PeerPid, PeerPid]}],
<a name="339"/>  339:     [gen_server:cast(?FUNCTION_NAME, {sync, PeerPg, FakeSync}) || _ &lt;- lists:seq(1, SyncCount)],
<a name="340"/>  340:     %% next call must not timetrap, otherwise test fails
<a name="341"/>  341:     pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, self()),
<a name="thundering_herd-last_expr"/><a name="342"/>  342: <b>    peer:stop</b>(Peer).
<a name="343"/>  343: 
<a name="initial-1"/><a name="344"/>  344: <b>initial</b>(Config) when is_list(Config) -&gt;
<a name="345"/>  345:     Pid = erlang:spawn(forever()),
<a name="346"/>  346:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, Pid)),
<a name="347"/>  347:     ?assertEqual([Pid], pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="348"/>  348:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="349"/>  349:     %% first sync makes the peer node to process 'nodeup' (and send discover)
<a name="350"/>  350:     sync({?FUNCTION_NAME, Node}),
<a name="351"/>  351:     %% second sync makes origin node pg to reply to discover'
<a name="352"/>  352:     sync(?FUNCTION_NAME),
<a name="353"/>  353:     %% third sync makes peer node to finish processing 'exchange'
<a name="354"/>  354:     sync({?FUNCTION_NAME, Node}),
<a name="355"/>  355:     ?assertEqual([Pid], rpc:call(Node, pg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
<a name="356"/>  356: 
<a name="357"/>  357:     ?assertEqual([], rpc:call(Node, pg, get_local_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
<a name="358"/>  358:     stop_proc(Pid),
<a name="359"/>  359:     sync({?FUNCTION_NAME, Node}),
<a name="360"/>  360:     ?assertEqual([], rpc:call(Node, pg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
<a name="361"/>  361:     peer:stop(Peer),
<a name="initial-last_expr"/><a name="362"/>  362:     ok.
<a name="363"/>  363: 
<a name="netsplit-1"/><a name="364"/>  364: <b>netsplit</b>(Config) when is_list(Config) -&gt;
<a name="365"/>  365:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="366"/>  366:     ?assertEqual(Node, peer:call(Peer, erlang, node, [])), %% just to test RPC
<a name="367"/>  367:     RemoteOldPid = spawn_sleeper_at(Node),
<a name="368"/>  368:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, '$invisible', RemoteOldPid])),
<a name="369"/>  369:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="370"/>  370:     ?assertEqual([RemoteOldPid], pg:get_members(?FUNCTION_NAME, '$invisible')),
<a name="371"/>  371: 
<a name="372"/>  372:     %% hohoho, partition!
<a name="373"/>  373:     disconnect_nodes([Node]),
<a name="374"/>  374:     ?assertEqual(Node, peer:call(Peer, erlang, node, [])), %% just to ensure RPC still works
<a name="375"/>  375:     RemotePid = peer:call(Peer, erlang, spawn, sleeper_mfa()),
<a name="376"/>  376:     ?assertEqual([], peer:call(Peer, erlang, nodes, [])),
<a name="377"/>  377:     ?assertNot(lists:member(Node, nodes())), %% should be no nodes in the cluster
<a name="378"/>  378:     ?assertEqual(ok, peer:call(Peer, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])), %% join - in a partition!
<a name="379"/>  379: 
<a name="380"/>  380:     ?assertEqual(ok, peer:call(Peer, pg, leave, [?FUNCTION_NAME, '$invisible', RemoteOldPid])),
<a name="381"/>  381:     ?assertEqual(ok, peer:call(Peer, pg, join, [?FUNCTION_NAME, '$visible', RemoteOldPid])),
<a name="382"/>  382:     ?assertEqual([RemoteOldPid], peer:call(Peer, pg, get_local_members, [?FUNCTION_NAME, '$visible'])),
<a name="383"/>  383:     %% join locally too
<a name="384"/>  384:     LocalPid = erlang:spawn(forever()),
<a name="385"/>  385:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, LocalPid)),
<a name="386"/>  386: 
<a name="387"/>  387:     ?assertNot(lists:member(Node, nodes())), %% should be no nodes in the cluster
<a name="388"/>  388: 
<a name="389"/>  389:     PgPid = whereis(?FUNCTION_NAME),
<a name="390"/>  390:     1 = erlang:trace(PgPid, true, ['receive']),
<a name="391"/>  391:     pong = net_adm:ping(Node),
<a name="392"/>  392:     receive
<a name="393"/>  393:         {trace, PgPid, 'receive', {nodeup, Node}} -&gt; ok
<a name="394"/>  394:     end,
<a name="395"/>  395:     1 = erlang:trace(PgPid, false, ['receive']),
<a name="396"/>  396: 
<a name="397"/>  397:     %% now ensure sync happened
<a name="398"/>  398:     sync_via(?FUNCTION_NAME, {?FUNCTION_NAME, Node}),
<a name="399"/>  399:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="400"/>  400:     ?assertEqual(lists:sort([RemotePid, LocalPid]),
<a name="401"/>  401:                  lists:sort(rpc:call(Node, pg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME]))),
<a name="402"/>  402:     ?assertEqual([RemoteOldPid], pg:get_members(?FUNCTION_NAME, '$visible')),
<a name="403"/>  403:     peer:stop(Peer),
<a name="netsplit-last_expr"/><a name="404"/>  404:     ok.
<a name="405"/>  405: 
<a name="trisplit-1"/><a name="406"/>  406: <b>trisplit</b>(Config) when is_list(Config) -&gt;
<a name="407"/>  407:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="408"/>  408:     _PeerPid1 = spawn_sleeper_at(Node),
<a name="409"/>  409:     PeerPid2 = spawn_sleeper_at(Node),
<a name="410"/>  410:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, three, PeerPid2])),
<a name="411"/>  411:     disconnect_nodes([Node]),
<a name="412"/>  412:     ?assertEqual(true, net_kernel:connect_node(Node)),
<a name="413"/>  413:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, one, PeerPid2])),
<a name="414"/>  414:     %% now ensure sync happened
<a name="415"/>  415:     {Peer2, Node2} = spawn_node(?FUNCTION_NAME, Config),
<a name="416"/>  416:     ?assertEqual(true, rpc:call(Node2, net_kernel, connect_node, [Node])),
<a name="417"/>  417:     ?assertEqual(lists:sort([node(), Node]), lists:sort(rpc:call(Node2, erlang, nodes, []))),
<a name="418"/>  418:     ok = rpc:call(Node2, ?MODULE, ensure_peers_info, [?FUNCTION_NAME, [node(), Node]]),
<a name="419"/>  419:     ?assertEqual([PeerPid2], rpc:call(Node2, pg, get_members, [?FUNCTION_NAME, one])),
<a name="420"/>  420:     peer:stop(Peer),
<a name="421"/>  421:     peer:stop(Peer2),
<a name="trisplit-last_expr"/><a name="422"/>  422:     ok.
<a name="423"/>  423: 
<a name="foursplit-1"/><a name="424"/>  424: <b>foursplit</b>(Config) when is_list(Config) -&gt;
<a name="425"/>  425:     Pid = erlang:spawn(forever()),
<a name="426"/>  426:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="427"/>  427:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, one, Pid)),
<a name="428"/>  428:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, two, Pid)),
<a name="429"/>  429:     PeerPid1 = erlang:spawn(Node, forever()),
<a name="430"/>  430:     ?assertEqual(ok, pg:leave(?FUNCTION_NAME, one, Pid)),
<a name="431"/>  431:     ?assertEqual(not_joined, pg:leave(?FUNCTION_NAME, three, Pid)),
<a name="432"/>  432:     disconnect_nodes([Node]),
<a name="433"/>  433:     ?assertEqual(ok, peer:call(Peer, ?MODULE, stop_proc, [PeerPid1])),
<a name="434"/>  434:     ?assertEqual(not_joined, pg:leave(?FUNCTION_NAME, three, Pid)),
<a name="435"/>  435:     ?assertEqual(true, net_kernel:connect_node(Node)),
<a name="436"/>  436:     ?assertEqual([], pg:get_members(?FUNCTION_NAME, one)),
<a name="437"/>  437:     ?assertEqual([], peer:call(Peer, pg, get_members, [?FUNCTION_NAME, one])),
<a name="438"/>  438:     peer:stop(Peer),
<a name="foursplit-last_expr"/><a name="439"/>  439:     ok.
<a name="440"/>  440: 
<a name="exchange-1"/><a name="441"/>  441: <b>exchange</b>(Config) when is_list(Config) -&gt;
<a name="442"/>  442:     {Peer1, Node1} = spawn_node(?FUNCTION_NAME, Config),
<a name="443"/>  443:     {Peer2, Node2} = spawn_node(?FUNCTION_NAME, Config),
<a name="444"/>  444:     Pids10 = [peer:call(Peer1, erlang, spawn, [forever()]) || _ &lt;- lists:seq(1, 10)],
<a name="445"/>  445:     Pids2 = [peer:call(Peer2, erlang, spawn, [forever()]) || _ &lt;- lists:seq(1, 10)],
<a name="446"/>  446:     Pids11 = [peer:call(Peer1, erlang, spawn, [forever()]) || _ &lt;- lists:seq(1, 10)],
<a name="447"/>  447:     %% kill first 3 pids from node1
<a name="448"/>  448:     {PidsToKill, Pids1} = lists:split(3, Pids10),
<a name="449"/>  449: 
<a name="450"/>  450:     ?assertEqual(ok, peer:call(Peer1, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, Pids10])),
<a name="451"/>  451:     sync({?FUNCTION_NAME, Node1}), %% Join broadcast have reached local
<a name="452"/>  452:     sync(?FUNCTION_NAME), %% Join broadcast has been processed by local
<a name="453"/>  453:     ?assertEqual(lists:sort(Pids10), lists:sort(pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="454"/>  454:     [peer:call(Peer1, ?MODULE, stop_proc, [Pid]) || Pid &lt;- PidsToKill],
<a name="455"/>  455:     sync(?FUNCTION_NAME),
<a name="456"/>  456:     sync({?FUNCTION_NAME, Node1}),
<a name="457"/>  457: 
<a name="458"/>  458:     Pids = lists:sort(Pids1 ++ Pids2 ++ Pids11),
<a name="459"/>  459:     ?assert(lists:all(fun erlang:is_pid/1, Pids)),
<a name="460"/>  460: 
<a name="461"/>  461:     disconnect_nodes([Node1, Node2]),
<a name="462"/>  462: 
<a name="463"/>  463:     sync(?FUNCTION_NAME), %% Processed nodedowns...
<a name="464"/>  464:     ?assertEqual([], lists:sort(pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="465"/>  465: 
<a name="466"/>  466:     [?assertEqual(ok, peer:call(Peer2, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, Pid])) || Pid &lt;- Pids2],
<a name="467"/>  467:     [?assertEqual(ok, peer:call(Peer1, pg, join, [?FUNCTION_NAME, second, Pid])) || Pid &lt;- Pids11],
<a name="468"/>  468:     ?assertEqual(ok, peer:call(Peer1, pg, join, [?FUNCTION_NAME, third, Pids11])),
<a name="469"/>  469:     %% rejoin
<a name="470"/>  470:     ?assertEqual(true, net_kernel:connect_node(Node1)),
<a name="471"/>  471:     ?assertEqual(true, net_kernel:connect_node(Node2)),
<a name="472"/>  472:     %% need to sleep longer to ensure both nodes made the exchange
<a name="473"/>  473:     ensure_peers_info(?FUNCTION_NAME, [Node1, Node2]),
<a name="474"/>  474:     ?assertEqual(Pids, lists:sort(pg:get_members(?FUNCTION_NAME, second) ++ pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="475"/>  475:     ?assertEqual(lists:sort(Pids11), lists:sort(pg:get_members(?FUNCTION_NAME, third))),
<a name="476"/>  476: 
<a name="477"/>  477:     {Left, Stay} = lists:split(3, Pids11),
<a name="478"/>  478:     ?assertEqual(ok, peer:call(Peer1, pg, leave, [?FUNCTION_NAME, third, Left])),
<a name="479"/>  479:     sync({?FUNCTION_NAME, Node1}),
<a name="480"/>  480:     sync(?FUNCTION_NAME),
<a name="481"/>  481:     ?assertEqual(lists:sort(Stay), lists:sort(pg:get_members(?FUNCTION_NAME, third))),
<a name="482"/>  482:     ?assertEqual(not_joined, peer:call(Peer1, pg, leave, [?FUNCTION_NAME, left, Stay])),
<a name="483"/>  483:     ?assertEqual(ok, peer:call(Peer1, pg, leave, [?FUNCTION_NAME, third, Stay])),
<a name="484"/>  484:     sync({?FUNCTION_NAME, Node1}),
<a name="485"/>  485:     sync(?FUNCTION_NAME),
<a name="486"/>  486:     ?assertEqual([], lists:sort(pg:get_members(?FUNCTION_NAME, third))),
<a name="487"/>  487:     sync({?FUNCTION_NAME, Node1}),
<a name="488"/>  488:     sync(?FUNCTION_NAME),
<a name="489"/>  489: 
<a name="490"/>  490:     peer:stop(Peer1),
<a name="491"/>  491:     peer:stop(Peer2),
<a name="exchange-last_expr"/><a name="492"/>  492:     ok.
<a name="493"/>  493: 
<a name="nolocal-1"/><a name="494"/>  494: <b>nolocal</b>(Config) when is_list(Config) -&gt;
<a name="495"/>  495:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="496"/>  496:     RemotePid = spawn_sleeper_at(Node),
<a name="497"/>  497:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
<a name="498"/>  498:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
<a name="499"/>  499:     ?assertEqual([], pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="500"/>  500:     peer:stop(Peer),
<a name="nolocal-last_expr"/><a name="501"/>  501:     ok.
<a name="502"/>  502: 
<a name="double-1"/><a name="503"/>  503: <b>double</b>(Config) when is_list(Config) -&gt;
<a name="504"/>  504:     Pid = erlang:spawn(forever()),
<a name="505"/>  505:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, Pid)),
<a name="506"/>  506:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="507"/>  507:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [Pid])),
<a name="508"/>  508:     ?assertEqual([Pid, Pid], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="509"/>  509:     sync({?FUNCTION_NAME, Node}),
<a name="510"/>  510:     sync_via(?FUNCTION_NAME, {?FUNCTION_NAME, Node}),
<a name="511"/>  511:     ?assertEqual([Pid, Pid], rpc:call(Node, pg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
<a name="512"/>  512:     peer:stop(Peer),
<a name="double-last_expr"/><a name="513"/>  513:     ok.
<a name="514"/>  514: 
<a name="scope_restart-1"/><a name="515"/>  515: <b>scope_restart</b>(Config) when is_list(Config) -&gt;
<a name="516"/>  516:     Pid = erlang:spawn(forever()),
<a name="517"/>  517:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [Pid, Pid])),
<a name="518"/>  518:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="519"/>  519:     RemotePid = erlang:spawn(Node, forever()),
<a name="520"/>  520:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
<a name="521"/>  521:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="522"/>  522:     ?assertEqual(lists:sort([RemotePid, Pid, Pid]), lists:sort(pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="523"/>  523:     %% stop scope locally, and restart
<a name="524"/>  524:     gen_server:stop(?FUNCTION_NAME),
<a name="525"/>  525:     pg:start(?FUNCTION_NAME),
<a name="526"/>  526:     %% ensure remote pids joined, local are missing
<a name="527"/>  527:     sync(?FUNCTION_NAME),
<a name="528"/>  528:     sync({?FUNCTION_NAME, Node}),
<a name="529"/>  529:     sync(?FUNCTION_NAME),
<a name="530"/>  530:     ?assertEqual([RemotePid], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="531"/>  531:     peer:stop(Peer),
<a name="scope_restart-last_expr"/><a name="532"/>  532:     ok.
<a name="533"/>  533: 
<a name="missing_scope_join-1"/><a name="534"/>  534: <b>missing_scope_join</b>(Config) when is_list(Config) -&gt;
<a name="535"/>  535:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="536"/>  536:     ?assertEqual(ok, rpc:call(Node, gen_server, stop, [?FUNCTION_NAME])),
<a name="537"/>  537:     RemotePid = erlang:spawn(Node, forever()),
<a name="538"/>  538:     ?assertMatch({badrpc, {'EXIT', {noproc, _}}}, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
<a name="539"/>  539:     ?assertMatch({badrpc, {'EXIT', {noproc, _}}}, rpc:call(Node, pg, leave, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
<a name="540"/>  540:     peer:stop(Peer),
<a name="missing_scope_join-last_expr"/><a name="541"/>  541:     ok.
<a name="542"/>  542: 
<a name="disconnected_start-1"/><a name="543"/>  543: <b>disconnected_start</b>(Config) when is_list(Config) -&gt;
<a name="disconnected_start-last_expr"/><a name="544"/>  544: <b>    case test_server:is_cover</b>() of
<a name="545"/>  545:         true -&gt;
<a name="546"/>  546:             {skip, &quot;Cover is running&quot;};
<a name="547"/>  547:         false -&gt;
<a name="548"/>  548:             disconnected_start_test(Config)
<a name="549"/>  549:     end.
<a name="550"/>  550: 
<a name="disconnected_start_test-1"/><a name="551"/>  551: <b>disconnected_start_test</b>(Config) when is_list(Config) -&gt;
<a name="552"/>  552:     {Peer, Node} = spawn_disconnected_node(?FUNCTION_NAME, ?FUNCTION_NAME, Config),
<a name="553"/>  553:     ?assertNot(lists:member(Node, nodes())),
<a name="554"/>  554:     ?assertEqual(ok, peer:call(Peer, gen_server, stop, [?FUNCTION_NAME])),
<a name="555"/>  555:     ?assertMatch({ok, _Pid}, peer:call(Peer, pg, start,[?FUNCTION_NAME])),
<a name="556"/>  556:     ?assertEqual(ok, peer:call(Peer, gen_server, stop, [?FUNCTION_NAME])),
<a name="557"/>  557:     RemotePid = peer:call(Peer, erlang, spawn, [forever()]),
<a name="558"/>  558:     ?assert(is_pid(RemotePid)),
<a name="559"/>  559:     peer:stop(Peer),
<a name="disconnected_start_test-last_expr"/><a name="560"/>  560:     ok.
<a name="561"/>  561: 
<a name="forced_sync-0"/><a name="562"/>  562: <b>forced_sync</b>() -&gt;
<a name="forced_sync-last_expr"/><a name="563"/>  563:     [{doc, &quot;This test was added when lookup_element was erroneously used instead of lookup, crashing pg with badmatch, and it tests rare out-of-order sync operations&quot;}].
<a name="564"/>  564: 
<a name="forced_sync-1"/><a name="565"/>  565: <b>forced_sync</b>(Config) when is_list(Config) -&gt;
<a name="566"/>  566:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="567"/>  567:     Pid = erlang:spawn(forever()),
<a name="568"/>  568:     RemotePid = erlang:spawn(Node, forever()),
<a name="569"/>  569:     Expected = lists:sort([Pid, RemotePid]),
<a name="570"/>  570:     pg:join(?FUNCTION_NAME, one, Pid),
<a name="571"/>  571: 
<a name="572"/>  572:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, one, RemotePid])),
<a name="573"/>  573:     RemoteScopePid = rpc:call(Node, erlang, whereis, [?FUNCTION_NAME]),
<a name="574"/>  574:     ?assert(is_pid(RemoteScopePid)),
<a name="575"/>  575:     %% hohoho, partition!
<a name="576"/>  576:     disconnect_nodes([Node]),
<a name="577"/>  577:     ?assertEqual(true, net_kernel:connect_node(Node)),
<a name="578"/>  578:     ensure_peers_info(?FUNCTION_NAME, [Node]),
<a name="579"/>  579:     ?assertEqual(Expected, lists:sort(pg:get_members(?FUNCTION_NAME, one))),
<a name="580"/>  580: 
<a name="581"/>  581:     %% Do extra sync to make sure any redundant sync message has arrived
<a name="582"/>  582:     %% before we send our fake sync message below.
<a name="583"/>  583:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="584"/>  584: 
<a name="585"/>  585:     %% WARNING: this code uses pg as white-box, exploiting internals,
<a name="586"/>  586:     %%  only to simulate broken 'sync'
<a name="587"/>  587:     %% Fake Groups: one should disappear, one should be replaced, one stays
<a name="588"/>  588:     %% This tests handle_sync function.
<a name="589"/>  589:     FakeGroups = [{one, [RemotePid, RemotePid]}, {?FUNCTION_NAME, [RemotePid, RemotePid]}],
<a name="590"/>  590:     gen_server:cast(?FUNCTION_NAME, {sync, RemoteScopePid, FakeGroups}),
<a name="591"/>  591:     %% ensure it is broken well enough
<a name="592"/>  592:     sync(?FUNCTION_NAME),
<a name="593"/>  593:     ?assertEqual(lists:sort([RemotePid, RemotePid]), lists:sort(pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="594"/>  594:     ?assertEqual(lists:sort([RemotePid, RemotePid, Pid]), lists:sort(pg:get_members(?FUNCTION_NAME, one))),
<a name="595"/>  595:     %% simulate force-sync via 'discover' - ask peer to send sync to us
<a name="596"/>  596:     {?FUNCTION_NAME, Node} ! {discover, whereis(?FUNCTION_NAME)},
<a name="597"/>  597:     sync({?FUNCTION_NAME, Node}),
<a name="598"/>  598:     sync(?FUNCTION_NAME),
<a name="599"/>  599:     ?assertEqual(Expected, lists:sort(pg:get_members(?FUNCTION_NAME, one))),
<a name="600"/>  600:     ?assertEqual([], lists:sort(pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="601"/>  601:     %% and simulate extra sync
<a name="602"/>  602:     sync({?FUNCTION_NAME, Node}),
<a name="603"/>  603:     sync(?FUNCTION_NAME),
<a name="604"/>  604:     ?assertEqual(Expected, lists:sort(pg:get_members(?FUNCTION_NAME, one))),
<a name="605"/>  605: 
<a name="606"/>  606:     peer:stop(Peer),
<a name="forced_sync-last_expr"/><a name="607"/>  607:     ok.
<a name="608"/>  608: 
<a name="group_leave-1"/><a name="609"/>  609: <b>group_leave</b>(Config) when is_list(Config) -&gt;
<a name="610"/>  610:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="611"/>  611:     RemotePid = erlang:spawn(Node, forever()),
<a name="612"/>  612:     Total = lists:duplicate(16, RemotePid),
<a name="613"/>  613:     {Left, Remain} = lists:split(4, Total),
<a name="614"/>  614:     %% join 16 times!
<a name="615"/>  615:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, two, Total])),
<a name="616"/>  616:     ?assertEqual(ok, rpc:call(Node, pg, leave, [?FUNCTION_NAME, two, Left])),
<a name="617"/>  617: 
<a name="618"/>  618:     sync({?FUNCTION_NAME, Node}),
<a name="619"/>  619:     sync(?FUNCTION_NAME),
<a name="620"/>  620:     ?assertEqual(Remain, pg:get_members(?FUNCTION_NAME, two)),
<a name="621"/>  621: 
<a name="622"/>  622:     PgPid = whereis(?FUNCTION_NAME),
<a name="623"/>  623:     1 = erlang:trace(PgPid, true, ['receive']),
<a name="624"/>  624:     peer:stop(Peer),
<a name="625"/>  625:     receive
<a name="626"/>  626:         {trace, PgPid, 'receive', {nodedown, Node}} -&gt; ok
<a name="627"/>  627:     end,
<a name="628"/>  628:     1 = erlang:trace(PgPid, false, ['receive']),
<a name="629"/>  629:     sync(?FUNCTION_NAME),
<a name="630"/>  630:     ?assertEqual([], pg:get_members(?FUNCTION_NAME, two)),
<a name="group_leave-last_expr"/><a name="631"/>  631:     ok.
<a name="632"/>  632: 
<a name="monitor_nonempty_scope-0"/><a name="633"/>  633: <b>monitor_nonempty_scope</b>() -&gt;
<a name="monitor_nonempty_scope-last_expr"/><a name="634"/>  634:     [{doc, &quot;Ensure that monitor_scope returns full map of groups in the scope&quot;}].
<a name="635"/>  635: 
<a name="monitor_nonempty_scope-1"/><a name="636"/>  636: <b>monitor_nonempty_scope</b>(Config) when is_list(Config) -&gt;
<a name="637"/>  637:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="638"/>  638:     Pid = erlang:spawn_link(forever()),
<a name="639"/>  639:     RemotePid = erlang:spawn(Node, forever()),
<a name="640"/>  640:     Expected = lists:sort([Pid, RemotePid]),
<a name="641"/>  641:     pg:join(?FUNCTION_NAME, one, Pid),
<a name="642"/>  642:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, one, RemotePid])),
<a name="643"/>  643:     %% Ensure that initial monitoring request returns current map of groups to pids
<a name="644"/>  644:     {Ref, #{one := Actual} = FullScope} = pg:monitor_scope(?FUNCTION_NAME),
<a name="645"/>  645:     ?assertEqual(Expected, Actual),
<a name="646"/>  646:     %% just in case - check there are no extra groups in that scope
<a name="647"/>  647:     ?assertEqual(1, map_size(FullScope)),
<a name="648"/>  648:     pg:demonitor(?FUNCTION_NAME, Ref),
<a name="649"/>  649:     %% re-check
<a name="650"/>  650:     {_Ref, FullScope} = pg:monitor_scope(?FUNCTION_NAME),
<a name="651"/>  651:     peer:stop(Peer),
<a name="monitor_nonempty_scope-last_expr"/><a name="652"/>  652: <b>    exit</b>(Pid, normal).
<a name="653"/>  653: 
<a name="monitor_scope-0"/><a name="654"/>  654: <b>monitor_scope</b>() -&gt;
<a name="monitor_scope-last_expr"/><a name="655"/>  655:     [{doc, &quot;Tests monitor_scope/1 and demonitor/2&quot;}].
<a name="656"/>  656: 
<a name="monitor_scope-1"/><a name="657"/>  657: <b>monitor_scope</b>(Config) when is_list(Config) -&gt;
<a name="658"/>  658:     %% ensure that demonitoring returns 'false' when monitor is not installed
<a name="659"/>  659:     ?assertEqual(false, pg:demonitor(?FUNCTION_NAME, erlang:make_ref())),
<a name="660"/>  660:     InitialMonitor = fun (Scope) -&gt; {Ref, #{}} = pg:monitor_scope(Scope), Ref end,
<a name="661"/>  661:     SecondMonitor = fun (Scope, Group, Control) -&gt; {Ref, #{Group := [Control]}} = pg:monitor_scope(Scope), Ref end,
<a name="662"/>  662:     %% WHITE BOX: knowing pg state internals - only the original monitor should stay
<a name="663"/>  663:     DownMonitor = fun (Scope, Ref, Self) -&gt;
<a name="664"/>  664:         {state, _, _, _, _, _, _, ScopeMonitors, _, _} = sys:get_state(Scope),
<a name="665"/>  665:         ?assertEqual(#{Ref =&gt; {Self, #{}}}, ScopeMonitors, &quot;pg did not remove DOWNed scope monitor&quot;)
<a name="666"/>  666:                   end,
<a name="monitor_scope-last_expr"/><a name="667"/>  667: <b>    monitor_test_impl</b>(Config, ?FUNCTION_NAME, ?FUNCTION_ARITY, InitialMonitor,
<a name="668"/>  668:                       SecondMonitor, DownMonitor).
<a name="669"/>  669: 
<a name="monitor-1"/><a name="670"/>  670: <b>monitor</b>(Config) when is_list(Config) -&gt;
<a name="671"/>  671:     ExpectedGroup = {?FUNCTION_NAME, ?FUNCTION_ARITY},
<a name="672"/>  672:     InitialMonitor = fun (Scope) -&gt; {Ref, []} = pg:monitor(Scope, ExpectedGroup), Ref end,
<a name="673"/>  673:     SecondMonitor = fun (Scope, Group, Control) -&gt;
<a name="674"/>  674:         {Ref, [Control]} = pg:monitor(Scope, Group), Ref end,
<a name="675"/>  675:     DownMonitor = fun (Scope, Ref, Self) -&gt;
<a name="676"/>  676:         {state, _, _, _, _, _, _, _, GM, MG} = sys:get_state(Scope),
<a name="677"/>  677:         ?assertEqual(#{Ref =&gt; ExpectedGroup}, GM, &quot;pg did not remove DOWNed group monitor&quot;),
<a name="678"/>  678:         ?assertEqual(#{ExpectedGroup =&gt; #{Ref =&gt; {Self, #{}}}}, MG, &quot;pg did not remove DOWNed group&quot;)
<a name="679"/>  679:                   end,
<a name="monitor-last_expr"/><a name="680"/>  680: <b>    monitor_test_impl</b>(Config, ?FUNCTION_NAME, ExpectedGroup, InitialMonitor,
<a name="681"/>  681:                       SecondMonitor, DownMonitor).
<a name="682"/>  682: 
<a name="monitor_test_impl-6"/><a name="683"/>  683: <b>monitor_test_impl</b>(Config, Scope, Group, InitialMonitor, SecondMonitor, DownMonitor) -&gt;
<a name="684"/>  684:     Self = self(),
<a name="685"/>  685:     Ref = InitialMonitor(Scope),
<a name="686"/>  686:     %% local join
<a name="687"/>  687:     ?assertEqual(ok, pg:join(Scope, Group, Self)),
<a name="688"/>  688:     wait_message(Ref, join, Group, [Self], &quot;Local&quot;),
<a name="689"/>  689:     %% start second monitor (which has 1 local pid at the start)
<a name="690"/>  690:     ExtraMonitor = spawn_link(fun() -&gt; second_monitor(Scope, Group, Self, SecondMonitor) end),
<a name="691"/>  691:     Ref2 = receive {ExtraMonitor, SecondRef} -&gt; SecondRef end,
<a name="692"/>  692:     %% start a remote node, and a remote monitor
<a name="693"/>  693:     {Peer, Node} = spawn_node(Scope, Config),
<a name="694"/>  694:     ScopePid = whereis(Scope),
<a name="695"/>  695:     %% do not care about the remote monitor, it is started only to check DOWN handling
<a name="696"/>  696:     ThirdMonitor = spawn_link(Node, fun() -&gt; second_monitor(ScopePid, Group, Self, SecondMonitor) end),
<a name="697"/>  697:     Ref3 = receive {ThirdMonitor, ThirdRef} -&gt; ThirdRef end,
<a name="698"/>  698:     %% remote join
<a name="699"/>  699:     RemotePid = erlang:spawn(Node, forever()),
<a name="700"/>  700:     ?assertEqual(ok, rpc:call(Node, pg, join, [Scope, Group, [RemotePid, RemotePid]])),
<a name="701"/>  701:     wait_message(Ref, join, Group, [RemotePid, RemotePid], &quot;Remote&quot;),
<a name="702"/>  702:     %% verify leave event
<a name="703"/>  703:     ?assertEqual([Self], pg:get_local_members(Scope, Group)),
<a name="704"/>  704:     ?assertEqual(ok, pg:leave(Scope, Group, self())),
<a name="705"/>  705:     wait_message(Ref, leave, Group, [Self], &quot;Local&quot;),
<a name="706"/>  706:     %% remote leave
<a name="707"/>  707:     ?assertEqual(ok, rpc:call(Node, pg, leave, [Scope, Group, RemotePid])),
<a name="708"/>  708:     %% flush the local pg scope via remote pg (to ensure local pg finished sending notifications)
<a name="709"/>  709:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="710"/>  710:     wait_message(Ref, leave, Group, [RemotePid], &quot;Remote&quot;),
<a name="711"/>  711:     %% drop the ExtraMonitor - this keeps original and remote monitors
<a name="712"/>  712:     SecondMonMsgs = gen_server:call(ExtraMonitor, flush),
<a name="713"/>  713:     %% inspect the queue, it should contain double remote join, then single local and single remove leave
<a name="714"/>  714:     ExpectedLocalMessages = [
<a name="715"/>  715:         {Ref2, join, Group, [RemotePid, RemotePid]},
<a name="716"/>  716:         {Ref2, leave, Group, [Self]},
<a name="717"/>  717:         {Ref2, leave, Group, [RemotePid]}],
<a name="718"/>  718:     ?assertEqual(ExpectedLocalMessages, SecondMonMsgs, &quot;Local monitor failed&quot;),
<a name="719"/>  719:     %% inspect remote monitor queue
<a name="720"/>  720:     ThirdMonMsgs = gen_server:call(ThirdMonitor, flush),
<a name="721"/>  721:     ExpectedRemoteMessages = [
<a name="722"/>  722:         {Ref3, join, Group, [RemotePid, RemotePid]},
<a name="723"/>  723:         {Ref3, leave, Group, [Self]},
<a name="724"/>  724:         {Ref3, leave, Group, [RemotePid]}],
<a name="725"/>  725:     ?assertEqual(ExpectedRemoteMessages, ThirdMonMsgs, &quot;Remote monitor failed&quot;),
<a name="726"/>  726:     %% remote leave via stop (causes remote monitor to go DOWN)
<a name="727"/>  727:     ok = peer:stop(Peer),
<a name="728"/>  728:     wait_message(Ref, leave, Group, [RemotePid], &quot;Remote stop&quot;),
<a name="729"/>  729:     DownMonitor(Scope, Ref, Self),
<a name="730"/>  730:     %% demonitor
<a name="731"/>  731:     ?assertEqual(ok, pg:demonitor(Scope, Ref)),
<a name="732"/>  732:     ?assertEqual(false, pg:demonitor(Scope, Ref)),
<a name="733"/>  733:     %% ensure messages don't come
<a name="734"/>  734:     ?assertEqual(ok, pg:join(Scope, Group, Self)),
<a name="735"/>  735:     sync(Scope),
<a name="736"/>  736:     %% join should not be here
<a name="monitor_test_impl-last_expr"/><a name="737"/>  737: <b>    receive {Ref, Action, Group, [Self]} -&gt; ?assert</b>(false, lists:concat([&quot;Unexpected &quot;, Action, &quot;event&quot;]))
<a name="738"/>  738:     after 0 -&gt; ok end.
<a name="739"/>  739: 
<a name="wait_message-5"/><a name="740"/>  740: <b>wait_message</b>(Ref, Action, Group, Pids, Msg) -&gt;
<a name="wait_message-last_expr"/><a name="741"/>  741:     receive
<a name="742"/>  742:         {Ref, Action, Group, Pids} -&gt;
<a name="743"/>  743:             ok
<a name="744"/>  744:     after 1000 -&gt;
<a name="745"/>  745:         {messages, Msgs} = process_info(self(), messages),
<a name="746"/>  746:         ct:pal(&quot;Message queue: ~0p&quot;, [Msgs]),
<a name="747"/>  747:         ?assert(false, lists:flatten(io_lib:format(&quot;Expected ~s ~s for ~p&quot;, [Msg, Action, Group])))
<a name="748"/>  748:     end.
<a name="749"/>  749: 
<a name="second_monitor-4"/><a name="750"/>  750: <b>second_monitor</b>(Scope, Group, Control, SecondMonitor) -&gt;
<a name="751"/>  751:     Ref = SecondMonitor(Scope, Group, Control),
<a name="752"/>  752:     Control ! {self(), Ref},
<a name="second_monitor-last_expr"/><a name="753"/>  753: <b>    second_monitor</b>([]).
<a name="754"/>  754: 
<a name="second_monitor-1"/><a name="755"/>  755: <b>second_monitor</b>(Msgs) -&gt;
<a name="second_monitor-last_expr"/><a name="756"/>  756:     receive
<a name="757"/>  757:         {'$gen_call', Reply, flush} -&gt;
<a name="758"/>  758:             gen:reply(Reply, lists:reverse(Msgs));
<a name="759"/>  759:         Msg -&gt;
<a name="760"/>  760:             second_monitor([Msg | Msgs])
<a name="761"/>  761:     end.
<a name="762"/>  762: 
<a name="763"/>  763: <i>%% Test for GH-7625: monitor process that joined a group</i>
<a name="monitor_self-1"/><a name="764"/>  764: <b>monitor_self</b>(Config) when is_list(Config) -&gt;
<a name="765"/>  765:     F = fun() -&gt;
<a name="766"/>  766:         %% spawned process both monitor and group-joined
<a name="767"/>  767:         pg:monitor(?FUNCTION_NAME, ?FUNCTION_NAME),
<a name="768"/>  768:         pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, self())
<a name="769"/>  769:         end,
<a name="770"/>  770:     {Pid, Mon} = spawn_monitor(F),
<a name="771"/>  771:     receive
<a name="772"/>  772:         {'DOWN', Mon, process, Pid, Reason} -&gt;
<a name="773"/>  773:             ?assertEqual(normal, Reason)
<a name="774"/>  774:     end,
<a name="775"/>  775:     %% if pg crashes, next expression fails the test
<a name="monitor_self-last_expr"/><a name="776"/>  776: <b>    sync</b>(?FUNCTION_NAME).
<a name="777"/>  777: 
<a name="778"/>  778: <i>%% check same process monitoring several things at once,</i>
<a name="779"/>  779: <i>%% and also joining a few groups</i>
<a name="multi_monitor-1"/><a name="780"/>  780: <b>multi_monitor</b>(Config) when is_list(Config) -&gt;
<a name="781"/>  781:     F = fun() -&gt;
<a name="782"/>  782:         Self = self(),
<a name="783"/>  783:         %% spawned process both monitor and group-joined
<a name="784"/>  784:         {RefOne, []} = pg:monitor(?FUNCTION_NAME, one),
<a name="785"/>  785:         {RefTwo, []} = pg:monitor(?FUNCTION_NAME, two),
<a name="786"/>  786:         {RefScope, _} = pg:monitor_scope(?FUNCTION_NAME),
<a name="787"/>  787:         ok = pg:join(?FUNCTION_NAME, one, Self),
<a name="788"/>  788:         ok = pg:join(?FUNCTION_NAME, two, Self),
<a name="789"/>  789:         sync(?FUNCTION_NAME),
<a name="790"/>  790:         %% ensure receiving 4 messages: two per group this process
<a name="791"/>  791:         [wait_message(Ref, join, Group, [Self], &quot;Local&quot;) || {Ref, Group} &lt;-
<a name="792"/>  792:             [{RefOne, one}, {RefScope, one}, {RefTwo, two}, {RefScope, two}]]
<a name="793"/>  793:         end,
<a name="794"/>  794:     {Pid, Mon} = spawn_monitor(F),
<a name="795"/>  795:     receive
<a name="796"/>  796:         {'DOWN', Mon, process, Pid, Reason} -&gt;
<a name="797"/>  797:             ?assertEqual(normal, Reason)
<a name="798"/>  798:     end,
<a name="799"/>  799:     %% if pg crashes, next expression fails the test
<a name="800"/>  800:     sync(?FUNCTION_NAME),
<a name="801"/>  801:     %% white box: pg should not have any group or scope monitors
<a name="802"/>  802:     {state, _, _, _, _, _, _, SM, GM, _} = sys:get_state(?FUNCTION_NAME),
<a name="803"/>  803:     ?assertEqual(#{}, SM),
<a name="multi_monitor-last_expr"/><a name="804"/>  804: <b>    ?assertEqual</b>(#{}, GM).
<a name="805"/>  805: 
<a name="protocol_upgrade-1"/><a name="806"/>  806: <b>protocol_upgrade</b>(Config) when is_list(Config) -&gt;
<a name="807"/>  807:     Scope = ?FUNCTION_NAME,
<a name="808"/>  808:     Group = ?FUNCTION_NAME,
<a name="809"/>  809:     {Peer, Node} = spawn_node(Scope, Config),
<a name="810"/>  810:     PgPid = rpc:call(Node, erlang, whereis, [Scope]),
<a name="811"/>  811: 
<a name="812"/>  812:     RemotePid = erlang:spawn(Node, forever()),
<a name="813"/>  813:     ok = rpc:call(Node, pg, join, [Scope, Group, RemotePid]),
<a name="814"/>  814: 
<a name="815"/>  815:     %% OTP 26:
<a name="816"/>  816:     %% Just do a white-box test and verify that pg accepts
<a name="817"/>  817:     %% a &quot;future&quot; discover message and replies with a sync.
<a name="818"/>  818:     PgPid ! {discover, self(), &quot;Protocol version (ignore me)&quot;},
<a name="819"/>  819:     {'$gen_cast', {sync, PgPid, [{Group, [RemotePid]}]}} = receive_any(),
<a name="820"/>  820: 
<a name="821"/>  821:     %% stop the peer
<a name="822"/>  822:     peer:stop(Peer),
<a name="protocol_upgrade-last_expr"/><a name="823"/>  823:     ok.
<a name="824"/>  824: 
<a name="825"/>  825: 
<a name="826"/>  826: <i>%%--------------------------------------------------------------------</i>
<a name="827"/>  827: <i>%% Test Helpers - start/stop additional Erlang nodes</i>
<a name="828"/>  828: 
<a name="receive_any-0"/><a name="829"/>  829: <b>receive_any</b>() -&gt;
<a name="receive_any-last_expr"/><a name="830"/>  830:     receive M -&gt; M end.
<a name="831"/>  831: 
<a name="832"/>  832: <i>%% flushes GS (GenServer) queue, ensuring that all prior</i>
<a name="833"/>  833: <i>%%  messages have been processed</i>
<a name="sync-1"/><a name="834"/>  834: <b>sync</b>(GS) -&gt;
<a name="sync-last_expr"/><a name="835"/>  835: <b>    _ = sys:log</b>(GS, get).
<a name="836"/>  836: 
<a name="837"/>  837: <i>%% flushes GS queue from the point of view of a registered process RegName</i>
<a name="838"/>  838: <i>%%  running on the Node.</i>
<a name="sync_via-2"/><a name="839"/>  839: <b>sync_via</b>({RegName, Node}, GS) -&gt;
<a name="840"/>  840:     MyNode = node(),
<a name="841"/>  841:     rpc:call(Node, sys, replace_state,
<a name="842"/>  842:              [RegName, fun (S) -&gt; (catch sys:get_state({GS, MyNode})), S end]);
<a name="843"/>  843: 
<a name="844"/>  844: <i>%% flush remote GS queue from local process RegName</i>
<a name="845"/>  845: <b>sync_via</b>(RegName, {GS, Node}) -&gt;
<a name="sync_via-last_expr"/><a name="846"/>  846: <b>    sys:replace_state</b>(RegName,
<a name="847"/>  847:                       fun (S) -&gt; _R = (catch sys:get_state({GS, Node})),
<a name="848"/>  848:                                  %%io:format(&quot;sync_via: ~p -&gt; R = ~p\n&quot;, [{GS, Node},_R]),
<a name="849"/>  849:                                  S
<a name="850"/>  850:                       end).
<a name="851"/>  851: 
<a name="ensure_peers_info-2"/><a name="852"/>  852: <b>ensure_peers_info</b>(Scope, Nodes) -&gt;
<a name="853"/>  853:     %% Ensures that pg server on local node has gotten info from
<a name="854"/>  854:     %% pg servers on all Peer nodes passed as argument (assuming
<a name="855"/>  855:     %% no connection failures).
<a name="856"/>  856:     %% 
<a name="857"/>  857:     %% This function assumes that all nodeup messages has been
<a name="858"/>  858:     %% delivered to all local recipients (pg server) when called.
<a name="859"/>  859:     %%
<a name="860"/>  860:     %% Note that this relies on current ERTS implementation; not
<a name="861"/>  861:     %% language guarantees.
<a name="862"/>  862:     %%
<a name="863"/>  863: 
<a name="864"/>  864:     sync(Scope),
<a name="865"/>  865:     %% Known: nodeup handled and discover sent to Peer
<a name="866"/>  866: 
<a name="867"/>  867:     lists:foreach(fun (Node) -&gt; sync({Scope, Node}) end, Nodes),
<a name="868"/>  868:     %% Known: nodeup handled by Peers and discover sent to local
<a name="869"/>  869:     %% Known: discover received/handled by Peers and sync sent to local
<a name="870"/>  870:     %% Known: discover received from Peer
<a name="871"/>  871:     %% Known: sync received from Peer
<a name="872"/>  872: 
<a name="873"/>  873:     sync(Scope),
<a name="874"/>  874:     %% Known: discover handled from Peers and sync sent to Peers
<a name="875"/>  875:     %% Known: sync from Peers handled
<a name="ensure_peers_info-last_expr"/><a name="876"/>  876:     ok.
<a name="877"/>  877: 
<a name="878"/>  878: <b>-ifdef</b>(CURRENTLY_UNUSED_BUT_SERVES_AS_DOC).
<a name="879"/>  879: 
<a name="880"/>  880: ensure_synced(Scope, Nodes) -&gt;
<a name="881"/>  881:     %% Ensures that the pg server on local node have synced
<a name="882"/>  882:     %% with pg servers on all Peer nodes (assuming no connection
<a name="883"/>  883:     %% failures).
<a name="884"/>  884:     %% 
<a name="885"/>  885:     %% This function assumes that all nodeup messages has been
<a name="886"/>  886:     %% delivered to all local recipients (pg server) when called.
<a name="887"/>  887:     %%
<a name="888"/>  888:     %% Note that this relies on current ERTS implementation; not
<a name="889"/>  889:     %% language guarantees.
<a name="890"/>  890:     %%
<a name="891"/>  891:     ensure_peer_info(Scope, Node),
<a name="892"/>  892:     %% Known: local has gotten info from all Peers
<a name="893"/>  893:     %% Known: discover from Peers handled and sync sent to Peers
<a name="894"/>  894:     lists:foreach(fun (Node) -&gt; sync({Scope, Node}) end, Nodes),
<a name="895"/>  895:     %% Known: sync from local handled by Peers
<a name="896"/>  896:     ok.
<a name="897"/>  897: 
<a name="898"/>  898: -endif.
<a name="899"/>  899: 
<a name="disconnect_nodes-1"/><a name="900"/>  900: <b>disconnect_nodes</b>(Nodes) -&gt;
<a name="901"/>  901:     %% The following is not a language guarantee, but internal
<a name="902"/>  902:     %% knowledge about current implementation of ERTS and pg.
<a name="903"/>  903:     %%
<a name="904"/>  904:     %% The pg server reacts on 'DOWN's via process monitors of
<a name="905"/>  905:     %% its peers. These are delivered before 'nodedown's from
<a name="906"/>  906:     %% net_kernel:monitor_nodes(). That is, by waiting for
<a name="907"/>  907:     %% 'nodedown' from net_kernel:monitor_nodes() we know that
<a name="908"/>  908:     %% the 'DOWN' has been delivered to the pg server.
<a name="909"/>  909:     %%
<a name="910"/>  910:     %% We do this in a separate process to avoid stray
<a name="911"/>  911:     %% nodeup/nodedown messages in the test process after
<a name="912"/>  912:     %% the operation...
<a name="913"/>  913:     F = fun () -&gt;
<a name="914"/>  914:                 ok = net_kernel:monitor_nodes(true),
<a name="915"/>  915:                 lists:foreach(fun (Node) -&gt;
<a name="916"/>  916:                                       true = erlang:disconnect_node(Node)
<a name="917"/>  917:                               end,
<a name="918"/>  918:                               Nodes),
<a name="919"/>  919:                 lists:foreach(fun (Node) -&gt;
<a name="920"/>  920:                                       receive {nodedown, Node} -&gt; ok end
<a name="921"/>  921:                               end,
<a name="922"/>  922:                               Nodes)
<a name="923"/>  923:         end,
<a name="924"/>  924:     {Pid, Mon} = spawn_monitor(F),
<a name="925"/>  925:     receive
<a name="926"/>  926:         {'DOWN', Mon, process, Pid, Reason} -&gt;
<a name="927"/>  927:             ?assertEqual(normal, Reason)
<a name="928"/>  928:     end,
<a name="disconnect_nodes-last_expr"/><a name="929"/>  929:     ok.
<a name="930"/>  930: 
<a name="931"/>  931: <i>%% @doc Kills process Pid and waits for it to exit using monitor,</i>
<a name="932"/>  932: <i>%%      and yields after (for 1 ms).</i>
<a name="933"/>  933: <b>-spec stop_proc</b>(pid()) -&gt; ok.
<a name="stop_proc-1"/><a name="934"/>  934: <b>stop_proc</b>(Pid) -&gt;
<a name="935"/>  935:     monitor(process, Pid),
<a name="936"/>  936:     erlang:exit(Pid, kill),
<a name="stop_proc-last_expr"/><a name="937"/>  937:     receive
<a name="938"/>  938:         {'DOWN', _MRef, process, Pid, _Info} -&gt;
<a name="939"/>  939:             timer:sleep(1)
<a name="940"/>  940:     end.
<a name="941"/>  941: 
<a name="forever-0"/><a name="942"/>  942: <b>forever</b>() -&gt;
<a name="943"/>  943:     Parent = self(),
<a name="forever-last_expr"/><a name="944"/>  944: <b>    fun</b>() -&gt;
<a name="945"/>  945:             %% forever() is used both locally and on a remote node,
<a name="946"/>  946:             %% if used locally, we want to terminate when the
<a name="947"/>  947:             %% parent terminates in order to not leak process to
<a name="948"/>  948:             %% later test cases
<a name="949"/>  949:             Ref = monitor(process,Parent),
<a name="950"/>  950:             receive
<a name="951"/>  951:                 {'DOWN',Ref,_,_,_} when node() =:= node(Parent) -&gt;
<a name="952"/>  952:                     ok
<a name="953"/>  953:             end
<a name="954"/>  954:     end.
<a name="955"/>  955: 
<a name="956"/>  956: <i>%% Spawn a sleeping process on remote node.</i>
<a name="957"/>  957: <i>%% Works on older nodes also without having to run any specially compiled code.</i>
<a name="spawn_sleeper_at-1"/><a name="958"/>  958: <b>spawn_sleeper_at</b>(Node) when Node =/= node() -&gt;
<a name="spawn_sleeper_at-last_expr"/><a name="959"/>  959: <b>    spawn</b>(Node, erlang, hibernate, [?MODULE,dummy,[]]).
<a name="960"/>  960: 
<a name="sleeper_mfa-0"/><a name="961"/>  961: <b>sleeper_mfa</b>() -&gt;
<a name="sleeper_mfa-last_expr"/><a name="962"/>  962:     [erlang, hibernate, [?MODULE,dummy,[]]].
<a name="963"/>  963: 
<a name="spawn_node-2"/><a name="964"/>  964: <b>spawn_node</b>(TestCase, Config) -&gt;
<a name="965"/>  965:     {Peer, Node} = spawn_disconnected_node(TestCase, TestCase, Config),
<a name="966"/>  966:     true = net_kernel:connect_node(Node),
<a name="spawn_node-last_expr"/><a name="967"/>  967:     {Peer, Node}.
<a name="968"/>  968: 
<a name="spawn_disconnected_node-3"/><a name="969"/>  969: <b>spawn_disconnected_node</b>(Scope, TestCase, Config) -&gt;
<a name="970"/>  970:     Opts = #{name =&gt; ?CT_PEER_NAME(TestCase),
<a name="971"/>  971:              connection =&gt; 0,
<a name="972"/>  972:              args =&gt; [&quot;-connect_all&quot;, &quot;false&quot;,
<a name="973"/>  973:                       &quot;-kernel&quot;, &quot;dist_auto_connect&quot;, &quot;never&quot;]},
<a name="974"/>  974:     {ok, Peer, Node} =
<a name="975"/>  975:         case proplists:get_value(otp_release, Config) of
<a name="976"/>  976:             undefined -&gt;
<a name="977"/>  977:                 ?CT_PEER(Opts);
<a name="978"/>  978:             Release -&gt;
<a name="979"/>  979:                 TcPrivDir = filename:join(proplists:get_value(priv_dir, Config),
<a name="980"/>  980:                                           TestCase),
<a name="981"/>  981:                 ok = ensure_dir(TcPrivDir),
<a name="982"/>  982:                 ?CT_PEER_REL(Opts, Release, TcPrivDir)
<a name="983"/>  983:         end,
<a name="984"/>  984:     case proplists:get_value(shard_and_metadata, Config) of
<a name="985"/>  985:         true -&gt;
<a name="986"/>  986:             ok = peer:call(Peer, application, set_env, [kernel, pg_shards_and_metadata, true]);
<a name="987"/>  987:         _ -&gt;
<a name="988"/>  988:             ok
<a name="989"/>  989:     end,
<a name="990"/>  990:     {ok, _Pid} = peer:call(Peer, pg, start, [Scope]),
<a name="spawn_disconnected_node-last_expr"/><a name="991"/>  991:     {Peer, Node}.
<a name="992"/>  992: 
<a name="ensure_dir-1"/><a name="993"/>  993: <b>ensure_dir</b>(Dir) -&gt;
<a name="ensure_dir-last_expr"/><a name="994"/>  994: <b>    case file:make_dir</b>(Dir) of
<a name="995"/>  995:         ok -&gt; ok;
<a name="996"/>  996:         {error, eexist} -&gt; ok;
<a name="997"/>  997:         E -&gt; E
<a name="998"/>  998:     end.
<a name="999"/>  999: 
<a name="1000"/> 1000: 
<a name="1001"/> 1001: <i>%%--------------------------------------------------------------------</i>
<a name="1002"/> 1002: <i>%% Debug Helpers</i>
<a name="1003"/> 1003: 
<a name="1004"/> 1004: <i>%% Add test cases here to enable 'receive' trace of the local pg process</i>
<a name="traced_testcases-0"/><a name="traced_testcases-last_expr"/><a name="1005"/> 1005: <b>traced_testcases</b>() -&gt; [].
<a name="1006"/> 1006: 
<a name="trace_start-3"/><a name="1007"/> 1007: <b>trace_start</b>(TestCase, Config, Tracee) -&gt;
<a name="trace_start-last_expr"/><a name="1008"/> 1008: <b>    case lists:member</b>(TestCase, traced_testcases()) of
<a name="1009"/> 1009:         true -&gt;
<a name="1010"/> 1010:             Tracer = spawn_link(fun() -&gt; tracer() end),
<a name="1011"/> 1011:             1 = erlang:trace(Tracee, true, ['receive', {tracer, Tracer}, timestamp]),
<a name="1012"/> 1012:             [{tracer, Tracer} | Config];
<a name="1013"/> 1013:         false -&gt;
<a name="1014"/> 1014:             Config
<a name="1015"/> 1015:     end.
<a name="1016"/> 1016: 
<a name="trace_end-1"/><a name="1017"/> 1017: <b>trace_end</b>(Config) -&gt;
<a name="trace_end-last_expr"/><a name="1018"/> 1018: <b>    case proplists:get_value</b>(tracer, Config) of
<a name="1019"/> 1019:         undefined -&gt; ok;
<a name="1020"/> 1020:         Tracer -&gt;
<a name="1021"/> 1021:             Mon = erlang:monitor(process, Tracer),
<a name="1022"/> 1022:             Tracer ! flush,
<a name="1023"/> 1023:             normal = receive
<a name="1024"/> 1024:                          {'DOWN', Mon, process, Tracer, R} -&gt; R
<a name="1025"/> 1025:                      end
<a name="1026"/> 1026:     end.
<a name="1027"/> 1027: 
<a name="tracer-0"/><a name="1028"/> 1028: <b>tracer</b>() -&gt;
<a name="1029"/> 1029:     receive flush -&gt; ok end,
<a name="1030"/> 1030:     io:format(&quot;Flush trace messages:\n&quot;),
<a name="tracer-last_expr"/><a name="1031"/> 1031: <b>    tracer_flush</b>().
<a name="1032"/> 1032: 
<a name="tracer_flush-0"/><a name="1033"/> 1033: <b>tracer_flush</b>() -&gt;
<a name="tracer_flush-last_expr"/><a name="1034"/> 1034:     receive M -&gt;
<a name="1035"/> 1035:             io:format(&quot;~p\n&quot;, [M]),
<a name="1036"/> 1036:             tracer_flush()
<a name="1037"/> 1037:     after 0 -&gt;
<a name="1038"/> 1038:             io:format(&quot;Flush done.\n&quot;)
<a name="1039"/> 1039:     end.
<a name="1040"/> 1040: 
<a name="e2e-1"/><a name="1041"/> 1041: <b>e2e</b>(Config) -&gt;
<a name="1042"/> 1042:     {Peer1, Node1} = spawn_node(?FUNCTION_NAME, Config),
<a name="1043"/> 1043:     {Peer2, Node2} = spawn_node(?FUNCTION_NAME, Config),
<a name="1044"/> 1044:     {Peer3, Node3} = spawn_node(?FUNCTION_NAME, proplists:delete(otp_release, Config)),
<a name="1045"/> 1045:     {Peer4, Node4} = spawn_node(?FUNCTION_NAME, proplists:delete(otp_release, Config)),
<a name="1046"/> 1046:     {Peer5, Node5} = spawn_node(?FUNCTION_NAME, [{shard_and_metadata, true} | proplists:delete(otp_release, Config)]),
<a name="1047"/> 1047:     {Peer6, Node6} = spawn_node(?FUNCTION_NAME, [{shard_and_metadata, true} | proplists:delete(otp_release, Config)]),
<a name="1048"/> 1048:     Peers = [{Peer1, Node1, 1}, {Peer2, Node2, 1}, {Peer3, Node3, 2}, {Peer4, Node4, 2}, {Peer5, Node5, 3}, {Peer6, Node6, 3}],
<a name="1049"/> 1049:     [true = net_kernel:connect_node(Node) || {_, Node, _} &lt;- Peers],
<a name="1050"/> 1050:     Self = self(),
<a name="1051"/> 1051:     Workers = [
<a name="1052"/> 1052:         {
<a name="1053"/> 1053:             Peer,
<a name="1054"/> 1054:             peer:call(P, erlang, spawn, [fun() -&gt;
<a name="1055"/> 1055:                 link(whereis(?FUNCTION_NAME)),
<a name="1056"/> 1056:                 e2e_worker(Self, Version, ?FUNCTION_NAME, [], [])
<a name="1057"/> 1057:             end])
<a name="1058"/> 1058:         }
<a name="1059"/> 1059:      || {P, _, Version} = Peer &lt;- Peers],
<a name="1060"/> 1060:     [erlang:monitor(process, Worker) || {_, Worker} &lt;- Workers],
<a name="1061"/> 1061:     [
<a name="1062"/> 1062:         begin
<a name="1063"/> 1063:             Graph = e2e_connect_graph(Peers),
<a name="1064"/> 1064:             [erlang:send(Worker, {peers, [{Y, B} || {X, Y, B} &lt;- Graph, X =:= Peer]}) || {Peer, Worker} &lt;- Workers],
<a name="1065"/> 1065:             Global =
<a name="1066"/> 1066:                 [
<a name="1067"/> 1067:                     receive
<a name="1068"/> 1068:                         {Pid, Local} when Pid =:= Worker -&gt;
<a name="1069"/> 1069:                             {Peer, Local};
<a name="1070"/> 1070:                         {'DOWN', _, _, _, _} = Down -&gt;
<a name="1071"/> 1071:                             error(Down)
<a name="1072"/> 1072:                         after 5000 -&gt;
<a name="1073"/> 1073:                             error(timeout)
<a name="1074"/> 1074:                     end
<a name="1075"/> 1075:                  || {Peer, Worker} &lt;- Workers],
<a name="1076"/> 1076:             [erlang:send(Worker, {global, maps:from_list(Global)}) || {_Peer, Worker} &lt;- Workers],
<a name="1077"/> 1077:             [
<a name="1078"/> 1078:                 receive
<a name="1079"/> 1079:                     {Pid, done} when Pid =:= Worker -&gt;
<a name="1080"/> 1080:                         ok;
<a name="1081"/> 1081:                     {'DOWN', _, _, _, _} = Down -&gt;
<a name="1082"/> 1082:                         error(Down)
<a name="1083"/> 1083:                     after 5000 -&gt;
<a name="1084"/> 1084:                         error(timeout)
<a name="1085"/> 1085:                 end
<a name="1086"/> 1086:              || {_Peer, Worker} &lt;- Workers]
<a name="1087"/> 1087:         end
<a name="1088"/> 1088:          || _ &lt;- lists:seq(1, 20)],
<a name="1089"/> 1089:     peer:stop(Peer1),
<a name="1090"/> 1090:     peer:stop(Peer2),
<a name="1091"/> 1091:     peer:stop(Peer3),
<a name="1092"/> 1092:     peer:stop(Peer4),
<a name="1093"/> 1093:     peer:stop(Peer5),
<a name="1094"/> 1094:     peer:stop(Peer6),
<a name="e2e-last_expr"/><a name="1095"/> 1095:     ok.
<a name="1096"/> 1096: 
<a name="e2e_connect_graph-1"/><a name="1097"/> 1097: <b>e2e_connect_graph</b>(List) -&gt;
<a name="e2e_connect_graph-last_expr"/><a name="1098"/> 1098: <b>    e2e_connect_graph</b>(List, []).
<a name="1099"/> 1099: 
<a name="e2e_connect_graph-2"/><a name="1100"/> 1100: <b>e2e_connect_graph</b>([], Acc) -&gt;
<a name="1101"/> 1101:     Acc;
<a name="1102"/> 1102: <b>e2e_connect_graph</b>([X | Rest], Acc) -&gt;
<a name="e2e_connect_graph-last_expr"/><a name="1103"/> 1103: <b>    e2e_connect_graph</b>(Rest, e2e_connect_graph(X, Rest, Acc)).
<a name="1104"/> 1104: 
<a name="e2e_connect_graph-3"/><a name="1105"/> 1105: <b>e2e_connect_graph</b>(_X, [], Acc) -&gt;
<a name="1106"/> 1106:     Acc;
<a name="1107"/> 1107: <b>e2e_connect_graph</b>(X, [Y | Rest], Acc) -&gt;
<a name="1108"/> 1108:     Bool = rand:uniform() &lt; 0.5,
<a name="e2e_connect_graph-last_expr"/><a name="1109"/> 1109: <b>    e2e_connect_graph</b>(X, Rest, [{X, Y, Bool}, {Y, X, Bool} | Acc]).
<a name="1110"/> 1110: 
<a name="e2e_worker-5"/><a name="1111"/> 1111: <b>e2e_worker</b>(From, Version, Scope, Pids, Local) -&gt;
<a name="e2e_worker-last_expr"/><a name="1112"/> 1112:     receive
<a name="1113"/> 1113:         {peers, Peers} -&gt;
<a name="1114"/> 1114:             [
<a name="1115"/> 1115:                 if
<a name="1116"/> 1116:                     Connect -&gt;
<a name="1117"/> 1117:                         true = net_kernel:connect_node(Node);
<a name="1118"/> 1118:                     true -&gt;
<a name="1119"/> 1119:                         disconnect_node(Node)
<a name="1120"/> 1120:                 end
<a name="1121"/> 1121:                 || {{_, Node, _}, Connect} &lt;- Peers],
<a name="1122"/> 1122:             PidsAfterKill = [Pid || Pid &lt;- Pids, rand:uniform() &lt; 0.7 orelse not exit(Pid, kill)],
<a name="1123"/> 1123:             NewPids = PidsAfterKill ++ [erlang:spawn(forever()) || _ &lt;- lists:seq(1, 10 - length(PidsAfterKill))],
<a name="1124"/> 1124:             NewLocal =
<a name="1125"/> 1125:                 lists:sort(lists:foldl(
<a name="1126"/> 1126:                     fun(_, Acc) -&gt;
<a name="1127"/> 1127:                         e2e_do_random(Version, NewPids, Scope, Acc)
<a name="1128"/> 1128:                     end,
<a name="1129"/> 1129:                     [{K, V} || {K, V} &lt;- Local, e2e_pid_member(V, NewPids)],
<a name="1130"/> 1130:                     lists:seq(1, 20)
<a name="1131"/> 1131:                 )),
<a name="1132"/> 1132:             e2e_wait(NewLocal, Scope, 3, 100),
<a name="1133"/> 1133:             From ! {self(), NewLocal},
<a name="1134"/> 1134:             receive
<a name="1135"/> 1135:                 {global, Global} -&gt;
<a name="1136"/> 1136:                     Expect = lists:sort(lists:flatten(NewLocal ++ [
<a name="1137"/> 1137:                         e2e_should_see(maps:get(Peer, Global), Version, PeerVersion)
<a name="1138"/> 1138:                         || {{_, _, PeerVersion} = Peer, true} &lt;- Peers])),
<a name="1139"/> 1139:                     e2e_wait(Expect, Scope, 2, 100),
<a name="1140"/> 1140:                     From ! {self(), done},
<a name="1141"/> 1141:                     e2e_worker(From, Version, Scope, NewPids, NewLocal)
<a name="1142"/> 1142:             end
<a name="1143"/> 1143:     end.
<a name="1144"/> 1144: 
<a name="e2e_pid_member-2"/><a name="1145"/> 1145: <b>e2e_pid_member</b>({Pid, _}, List) -&gt;
<a name="1146"/> 1146:     e2e_pid_member(Pid, List);
<a name="1147"/> 1147: <b>e2e_pid_member</b>(Pid, List) -&gt;
<a name="e2e_pid_member-last_expr"/><a name="1148"/> 1148: <b>    lists:member</b>(Pid, List).
<a name="1149"/> 1149: 
<a name="e2e_validate-1"/><a name="1150"/> 1150: <b>e2e_validate</b>([]) -&gt;
<a name="1151"/> 1151:     true;
<a name="1152"/> 1152: <b>e2e_validate</b>([_]) -&gt;
<a name="1153"/> 1153:     true;
<a name="1154"/> 1154: <b>e2e_validate</b>([{{_, singleton}, _, _} | Rest]) -&gt;
<a name="1155"/> 1155:     e2e_validate(Rest);
<a name="1156"/> 1156: <b>e2e_validate</b>([{{_, _, _}, _, _}, {{_, singleton}, _, _} | Rest]) -&gt;
<a name="1157"/> 1157:     e2e_validate(Rest);
<a name="1158"/> 1158: <b>e2e_validate</b>([{Key1, _, _}, {Key2, _, _} = T | Rest]) when element(1, Key1) &lt; element(1, Key2) -&gt;
<a name="1159"/> 1159:     e2e_validate([T | Rest]);
<a name="1160"/> 1160: <b>e2e_validate</b>([{{G, _, R1}, _, _}, {{G, L2, _}, _, _} = T | Rest]) when R1 &lt; L2 - 1 -&gt;
<a name="1161"/> 1161:     e2e_validate([T | Rest]);
<a name="1162"/> 1162: <b>e2e_validate</b>([{{G, _, R1}, M1, _}, {{G, L2, _}, M2, _} = T | Rest]) when R1 =:= L2 - 1 -&gt;
<a name="1163"/> 1163:     lists:sort(M1) =:= lists:sort(M2) andalso e2e_validate([T | Rest]);
<a name="1164"/> 1164: <b>e2e_validate</b>(List) -&gt;
<a name="e2e_validate-last_expr"/><a name="1165"/> 1165: <b>    error</b>(List).
<a name="1166"/> 1166: 
<a name="e2e_do_random-4"/><a name="1167"/> 1167: <b>e2e_do_random</b>(1, Pids, Scope, Local) -&gt;
<a name="1168"/> 1168:     case rand:uniform() &lt; 0.4 of
<a name="1169"/> 1169:         true -&gt;
<a name="1170"/> 1170:             {Leave, NewLocal} = lists:splitwith(fun(_) -&gt; rand:uniform() &lt; 0.3 end, Local),
<a name="1171"/> 1171:             LeavePids = [Pid || {_, Pid} &lt;- Leave],
<a name="1172"/> 1172:             (LeavePids =:= []) orelse (ok = pg:leave(Scope, group, LeavePids)),
<a name="1173"/> 1173:             NewLocal;
<a name="1174"/> 1174:         false -&gt;
<a name="1175"/> 1175:             JoinPids = [Pid || Pid &lt;- Pids, rand:uniform() &lt; 0.3],
<a name="1176"/> 1176:             (JoinPids =:= []) orelse (ok = pg:join(Scope, group, JoinPids)),
<a name="1177"/> 1177:             [{{group, singleton}, Pid} || Pid &lt;- JoinPids] ++ Local
<a name="1178"/> 1178:     end;
<a name="1179"/> 1179: <b>e2e_do_random</b>(_, Pids, Scope, Local) -&gt;
<a name="1180"/> 1180:     {Leave, NewLocal} = lists:splitwith(fun(_) -&gt; rand:uniform() &lt; 0.3 end, Local),
<a name="1181"/> 1181:     LeaveUpdates = [{G, case Pos of singleton -&gt; singleton; N -&gt; [{N, N}] end, [Member], []} || {{G, Pos}, Member} &lt;- Leave],
<a name="1182"/> 1182:     JoinMembers = [
<a name="1183"/> 1183:         case rand:uniform() &lt; 0.5 of true -&gt; Pid; false -&gt; {Pid, rand:uniform(10)} end
<a name="1184"/> 1184:         || Pid &lt;- Pids, rand:uniform() &lt; 0.3],
<a name="1185"/> 1185:     {Joins, JoinUpdate} =
<a name="1186"/> 1186:         case rand:uniform() &lt; 0.5 of
<a name="1187"/> 1187:             true -&gt;
<a name="1188"/> 1188:                 {[{{group, singleton}, Member} || Member &lt;- JoinMembers], {group, singleton, [], JoinMembers}};
<a name="1189"/> 1189:             false -&gt;
<a name="1190"/> 1190:                 L = rand:uniform(5),
<a name="1191"/> 1191:                 R = L + rand:uniform(5) - 1,
<a name="1192"/> 1192:                 {
<a name="1193"/> 1193:                     [{{group, N}, Member} || Member &lt;- JoinMembers, N &lt;- lists:seq(L, R)],
<a name="1194"/> 1194:                     {group, [{L, R}], [], JoinMembers}
<a name="1195"/> 1195:                 }
<a name="1196"/> 1196:         end,
<a name="1197"/> 1197:     pg:update(Scope, LeaveUpdates ++ [JoinUpdate]),
<a name="e2e_do_random-last_expr"/><a name="1198"/> 1198:     Joins ++ NewLocal.
<a name="1199"/> 1199: 
<a name="e2e_wait-4"/><a name="1200"/> 1200: <b>e2e_wait</b>(Expect, Scope, ElementPos, Retry) -&gt;
<a name="1201"/> 1201:     sys:get_state(Scope),
<a name="1202"/> 1202:     e2e_validate(ets:tab2list(Scope)),
<a name="1203"/> 1203:     Actual = lists:sort(lists:foldl(
<a name="1204"/> 1204:         fun
<a name="1205"/> 1205:             ({{G, singleton}, _, _} = Entry, Acc) -&gt;
<a name="1206"/> 1206:                 [{{G, singleton}, Member} || Member &lt;- element(ElementPos, Entry)] ++ Acc;
<a name="1207"/> 1207:             ({{G, L, R}, _, _} = Entry, Acc) -&gt;
<a name="1208"/> 1208:                 [{{G, N}, Member} || Member &lt;- element(ElementPos, Entry), N &lt;- lists:seq(L, R)] ++ Acc;
<a name="1209"/> 1209:             ({G, _, _} = Entry, Acc) -&gt;
<a name="1210"/> 1210:                 [{{G, singleton}, Member} || Member &lt;- element(ElementPos, Entry)] ++ Acc
<a name="1211"/> 1211:         end,
<a name="1212"/> 1212:         [],
<a name="1213"/> 1213:         ets:tab2list(Scope)
<a name="1214"/> 1214:     )),
<a name="e2e_wait-last_expr"/><a name="1215"/> 1215:     case Expect =:= Actual of
<a name="1216"/> 1216:         true -&gt;
<a name="1217"/> 1217:             ok;
<a name="1218"/> 1218:         _ -&gt;
<a name="1219"/> 1219:             case Retry &gt; 0 of
<a name="1220"/> 1220:                 true -&gt;
<a name="1221"/> 1221:                     timer:sleep(10),
<a name="1222"/> 1222:                     e2e_wait(Expect, Scope, ElementPos, Retry - 1);
<a name="1223"/> 1223:                 _ -&gt;
<a name="1224"/> 1224:                     error({node(), Expect -- Actual, Actual -- Expect, Actual})
<a name="1225"/> 1225:             end
<a name="1226"/> 1226:     end.
<a name="1227"/> 1227: 
<a name="e2e_should_see-3"/><a name="1228"/> 1228: <b>e2e_should_see</b>(List, 3, 1) -&gt;
<a name="1229"/> 1229:     [Entry || Entry = {{_, singleton}, _} &lt;- List];
<a name="1230"/> 1230: <b>e2e_should_see</b>(List, 3, _) -&gt;
<a name="1231"/> 1231:     List;
<a name="1232"/> 1232: <b>e2e_should_see</b>(List, _, _) -&gt;
<a name="e2e_should_see-last_expr"/><a name="1233"/> 1233: <b>    [Entry || Entry = {{_, singleton}, Pid} &lt;- List, is_pid</b>(Pid)].</pre>
<script>
var hash = window.location.hash.substring(1);
var anchor = document.getElementsByName(hash);
anchor[0].style.backgroundColor="orange";
</script>
</body>
</html>
