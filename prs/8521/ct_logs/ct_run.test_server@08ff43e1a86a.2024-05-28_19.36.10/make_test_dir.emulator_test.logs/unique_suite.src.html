<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/erts/emulator/make_test_dir/emulator_test/unique_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%</i>
<a name="2"/>    2: <i>%% %CopyrightBegin%</i>
<a name="3"/>    3: <i>%% </i>
<a name="4"/>    4: <i>%% Copyright Ericsson AB 2014-2022. All Rights Reserved.</i>
<a name="5"/>    5: <i>%% </i>
<a name="6"/>    6: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="7"/>    7: <i>%% you may not use this file except in compliance with the License.</i>
<a name="8"/>    8: <i>%% You may obtain a copy of the License at</i>
<a name="9"/>    9: <i>%%</i>
<a name="10"/>   10: <i>%%     http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="11"/>   11: <i>%%</i>
<a name="12"/>   12: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="13"/>   13: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="14"/>   14: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="15"/>   15: <i>%% See the License for the specific language governing permissions and</i>
<a name="16"/>   16: <i>%% limitations under the License.</i>
<a name="17"/>   17: <i>%% </i>
<a name="18"/>   18: <i>%% %CopyrightEnd%</i>
<a name="19"/>   19: <i>%%</i>
<a name="20"/>   20: 
<a name="21"/>   21: <b>-module</b>(unique_SUITE).
<a name="22"/>   22: 
<a name="23"/>   23: <b>-export</b>([all/0, suite/0, init_per_suite/1, end_per_suite/1]).
<a name="24"/>   24: <b>-export</b>([init_per_testcase/2, end_per_testcase/2]).
<a name="25"/>   25: <b>-export</b>([unique_monotonic_integer_white_box/1,
<a name="26"/>   26: 	 unique_integer_white_box/1]).
<a name="27"/>   27: 
<a name="28"/>   28: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="29"/>   29: 
<a name="30"/>   30: <i>%-define(P(V), V).</i>
<a name="31"/>   31: <b>-define</b>(P(V), print_ret_val(?FILE, ?LINE, V)).
<a name="32"/>   32: 
<a name="33"/>   33: <b>-define</b>(PRINT(V), print_ret_val(?FILE, ?LINE, V)).
<a name="34"/>   34: 
<a name="suite-0"/><a name="35"/>   35: <b>suite</b>() -&gt;
<a name="suite-last_expr"/><a name="36"/>   36:     [{ct_hooks,[ts_install_cth]},
<a name="37"/>   37:      {timetrap, {minutes, 4}}].
<a name="38"/>   38: 
<a name="all-0"/><a name="39"/>   39: <b>all</b>() -&gt; 
<a name="all-last_expr"/><a name="40"/>   40:     [unique_monotonic_integer_white_box,
<a name="41"/>   41:      unique_integer_white_box].
<a name="42"/>   42: 
<a name="init_per_suite-1"/><a name="43"/>   43: <b>init_per_suite</b>(Config) -&gt;
<a name="44"/>   44:     erts_debug:set_internal_state(available_internal_state, true),
<a name="init_per_suite-last_expr"/><a name="45"/>   45:     Config.
<a name="46"/>   46: 
<a name="end_per_suite-1"/><a name="47"/>   47: <b>end_per_suite</b>(_Config) -&gt;
<a name="48"/>   48:     erts_debug:set_internal_state(available_internal_state, false),
<a name="end_per_suite-last_expr"/><a name="49"/>   49:     ok.
<a name="50"/>   50: 
<a name="init_per_testcase-2"/><a name="51"/>   51: <b>init_per_testcase</b>(_TestCase, Config) -&gt;
<a name="init_per_testcase-last_expr"/><a name="52"/>   52:     Config.
<a name="end_per_testcase-2"/><a name="53"/>   53: <b>end_per_testcase</b>(_TestCase, Config) -&gt;
<a name="end_per_testcase-last_expr"/><a name="54"/>   54: <b>    erts_test_utils:ept_check_leaked_nodes</b>(Config).
<a name="55"/>   55: 
<a name="56"/>   56: <i>%%</i>
<a name="57"/>   57: <i>%%</i>
<a name="58"/>   58: <i>%% Unique counter white box test case</i>
<a name="59"/>   59: <i>%%</i>
<a name="60"/>   60: <i>%%</i>
<a name="61"/>   61: 
<a name="unique_monotonic_integer_white_box-1"/><a name="62"/>   62: <b>unique_monotonic_integer_white_box</b>(Config) when is_list(Config) -&gt;
<a name="63"/>   63:     {ok, Peer, Node} = ?CT_PEER(),
<a name="64"/>   64:     TestServer = self(),
<a name="65"/>   65:     Success = make_ref(),
<a name="66"/>   66:     %% Run this in a separate node, so we don't mess up
<a name="67"/>   67:     %% the system when moving the strict monotonic counter
<a name="68"/>   68:     %% around in a non-strict monotonic way...
<a name="69"/>   69:     Test = spawn(Node,
<a name="70"/>   70:                  fun () -&gt;
<a name="71"/>   71:                          unique_monotonic_integer_white_box_test(TestServer, Success)
<a name="72"/>   72:                  end),
<a name="73"/>   73:     Mon = erlang:monitor(process, Test),
<a name="74"/>   74:     receive
<a name="75"/>   75:         {'DOWN', Mon, process, Test, Error} -&gt;
<a name="76"/>   76:             ct:fail(Error);
<a name="77"/>   77:         Success -&gt;
<a name="78"/>   78:             ok
<a name="79"/>   79:     end,
<a name="80"/>   80:     erlang:demonitor(Mon, [flush]),
<a name="unique_monotonic_integer_white_box-last_expr"/><a name="81"/>   81: <b>    peer:stop</b>(Peer).
<a name="82"/>   82: 
<a name="set_unique_monotonic_integer_state-2"/><a name="83"/>   83: <b>set_unique_monotonic_integer_state</b>(MinCounter, NextValue) -&gt;
<a name="set_unique_monotonic_integer_state-last_expr"/><a name="84"/>   84: <b>    true = erts_debug:set_internal_state</b>(unique_monotonic_integer_state,
<a name="85"/>   85:                                          NextValue-MinCounter-1).
<a name="86"/>   86: 
<a name="87"/>   87: 
<a name="88"/>   88: 
<a name="unique_monotonic_integer_white_box_test-2"/><a name="89"/>   89: <b>unique_monotonic_integer_white_box_test</b>(TestServer, Success) -&gt;
<a name="90"/>   90:     erts_debug:set_internal_state(available_internal_state, true),
<a name="91"/>   91: 
<a name="92"/>   92:     WordSize = erlang:system_info({wordsize, internal}),
<a name="93"/>   93:     SmallBits = WordSize*8 - 4,
<a name="94"/>   94: 
<a name="95"/>   95:     MinSmall = -1*(1 bsl (SmallBits-1)),
<a name="96"/>   96:     MaxSmall = (1 bsl (SmallBits-1))-1,
<a name="97"/>   97:     %% Make sure we got small sizes correct...
<a name="98"/>   98:     0 = erts_debug:size(MinSmall),
<a name="99"/>   99:     false = 0 =:= erts_debug:size(MinSmall-1),
<a name="100"/>  100:     0 = erts_debug:size(MaxSmall),
<a name="101"/>  101:     false = 0 =:= erts_debug:size(MaxSmall+1),
<a name="102"/>  102: 
<a name="103"/>  103:     ?PRINT({min_small, MinSmall}),
<a name="104"/>  104:     ?PRINT({max_small, MaxSmall}),
<a name="105"/>  105: 
<a name="106"/>  106:     MinSint64 = -1*(1 bsl 63),
<a name="107"/>  107:     MaxSint64 = (1 bsl 63)-1,
<a name="108"/>  108: 
<a name="109"/>  109:     ?PRINT({min_Sint64, MinSint64}),
<a name="110"/>  110:     ?PRINT({max_Sint64, MaxSint64}),
<a name="111"/>  111: 
<a name="112"/>  112:     MinCounter = erts_debug:get_internal_state(min_unique_monotonic_integer),
<a name="113"/>  113:     MaxCounter = MinCounter + (1 bsl 64) - 1,
<a name="114"/>  114: 
<a name="115"/>  115:     ?PRINT({min_counter, MinCounter}),
<a name="116"/>  116:     ?PRINT({max_counter, MaxCounter}),
<a name="117"/>  117: 
<a name="118"/>  118:     case WordSize of
<a name="119"/>  119:         4 -&gt;
<a name="120"/>  120:             MinCounter = MinSint64;
<a name="121"/>  121:         8 -&gt;
<a name="122"/>  122:             MinCounter = MinSmall
<a name="123"/>  123:     end,
<a name="124"/>  124: 
<a name="125"/>  125:     StartState = erts_debug:get_internal_state(unique_monotonic_integer_state),
<a name="126"/>  126: 
<a name="127"/>  127:     %% Verify that we get expected results over all internal limits...
<a name="128"/>  128: 
<a name="129"/>  129:     case MinCounter &lt; MinSmall of
<a name="130"/>  130:         false -&gt;
<a name="131"/>  131:             8 = WordSize,
<a name="132"/>  132:             ok;
<a name="133"/>  133:         true -&gt;
<a name="134"/>  134:             4 = WordSize,
<a name="135"/>  135:             ?PRINT(over_min_small),
<a name="136"/>  136:             set_unique_monotonic_integer_state(MinCounter, MinSmall-2),
<a name="137"/>  137:             true = (?P(erlang:unique_integer([monotonic])) == MinSmall - 2),
<a name="138"/>  138:             true = (?P(erlang:unique_integer([monotonic])) == MinSmall - 1),
<a name="139"/>  139:             true = (?P(erlang:unique_integer([monotonic])) == MinSmall),
<a name="140"/>  140:             true = (?P(erlang:unique_integer([monotonic]))  == MinSmall + 1),
<a name="141"/>  141:             true = (?P(erlang:unique_integer([monotonic]))  == MinSmall + 2),
<a name="142"/>  142:             garbage_collect(),
<a name="143"/>  143:             ok
<a name="144"/>  144:     end,
<a name="145"/>  145: 
<a name="146"/>  146:     ?PRINT(over_zero), %% Not really an interesting limit, but...
<a name="147"/>  147:     set_unique_monotonic_integer_state(MinCounter, -2),
<a name="148"/>  148:     true = (?P(erlang:unique_integer([monotonic])) == -2),
<a name="149"/>  149:     true = (?P(erlang:unique_integer([monotonic])) == -1),
<a name="150"/>  150:     true = (?P(erlang:unique_integer([monotonic])) == 0),
<a name="151"/>  151:     true = (?P(erlang:unique_integer([monotonic]))  == 1),
<a name="152"/>  152:     true = (?P(erlang:unique_integer([monotonic]))  == 2),
<a name="153"/>  153:     garbage_collect(),
<a name="154"/>  154: 
<a name="155"/>  155:     ?PRINT(over_max_small),
<a name="156"/>  156:     set_unique_monotonic_integer_state(MinCounter, MaxSmall-2),
<a name="157"/>  157:     true = (?P(erlang:unique_integer([monotonic])) == MaxSmall - 2),
<a name="158"/>  158:     true = (?P(erlang:unique_integer([monotonic])) == MaxSmall - 1),
<a name="159"/>  159:     true = (?P(erlang:unique_integer([monotonic])) == MaxSmall),
<a name="160"/>  160:     true = (?P(erlang:unique_integer([monotonic]))  == MaxSmall + 1),
<a name="161"/>  161:     true = (?P(erlang:unique_integer([monotonic]))  == MaxSmall + 2),
<a name="162"/>  162:     garbage_collect(),
<a name="163"/>  163: 
<a name="164"/>  164:     case MaxCounter &gt; MaxSint64 of
<a name="165"/>  165:         false -&gt;
<a name="166"/>  166:             4 = WordSize,
<a name="167"/>  167:             ok;
<a name="168"/>  168:         true -&gt;
<a name="169"/>  169:             8 = WordSize,
<a name="170"/>  170:             ?PRINT(over_max_sint64),
<a name="171"/>  171:             set_unique_monotonic_integer_state(MinCounter, MaxSint64-2),
<a name="172"/>  172:             true = (?P(erlang:unique_integer([monotonic])) == MaxSint64 - 2),
<a name="173"/>  173:             true = (?P(erlang:unique_integer([monotonic])) == MaxSint64 - 1),
<a name="174"/>  174:             true = (?P(erlang:unique_integer([monotonic])) == MaxSint64),
<a name="175"/>  175:             true = (?P(erlang:unique_integer([monotonic])) == MaxSint64 + 1),
<a name="176"/>  176:             true = (?P(erlang:unique_integer([monotonic])) == MaxSint64 + 2),
<a name="177"/>  177:             garbage_collect()
<a name="178"/>  178:     end,
<a name="179"/>  179: 
<a name="180"/>  180:     ?PRINT(over_max_min_counter),
<a name="181"/>  181:     set_unique_monotonic_integer_state(MinCounter, if MaxCounter == MaxSint64 -&gt;
<a name="182"/>  182:                                                           MaxCounter-2;
<a name="183"/>  183:                                                       true -&gt;
<a name="184"/>  184:                                                           MinCounter-3
<a name="185"/>  185:                                                    end),
<a name="186"/>  186:     true = (?P(erlang:unique_integer([monotonic])) == MaxCounter - 2),
<a name="187"/>  187:     true = (?P(erlang:unique_integer([monotonic])) == MaxCounter - 1),
<a name="188"/>  188:     true = (?P(erlang:unique_integer([monotonic])) == MaxCounter),
<a name="189"/>  189:     true = (?P(erlang:unique_integer([monotonic])) == MinCounter),
<a name="190"/>  190:     true = (?P(erlang:unique_integer([monotonic])) == MinCounter + 1),
<a name="191"/>  191:     true = (?P(erlang:unique_integer([monotonic])) == MinCounter + 2),
<a name="192"/>  192:     garbage_collect(),
<a name="193"/>  193: 
<a name="194"/>  194:     %% Restore initial state and hope we didn't mess it up for the
<a name="195"/>  195:     %% system...
<a name="196"/>  196:     true = erts_debug:set_internal_state(unique_monotonic_integer_state,
<a name="197"/>  197:                                          StartState),
<a name="198"/>  198: 
<a name="unique_monotonic_integer_white_box_test-last_expr"/><a name="199"/>  199:     TestServer ! Success.
<a name="200"/>  200: 
<a name="201"/>  201: <i>%%</i>
<a name="202"/>  202: <i>%%</i>
<a name="203"/>  203: <i>%% Unique integer white box test case</i>
<a name="204"/>  204: <i>%%</i>
<a name="205"/>  205: <i>%%</i>
<a name="206"/>  206: 
<a name="207"/>  207: <b>-record</b>(uniqint_info, {min_int,
<a name="208"/>  208:                        max_int,
<a name="209"/>  209:                        max_small,
<a name="210"/>  210:                        schedulers,
<a name="211"/>  211:                        sched_bits}).
<a name="212"/>  212: 
<a name="unique_integer_white_box-1"/><a name="213"/>  213: <b>unique_integer_white_box</b>(Config) when is_list(Config) -&gt;
<a name="214"/>  214:     UinqintInfo = init_uniqint_info(),
<a name="215"/>  215:     #uniqint_info{min_int = MinInt,
<a name="216"/>  216:                   max_int = MaxInt,
<a name="217"/>  217:                   max_small = MaxSmall} = UinqintInfo,
<a name="218"/>  218:     io:format(&quot;****************************************************~n&quot;, []),
<a name="219"/>  219:     io:format(&quot;*** Around MIN_UNIQ_INT ~p ***~n&quot;, [MinInt]),
<a name="220"/>  220:     io:format(&quot;****************************************************~n&quot;, []),
<a name="221"/>  221:     check_unique_integer_around(MinInt, UinqintInfo),
<a name="222"/>  222:     io:format(&quot;****************************************************~n&quot;, []),
<a name="223"/>  223:     io:format(&quot;*** Around 0 ***~n&quot;, []),
<a name="224"/>  224:     io:format(&quot;****************************************************~n&quot;, []),
<a name="225"/>  225:     check_unique_integer_around(0, UinqintInfo),
<a name="226"/>  226:     io:format(&quot;****************************************************~n&quot;, []),
<a name="227"/>  227:     io:format(&quot;*** Around MAX_SMALL ~p ***~n&quot;, [MaxSmall]),
<a name="228"/>  228:     io:format(&quot;****************************************************~n&quot;, []),
<a name="229"/>  229:     check_unique_integer_around(MaxSmall, UinqintInfo),
<a name="230"/>  230:     io:format(&quot;****************************************************~n&quot;, []),
<a name="231"/>  231:     io:format(&quot;*** Around 2^64+MIN_UNIQ_INT ~p ***~n&quot;, [(1 bsl 64)+MinInt]),
<a name="232"/>  232:     io:format(&quot;****************************************************~n&quot;, []),
<a name="233"/>  233:     check_unique_integer_around((1 bsl 64)+MinInt, UinqintInfo),
<a name="234"/>  234:     io:format(&quot;****************************************************~n&quot;, []),
<a name="235"/>  235:     io:format(&quot;*** Around 2^64 ~p~n&quot;, [(1 bsl 64)]),
<a name="236"/>  236:     io:format(&quot;****************************************************~n&quot;, []),
<a name="237"/>  237:     check_unique_integer_around((1 bsl 64), UinqintInfo),
<a name="238"/>  238:     io:format(&quot;****************************************************~n&quot;, []),
<a name="239"/>  239:     io:format(&quot;*** Around 2^64-MIN_UNIQ_INT ~p ***~n&quot;, [(1 bsl 64)-MinInt]),
<a name="240"/>  240:     io:format(&quot;****************************************************~n&quot;, []),
<a name="241"/>  241:     check_unique_integer_around((1 bsl 64)-MinInt, UinqintInfo),
<a name="242"/>  242:     io:format(&quot;****************************************************~n&quot;, []),
<a name="243"/>  243:     io:format(&quot;*** Around MAX_UNIQ_INT ~p ***~n&quot;, [MaxInt]),
<a name="244"/>  244:     io:format(&quot;****************************************************~n&quot;, []),
<a name="245"/>  245:     check_unique_integer_around(MaxInt, UinqintInfo),
<a name="unique_integer_white_box-last_expr"/><a name="246"/>  246:     ok.
<a name="247"/>  247: 
<a name="248"/>  248: 
<a name="249"/>  249: <i>%%% Internal unique_integer_white_box/1 test case</i>
<a name="250"/>  250: 
<a name="calc_sched_bits-2"/><a name="251"/>  251: <b>calc_sched_bits</b>(NoScheds, Shift) when NoScheds &lt; 1 bsl Shift -&gt;
<a name="252"/>  252:     Shift;
<a name="253"/>  253: <b>calc_sched_bits</b>(NoScheds, Shift) -&gt;
<a name="calc_sched_bits-last_expr"/><a name="254"/>  254: <b>    calc_sched_bits</b>(NoScheds, Shift+1).
<a name="255"/>  255: 
<a name="schedulers-0"/><a name="256"/>  256: <b>schedulers</b>() -&gt;
<a name="257"/>  257:     S = erlang:system_info(schedulers),
<a name="schedulers-last_expr"/><a name="258"/>  258:     try
<a name="259"/>  259:         DCPUS = erlang:system_info(dirty_cpu_schedulers),
<a name="260"/>  260:         DIOS = erlang:system_info(dirty_io_schedulers),
<a name="261"/>  261:         S+DCPUS+DIOS
<a name="262"/>  262:     catch
<a name="263"/>  263:         _ : _ -&gt;
<a name="264"/>  264:             S
<a name="265"/>  265:     end.
<a name="266"/>  266: 
<a name="init_uniqint_info-0"/><a name="267"/>  267: <b>init_uniqint_info</b>() -&gt;
<a name="268"/>  268:     SmallBits = erlang:system_info({wordsize, internal})*8-4,
<a name="269"/>  269:     io:format(&quot;SmallBits=~p~n&quot;, [SmallBits]),
<a name="270"/>  270:     Schedulers = schedulers(),
<a name="271"/>  271:     io:format(&quot;Schedulers=~p~n&quot;, [Schedulers]),
<a name="272"/>  272:     MinSmall = -1*(1 bsl (SmallBits-1)),
<a name="273"/>  273:     io:format(&quot;MinSmall=~p~n&quot;, [MinSmall]),
<a name="274"/>  274:     MaxSmall = (1 bsl (SmallBits-1))-1,
<a name="275"/>  275:     io:format(&quot;MaxSmall=~p~n&quot;, [MaxSmall]),
<a name="276"/>  276:     SchedBits = calc_sched_bits(Schedulers, 0),
<a name="277"/>  277:     io:format(&quot;SchedBits=~p~n&quot;, [SchedBits]),
<a name="278"/>  278:     MaxInt = ((((1 bsl 64) - 1) bsl SchedBits) bor Schedulers) + MinSmall,
<a name="279"/>  279:     io:format(&quot;MaxInt=~p~n&quot;, [MaxInt]),
<a name="init_uniqint_info-last_expr"/><a name="280"/>  280:     #uniqint_info{min_int = MinSmall,
<a name="281"/>  281:                   max_int = MaxInt,
<a name="282"/>  282:                   max_small = MaxSmall,
<a name="283"/>  283:                   schedulers = Schedulers,
<a name="284"/>  284:                   sched_bits = SchedBits}.
<a name="285"/>  285: 
<a name="valid_uniqint-2"/><a name="286"/>  286: <b>valid_uniqint</b>(Int, #uniqint_info{min_int = MinInt} = UinqintInfo) when Int &lt; MinInt -&gt;
<a name="287"/>  287:     valid_uniqint(MinInt, UinqintInfo);
<a name="288"/>  288: <b>valid_uniqint</b>(Int, #uniqint_info{min_int = MinInt,
<a name="289"/>  289:                                  sched_bits = SchedBits,
<a name="290"/>  290:                                  schedulers = Scheds}) -&gt;
<a name="291"/>  291:     Int1 = Int - MinInt,
<a name="292"/>  292:     {Inc, ThreadNo} = case Int1 band ((1 bsl SchedBits) - 1) of
<a name="293"/>  293:                           TN when TN &gt; Scheds -&gt;
<a name="294"/>  294:                               {1, Scheds};
<a name="295"/>  295:                           TN -&gt;
<a name="296"/>  296:                               {0, TN}
<a name="297"/>  297:                       end,
<a name="298"/>  298:     Counter = ((Int1 bsr SchedBits) + Inc) rem (1 bsl 64),
<a name="valid_uniqint-last_expr"/><a name="299"/>  299: <b>    </b>((Counter bsl SchedBits) bor ThreadNo) + MinInt.
<a name="300"/>  300: 
<a name="smaller_valid_uniqint-2"/><a name="301"/>  301: <b>smaller_valid_uniqint</b>(Int, UinqintInfo) -&gt;
<a name="302"/>  302:     Cand = Int-1,
<a name="smaller_valid_uniqint-last_expr"/><a name="303"/>  303: <b>    case valid_uniqint</b>(Cand, UinqintInfo) of
<a name="304"/>  304:         RI when RI &lt; Int -&gt;
<a name="305"/>  305:             RI;
<a name="306"/>  306:         _ -&gt;
<a name="307"/>  307:             smaller_valid_uniqint(Cand, UinqintInfo)
<a name="308"/>  308:     end.
<a name="309"/>  309: 
<a name="mk_uniqint-2"/><a name="310"/>  310: <b>mk_uniqint</b>(Int, #uniqint_info {min_int = MinInt,
<a name="311"/>  311:                                sched_bits = SchedBits} = _UinqintInfo) -&gt;
<a name="312"/>  312:     Int1 = Int - MinInt,
<a name="313"/>  313:     ThrId = Int1 band ((1 bsl SchedBits) - 1),
<a name="314"/>  314:     Value = (Int1 bsr SchedBits) band ((1 bsl 64) - 1),
<a name="315"/>  315:     0 = Int1 bsr (SchedBits + 64),
<a name="316"/>  316:     Make = {make_unique_integer, ThrId, Value},
<a name="317"/>  317:     %% erlang:display(Make),
<a name="318"/>  318:     Res = erts_debug:get_internal_state(Make),
<a name="319"/>  319:     %% erlang:display({uniq_int, Res}),
<a name="mk_uniqint-last_expr"/><a name="320"/>  320:     Res.
<a name="321"/>  321: 
<a name="check_uniqint-2"/><a name="322"/>  322: <b>check_uniqint</b>(Int, UinqintInfo) -&gt;
<a name="323"/>  323:     UniqInt = mk_uniqint(Int, UinqintInfo),
<a name="324"/>  324:     io:format(&quot;UniqInt=~p &quot;, [UniqInt]),
<a name="check_uniqint-last_expr"/><a name="325"/>  325:     case UniqInt =:= Int of
<a name="326"/>  326:         true -&gt;
<a name="327"/>  327:             io:format(&quot;OK~n~n&quot;, []);
<a name="328"/>  328:         false -&gt;
<a name="329"/>  329:             io:format(&quot;result Int=~p FAILED~n&quot;, [Int]),
<a name="330"/>  330:             exit(badres)
<a name="331"/>  331:     end.
<a name="332"/>  332: 
<a name="check_unique_integer_around-2"/><a name="333"/>  333: <b>check_unique_integer_around</b>(Int, #uniqint_info{min_int = MinInt,
<a name="334"/>  334:                                                max_int = MaxInt} = UinqintInfo) -&gt;
<a name="335"/>  335:     {Start, End} = case {Int =&lt; MinInt+100, Int &gt;= MaxInt-100} of
<a name="336"/>  336:                        {true, false} -&gt;
<a name="337"/>  337:                            {MinInt, MinInt+100};
<a name="338"/>  338:                        {false, false} -&gt;
<a name="339"/>  339:                            {smaller_valid_uniqint(Int-100, UinqintInfo),
<a name="340"/>  340:                             valid_uniqint(Int+100, UinqintInfo)};
<a name="341"/>  341:                        {false, true} -&gt;
<a name="342"/>  342:                            {MaxInt-100, MaxInt}
<a name="343"/>  343:                    end,
<a name="check_unique_integer_around-last_expr"/><a name="344"/>  344: <b>    lists:foldl</b>(fun (I, OldRefInt) -&gt;
<a name="345"/>  345:                         RefInt = valid_uniqint(I, UinqintInfo),
<a name="346"/>  346:                         case OldRefInt =:= RefInt of
<a name="347"/>  347:                             true -&gt;
<a name="348"/>  348:                                 ok;
<a name="349"/>  349:                             false -&gt;
<a name="350"/>  350:                                 check_uniqint(RefInt, UinqintInfo)
<a name="351"/>  351:                         end,
<a name="352"/>  352:                         RefInt
<a name="353"/>  353:                 end,
<a name="354"/>  354:                 none,
<a name="355"/>  355:                 lists:seq(Start, End)).
<a name="356"/>  356: 
<a name="357"/>  357: 
<a name="358"/>  358: <i>%% helpers</i>
<a name="359"/>  359: 
<a name="print_ret_val-3"/><a name="360"/>  360: <b>print_ret_val</b>(File, Line, Value) -&gt;    
<a name="361"/>  361:     io:format(&quot;~s:~p: ~p~n&quot;, [File, Line, Value]),
<a name="print_ret_val-last_expr"/><a name="362"/>  362:     Value.
</pre>
<script>
var hash = window.location.hash.substring(1);
var anchor = document.getElementsByName(hash);
anchor[0].style.backgroundColor="orange";
</script>
</body>
</html>
