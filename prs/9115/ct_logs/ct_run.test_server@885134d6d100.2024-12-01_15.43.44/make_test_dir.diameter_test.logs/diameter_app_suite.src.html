<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/lib/diameter/make_test_dir/diameter_test/diameter_app_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%</i>
<a name="2"/>    2: <i>%% %CopyrightBegin%</i>
<a name="3"/>    3: <i>%%</i>
<a name="4"/>    4: <i>%% Copyright Ericsson AB 2010-2024. All Rights Reserved.</i>
<a name="5"/>    5: <i>%%</i>
<a name="6"/>    6: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="7"/>    7: <i>%% you may not use this file except in compliance with the License.</i>
<a name="8"/>    8: <i>%% You may obtain a copy of the License at</i>
<a name="9"/>    9: <i>%%</i>
<a name="10"/>   10: <i>%%     http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="11"/>   11: <i>%%</i>
<a name="12"/>   12: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="13"/>   13: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="14"/>   14: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="15"/>   15: <i>%% See the License for the specific language governing permissions and</i>
<a name="16"/>   16: <i>%% limitations under the License.</i>
<a name="17"/>   17: <i>%%</i>
<a name="18"/>   18: <i>%% %CopyrightEnd%</i>
<a name="19"/>   19: <i>%%</i>
<a name="20"/>   20: 
<a name="21"/>   21: <i>%%</i>
<a name="22"/>   22: <i>%% Tests based on the contents of the diameter app file.</i>
<a name="23"/>   23: <i>%%</i>
<a name="24"/>   24: 
<a name="25"/>   25: <b>-module</b>(diameter_app_SUITE).
<a name="26"/>   26: 
<a name="27"/>   27: <i>%% testcases, no common_test dependency</i>
<a name="28"/>   28: <b>-export</b>([run/0,
<a name="29"/>   29:          run/1]).
<a name="30"/>   30: 
<a name="31"/>   31: <i>%% common_test wrapping</i>
<a name="32"/>   32: <b>-export</b>([
<a name="33"/>   33:          %% Framework functions
<a name="34"/>   34:          suite/0,
<a name="35"/>   35:          all/0,
<a name="36"/>   36:          init_per_suite/1,
<a name="37"/>   37:          end_per_suite/1,
<a name="38"/>   38:          init_per_testcase/2,
<a name="39"/>   39:          end_per_testcase/2
<a name="40"/>   40:         ]).
<a name="41"/>   41: 
<a name="42"/>   42: <i>%% testcases</i>
<a name="43"/>   43: <b>-export</b>([keys/1,
<a name="44"/>   44:          vsn/1,
<a name="45"/>   45:          modules/1,
<a name="46"/>   46:          exports/1,
<a name="47"/>   47:          release/1,
<a name="48"/>   48:          xref/1,
<a name="49"/>   49:          relup/1]).
<a name="50"/>   50: 
<a name="51"/>   51: <b>-include_lib</b>(&quot;kernel/include/file.hrl&quot;).
<a name="52"/>   52: 
<a name="53"/>   53: <b>-include</b>(&quot;diameter_util.hrl&quot;).
<a name="54"/>   54: 
<a name="55"/>   55: 
<a name="56"/>   56: <i>%% ===========================================================================</i>
<a name="57"/>   57: 
<a name="58"/>   58: <b>-define</b>(A, list_to_atom).
<a name="59"/>   59: 
<a name="60"/>   60: <i>%% Modules not in the app and that should not have dependencies on it</i>
<a name="61"/>   61: <i>%% for build reasons.</i>
<a name="62"/>   62: <b>-define</b>(COMPILER_MODULES, [diameter_codegen,
<a name="63"/>   63:                            diameter_dict_scanner,
<a name="64"/>   64:                            diameter_dict_parser,
<a name="65"/>   65:                            diameter_dict_util,
<a name="66"/>   66:                            diameter_exprecs,
<a name="67"/>   67:                            diameter_make]).
<a name="68"/>   68: 
<a name="69"/>   69: <b>-define</b>(INFO_MODULES, [diameter_dbg,
<a name="70"/>   70:                        diameter_info]).
<a name="71"/>   71: 
<a name="72"/>   72: <b>-define</b>(AL(F),    ?AL(F, [])).
<a name="73"/>   73: <b>-define</b>(AL(F, A), ?LOG(&quot;DAPPS&quot;, F, A)).
<a name="74"/>   74: 
<a name="75"/>   75: 
<a name="76"/>   76: <i>%% ===========================================================================</i>
<a name="77"/>   77: 
<a name="suite-0"/><a name="78"/>   78: <b>suite</b>() -&gt;
<a name="suite-last_expr"/><a name="79"/>   79:     [{timetrap, {seconds, 120}}].
<a name="80"/>   80: 
<a name="all-0"/><a name="81"/>   81: <b>all</b>() -&gt;
<a name="all-last_expr"/><a name="82"/>   82:     [keys,
<a name="83"/>   83:      vsn,
<a name="84"/>   84:      modules,
<a name="85"/>   85:      exports,
<a name="86"/>   86:      release,
<a name="87"/>   87:      xref,
<a name="88"/>   88:      relup].
<a name="89"/>   89: 
<a name="90"/>   90: 
<a name="init_per_suite-1"/><a name="91"/>   91: <b>init_per_suite</b>(Config) -&gt;
<a name="init_per_suite-last_expr"/><a name="92"/>   92: <b>    ?DUTIL:init_per_suite</b>(Config).
<a name="93"/>   93: 
<a name="94"/>   94: 
<a name="end_per_suite-1"/><a name="95"/>   95: <b>end_per_suite</b>(Config) -&gt;
<a name="end_per_suite-last_expr"/><a name="96"/>   96: <b>    ?DUTIL:end_per_suite</b>(Config).
<a name="97"/>   97: 
<a name="98"/>   98: 
<a name="99"/>   99: <i>%% This test case can take a *long* time, so if the machine is too slow, skip</i>
<a name="init_per_testcase-2"/><a name="100"/>  100: <b>init_per_testcase</b>(xref = Case, Config) when is_list(Config) -&gt;
<a name="101"/>  101:     ?AL(&quot;init_per_testcase(~w) -&gt; check factor&quot;, [Case]),
<a name="102"/>  102:     Key = dia_factor,
<a name="103"/>  103:     case lists:keysearch(Key, 1, Config) of
<a name="104"/>  104:         {value, {Key, Factor}} when (Factor &gt; 10) -&gt;
<a name="105"/>  105:             ?AL(&quot;init_per_testcase(~w) -&gt; Too slow (~w) =&gt; SKIP&quot;,
<a name="106"/>  106:                 [Case, Factor]),
<a name="107"/>  107:             {skip, {machine_too_slow, Factor}};
<a name="108"/>  108:         _ -&gt;
<a name="109"/>  109:             ?AL(&quot;init_per_testcase(~w) -&gt; run test&quot;, [Case]),
<a name="110"/>  110:             Config
<a name="111"/>  111:     end;
<a name="112"/>  112: <b>init_per_testcase</b>(Case, Config) -&gt;
<a name="113"/>  113:     ?AL(&quot;init_per_testcase(~w) -&gt; entry&quot;, [Case]),
<a name="init_per_testcase-last_expr"/><a name="114"/>  114:     Config.
<a name="115"/>  115: 
<a name="116"/>  116: 
<a name="end_per_testcase-2"/><a name="117"/>  117: <b>end_per_testcase</b>(Case, Config) when is_list(Config) -&gt;
<a name="118"/>  118:     ?AL(&quot;end_per_testcase(~w) -&gt; entry&quot;, [Case]),
<a name="end_per_testcase-last_expr"/><a name="119"/>  119:     Config.
<a name="120"/>  120: 
<a name="121"/>  121: 
<a name="122"/>  122: <i>%% ===========================================================================</i>
<a name="123"/>  123: 
<a name="run-0"/><a name="124"/>  124: <b>run</b>() -&gt;
<a name="run-last_expr"/><a name="125"/>  125: <b>    run</b>(all()).
<a name="126"/>  126: 
<a name="run-1"/><a name="127"/>  127: <b>run</b>(List) -&gt;
<a name="128"/>  128:     Tmp = ?MKTEMP(&quot;diameter_app&quot;),
<a name="run-last_expr"/><a name="129"/>  129:     try
<a name="130"/>  130:         run([{priv_dir, Tmp}], List)
<a name="131"/>  131:     after
<a name="132"/>  132:         file:del_dir_r(Tmp)
<a name="133"/>  133:     end.
<a name="134"/>  134: 
<a name="run-2"/><a name="135"/>  135: <b>run</b>(Config, List) -&gt;
<a name="136"/>  136:     Timeout = factor2timeout(Config, 10000),
<a name="137"/>  137:     ?AL(&quot;run -&gt; use Timeout: ~w&quot;, [Timeout]),
<a name="138"/>  138:     [{application, diameter, App}] = ?CONSULT(diameter, app),
<a name="run-last_expr"/><a name="139"/>  139: <b>    ?RUN</b>([{{?MODULE, F, [{App, Config}]}, Timeout} || F &lt;- List]).
<a name="140"/>  140: 
<a name="141"/>  141: 
<a name="factor2timeout-2"/><a name="142"/>  142: <b>factor2timeout</b>(Config, BaseTime) -&gt;
<a name="143"/>  143:     Key = dia_factor,
<a name="factor2timeout-last_expr"/><a name="144"/>  144: <b>    case lists:keysearch</b>(Key, 1, Config) of
<a name="145"/>  145:         {value, {Key, Factor}} when (Factor &gt; 0) -&gt;
<a name="146"/>  146:             BaseTime + (((Factor-1)*BaseTime) div 10);
<a name="147"/>  147:         _ -&gt;
<a name="148"/>  148:             BaseTime
<a name="149"/>  149:     end.
<a name="150"/>  150: 
<a name="151"/>  151:     
<a name="152"/>  152: <i>%% ===========================================================================</i>
<a name="153"/>  153: <i>%% # keys/1</i>
<a name="154"/>  154: <i>%%</i>
<a name="155"/>  155: <i>%% Ensure that the app file contains selected keys. Some of these would</i>
<a name="156"/>  156: <i>%% also be caught by other testcases.</i>
<a name="157"/>  157: <i>%% ===========================================================================</i>
<a name="158"/>  158: 
<a name="keys-1"/><a name="159"/>  159: <b>keys</b>({App, _Config}) -&gt;
<a name="160"/>  160:     [] = lists:filter(fun(K) -&gt; not lists:keymember(K, 1, App) end,
<a name="161"/>  161:                       [vsn, description, modules, registered, applications]);
<a name="162"/>  162: 
<a name="163"/>  163: <b>keys</b>(Config) -&gt;
<a name="keys-last_expr"/><a name="164"/>  164: <b>    run</b>(Config, [keys]).
<a name="165"/>  165: 
<a name="166"/>  166: <i>%% ===========================================================================</i>
<a name="167"/>  167: <i>%% # vsn/1</i>
<a name="168"/>  168: <i>%%</i>
<a name="169"/>  169: <i>%% Ensure that our app version sticks to convention.</i>
<a name="170"/>  170: <i>%% ===========================================================================</i>
<a name="171"/>  171: 
<a name="vsn-1"/><a name="172"/>  172: <b>vsn</b>({App, _Config}) -&gt;
<a name="173"/>  173:     true = is_vsn(fetch(vsn, App));
<a name="174"/>  174: 
<a name="175"/>  175: <b>vsn</b>(Config) -&gt;
<a name="vsn-last_expr"/><a name="176"/>  176: <b>    run</b>(Config, [vsn]).
<a name="177"/>  177: 
<a name="178"/>  178: <i>%% ===========================================================================</i>
<a name="179"/>  179: <i>%% # modules/1</i>
<a name="180"/>  180: <i>%%</i>
<a name="181"/>  181: <i>%% Ensure that the app file modules and installed modules differ by</i>
<a name="182"/>  182: <i>%% compiler/info modules.</i>
<a name="183"/>  183: <i>%% ===========================================================================</i>
<a name="184"/>  184: 
<a name="modules-1"/><a name="185"/>  185: <b>modules</b>({App, _Config}) -&gt;
<a name="186"/>  186:     Mods = fetch(modules, App),
<a name="187"/>  187:     Installed = code_mods(),
<a name="188"/>  188:     Help = lists:sort(?INFO_MODULES ++ ?COMPILER_MODULES),
<a name="189"/>  189:     {[], Help} = {Mods -- Installed, lists:sort(Installed -- Mods)};
<a name="190"/>  190: 
<a name="191"/>  191: <b>modules</b>(Config) -&gt;
<a name="modules-last_expr"/><a name="192"/>  192: <b>    run</b>(Config, [modules]).
<a name="193"/>  193: 
<a name="code_mods-0"/><a name="194"/>  194: <b>code_mods</b>() -&gt;
<a name="195"/>  195:     Dir  = code:lib_dir(diameter, ebin),
<a name="196"/>  196:     {ok, Files} = file:list_dir(Dir),
<a name="code_mods-last_expr"/><a name="197"/>  197: <b>    [?A</b>(lists:reverse(R)) || N &lt;- Files, &quot;maeb.&quot; ++ R &lt;- [lists:reverse(N)]].
<a name="198"/>  198: 
<a name="199"/>  199: <i>%% ===========================================================================</i>
<a name="200"/>  200: <i>%% # exports/1</i>
<a name="201"/>  201: <i>%%</i>
<a name="202"/>  202: <i>%% Ensure that no module does export_all.</i>
<a name="203"/>  203: <i>%% ===========================================================================</i>
<a name="204"/>  204: 
<a name="exports-1"/><a name="205"/>  205: <b>exports</b>({App, _Config}) -&gt;
<a name="206"/>  206:     Mods = fetch(modules, App),
<a name="207"/>  207:     [] = [M || M &lt;- Mods, exports_all(M)];
<a name="208"/>  208: 
<a name="209"/>  209: <b>exports</b>(Config) -&gt;
<a name="exports-last_expr"/><a name="210"/>  210: <b>    run</b>(Config, [exports]).
<a name="211"/>  211: 
<a name="exports_all-1"/><a name="212"/>  212: <b>exports_all</b>(Mod) -&gt;
<a name="213"/>  213:     Opts = fetch(options, Mod:module_info(compile)),
<a name="214"/>  214: 
<a name="exports_all-last_expr"/><a name="215"/>  215: <b>    is_list</b>(Opts) andalso lists:member(export_all, Opts).
<a name="216"/>  216: 
<a name="217"/>  217: <i>%% ===========================================================================</i>
<a name="218"/>  218: <i>%% # release/1</i>
<a name="219"/>  219: <i>%%</i>
<a name="220"/>  220: <i>%% Ensure that it's possible to build a minimal release with our app file.</i>
<a name="221"/>  221: <i>%% ===========================================================================</i>
<a name="222"/>  222: 
<a name="release-1"/><a name="223"/>  223: <b>release</b>({App, Config}) -&gt;
<a name="224"/>  224:     Rel = {release,
<a name="225"/>  225:            {&quot;diameter test release&quot;, fetch(vsn, App)},
<a name="226"/>  226:            {erts, erlang:system_info(version)},
<a name="227"/>  227:            [{A, appvsn(A)} || A &lt;- [sasl | fetch(applications, App)]]},
<a name="228"/>  228:     Dir = fetch(priv_dir, Config),
<a name="229"/>  229:     ok = write_file(filename:join([Dir, &quot;diameter_test.rel&quot;]), Rel),
<a name="230"/>  230:     {ok, _, []} = systools:make_script(&quot;diameter_test&quot;, [{path, [Dir]},
<a name="231"/>  231:                                                          {outdir, Dir},
<a name="232"/>  232:                                                          silent]);
<a name="233"/>  233: 
<a name="234"/>  234: <b>release</b>(Config) -&gt;
<a name="release-last_expr"/><a name="235"/>  235: <b>    run</b>(Config, [release]).
<a name="236"/>  236: 
<a name="237"/>  237: <i>%% sasl need to be included to avoid a missing_sasl warning, error</i>
<a name="238"/>  238: <i>%% in the case of relup/1.</i>
<a name="239"/>  239: 
<a name="appvsn-1"/><a name="240"/>  240: <b>appvsn</b>(Name) -&gt;
<a name="241"/>  241:     [{application, Name, App}] = ?CONSULT(Name, app),
<a name="appvsn-last_expr"/><a name="242"/>  242: <b>    fetch</b>(vsn, App).
<a name="243"/>  243: 
<a name="244"/>  244: <i>%% ===========================================================================</i>
<a name="245"/>  245: <i>%% # xref/1</i>
<a name="246"/>  246: <i>%%</i>
<a name="247"/>  247: <i>%% Ensure that no function in our application calls an undefined function</i>
<a name="248"/>  248: <i>%% or one in an application we haven't declared as a dependency. (Almost.)</i>
<a name="249"/>  249: <i>%% ===========================================================================</i>
<a name="250"/>  250: 
<a name="xref-1"/><a name="251"/>  251: <b>xref</b>({App, _Config}) -&gt;
<a name="252"/>  252:     ?AL(&quot;xref -&gt; entry with&quot;
<a name="253"/>  253:         &quot;~n   App:    ~p&quot;
<a name="254"/>  254:         &quot;~n   Config: ~p&quot;, [App, _Config]),
<a name="255"/>  255: 
<a name="256"/>  256:     Mods = fetch(modules, App),  %% modules listed in the app file
<a name="257"/>  257: 
<a name="258"/>  258:     %% List of application names extracted from runtime_dependencies.
<a name="259"/>  259:     ?AL(&quot;xref -&gt; get deps&quot;),
<a name="260"/>  260:     Deps = lists:map(fun unversion/1, fetch(runtime_dependencies, App)),
<a name="261"/>  261: 
<a name="262"/>  262:     ?AL(&quot;xref -&gt; start xref&quot;),
<a name="263"/>  263:     {ok, XRef} = xref:start(make_name(xref_test_name)),
<a name="264"/>  264:     ok = xref:set_default(XRef, [{verbose, false}, {warnings, false}]),
<a name="265"/>  265: 
<a name="266"/>  266:     %% Only add our application and those it's dependent on according
<a name="267"/>  267:     %% to the app file. Well, almost. erts beams are also required to
<a name="268"/>  268:     %% stop xref from complaining about calls to module erlang, which
<a name="269"/>  269:     %% was previously in kernel. Erts isn't an application however, in
<a name="270"/>  270:     %% the sense that there's no .app file, and isn't listed in
<a name="271"/>  271:     %% applications.
<a name="272"/>  272:     Apps = [diameter, erts | fetch(applications, App)],
<a name="273"/>  273:     ?AL(&quot;xref -&gt; add own and dep apps: &quot;
<a name="274"/>  274:         &quot;~n   ~p&quot;, [Apps]),
<a name="275"/>  275:     ok = lists:foreach(fun(A) -&gt; add_application(XRef, A) end, Apps),
<a name="276"/>  276: 
<a name="277"/>  277:     ?AL(&quot;xref -&gt; analyze undefined_function_calls&quot;),
<a name="278"/>  278:     {ok, Undefs} = xref:analyze(XRef, undefined_function_calls),
<a name="279"/>  279:     ?AL(&quot;xref -&gt; analyze module use: &quot;
<a name="280"/>  280:         &quot;~n   For mods: ~p&quot;, [Mods]),
<a name="281"/>  281:     {ok, RTmods} = xref:analyze(XRef, {module_use, Mods}),
<a name="282"/>  282:     ?AL(&quot;xref -&gt; analyze (compiler) module use: &quot;
<a name="283"/>  283:         &quot;~n   For mods: ~p&quot;, [?COMPILER_MODULES]),
<a name="284"/>  284:     {ok, CTmods} = xref:analyze(XRef, {module_use, ?COMPILER_MODULES}),
<a name="285"/>  285:     ?AL(&quot;xref -&gt; analyze module call: &quot;
<a name="286"/>  286:         &quot;~n   For mods: ~p&quot;, [Mods]),
<a name="287"/>  287:     {ok, RTdeps} = xref:analyze(XRef, {module_call, Mods}),
<a name="288"/>  288: 
<a name="289"/>  289:     ?AL(&quot;xref -&gt; stop xref&quot;),
<a name="290"/>  290:     xref:stop(XRef),
<a name="291"/>  291: 
<a name="292"/>  292:     ?AL(&quot;xref -&gt; get OTP release&quot;),
<a name="293"/>  293:     Rel = release(),  %% otp_release-ish
<a name="294"/>  294: 
<a name="295"/>  295:     %% Only care about calls from our own application.
<a name="296"/>  296:     ?AL(&quot;xref -&gt; Only care about calls from our own application&quot;),
<a name="297"/>  297:     [] = lists:filter(fun({{F,_,_} = From, {_,_,_} = To}) -&gt;
<a name="298"/>  298:                               lists:member(F, Mods)
<a name="299"/>  299:                                   andalso not ignored(From, To, Rel)
<a name="300"/>  300:                       end,
<a name="301"/>  301:                       Undefs),
<a name="302"/>  302: 
<a name="303"/>  303:     %% Ensure that only runtime or info modules call runtime modules.
<a name="304"/>  304:     %% It's not strictly necessary that diameter compiler modules not
<a name="305"/>  305:     %% depend on other diameter modules but it's a simple source of
<a name="306"/>  306:     %% build errors if not properly encoded in the makefile so guard
<a name="307"/>  307:     %% against it.
<a name="308"/>  308:     ?AL(&quot;xref -&gt; ensure only runtime and info mod&quot;),
<a name="309"/>  309:     [] = (RTmods -- Mods) -- ?INFO_MODULES,
<a name="310"/>  310: 
<a name="311"/>  311:     %% Ensure that runtime modules don't call compiler modules.
<a name="312"/>  312:     ?AL(&quot;xref -&gt; ensure runtime mods don't call compiler mods&quot;),
<a name="313"/>  313:     CTmods = CTmods -- Mods,
<a name="314"/>  314: 
<a name="315"/>  315:     %% Ensure that runtime modules only call other runtime modules, or
<a name="316"/>  316:     %% applications declared in runtime_dependencies in the app file.
<a name="317"/>  317:     %% The declared application versions are ignored since we only
<a name="318"/>  318:     %% know what we see now.
<a name="319"/>  319:     ?AL(&quot;xref -&gt; ensure runtime mods only call runtime mods&quot;),
<a name="320"/>  320:     [] = lists:filter(fun(M) -&gt; not lists:member(app(M), Deps) end,
<a name="321"/>  321:                       RTdeps -- Mods),
<a name="322"/>  322: 
<a name="323"/>  323:     ?AL(&quot;xref -&gt; done&quot;),
<a name="324"/>  324:     ok;
<a name="325"/>  325: 
<a name="326"/>  326: <b>xref</b>(Config) -&gt;
<a name="327"/>  327:     ?AL(&quot;xref -&gt; entry with&quot;
<a name="328"/>  328:         &quot;~n   Config: ~p&quot;, [Config]),
<a name="329"/>  329:     Res = run(Config, [xref]),
<a name="330"/>  330:     ?AL(&quot;xref -&gt; done when&quot;
<a name="331"/>  331:         &quot;~n   Res: ~p&quot;, [Res]),
<a name="xref-last_expr"/><a name="332"/>  332:     Res.
<a name="333"/>  333: 
<a name="ignored-3"/><a name="334"/>  334: <b>ignored</b>({FromMod,_,_}, {ToMod,_,_} = To, Rel)-&gt;
<a name="335"/>  335:     %% diameter_tcp does call ssl despite the latter not being listed
<a name="336"/>  336:     %% as a dependency in the app file since ssl is only required for
<a name="337"/>  337:     %% TLS security: it's up to a client who wants TLS to start ssl.
<a name="338"/>  338:     %% The OTP 18 time api is also called if it exists, so that the
<a name="339"/>  339:     %% same code can be run on older releases.
<a name="340"/>  340:     {FromMod, ToMod} == {diameter_tcp, ssl}
<a name="ignored-last_expr"/><a name="341"/>  341: <b>        orelse </b>(FromMod == diameter_lib
<a name="342"/>  342:                 andalso Rel &lt; 18
<a name="343"/>  343:                 andalso lists:member(To, time_api())).
<a name="344"/>  344: 
<a name="345"/>  345: <i>%% New time api in OTP 18.</i>
<a name="time_api-0"/><a name="346"/>  346: <b>time_api</b>() -&gt;
<a name="347"/>  347:     [{erlang, F, A} || {F,A} &lt;- [{convert_time_unit,3},
<a name="348"/>  348:                                  {monotonic_time,0},
<a name="349"/>  349:                                  {monotonic_time,1},
<a name="350"/>  350:                                  {system_time,0},
<a name="351"/>  351:                                  {system_time,1},
<a name="352"/>  352:                                  {time_offset,0},
<a name="353"/>  353:                                  {time_offset,1},
<a name="354"/>  354:                                  {timestamp,0},
<a name="355"/>  355:                                  {unique_integer,0},
<a name="356"/>  356:                                  {unique_integer,1}]]
<a name="time_api-last_expr"/><a name="357"/>  357:         ++ [{os, system_time, 0},
<a name="358"/>  358:             {os, system_time, 1}].
<a name="359"/>  359: 
<a name="release-0"/><a name="360"/>  360: <b>release</b>() -&gt;
<a name="361"/>  361:     Rel = erlang:system_info(otp_release),
<a name="release-last_expr"/><a name="362"/>  362: <b>    try list_to_integer</b>(Rel) of
<a name="363"/>  363:         N -&gt; N
<a name="364"/>  364:     catch
<a name="365"/>  365:         error:_ -&gt;
<a name="366"/>  366:             0  %% aka &lt; 17
<a name="367"/>  367:     end.
<a name="368"/>  368: 
<a name="unversion-1"/><a name="369"/>  369: <b>unversion</b>(App) -&gt;
<a name="370"/>  370:     {Name, [$-|Vsn]} = lists:splitwith(fun(C) -&gt; C /= $- end, App),
<a name="371"/>  371:     true = is_app(Name), %% assert
<a name="372"/>  372:     Vsn = vsn_str(Vsn),  %%
<a name="unversion-last_expr"/><a name="373"/>  373:     Name.
<a name="374"/>  374: 
<a name="app-1"/><a name="375"/>  375: <b>app</b>('$M_EXPR') -&gt; %% could be anything but assume it's ok
<a name="376"/>  376:     &quot;erts&quot;;
<a name="377"/>  377: <b>app</b>(Mod) -&gt;
<a name="app-last_expr"/><a name="378"/>  378: <b>    case code:which</b>(Mod) of
<a name="379"/>  379:         preloaded -&gt;
<a name="380"/>  380:             &quot;erts&quot;;
<a name="381"/>  381:         Reason when is_atom(Reason) -&gt;
<a name="382"/>  382:             error({Reason, Mod});
<a name="383"/>  383:         Path -&gt;
<a name="384"/>  384:             %% match to identify an unexpectedly short path
<a name="385"/>  385:             {_, _, [_,_,_|_] = Split} = {Mod, Path, filename:split(Path)},
<a name="386"/>  386:             unversion(lists:nth(3, lists:reverse(Split)))
<a name="387"/>  387:     end.
<a name="388"/>  388: 
<a name="add_application-2"/><a name="389"/>  389: <b>add_application</b>(XRef, App) -&gt;
<a name="390"/>  390:     ?AL(&quot;add_application -&gt; get lib dir for app ~p&quot;, [App]),
<a name="391"/>  391:     LibDir = code:lib_dir(App),
<a name="392"/>  392:     ?AL(&quot;add_application -&gt; [xref] add lib dir:&quot;
<a name="393"/>  393:         &quot;~n   ~p&quot;, [LibDir]),
<a name="add_application-last_expr"/><a name="394"/>  394: <b>    {ok, App} = xref:add_application</b>(XRef, LibDir, []).
<a name="395"/>  395: 
<a name="make_name-1"/><a name="396"/>  396: <b>make_name</b>(Suf) -&gt;
<a name="make_name-last_expr"/><a name="397"/>  397: <b>    list_to_atom</b>(&quot;diameter_&quot; ++ atom_to_list(Suf)).
<a name="398"/>  398: 
<a name="399"/>  399: 
<a name="400"/>  400: <i>%% ===========================================================================</i>
<a name="401"/>  401: <i>%% # relup/1</i>
<a name="402"/>  402: <i>%%</i>
<a name="403"/>  403: <i>%% Ensure that we can generate release upgrade files using our appup file.</i>
<a name="404"/>  404: <i>%% ===========================================================================</i>
<a name="405"/>  405: 
<a name="relup-1"/><a name="406"/>  406: <b>relup</b>({App, Config}) -&gt;
<a name="407"/>  407:     i(&quot;relup -&gt; entry with&quot;
<a name="408"/>  408:       &quot;~n   App:    ~p&quot;
<a name="409"/>  409:       &quot;~n   Config: ~p&quot;, [App, Config]),
<a name="410"/>  410: 
<a name="411"/>  411:     [{Vsn, Up, Down}] = ?CONSULT(diameter, appup),
<a name="412"/>  412:     true = is_vsn(Vsn),
<a name="413"/>  413: 
<a name="414"/>  414:     i(&quot;relup -&gt; &quot;
<a name="415"/>  415:       &quot;~n   Vsn:  ~p&quot;
<a name="416"/>  416:       &quot;~n   Up:   ~p&quot;
<a name="417"/>  417:       &quot;~n   Down: ~p&quot;, [Vsn, Up, Down]),
<a name="418"/>  418: 
<a name="419"/>  419:     Rel = [{erts, erlang:system_info(version)}
<a name="420"/>  420:            | [{A, appvsn(A)} || A &lt;- [sasl | fetch(applications, App)]]],
<a name="421"/>  421: 
<a name="422"/>  422:     i(&quot;relup -&gt; &quot;
<a name="423"/>  423:       &quot;~n   Rel: ~p&quot;, [Rel]),
<a name="424"/>  424: 
<a name="425"/>  425:     Dir = fetch(priv_dir, Config),
<a name="426"/>  426: 
<a name="427"/>  427:     i(&quot;relup -&gt; verify path&quot;
<a name="428"/>  428:       &quot;~n   Dir: ~p&quot;, [Dir]),
<a name="429"/>  429:     verify_path(Dir),
<a name="430"/>  430: 
<a name="431"/>  431:     i(&quot;relup -&gt; &quot;
<a name="432"/>  432:       &quot;~n   Dir: &quot;
<a name="433"/>  433:       &quot;~n      ~s&quot;
<a name="434"/>  434:       &quot;~n   File info (dir): &quot;
<a name="435"/>  435:       &quot;~n      ~s&quot;, [Dir, file_info(Dir)]),
<a name="436"/>  436: 
<a name="437"/>  437:     Name = write_rel(Dir, Rel, Vsn),
<a name="438"/>  438:     i(&quot;relup -&gt; written&quot;
<a name="439"/>  439:       &quot;~n   Name: &quot;
<a name="440"/>  440:       &quot;~n      ~s&quot;, [Name]),
<a name="441"/>  441:     UpFrom = acc_rel(Dir, Rel, Up),
<a name="442"/>  442:     i(&quot;relup -&gt; &quot;
<a name="443"/>  443:       &quot;~n   UpFrom: ~p&quot;, [UpFrom]),
<a name="444"/>  444:     DownTo = acc_rel(Dir, Rel, Down),
<a name="445"/>  445:     i(&quot;relup -&gt; &quot;
<a name="446"/>  446:       &quot;~n   DownTo: ~p&quot;, [DownTo]),
<a name="447"/>  447: 
<a name="448"/>  448:     {[], []} = {UpFrom -- DownTo, DownTo -- UpFrom},
<a name="449"/>  449:     [[], []] = [S -- sets:to_list(sets:from_list(S))
<a name="450"/>  450:                 || S &lt;- [UpFrom, DownTo]],
<a name="451"/>  451: 
<a name="452"/>  452:     i(&quot;relup -&gt; try make relup&quot;),
<a name="453"/>  453:     {ok, _, _, []} = systools:make_relup(Name, UpFrom, DownTo, [{path, [Dir]},
<a name="454"/>  454:                                                                 {outdir, Dir},
<a name="455"/>  455:                                                                 silent]);
<a name="456"/>  456: 
<a name="457"/>  457: <b>relup</b>(Config) -&gt;
<a name="relup-last_expr"/><a name="458"/>  458: <b>    run</b>(Config, [relup]).
<a name="459"/>  459: 
<a name="460"/>  460: 
<a name="verify_path-1"/><a name="461"/>  461: <b>verify_path</b>(Path) -&gt;
<a name="462"/>  462:     Components = filename:split(filename:absname(Path)),
<a name="verify_path-last_expr"/><a name="463"/>  463: <b>    do_verify_path</b>(Components).
<a name="464"/>  464: 
<a name="do_verify_path-1"/><a name="465"/>  465: <b>do_verify_path</b>([]) -&gt;
<a name="466"/>  466:     exit(not_a_path);
<a name="467"/>  467: <b>do_verify_path</b>([Root|Components]) -&gt;
<a name="do_verify_path-last_expr"/><a name="468"/>  468: <b>    do_verify_path</b>(Root, Components).
<a name="469"/>  469: 
<a name="do_verify_path-2"/><a name="470"/>  470: <b>do_verify_path</b>(Path, []) -&gt;
<a name="471"/>  471:     case file:read_file_info(Path) of
<a name="472"/>  472:         {ok, #file_info{type   = directory,
<a name="473"/>  473:                         access = Access}} -&gt;
<a name="474"/>  474:             i(&quot;do_verify_path -&gt; (final) directory ok:&quot;
<a name="475"/>  475:               &quot;~n   Path:   ~p&quot;
<a name="476"/>  476:               &quot;~n   Access: ~p&quot;, [Path, Access]),
<a name="477"/>  477:             ok;
<a name="478"/>  478:         {ok, #file_info{type   = Type,
<a name="479"/>  479:                         access = Access}} -&gt;
<a name="480"/>  480:             i(&quot;do_verify_path -&gt; (final) unexpected type: &quot;
<a name="481"/>  481:               &quot;~n   Path:   ~p&quot;
<a name="482"/>  482:               &quot;~n   Type:   ~p&quot;
<a name="483"/>  483:               &quot;~n   Access: ~p&quot;, [Path, Type, Access]),
<a name="484"/>  484:             exit({not_dir, Path, Type, Access});
<a name="485"/>  485:         {error, Reason} -&gt;
<a name="486"/>  486:             i(&quot;do_verify_path -&gt; failed reading file info: &quot;
<a name="487"/>  487:               &quot;~n   Path:   ~p&quot;
<a name="488"/>  488:               &quot;~n   Reason: ~p&quot;, [Path, Reason]),
<a name="489"/>  489:             exit({read_file_info, Path, Reason})
<a name="490"/>  490:     end;
<a name="491"/>  491: <b>do_verify_path</b>(Path, [Component|Components]) -&gt;
<a name="do_verify_path-last_expr"/><a name="492"/>  492: <b>    case file:read_file_info</b>(Path) of
<a name="493"/>  493:         {ok, #file_info{type   = directory,
<a name="494"/>  494:                         access = Access}} -&gt;
<a name="495"/>  495:             i(&quot;do_verify_path -&gt; directory ok: &quot;
<a name="496"/>  496:               &quot;~n   Path:   ~p&quot;
<a name="497"/>  497:               &quot;~n   Access: ~p&quot;, [Path, Access]),
<a name="498"/>  498:             do_verify_path(filename:absname_join(Path, Component),
<a name="499"/>  499:                            Components);
<a name="500"/>  500:         {ok, #file_info{type   = Type,
<a name="501"/>  501:                         access = Access}} -&gt;
<a name="502"/>  502:             i(&quot;do_verify_path -&gt; unexpected type: &quot;
<a name="503"/>  503:               &quot;~n   Path:   ~p&quot;
<a name="504"/>  504:               &quot;~n   Type:   ~p&quot;
<a name="505"/>  505:               &quot;~n   Access: ~p&quot;, [Path, Type, Access]),
<a name="506"/>  506:             exit({not_dir, Path, Type, Access});
<a name="507"/>  507:         {error, Reason} -&gt;
<a name="508"/>  508:             i(&quot;do_verify_path -&gt; failed reading file info: &quot;
<a name="509"/>  509:               &quot;~n   Path:   ~p&quot;
<a name="510"/>  510:               &quot;~n   Reason: ~p&quot;, [Path, Reason]),
<a name="511"/>  511:             exit({read_file_info, Path, Reason})
<a name="512"/>  512:     end.
<a name="513"/>  513:             
<a name="514"/>  514: 
<a name="file_info-1"/><a name="515"/>  515: <b>file_info</b>(Path) -&gt;
<a name="file_info-last_expr"/><a name="516"/>  516: <b>    case file:read_file_info</b>(Path) of
<a name="517"/>  517:         {ok, Info} -&gt;
<a name="518"/>  518:             f(&quot;~p&quot;, [Info]);
<a name="519"/>  519:         {error, Reason} -&gt;
<a name="520"/>  520:             f(&quot;error: ~p&quot;, [Reason])
<a name="521"/>  521:     end.
<a name="522"/>  522: 
<a name="f-2"/><a name="523"/>  523: <b>f</b>(F, A) -&gt;
<a name="f-last_expr"/><a name="524"/>  524: <b>    lists:flatten</b>(io_lib:format(F, A)).
<a name="525"/>  525: 
<a name="acc_rel-3"/><a name="526"/>  526: <b>acc_rel</b>(Dir, Rel, List) -&gt;
<a name="acc_rel-last_expr"/><a name="527"/>  527: <b>    lists:map</b>(fun({V,_}) -&gt; write_rel(Dir, Rel, V) end, List).
<a name="528"/>  528: 
<a name="529"/>  529: <i>%% Write a rel file and return its name.</i>
<a name="write_rel-3"/><a name="530"/>  530: <b>write_rel</b>(Dir, [Erts | Apps], Vsn) -&gt;
<a name="531"/>  531:     VS   = vsn_str(Vsn),
<a name="532"/>  532:     Name = &quot;diameter_test_&quot; ++ VS,
<a name="533"/>  533:     File = filename:join([Dir, Name ++ &quot;.rel&quot;]),
<a name="534"/>  534:     i(&quot;write_rel -&gt; attempt write rel file:&quot;
<a name="535"/>  535:       &quot;~n   Dir:  ~p&quot;
<a name="536"/>  536:       &quot;~n   File: ~p&quot;
<a name="537"/>  537:       &quot;~n   File name length: ~p&quot;
<a name="538"/>  538:       &quot;~n   Erts: ~p&quot;
<a name="539"/>  539:       &quot;~n   Apps: ~p&quot;
<a name="540"/>  540:       &quot;~n   Vsn:  ~p (~p)&quot;,
<a name="541"/>  541:       [Dir, File, length(File), Erts, Apps, Vsn, VS]),
<a name="542"/>  542:     ok = write_file(File,
<a name="543"/>  543:                     {release,
<a name="544"/>  544:                      {&quot;diameter &quot; ++ VS ++ &quot; test release&quot;, VS},
<a name="545"/>  545:                      Erts,
<a name="546"/>  546:                      Apps}),
<a name="write_rel-last_expr"/><a name="547"/>  547:     Name.
<a name="548"/>  548: 
<a name="549"/>  549: 
<a name="550"/>  550: <i>%% ===========================================================================</i>
<a name="551"/>  551: <i>%% ===========================================================================</i>
<a name="552"/>  552: 
<a name="fetch-2"/><a name="553"/>  553: <b>fetch</b>(Key, List) -&gt;
<a name="554"/>  554:     {Key, {Key, Val}} = {Key, lists:keyfind(Key, 1, List)}, %% useful badmatch
<a name="fetch-last_expr"/><a name="555"/>  555:     Val.
<a name="556"/>  556: 
<a name="write_file-2"/><a name="557"/>  557: <b>write_file</b>(Path, T) -&gt;
<a name="write_file-last_expr"/><a name="558"/>  558: <b>    file:write_file</b>(Path, io_lib:format(&quot;~p.&quot;, [T])).
<a name="559"/>  559: 
<a name="560"/>  560: <i>%% Is a version string of the expected form?</i>
<a name="is_vsn-1"/><a name="561"/>  561: <b>is_vsn</b>(V) -&gt;
<a name="562"/>  562:     V = vsn_str(V),
<a name="is_vsn-last_expr"/><a name="563"/>  563:     true.
<a name="564"/>  564: 
<a name="565"/>  565: <i>%% Turn a from/to version in appup to a version string after ensuring</i>
<a name="566"/>  566: <i>%% that it's valid version number of regexp. In the regexp case, the</i>
<a name="567"/>  567: <i>%% regexp itself becomes the version string since there's no</i>
<a name="568"/>  568: <i>%% requirement that a version in appup be anything but a string. The</i>
<a name="569"/>  569: <i>%% restrictions placed on string-valued version numbers (that they be</i>
<a name="570"/>  570: <i>%% '.'-separated integers) are our own.</i>
<a name="571"/>  571: 
<a name="vsn_str-1"/><a name="572"/>  572: <b>vsn_str</b>(S)
<a name="573"/>  573:   when is_list(S) -&gt;
<a name="574"/>  574:     {_, match}   = {S, match(S, &quot;^(0|[1-9][0-9]*)(\\.(0|[1-9][0-9]*))*$&quot;)},
<a name="575"/>  575:     {_, nomatch} = {S, match(S, &quot;\\.0\\.0$&quot;)},
<a name="576"/>  576:     S;
<a name="577"/>  577: 
<a name="578"/>  578: <b>vsn_str</b>(B)
<a name="579"/>  579:   when is_binary(B) -&gt;
<a name="580"/>  580:     {ok, _} = re:compile(B),
<a name="581"/>  581:     %% Check if its a wildcard version: &quot;1\\..&quot;
<a name="582"/>  582:     Str = binary_to_list(B),
<a name="vsn_str-last_expr"/><a name="583"/>  583: <b>    case lists:reverse</b>(Str) of
<a name="584"/>  584:         [$*, $., $., $\\ | Rest] -&gt;
<a name="585"/>  585:             lists:reverse(Rest);
<a name="586"/>  586:         _ -&gt;
<a name="587"/>  587:             Str
<a name="588"/>  588:     end.
<a name="589"/>  589: 
<a name="match-2"/><a name="590"/>  590: <b>match</b>(S, RE) -&gt;
<a name="match-last_expr"/><a name="591"/>  591: <b>    re:run</b>(S, RE, [{capture, none}]).
<a name="592"/>  592: 
<a name="593"/>  593: <i>%% Is an application name of the expected form?</i>
<a name="is_app-1"/><a name="594"/>  594: <b>is_app</b>(S)
<a name="595"/>  595:   when is_list(S) -&gt;
<a name="596"/>  596:     {_, match} = {S, match(S, &quot;^([a-z]([a-z_]*|[a-zA-Z]*))$&quot;)},
<a name="is_app-last_expr"/><a name="597"/>  597:     true.
<a name="598"/>  598: 
<a name="599"/>  599: 
<a name="i-1"/><a name="600"/>  600: <b>i</b>(F) -&gt;
<a name="i-last_expr"/><a name="601"/>  601: <b>    i</b>(F, []).
<a name="602"/>  602: 
<a name="i-2"/><a name="603"/>  603: <b>i</b>(F, A) when is_list(F) andalso is_list(A) -&gt;
<a name="i-last_expr"/><a name="604"/>  604: <b>    io:format</b>(F ++ &quot;~n&quot;, A). 
</pre>
<script>
var hash = window.location.hash.substring(1);
var anchor = document.getElementsByName(hash);
anchor[0].style.backgroundColor="orange";
</script>
</body>
</html>
