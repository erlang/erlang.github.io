<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/lib/diameter/make_test_dir/diameter_test/diameter_watchdog_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%</i>
<a name="2"/>    2: <i>%% %CopyrightBegin%</i>
<a name="3"/>    3: <i>%%</i>
<a name="4"/>    4: <i>%% Copyright Ericsson AB 2010-2024. All Rights Reserved.</i>
<a name="5"/>    5: <i>%%</i>
<a name="6"/>    6: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="7"/>    7: <i>%% you may not use this file except in compliance with the License.</i>
<a name="8"/>    8: <i>%% You may obtain a copy of the License at</i>
<a name="9"/>    9: <i>%%</i>
<a name="10"/>   10: <i>%%     http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="11"/>   11: <i>%%</i>
<a name="12"/>   12: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="13"/>   13: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="14"/>   14: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="15"/>   15: <i>%% See the License for the specific language governing permissions and</i>
<a name="16"/>   16: <i>%% limitations under the License.</i>
<a name="17"/>   17: <i>%%</i>
<a name="18"/>   18: <i>%% %CopyrightEnd%</i>
<a name="19"/>   19: <i>%%</i>
<a name="20"/>   20: 
<a name="21"/>   21: <i>%%</i>
<a name="22"/>   22: <i>%% Tests of the RFC3539 watchdog state machine as implemented by</i>
<a name="23"/>   23: <i>%% module diameter_watchdog.</i>
<a name="24"/>   24: <i>%%</i>
<a name="25"/>   25: 
<a name="26"/>   26: <b>-module</b>(diameter_watchdog_SUITE).
<a name="27"/>   27: 
<a name="28"/>   28: <i>%% testcases, no common_test dependency</i>
<a name="29"/>   29: <b>-export</b>([run/0,
<a name="30"/>   30:          run/1]).
<a name="31"/>   31: 
<a name="32"/>   32: <i>%% common_test wrapping</i>
<a name="33"/>   33: <b>-export</b>([
<a name="34"/>   34:          %% Framework functions
<a name="35"/>   35:          suite/0,
<a name="36"/>   36:          all/0,
<a name="37"/>   37:          init_per_suite/1,
<a name="38"/>   38:          end_per_suite/1,
<a name="39"/>   39:          init_per_testcase/2,
<a name="40"/>   40:          end_per_testcase/2,
<a name="41"/>   41: 
<a name="42"/>   42:          %% The test cases
<a name="43"/>   43:          reopen/1,
<a name="44"/>   44:          suspect/1,
<a name="45"/>   45:          okay/1
<a name="46"/>   46:         ]).
<a name="47"/>   47: 
<a name="48"/>   48: <i>%% internal callbacks</i>
<a name="49"/>   49: <b>-export</b>([reopen/4, reopen/6,
<a name="50"/>   50:          suspect/4,
<a name="51"/>   51:          okay/4,
<a name="52"/>   52:          id/1,    %% jitter callback
<a name="53"/>   53:          abuse/1,
<a name="54"/>   54:          abuse/2]).
<a name="55"/>   55: 
<a name="56"/>   56: <i>%% diameter_app callbacks</i>
<a name="57"/>   57: <b>-export</b>([peer_up/3,
<a name="58"/>   58:          peer_down/3]).
<a name="59"/>   59: 
<a name="60"/>   60: <i>%% diameter_tcp message_cb</i>
<a name="61"/>   61: <b>-export</b>([message/3]).
<a name="62"/>   62: 
<a name="63"/>   63: <b>-include_lib</b>(&quot;diameter/include/diameter.hrl&quot;).
<a name="64"/>   64: <b>-include</b>(&quot;diameter_util.hrl&quot;).
<a name="65"/>   65: 
<a name="66"/>   66: <i>%% ===========================================================================</i>
<a name="67"/>   67: 
<a name="68"/>   68: <b>-define</b>(WL(F),    ?WL(F, [])).
<a name="69"/>   69: <b>-define</b>(WL(F, A), ?LOG(&quot;DWD&quot;, F, A)).
<a name="70"/>   70: 
<a name="71"/>   71: <b>-define</b>(BASE, ?DIAMETER_DICT_COMMON).
<a name="72"/>   72: <b>-define</b>(REALM, &quot;erlang.org&quot;).
<a name="73"/>   73: <b>-define</b>(ADDR, {127,0,0,1}).
<a name="74"/>   74: 
<a name="75"/>   75: <i>%% Config for diameter:start_service/2.</i>
<a name="76"/>   76: <b>-define</b>(SERVICE(Name),
<a name="77"/>   77:         [{'Origin-Host', Name ++ &quot;.&quot; ++ ?REALM},
<a name="78"/>   78:          {'Origin-Realm', ?REALM},
<a name="79"/>   79:          {'Host-IP-Address', [?ADDR]},
<a name="80"/>   80:          {'Vendor-Id', 42},
<a name="81"/>   81:          {'Product-Name', &quot;OTP/diameter&quot;},
<a name="82"/>   82:          {'Auth-Application-Id', [0 = ?BASE:id()]},
<a name="83"/>   83:          {application, [{alias, Name},
<a name="84"/>   84:                         {dictionary, ?BASE},
<a name="85"/>   85:                         {module, ?MODULE}]}]).
<a name="86"/>   86: 
<a name="87"/>   87: <i>%% Watchdog timer as a callback.</i>
<a name="88"/>   88: <b>-define</b>(WD(T), {?MODULE, id, [T]}).
<a name="89"/>   89: 
<a name="90"/>   90: <i>%% Watchdog timers used by the testcases.</i>
<a name="91"/>   91: <b>-define</b>(WD_TIMERS, [10000, ?WD(10000)]).
<a name="92"/>   92: 
<a name="93"/>   93: <i>%% Watchdog timer of the misbehaving node.</i>
<a name="94"/>   94: <b>-define</b>(PEER_WD, 10000).
<a name="95"/>   95: 
<a name="96"/>   96: <i>%% A timeout that ensures one watchdog. To ensure only one watchdog</i>
<a name="97"/>   97: <i>%% requires (Wd + 2000) + 1000 &lt; 2*(Wd - 2000) ==&gt; 7000 &lt; Wd for the</i>
<a name="98"/>   98: <i>%% case with random jitter.</i>
<a name="99"/>   99: <b>-define</b>(ONE_WD(Wd), jitter(Wd,2000) + 1000).
<a name="100"/>  100: <b>-define</b>(INFO(T), #diameter_event{info = T}).
<a name="101"/>  101: 
<a name="102"/>  102: <i>%% Receive an event message from diameter.</i>
<a name="103"/>  103: <b>-define</b>(EVENT(T),    %% apply to not bind T_
<a name="104"/>  104:         apply(fun() -&gt;
<a name="105"/>  105:                       receive ?INFO(T = T_) -&gt; log_event(T_) end
<a name="106"/>  106:               end,
<a name="107"/>  107:               [])).
<a name="108"/>  108: 
<a name="109"/>  109: <i>%% Receive a watchdog event.</i>
<a name="110"/>  110: <b>-define</b>(WD_EVENT(Ref), log_wd(element(4, ?EVENT({watchdog, Ref, _, _, _})))).
<a name="111"/>  111: <b>-define</b>(WD_EVENT(Ref, Ms),
<a name="112"/>  112:         apply(fun() -&gt;
<a name="113"/>  113:                       receive ?INFO({watchdog, Ref, _, T_, _}) -&gt;
<a name="114"/>  114:                               log_wd(T_)
<a name="115"/>  115:                       after Ms -&gt;
<a name="116"/>  116:                               false
<a name="117"/>  117:                       end
<a name="118"/>  118:               end,
<a name="119"/>  119:               [])).
<a name="120"/>  120: 
<a name="121"/>  121: 
<a name="122"/>  122: <i>%% ===========================================================================</i>
<a name="123"/>  123: 
<a name="suite-0"/><a name="124"/>  124: <b>suite</b>() -&gt;
<a name="suite-last_expr"/><a name="125"/>  125:     [{timetrap, {seconds, 315}}].
<a name="126"/>  126: 
<a name="all-0"/><a name="127"/>  127: <b>all</b>() -&gt;
<a name="all-last_expr"/><a name="128"/>  128:     [reopen, suspect, okay].
<a name="129"/>  129: 
<a name="130"/>  130: 
<a name="init_per_suite-1"/><a name="131"/>  131: <b>init_per_suite</b>(Config) -&gt;
<a name="init_per_suite-last_expr"/><a name="132"/>  132: <b>    ?DUTIL:init_per_suite</b>(Config).
<a name="133"/>  133: 
<a name="end_per_suite-1"/><a name="134"/>  134: <b>end_per_suite</b>(Config) -&gt;
<a name="end_per_suite-last_expr"/><a name="135"/>  135: <b>    ?DUTIL:end_per_suite</b>(Config).
<a name="136"/>  136: 
<a name="137"/>  137: 
<a name="138"/>  138: <i>%% This test case can take a *long* time, so if the machine is too slow, skip</i>
<a name="init_per_testcase-2"/><a name="139"/>  139: <b>init_per_testcase</b>(Case, Config) when is_list(Config) -&gt;
<a name="140"/>  140:     ?WL(&quot;init_per_testcase(~w) -&gt; check factor&quot;, [Case]),
<a name="141"/>  141:     Key = dia_factor,
<a name="init_per_testcase-last_expr"/><a name="142"/>  142: <b>    case lists:keysearch</b>(Key, 1, Config) of
<a name="143"/>  143:         {value, {Key, Factor}} when (Factor &gt; 10) -&gt;
<a name="144"/>  144:             ?WL(&quot;init_per_testcase(~w) -&gt; Too slow (~w) =&gt; SKIP&quot;,
<a name="145"/>  145:                 [Case, Factor]),
<a name="146"/>  146:             {skip, {machine_too_slow, Factor}};
<a name="147"/>  147:         _ -&gt;
<a name="148"/>  148:             ?WL(&quot;init_per_testcase(~w) -&gt; run test&quot;, [Case]),
<a name="149"/>  149:             Config
<a name="150"/>  150:     end.
<a name="151"/>  151: <i>%% init_per_testcase(Case, Config) -&gt;</i>
<a name="152"/>  152: <i>%%     ?WL(&quot;init_per_testcase(~w) -&gt; entry&quot;, [Case]),</i>
<a name="153"/>  153: <i>%%     Config.</i>
<a name="154"/>  154: 
<a name="155"/>  155: 
<a name="end_per_testcase-2"/><a name="156"/>  156: <b>end_per_testcase</b>(Case, Config) when is_list(Config) -&gt;
<a name="157"/>  157:     ?WL(&quot;end_per_testcase(~w) -&gt; entry&quot;, [Case]),
<a name="end_per_testcase-last_expr"/><a name="158"/>  158:     Config.
<a name="159"/>  159: 
<a name="160"/>  160: 
<a name="161"/>  161: 
<a name="162"/>  162: 
<a name="163"/>  163: <i>%% ===========================================================================</i>
<a name="164"/>  164: 
<a name="reopen-1"/><a name="165"/>  165: <b>reopen</b>(_Config) -&gt;
<a name="166"/>  166:     ?WL(&quot;~w -&gt; entry&quot;, [?FUNCTION_NAME]),
<a name="167"/>  167:     Res = run([reopen]),
<a name="168"/>  168:     ?WL(&quot;~w -&gt; done when&quot;
<a name="169"/>  169:         &quot;~n   Res: ~p&quot;, [?FUNCTION_NAME, Res]),
<a name="reopen-last_expr"/><a name="170"/>  170:     Res.
<a name="171"/>  171: 
<a name="suspect-1"/><a name="172"/>  172: <b>suspect</b>(_Config) -&gt;
<a name="173"/>  173:     ?WL(&quot;~w -&gt; entry&quot;, [?FUNCTION_NAME]),
<a name="174"/>  174:     Res = run([suspect]),
<a name="175"/>  175:     ?WL(&quot;~w -&gt; done when&quot;
<a name="176"/>  176:         &quot;~n   Res: ~p&quot;, [?FUNCTION_NAME, Res]),
<a name="suspect-last_expr"/><a name="177"/>  177:     Res.
<a name="178"/>  178: 
<a name="okay-1"/><a name="179"/>  179: <b>okay</b>(_Config) -&gt;
<a name="180"/>  180:     ?WL(&quot;~w -&gt; entry&quot;, [?FUNCTION_NAME]),
<a name="181"/>  181:     Res = run([okay]),
<a name="182"/>  182:     ?WL(&quot;~w -&gt; done when&quot;
<a name="183"/>  183:         &quot;~n   Res: ~p&quot;, [?FUNCTION_NAME, Res]),
<a name="okay-last_expr"/><a name="184"/>  184:     Res.
<a name="185"/>  185: 
<a name="186"/>  186: 
<a name="187"/>  187: <i>%% ===========================================================================</i>
<a name="188"/>  188: 
<a name="189"/>  189: <i>%% run/0</i>
<a name="190"/>  190: 
<a name="run-0"/><a name="191"/>  191: <b>run</b>() -&gt;
<a name="run-last_expr"/><a name="192"/>  192: <b>    run</b>(all()).
<a name="193"/>  193: 
<a name="194"/>  194: <i>%% run/1.</i>
<a name="195"/>  195: 
<a name="run-1"/><a name="196"/>  196: <b>run</b>(reopen) -&gt;
<a name="197"/>  197:     reopen();   %% 20 watchdogs @ 15 sec
<a name="198"/>  198: 
<a name="199"/>  199: <b>run</b>(suspect) -&gt;
<a name="200"/>  200:     suspect();
<a name="201"/>  201: 
<a name="202"/>  202: <b>run</b>(okay) -&gt;
<a name="203"/>  203:     okay();
<a name="204"/>  204: 
<a name="205"/>  205: <b>run</b>(List) -&gt;
<a name="206"/>  206:     ok = diameter:start(),
<a name="run-last_expr"/><a name="207"/>  207:     try
<a name="208"/>  208:         ?RUN([{[fun run/1, T], maps:get(T, #{reopen =&gt; 300000}, 90000)}
<a name="209"/>  209:               || T &lt;- List])
<a name="210"/>  210:     after
<a name="211"/>  211:         ok = diameter:stop()
<a name="212"/>  212:     end.
<a name="213"/>  213: 
<a name="214"/>  214: 
<a name="215"/>  215: <i>%% ===========================================================================</i>
<a name="216"/>  216: <i>%% # reopen/0</i>
<a name="217"/>  217: <i>%% ===========================================================================</i>
<a name="218"/>  218: 
<a name="219"/>  219: <i>%% Test the watchdog state machine for the required failover, failback</i>
<a name="220"/>  220: <i>%% and reopen behaviour by examining watchdog events.</i>
<a name="221"/>  221: 
<a name="reopen-0"/><a name="222"/>  222: <b>reopen</b>() -&gt;
<a name="reopen-last_expr"/><a name="223"/>  223: <b>    ?RUN</b>([{?MODULE, reopen, [T, W, N, M]}
<a name="224"/>  224:           || T &lt;- [listen, connect], %% watchdog to test
<a name="225"/>  225:              W &lt;- ?WD_TIMERS,        %% watchdog_timer value
<a name="226"/>  226:              N &lt;- [0,1,2],           %% DWR's to answer before ignoring
<a name="227"/>  227:              M &lt;- ['DWR', 'DWA', 'RAA']]). %% how to induce failback
<a name="228"/>  228: 
<a name="reopen-4"/><a name="229"/>  229: <b>reopen</b>(Test, Wd, N, M) -&gt;
<a name="230"/>  230:     %% Publish a ref ensure the connecting transport is added only
<a name="231"/>  231:     %% once events from the listening transport are subscribed to.
<a name="232"/>  232:     Ref = make_ref(),
<a name="reopen-last_expr"/><a name="233"/>  233: <b>    ?RUN</b>([{?MODULE, reopen, [T, Test, Ref, Wd, N, M]}
<a name="234"/>  234:           || T &lt;- [listen, connect]]).
<a name="235"/>  235: 
<a name="236"/>  236: <i>%% reopen/6</i>
<a name="237"/>  237: 
<a name="reopen-6"/><a name="238"/>  238: <b>reopen</b>(Type, Test, Ref, Wd, N, M) -&gt;
<a name="239"/>  239:     {SvcName, TRef} = start(Type, Ref, cfg(Type, Test, Wd)),
<a name="reopen-last_expr"/><a name="240"/>  240: <b>    reopen</b>(Type, Test, SvcName, TRef, Wd, N, M).
<a name="241"/>  241: 
<a name="cfg-3"/><a name="242"/>  242: <b>cfg</b>(Type, Type, Wd) -&gt;
<a name="243"/>  243:     {Wd, [], false};
<a name="244"/>  244: <b>cfg</b>(_Type, _Test, _Wd) -&gt;
<a name="cfg-last_expr"/><a name="245"/>  245: <b>    {?WD</b>(?PEER_WD), [{okay, 0}], true}.
<a name="246"/>  246: 
<a name="247"/>  247: <i>%% reopen/7</i>
<a name="248"/>  248: 
<a name="249"/>  249: <i>%% The watchdog to be tested.</i>
<a name="reopen-7"/><a name="250"/>  250: <b>reopen</b>(Type, Type, SvcName, Ref, Wd, N, M) -&gt;
<a name="251"/>  251:     ?WL(&quot;node ~p&quot;, [[Type, SvcName, Ref, Wd, N, M]]),
<a name="252"/>  252: 
<a name="253"/>  253:     %% Connection should come up immediately as a consequence of
<a name="254"/>  254:     %% starting the watchdog process. In the accepting case this
<a name="255"/>  255:     %% results in a new watchdog on a transport waiting for a new
<a name="256"/>  256:     %% connection.
<a name="257"/>  257: 
<a name="258"/>  258:     {initial, okay} = ?WD_EVENT(Ref),
<a name="259"/>  259:     ?EVENT({up, Ref, _, _, #diameter_packet{}}),
<a name="260"/>  260: 
<a name="261"/>  261:     %%   OKAY          Timer expires &amp;      Failover()
<a name="262"/>  262:     %%                 Pending              SetWatchdog()        SUSPECT
<a name="263"/>  263:     %%
<a name="264"/>  264:     %% The peer replies to N DWR's before becoming silent, we should
<a name="265"/>  265:     %% go down after N+2 watchdog_timer expirations: that is, after
<a name="266"/>  266:     %% the first unanswered DWR. Knowing the min/max watchdog timeout
<a name="267"/>  267:     %% values gives the time interval in which the event is expected.
<a name="268"/>  268: 
<a name="269"/>  269:     [0,0,0,0] = wd_counts(SvcName),
<a name="270"/>  270: 
<a name="271"/>  271:     {okay, suspect} = ?WD_EVENT(Ref),
<a name="272"/>  272:     ?EVENT({down, Ref, _, _}),
<a name="273"/>  273: 
<a name="274"/>  274:     %% N received DWA's
<a name="275"/>  275:     [_,_,_,N] = wd_counts(SvcName),
<a name="276"/>  276: 
<a name="277"/>  277:     %%   SUSPECT       Receive DWA          Pending = FALSE
<a name="278"/>  278:     %%                                      Failback()
<a name="279"/>  279:     %%                                      SetWatchdog()        OKAY
<a name="280"/>  280:     %%
<a name="281"/>  281:     %%   SUSPECT       Receive non-DWA      Failback()
<a name="282"/>  282:     %%                                      SetWatchdog()        OKAY
<a name="283"/>  283:     %%
<a name="284"/>  284:     %% The peer sends a message before the expiry of another watchdog
<a name="285"/>  285:     %% to induce failback.
<a name="286"/>  286: 
<a name="287"/>  287:     {suspect, okay} = ?WD_EVENT(Ref),
<a name="288"/>  288:     ?EVENT({up, Ref, _, _}),
<a name="289"/>  289: 
<a name="290"/>  290:     %% N+1 sent DWR's, N/N+1 received DWA's
<a name="291"/>  291:     R1 = N+1,
<a name="292"/>  292:     A1 = choose(M == 'DWA', R1, N),
<a name="293"/>  293:     [R1,_,_,A1] = wd_counts(SvcName),
<a name="294"/>  294: 
<a name="295"/>  295:     %%   OKAY          Timer expires &amp;      SendWatchdog()
<a name="296"/>  296:     %%                 !Pending             SetWatchdog()
<a name="297"/>  297:     %%                                      Pending = TRUE       OKAY
<a name="298"/>  298:     %%
<a name="299"/>  299:     %%   OKAY          Timer expires &amp;      Failover()
<a name="300"/>  300:     %%                 Pending              SetWatchdog()        SUSPECT
<a name="301"/>  301:     %%
<a name="302"/>  302:     %% The peer is now ignoring all watchdogs so the connection goes
<a name="303"/>  303:     %% back down after either one or two watchdog expiries, depending
<a name="304"/>  304:     %% on whether or not DWA restored the connection.
<a name="305"/>  305: 
<a name="306"/>  306:     {okay, suspect} = ?WD_EVENT(Ref),
<a name="307"/>  307:     ?EVENT({down, Ref, _, _}),
<a name="308"/>  308: 
<a name="309"/>  309:     %%   SUSPECT       Timer expires        CloseConnection()
<a name="310"/>  310:     %%                                      SetWatchdog()        DOWN
<a name="311"/>  311:     %%
<a name="312"/>  312:     %% Non-response brings the connection down after another timeout.
<a name="313"/>  313: 
<a name="314"/>  314:     {suspect, down} = ?WD_EVENT(Ref),
<a name="315"/>  315: 
<a name="316"/>  316:     R2 = R1 + choose(M == 'DWA', 1, 0),
<a name="317"/>  317:     A2 = A1,
<a name="318"/>  318:     [R2,_,_,A2] = wd_counts(SvcName),
<a name="319"/>  319: 
<a name="320"/>  320:     %%   DOWN          Timer expires        AttemptOpen()
<a name="321"/>  321:     %%                                      SetWatchdog()        DOWN
<a name="322"/>  322:     %%
<a name="323"/>  323:     %%   DOWN          Connection up        NumDWA = 0
<a name="324"/>  324:     %%                                      SendWatchdog()
<a name="325"/>  325:     %%                                      SetWatchdog()
<a name="326"/>  326:     %%                                      Pending = TRUE       REOPEN
<a name="327"/>  327:     %%
<a name="328"/>  328:     %% The connection is reestablished after another timeout.
<a name="329"/>  329: 
<a name="330"/>  330:     recv_reopen(Type, Ref),
<a name="331"/>  331: 
<a name="332"/>  332:     %%   REOPEN        Receive non-DWA      Throwaway()          REOPEN
<a name="333"/>  333:     %%
<a name="334"/>  334:     %%   REOPEN        Receive DWA &amp;        Pending = FALSE
<a name="335"/>  335:     %%                 NumDWA &lt; 2           NumDWA++             REOPEN
<a name="336"/>  336:     %%
<a name="337"/>  337:     %%   REOPEN        Receive DWA &amp;        Pending = FALSE
<a name="338"/>  338:     %%                 NumDWA == 2          NumDWA++
<a name="339"/>  339:     %%                                      Failback()           OKAY
<a name="340"/>  340:     %%
<a name="341"/>  341:     %%   REOPEN        Timer expires &amp;      SendWatchdog()
<a name="342"/>  342:     %%                 !Pending             SetWatchdog()
<a name="343"/>  343:     %%                                      Pending = TRUE       REOPEN
<a name="344"/>  344:     %%
<a name="345"/>  345:     %% An exchange of 3 watchdogs (the first directly after
<a name="346"/>  346:     %% capabilities exchange) brings the connection back up.
<a name="347"/>  347: 
<a name="348"/>  348:     {reopen, okay} = ?WD_EVENT(Ref),
<a name="349"/>  349:     ?EVENT({up, Ref, _, _, #diameter_packet{}}),
<a name="350"/>  350: 
<a name="351"/>  351:     %% Three DWR's have been answered.
<a name="352"/>  352:     R3 = R2 + 3,
<a name="353"/>  353:     A3 = A2 + 3,
<a name="354"/>  354:     [R3,_,_,A3] = wd_counts(SvcName),
<a name="355"/>  355: 
<a name="356"/>  356:     %% Non-response brings it down again.
<a name="357"/>  357: 
<a name="358"/>  358:     {okay, suspect} = ?WD_EVENT(Ref),
<a name="359"/>  359:     ?EVENT({down, Ref, _, _}),
<a name="360"/>  360:     {suspect, down} = ?WD_EVENT(Ref),
<a name="361"/>  361: 
<a name="362"/>  362:     R4 = R3 + 1,
<a name="363"/>  363:     A4 = A3,
<a name="364"/>  364:     [R4,_,_,A4] = wd_counts(SvcName),
<a name="365"/>  365: 
<a name="366"/>  366:     %% Reestablish after another watchdog.
<a name="367"/>  367: 
<a name="368"/>  368:     recv_reopen(Type, Ref),
<a name="369"/>  369: 
<a name="370"/>  370:     %%   REOPEN        Timer expires &amp;      NumDWA = -1
<a name="371"/>  371:     %%                 Pending &amp;            SetWatchdog()
<a name="372"/>  372:     %%                 NumDWA &gt;= 0                               REOPEN
<a name="373"/>  373:     %%
<a name="374"/>  374:     %%   REOPEN        Timer expires &amp;      CloseConnection()
<a name="375"/>  375:     %%                 Pending &amp;            SetWatchdog()
<a name="376"/>  376:     %%                 NumDWA &lt; 0                                DOWN
<a name="377"/>  377:     %%
<a name="378"/>  378:     %% Peer is now ignoring all watchdogs go down again after 2
<a name="379"/>  379:     %% timeouts.
<a name="380"/>  380: 
<a name="381"/>  381:     {reopen, down} = ?WD_EVENT(Ref);
<a name="382"/>  382: 
<a name="383"/>  383: <i>%% The misbehaving peer.</i>
<a name="384"/>  384: <b>reopen</b>(Type, _, SvcName, Ref, Wd, N, M) -&gt;
<a name="385"/>  385:     ?WL(&quot;peer ~p&quot;, [[Type, SvcName, Ref, Wd, N, M]]),
<a name="386"/>  386: 
<a name="387"/>  387:     %% First transport process.
<a name="388"/>  388:     {initial, okay} = ?WD_EVENT(Ref),
<a name="389"/>  389:     ?EVENT({up, Ref, _, _, #diameter_packet{}}),
<a name="390"/>  390: 
<a name="391"/>  391:     reg(Ref, SvcName, {SvcName, {Wd,N,M}}),
<a name="392"/>  392: 
<a name="393"/>  393:     {okay, down} = ?WD_EVENT(Ref),
<a name="394"/>  394: 
<a name="395"/>  395:     %% Second transport process.
<a name="396"/>  396:     ?EVENT({watchdog, Ref, _, {_, okay}, _}),
<a name="397"/>  397:     reg(Ref, SvcName, 3),  %% answer 3 watchdogs then fall silent
<a name="398"/>  398:     ?EVENT({watchdog, Ref, _, {_, down}, _}),
<a name="399"/>  399: 
<a name="400"/>  400:     %% Third transport process.
<a name="401"/>  401:     ?EVENT({watchdog, Ref, _, {_, okay}, _}),
<a name="402"/>  402:     reg(Ref, SvcName, 0),  %% disable outgoing DWA
<a name="403"/>  403:     ?EVENT({watchdog, Ref, _, {_, down}, _}),
<a name="404"/>  404: 
<a name="reopen-last_expr"/><a name="405"/>  405:     ok.
<a name="406"/>  406: 
<a name="log_wd-1"/><a name="407"/>  407: <b>log_wd</b>({From, To} = T) -&gt;
<a name="408"/>  408:     ?WL(&quot;~p -&gt; ~p&quot;, [From, To]),
<a name="log_wd-last_expr"/><a name="409"/>  409:     T.
<a name="410"/>  410: 
<a name="log_event-1"/><a name="411"/>  411: <b>log_event</b>(E) -&gt;
<a name="412"/>  412:     T = element(1,E),
<a name="413"/>  413:     T == watchdog orelse ?WL(&quot;~p&quot;, [T]),
<a name="log_event-last_expr"/><a name="414"/>  414:     E.
<a name="415"/>  415: 
<a name="416"/>  416: <i>%% recv_reopen/2</i>
<a name="417"/>  417: 
<a name="recv_reopen-2"/><a name="418"/>  418: <b>recv_reopen</b>(connect, Ref) -&gt;
<a name="419"/>  419:     {down, reopen} = ?WD_EVENT(Ref),
<a name="420"/>  420:     ?EVENT({reconnect, Ref, _});
<a name="421"/>  421: 
<a name="422"/>  422: <b>recv_reopen</b>(listen, Ref) -&gt;
<a name="recv_reopen-last_expr"/><a name="423"/>  423: <b>    {_, reopen} = ?WD_EVENT</b>(Ref).
<a name="424"/>  424: 
<a name="425"/>  425: <i>%% reg/3</i>
<a name="426"/>  426: <i>%%</i>
<a name="427"/>  427: <i>%% Lookup the pid of the transport process and publish a term for</i>
<a name="428"/>  428: <i>%% message/3 to lookup.</i>
<a name="reg-3"/><a name="429"/>  429: <b>reg</b>(TRef, SvcName, T) -&gt;
<a name="430"/>  430:     TPid = tpid(TRef, diameter:service_info(SvcName, transport)),
<a name="reg-last_expr"/><a name="431"/>  431: <b>    true = diameter_reg:add_new</b>({?MODULE, TPid, T}).
<a name="432"/>  432: 
<a name="433"/>  433: <i>%% tpid/2</i>
<a name="434"/>  434: 
<a name="tpid-2"/><a name="435"/>  435: <b>tpid</b>(Ref, [[{ref, Ref},
<a name="436"/>  436:             {type, connect},
<a name="437"/>  437:             {options, _},
<a name="438"/>  438:             {watchdog, _},
<a name="439"/>  439:             {peer, _},
<a name="440"/>  440:             {apps, _},
<a name="441"/>  441:             {caps, _},
<a name="442"/>  442:             {port, [{owner, TPid} | _]}
<a name="443"/>  443:             | _]]) -&gt;
<a name="444"/>  444:     TPid;
<a name="445"/>  445: 
<a name="446"/>  446: <b>tpid</b>(Ref, [[{ref, Ref},
<a name="447"/>  447:             {type, listen},
<a name="448"/>  448:             {options, _},
<a name="449"/>  449:             {accept, As}
<a name="450"/>  450:             | _]]) -&gt;
<a name="451"/>  451:     [[{watchdog, _},
<a name="452"/>  452:       {peer, _},
<a name="453"/>  453:       {apps, _},
<a name="454"/>  454:       {caps, _},
<a name="455"/>  455:       {port, [{owner, TPid} | _]}
<a name="456"/>  456:       | _]]
<a name="457"/>  457:         = lists:filter(fun([{watchdog, {_,_,S}} | _]) -&gt;
<a name="458"/>  458:                                S == okay orelse S == reopen
<a name="459"/>  459:                        end,
<a name="460"/>  460:                        As),
<a name="tpid-last_expr"/><a name="461"/>  461:     TPid.
<a name="462"/>  462: 
<a name="463"/>  463: <i>%% ===========================================================================</i>
<a name="464"/>  464: <i>%% # suspect/0</i>
<a name="465"/>  465: <i>%% ===========================================================================</i>
<a name="466"/>  466: 
<a name="467"/>  467: <i>%% Configure transports to require a set number of watchdog timeouts</i>
<a name="468"/>  468: <i>%% before moving from OKAY to SUSPECT.</i>
<a name="469"/>  469: 
<a name="suspect-0"/><a name="470"/>  470: <b>suspect</b>() -&gt;
<a name="suspect-last_expr"/><a name="471"/>  471: <b>    ?RUN</b>([{?MODULE, abuse, [[suspect, N]]} || N &lt;- [0,1,3]]).
<a name="472"/>  472: 
<a name="suspect-4"/><a name="473"/>  473: <b>suspect</b>(Type, Fake, Ref, N)
<a name="474"/>  474:   when is_reference(Ref) -&gt;
<a name="475"/>  475:     {SvcName, TRef}
<a name="476"/>  476:         = start(Type, Ref, {?WD(10000), [{suspect, N}], Fake}),
<a name="477"/>  477:     {initial, okay} = ?WD_EVENT(TRef),
<a name="478"/>  478:     suspect(TRef, Fake, SvcName, N);
<a name="479"/>  479: 
<a name="480"/>  480: <b>suspect</b>(TRef, true, SvcName, _) -&gt;
<a name="481"/>  481:     reg(TRef, SvcName, 0),  %% disable outgoing DWA
<a name="482"/>  482:     {okay, _} = ?WD_EVENT(TRef);
<a name="483"/>  483: 
<a name="484"/>  484: <b>suspect</b>(TRef, false, SvcName, 0) -&gt;  %% SUSPECT disabled
<a name="485"/>  485:     %% Wait 2+ watchdogs and see that only one watchdog has been sent.
<a name="486"/>  486:     false = ?WD_EVENT(TRef, 28000),
<a name="487"/>  487:     [1,0,0,0] = wd_counts(SvcName);
<a name="488"/>  488: 
<a name="489"/>  489: <b>suspect</b>(TRef, false, SvcName, N) -&gt;
<a name="490"/>  490:     %% Check that no watchdog transition takes place within N+
<a name="491"/>  491:     %% watchdogs ...
<a name="492"/>  492:     false = ?WD_EVENT(TRef, N*10000+8000),
<a name="493"/>  493:     [1,0,0,0] = wd_counts(SvcName),
<a name="494"/>  494:     %% ... but that the connection then becomes suspect ...
<a name="495"/>  495:     {okay, suspect} = ?WD_EVENT(TRef, 10000),
<a name="496"/>  496:     [1,0,0,0] = wd_counts(SvcName),
<a name="497"/>  497:     %% ... and goes down.
<a name="498"/>  498:     {suspect, down} = ?WD_EVENT(TRef, 18000),
<a name="suspect-last_expr"/><a name="499"/>  499: <b>    [1,0,0,0] = wd_counts</b>(SvcName).
<a name="500"/>  500: 
<a name="501"/>  501: <i>%% abuse/1</i>
<a name="502"/>  502: 
<a name="abuse-1"/><a name="503"/>  503: <b>abuse</b>(F) -&gt;
<a name="abuse-last_expr"/><a name="504"/>  504: <b>    ?RUN</b>([{?MODULE, abuse, [F, T]} || T &lt;- [listen, connect]]).
<a name="505"/>  505: 
<a name="abuse-2"/><a name="506"/>  506: <b>abuse</b>(F, [_,_,_|_] = Args) -&gt;
<a name="507"/>  507:     ?WL(&quot;~p&quot;, [Args]),
<a name="508"/>  508:     apply(?MODULE, F, Args);
<a name="509"/>  509: 
<a name="510"/>  510: <b>abuse</b>([F|A], Test) -&gt;
<a name="511"/>  511:     Ref = make_ref(),
<a name="512"/>  512:     ?RUN([{?MODULE, abuse, [F, [T, T == Test, Ref] ++ A]}
<a name="513"/>  513:           || T &lt;- [listen, connect]]);
<a name="514"/>  514: 
<a name="515"/>  515: <b>abuse</b>(F, Test) -&gt;
<a name="abuse-last_expr"/><a name="516"/>  516: <b>    abuse</b>([F], Test).
<a name="517"/>  517: 
<a name="518"/>  518: 
<a name="519"/>  519: <i>%% ===========================================================================</i>
<a name="520"/>  520: <i>%% # okay/0</i>
<a name="521"/>  521: <i>%% ===========================================================================</i>
<a name="522"/>  522: 
<a name="523"/>  523: <i>%% Configure the number of watchdog exchanges before moving from</i>
<a name="524"/>  524: <i>%% REOPEN to OKAY.</i>
<a name="525"/>  525: 
<a name="okay-0"/><a name="526"/>  526: <b>okay</b>() -&gt;
<a name="okay-last_expr"/><a name="527"/>  527: <b>    ?RUN</b>([{?MODULE, abuse, [[okay, N]]} || N &lt;- [0,2,3]]).
<a name="528"/>  528: 
<a name="okay-4"/><a name="529"/>  529: <b>okay</b>(Type, Fake, Ref, N)
<a name="530"/>  530:   when is_reference(Ref) -&gt;
<a name="531"/>  531:     {SvcName, TRef}
<a name="532"/>  532:         = start(Type, Ref, {?WD(10000),
<a name="533"/>  533:                             [{okay, choose(Fake, 0, N)}],
<a name="534"/>  534:                             Fake}),
<a name="535"/>  535:     {initial, okay} = ?WD_EVENT(TRef),
<a name="okay-last_expr"/><a name="536"/>  536: <b>    okay</b>(TRef,
<a name="537"/>  537:          Fake,
<a name="538"/>  538:          SvcName,
<a name="539"/>  539:          choose(Type == listen, initial, down),
<a name="540"/>  540:          N).
<a name="541"/>  541: 
<a name="okay-5"/><a name="542"/>  542: <b>okay</b>(TRef, true, SvcName, Down, _) -&gt;
<a name="543"/>  543:     reg(TRef, SvcName, 0),  %% disable outgoing DWA
<a name="544"/>  544:     {okay, down} = ?WD_EVENT(TRef),
<a name="545"/>  545:     {Down, okay} = ?WD_EVENT(TRef),
<a name="546"/>  546:     reg(TRef, SvcName, -1), %% enable outgoing DWA
<a name="547"/>  547:     {okay, down} = ?WD_EVENT(TRef);
<a name="548"/>  548: 
<a name="549"/>  549: <b>okay</b>(TRef, false, SvcName, Down, N) -&gt;
<a name="550"/>  550:     {okay, suspect} = ?WD_EVENT(TRef),
<a name="551"/>  551:     [1,0,0,0] = wd_counts(SvcName),
<a name="552"/>  552:     {suspect, down} = ?WD_EVENT(TRef),
<a name="okay-last_expr"/><a name="553"/>  553: <b>    ok</b>(TRef, SvcName, Down, N).
<a name="554"/>  554: 
<a name="ok-4"/><a name="555"/>  555: <b>ok</b>(TRef, SvcName, Down, 0) -&gt;
<a name="556"/>  556:     %% Connection comes up without watchdog exchange.
<a name="557"/>  557:     {Down, okay} = ?WD_EVENT(TRef),
<a name="558"/>  558:     [1,0,0,0] = wd_counts(SvcName),
<a name="559"/>  559:     %% Wait 2+ watchdog timeouts to see that the connection stays up
<a name="560"/>  560:     %% and two watchdogs are exchanged.
<a name="561"/>  561:     false = ?WD_EVENT(TRef, 28000),
<a name="562"/>  562:     [3,0,0,2] = wd_counts(SvcName);
<a name="563"/>  563: 
<a name="564"/>  564: <b>ok</b>(TRef, SvcName, Down, N) -&gt;
<a name="565"/>  565:     %% Connection required watchdog exchange before reaching OKAY.
<a name="566"/>  566:     {Down, reopen} = ?WD_EVENT(TRef),
<a name="567"/>  567:     {reopen, okay} = ?WD_EVENT(TRef),
<a name="568"/>  568:     %% One DWR was sent in moving to expect, plus N more to reopen the
<a name="569"/>  569:     %% connection.
<a name="570"/>  570:     N1 = N+1,
<a name="ok-last_expr"/><a name="571"/>  571: <b>    [N1,0,0,N] = wd_counts</b>(SvcName).
<a name="572"/>  572: 
<a name="573"/>  573: <i>%% ===========================================================================</i>
<a name="574"/>  574: 
<a name="575"/>  575: <i>%% wd_counts/1</i>
<a name="576"/>  576: 
<a name="wd_counts-1"/><a name="577"/>  577: <b>wd_counts</b>(SvcName) -&gt;
<a name="578"/>  578:     [Info] = diameter:service_info(SvcName, transport),
<a name="579"/>  579:     {_, Counters} = lists:keyfind(statistics, 1, Info),
<a name="wd_counts-last_expr"/><a name="580"/>  580: <b>    [proplists:get_value</b>({{0,280,R}, D}, Counters, 0) || D &lt;- [send,recv],
<a name="581"/>  581:                                                          R &lt;- [1,0]].
<a name="582"/>  582: 
<a name="583"/>  583: <i>%% start/3</i>
<a name="584"/>  584: 
<a name="start-3"/><a name="585"/>  585: <b>start</b>(Type, Ref, T) -&gt;
<a name="586"/>  586:     Name = hostname(),
<a name="587"/>  587:     true = diameter:subscribe(Name),
<a name="588"/>  588:     ok = diameter:start_service(Name, [{monitor, self()} | ?SERVICE(Name)]),
<a name="589"/>  589:     {ok, TRef} = diameter:add_transport(Name, {Type, opts(Type, Ref, T)}),
<a name="590"/>  590:     true = diameter_reg:add_new({Type, Ref, Name}),
<a name="start-last_expr"/><a name="591"/>  591:     {Name, TRef}.
<a name="592"/>  592: 
<a name="opts-3"/><a name="593"/>  593: <b>opts</b>(Type, Ref, {Timer, Config, Fake})
<a name="594"/>  594:   when is_boolean(Fake) -&gt;
<a name="opts-last_expr"/><a name="595"/>  595:     [{transport_module, diameter_tcp},
<a name="596"/>  596:      {transport_config, mod(Fake) ++ [{ip, ?ADDR}, {port, 0}]
<a name="597"/>  597:                                   ++ cfg(Type, Ref)},
<a name="598"/>  598:      {watchdog_timer, Timer},
<a name="599"/>  599:      {watchdog_config, Config}].
<a name="600"/>  600: 
<a name="mod-1"/><a name="601"/>  601: <b>mod</b>(B) -&gt;
<a name="mod-last_expr"/><a name="602"/>  602:     [{message_cb, [fun message/3, capx]} || B].
<a name="603"/>  603: 
<a name="cfg-2"/><a name="604"/>  604: <b>cfg</b>(listen, _) -&gt;
<a name="605"/>  605:     [];
<a name="606"/>  606: <b>cfg</b>(connect, Ref) -&gt;
<a name="607"/>  607:     [{{_, _, SvcName}, _Pid}] = diameter_reg:wait({listen, Ref, '_'}),
<a name="608"/>  608:     [[{ref, LRef} | _]] = diameter:service_info(SvcName, transport),
<a name="609"/>  609:     [LP] = ?LPORT(tcp, LRef),
<a name="cfg-last_expr"/><a name="610"/>  610:     [{raddr, ?ADDR}, {rport, LP}].
<a name="611"/>  611: 
<a name="612"/>  612: <i>%% ===========================================================================</i>
<a name="613"/>  613: 
<a name="614"/>  614: <i>%% message/3</i>
<a name="615"/>  615: 
<a name="message-3"/><a name="616"/>  616: <b>message</b>(send, Bin, X) -&gt;
<a name="617"/>  617:     send(Bin, X);
<a name="618"/>  618: 
<a name="619"/>  619: <b>message</b>(recv, Bin, _) -&gt;
<a name="620"/>  620:     [Bin];
<a name="621"/>  621: 
<a name="622"/>  622: <b>message</b>(_, _, _) -&gt;
<a name="message-last_expr"/><a name="623"/>  623:     [].
<a name="624"/>  624: 
<a name="625"/>  625: <i>%% send/2</i>
<a name="626"/>  626: 
<a name="627"/>  627: <i>%% First outgoing message from a new transport process is CER/CEA.</i>
<a name="628"/>  628: <i>%% Remaining outgoing messages are either DWR or DWA.</i>
<a name="send-2"/><a name="629"/>  629: <b>send</b>(Bin, capx) -&gt;
<a name="630"/>  630:     &lt;&lt;_:32, _:8, 257:24, _/binary&gt;&gt; = Bin,  %% assert on CER/CEA
<a name="631"/>  631:     [Bin, fun message/3, init];
<a name="632"/>  632: 
<a name="633"/>  633: <i>%% Outgoing DWR: fake reception of DWA. Use the fact that AVP values</i>
<a name="634"/>  634: <i>%% are ignored. This is to ensure that the peer's watchdog state</i>
<a name="635"/>  635: <i>%% transitions are only induced by responses to messages it sends.</i>
<a name="636"/>  636: <b>send</b>(&lt;&lt;_:32, 1:1, _:7, 280:24, _:32, EId:32, HId:32, _/binary&gt;&gt;, _) -&gt;
<a name="637"/>  637:     Pkt = #diameter_packet{header = #diameter_header{version = 1,
<a name="638"/>  638:                                                      end_to_end_id = EId,
<a name="639"/>  639:                                                      hop_by_hop_id = HId},
<a name="640"/>  640:                            msg = ['DWA', {'Result-Code', 2001},
<a name="641"/>  641:                                          {'Origin-Host', &quot;XXX&quot;},
<a name="642"/>  642:                                          {'Origin-Realm', ?REALM}]},
<a name="643"/>  643:     #diameter_packet{bin = Bin} = diameter_codec:encode(?BASE, Pkt),
<a name="644"/>  644:     [recv, Bin];
<a name="645"/>  645: 
<a name="646"/>  646: <i>%% First outgoing DWA.</i>
<a name="647"/>  647: <b>send</b>(Bin, init) -&gt;
<a name="648"/>  648:     [{{?MODULE, _, T}, _}] = diameter_reg:wait({?MODULE, self(), '_'}),
<a name="649"/>  649:     send(Bin, T);
<a name="650"/>  650: 
<a name="651"/>  651: <i>%% First transport process.</i>
<a name="652"/>  652: <b>send</b>(Bin, {SvcName, {_,_,_} = T}) -&gt;
<a name="653"/>  653:     [{'Origin-Host', _} = OH, {'Origin-Realm', _} = OR | _]
<a name="654"/>  654:         = ?SERVICE(SvcName),
<a name="655"/>  655:     putr(origin, [OH, OR]),
<a name="656"/>  656:     send(Bin, T);
<a name="657"/>  657: 
<a name="658"/>  658: <i>%% Discard DWA, failback after another timeout in the peer.</i>
<a name="659"/>  659: <b>send</b>(Bin, {Wd, 0 = No, Msg}) -&gt;
<a name="660"/>  660:     Origin = getr(origin),
<a name="661"/>  661:     [{defer, ?ONE_WD(Wd), [msg(Msg, Bin, Origin)]}, fun message/3, No];
<a name="662"/>  662: 
<a name="663"/>  663: <i>%% Send DWA while we're in the mood (aka 0 &lt; N).</i>
<a name="664"/>  664: <b>send</b>(Bin, {Wd, N, Msg}) -&gt;
<a name="665"/>  665:     [Bin, fun message/3, {Wd, N-1, Msg}];
<a name="666"/>  666: 
<a name="667"/>  667: <i>%% Discard DWA.</i>
<a name="668"/>  668: <b>send</b>(_Bin, 0 = No) -&gt;
<a name="669"/>  669:     [fun message/3, No];
<a name="670"/>  670: 
<a name="671"/>  671: <i>%% Send DWA.</i>
<a name="672"/>  672: <b>send</b>(&lt;&lt;_:32, 0:1, _:7, 280:24, _/binary&gt;&gt; = DWA, N) -&gt;
<a name="send-last_expr"/><a name="673"/>  673:     [DWA, fun message/3, N-1].
<a name="674"/>  674: 
<a name="675"/>  675: <i>%% msg/2</i>
<a name="676"/>  676: 
<a name="msg-3"/><a name="677"/>  677: <b>msg</b>('DWA', Bin, _Origin) -&gt;
<a name="678"/>  678:     Bin;
<a name="679"/>  679: <b>msg</b>(Msg, _Bin, Origin) -&gt;
<a name="680"/>  680:     #diameter_packet{bin = Bin}
<a name="681"/>  681:         = diameter_codec:encode(?BASE, msg(Msg, Origin)),
<a name="msg-last_expr"/><a name="682"/>  682:     Bin.
<a name="683"/>  683: 
<a name="msg-2"/><a name="684"/>  684: <b>msg</b>('DWR' = M, T) -&gt;
<a name="685"/>  685:     [M | T];
<a name="686"/>  686: 
<a name="687"/>  687: <b>msg</b>('RAA', T) -&gt;
<a name="msg-last_expr"/><a name="688"/>  688: <b>    ['RAA', {'Session-Id', diameter:session_id</b>(&quot;abc&quot;)},
<a name="689"/>  689:             {'Result-Code', 2001}
<a name="690"/>  690:           | T].
<a name="691"/>  691: <i>%% An unexpected answer is discarded after passing through the</i>
<a name="692"/>  692: <i>%% watchdog state machine.</i>
<a name="693"/>  693: 
<a name="694"/>  694: <i>%% ===========================================================================</i>
<a name="695"/>  695: 
<a name="peer_up-3"/><a name="696"/>  696: <b>peer_up</b>(_SvcName, _Peer, S) -&gt;
<a name="peer_up-last_expr"/><a name="697"/>  697:     S.
<a name="698"/>  698: 
<a name="peer_down-3"/><a name="699"/>  699: <b>peer_down</b>(_SvcName, _Peer, S) -&gt;
<a name="peer_down-last_expr"/><a name="700"/>  700:     S.
<a name="701"/>  701: 
<a name="702"/>  702: 
<a name="703"/>  703: <i>%% ===========================================================================</i>
<a name="704"/>  704: 
<a name="choose-3"/><a name="705"/>  705: <b>choose</b>(true, X, _)  -&gt; X;
<a name="choose-last_expr"/><a name="706"/>  706: <b>choose</b>(false, _, X) -&gt; X.
<a name="707"/>  707: 
<a name="708"/>  708: <i>%% id/1</i>
<a name="709"/>  709: <i>%%</i>
<a name="710"/>  710: <i>%% Jitter callback.</i>
<a name="711"/>  711: 
<a name="id-1"/><a name="712"/>  712: <b>id</b>(T) -&gt;
<a name="id-last_expr"/><a name="713"/>  713:     T.
<a name="714"/>  714: 
<a name="715"/>  715: <i>%% jitter/2</i>
<a name="716"/>  716: 
<a name="jitter-2"/><a name="717"/>  717: <b>jitter</b>(?WD(T), _) -&gt;
<a name="718"/>  718:     T;
<a name="719"/>  719: <b>jitter</b>(T,D) -&gt;
<a name="jitter-last_expr"/><a name="720"/>  720:     T+D.
<a name="721"/>  721: 
<a name="722"/>  722: <i>%% Generate a unique hostname for the faked peer.</i>
<a name="hostname-0"/><a name="723"/>  723: <b>hostname</b>() -&gt;
<a name="hostname-last_expr"/><a name="724"/>  724: <b>    ?UNIQUE_STRING</b>().
<a name="725"/>  725: 
<a name="putr-2"/><a name="726"/>  726: <b>putr</b>(Key, Val) -&gt;
<a name="putr-last_expr"/><a name="727"/>  727: <b>    put</b>({?MODULE, Key}, Val).
<a name="728"/>  728: 
<a name="getr-1"/><a name="729"/>  729: <b>getr</b>(Key) -&gt;
<a name="getr-last_expr"/><a name="730"/>  730: <b>    get</b>({?MODULE, Key}).
</pre>
<script>
var hash = window.location.hash.substring(1);
var anchor = document.getElementsByName(hash);
anchor[0].style.backgroundColor="orange";
</script>
</body>
</html>
