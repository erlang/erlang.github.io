<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/lib/stdlib/make_test_dir/stdlib_test/ets_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%</i>
<a name="2"/>    2: <i>%% %CopyrightBegin%</i>
<a name="3"/>    3: <i>%%</i>
<a name="4"/>    4: <i>%% Copyright Ericsson AB 1996-2024. All Rights Reserved.</i>
<a name="5"/>    5: <i>%%</i>
<a name="6"/>    6: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="7"/>    7: <i>%% you may not use this file except in compliance with the License.</i>
<a name="8"/>    8: <i>%% You may obtain a copy of the License at</i>
<a name="9"/>    9: <i>%%</i>
<a name="10"/>   10: <i>%%     http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="11"/>   11: <i>%%</i>
<a name="12"/>   12: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="13"/>   13: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="14"/>   14: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="15"/>   15: <i>%% See the License for the specific language governing permissions and</i>
<a name="16"/>   16: <i>%% limitations under the License.</i>
<a name="17"/>   17: <i>%%</i>
<a name="18"/>   18: <i>%% %CopyrightEnd%</i>
<a name="19"/>   19: <i>%%</i>
<a name="20"/>   20: <b>-module</b>(ets_SUITE).
<a name="21"/>   21: 
<a name="22"/>   22: <b>-export</b>([all/0, suite/0,groups/0,init_per_suite/1, end_per_suite/1,
<a name="23"/>   23: 	 init_per_group/2,end_per_group/2]).
<a name="24"/>   24: <b>-export</b>([default/1,setbag/1,badnew/1,verybadnew/1,named/1,keypos2/1,
<a name="25"/>   25: 	 privacy/1]).
<a name="26"/>   26: <b>-export</b>([empty/1,badinsert/1]).
<a name="27"/>   27: <b>-export</b>([badlookup/1,lookup_order/1]).
<a name="28"/>   28: <b>-export</b>([delete_elem/1,delete_tab/1,delete_large_tab/1,
<a name="29"/>   29: 	 delete_large_named_table/1,
<a name="30"/>   30: 	 evil_delete/1,baddelete/1,match_delete/1,table_leak/1]).
<a name="31"/>   31: <b>-export</b>([match_delete3/1]).
<a name="32"/>   32: <b>-export</b>([firstnext/1,firstnext_concurrent/1]).
<a name="33"/>   33: <b>-export</b>([firstnext_lookup/1,firstnext_lookup_concurrent/1]).
<a name="34"/>   34: <b>-export</b>([slot/1]).
<a name="35"/>   35: <b>-export</b>([hash_clash/1]).
<a name="36"/>   36: <b>-export</b>([match1/1, match2/1, match_object/1, match_object2/1]).
<a name="37"/>   37: <b>-export</b>([dups/1, misc1/1, safe_fixtable/1, info/1, tab2list/1]).
<a name="38"/>   38: <b>-export</b>([info_binary_stress/1]).
<a name="39"/>   39: <b>-export</b>([info_whereis_busy/1]).
<a name="40"/>   40: <b>-export</b>([insert_trap_delete/1, insert_trap_rename/1]).
<a name="41"/>   41: <b>-export</b>([tab2file/1, tab2file2/1, tabfile_ext1/1,
<a name="42"/>   42: 	 tabfile_ext2/1, tabfile_ext3/1, tabfile_ext4/1, badfile/1]).
<a name="43"/>   43: <b>-export</b>([heavy_lookup/1, heavy_lookup_element/1, heavy_concurrent/1]).
<a name="44"/>   44: <b>-export</b>([lookup_element_mult/1, lookup_element_default/1]).
<a name="45"/>   45: <b>-export</b>([foldl_ordered/1, foldr_ordered/1, foldl/1, foldr/1, fold_empty/1]).
<a name="46"/>   46: <b>-export</b>([t_delete_object/1, t_init_table/1, t_whitebox/1,
<a name="47"/>   47:          select_bound_chunk/1, t_delete_all_objects/1, t_test_ms/1,
<a name="48"/>   48:          t_delete_all_objects_trap/1,
<a name="49"/>   49: 	 t_select_delete/1,t_select_replace/1,t_select_replace_next_bug/1,
<a name="50"/>   50:          t_select_pam_stack_overflow_bug/1,
<a name="51"/>   51:          t_select_flatmap_term_copy_bug/1,
<a name="52"/>   52:          t_select_hashmap_term_copy_bug/1,
<a name="53"/>   53:          t_ets_dets/1]).
<a name="54"/>   54: <b>-export</b>([t_insert_list/1, t_insert_list_bag/1, t_insert_list_duplicate_bag/1,
<a name="55"/>   55:          t_insert_list_set/1, t_insert_list_delete_set/1,
<a name="56"/>   56:          t_insert_list_parallel/1, t_insert_list_delete_parallel/1,
<a name="57"/>   57:          t_insert_list_kill_process/1,
<a name="58"/>   58:          t_insert_list_insert_order_preserved/1]).
<a name="59"/>   59: <b>-export</b>([test_table_size_concurrency/1,test_table_memory_concurrency/1,
<a name="60"/>   60:          test_delete_table_while_size_snapshot/1, test_delete_table_while_size_snapshot_helper/1,
<a name="61"/>   61:          test_decentralized_counters_setting/1]).
<a name="62"/>   62: 
<a name="63"/>   63: <b>-export</b>([ordered/1, ordered_match/1, interface_equality/1,
<a name="64"/>   64: 	 fixtable_next/1, fixtable_iter_bag/1,
<a name="65"/>   65:          fixtable_insert/1, rename/1, rename_unnamed/1, evil_rename/1,
<a name="66"/>   66: 	 update_element/1, update_element_default/1, update_counter/1, evil_update_counter/1, partly_bound/1, match_heavy/1]).
<a name="67"/>   67: <b>-export</b>([update_counter_with_default/1]).
<a name="68"/>   68: <b>-export</b>([update_counter_with_default_bad_pos/1]).
<a name="69"/>   69: <b>-export</b>([update_counter_table_growth/1]).
<a name="70"/>   70: <b>-export</b>([member/1]).
<a name="71"/>   71: <b>-export</b>([memory/1]).
<a name="72"/>   72: <b>-export</b>([select_fail/1]).
<a name="73"/>   73: <b>-export</b>([t_insert_new/1]).
<a name="74"/>   74: <b>-export</b>([t_repair_continuation/1]).
<a name="75"/>   75: <b>-export</b>([t_match_spec_run/1]).
<a name="76"/>   76: <b>-export</b>([t_bucket_disappears/1]).
<a name="77"/>   77: <b>-export</b>([t_named_select/1]).
<a name="78"/>   78: <b>-export</b>([select_fixtab_owner_change/1]).
<a name="79"/>   79: <b>-export</b>([otp_5340/1]).
<a name="80"/>   80: <b>-export</b>([otp_6338/1]).
<a name="81"/>   81: <b>-export</b>([otp_6842_select_1000/1]).
<a name="82"/>   82: <b>-export</b>([select_mbuf_trapping/1]).
<a name="83"/>   83: <b>-export</b>([otp_7665/1]).
<a name="84"/>   84: <b>-export</b>([meta_wb/1]).
<a name="85"/>   85: <b>-export</b>([grow_shrink/1, grow_pseudo_deleted/1, shrink_pseudo_deleted/1]).
<a name="86"/>   86: <b>-export</b>([meta_lookup_unnamed_read/1, meta_lookup_unnamed_write/1,
<a name="87"/>   87: 	 meta_lookup_named_read/1, meta_lookup_named_write/1,
<a name="88"/>   88: 	 meta_newdel_unnamed/1, meta_newdel_named/1]).
<a name="89"/>   89: <b>-export</b>([smp_insert/1, smp_fixed_delete/1, smp_unfix_fix/1, smp_select_delete/1,
<a name="90"/>   90:          smp_ordered_iteration/1,
<a name="91"/>   91:          smp_select_replace/1, otp_8166/1, otp_8732/1, delete_unfix_race/1]).
<a name="92"/>   92: <b>-export</b>([throughput_benchmark/0,
<a name="93"/>   93:          throughput_benchmark/1,
<a name="94"/>   94:          test_throughput_benchmark/1,
<a name="95"/>   95:          long_throughput_benchmark/1,
<a name="96"/>   96:          lookup_catree_par_vs_seq_init_benchmark/0]).
<a name="97"/>   97: <b>-export</b>([exit_large_table_owner/1,
<a name="98"/>   98: 	 exit_many_large_table_owner/1,
<a name="99"/>   99: 	 exit_many_tables_owner/1,
<a name="100"/>  100: 	 exit_many_many_tables_owner/1]).
<a name="101"/>  101: <b>-export</b>([write_concurrency/1, heir/1, give_away/1, setopts/1]).
<a name="102"/>  102: <b>-export</b>([bad_table/1, types/1]).
<a name="103"/>  103: <b>-export</b>([otp_9932/1]).
<a name="104"/>  104: <b>-export</b>([otp_9423/1]).
<a name="105"/>  105: <b>-export</b>([otp_10182/1]).
<a name="106"/>  106: <b>-export</b>([compress_magic_ref/1]).
<a name="107"/>  107: <b>-export</b>([ets_all/1]).
<a name="108"/>  108: <b>-export</b>([massive_ets_all/1]).
<a name="109"/>  109: <b>-export</b>([take/1]).
<a name="110"/>  110: <b>-export</b>([whereis_table/1]).
<a name="111"/>  111: <b>-export</b>([ms_excessive_nesting/1]).
<a name="112"/>  112: <b>-export</b>([error_info/1]).
<a name="113"/>  113: 
<a name="114"/>  114: <b>-export</b>([init_per_testcase/2, end_per_testcase/2]).
<a name="115"/>  115: <i>%% Convenience for manual testing</i>
<a name="116"/>  116: <b>-export</b>([random_test/0]).
<a name="117"/>  117: 
<a name="118"/>  118: <b>-export</b>([t_select_reverse/1]).
<a name="119"/>  119: 
<a name="120"/>  120: <b>-include_lib</b>(&quot;stdlib/include/ms_transform.hrl&quot;). % ets:fun2ms
<a name="121"/>  121: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="122"/>  122: <b>-include_lib</b>(&quot;common_test/include/ct_event.hrl&quot;).
<a name="123"/>  123: 
<a name="124"/>  124: <b>-define</b>(m(A,B), assert_eq(A,B)).
<a name="125"/>  125: <b>-define</b>(heap_binary_size, 64).
<a name="126"/>  126: 
<a name="init_per_testcase-2"/><a name="127"/>  127: <b>init_per_testcase</b>(Case, Config) -&gt;
<a name="128"/>  128:     rand:seed(default),
<a name="129"/>  129:     io:format(&quot;*** SEED: ~p ***\n&quot;, [rand:export_seed()]),
<a name="130"/>  130:     start_spawn_logger(),
<a name="131"/>  131:     wait_for_test_procs(), %% Ensure previous case cleaned up
<a name="init_per_testcase-last_expr"/><a name="132"/>  132:     [{test_case, Case} | Config].
<a name="133"/>  133: 
<a name="end_per_testcase-2"/><a name="134"/>  134: <b>end_per_testcase</b>(_Func, _Config) -&gt;
<a name="end_per_testcase-last_expr"/><a name="135"/>  135: <b>    wait_for_test_procs</b>(true).
<a name="136"/>  136: 
<a name="137"/>  137: 
<a name="138"/>  138: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="139"/>  139: 
<a name="suite-0"/><a name="140"/>  140: <b>suite</b>() -&gt;
<a name="suite-last_expr"/><a name="141"/>  141:     [{ct_hooks,[ts_install_cth]},
<a name="142"/>  142:      {timetrap,{minutes,30}}].
<a name="143"/>  143: 
<a name="all-0"/><a name="144"/>  144: <b>all</b>() -&gt;
<a name="all-last_expr"/><a name="145"/>  145:     [{group, new}, {group, insert}, {group, lookup},
<a name="146"/>  146:      {group, delete}, firstnext, firstnext_concurrent,
<a name="147"/>  147:      firstnext_lookup, firstnext_lookup_concurrent, slot, hash_clash,
<a name="148"/>  148:      {group, match}, t_match_spec_run,
<a name="149"/>  149:      {group, lookup_element}, {group, misc}, {group, files},
<a name="150"/>  150:      {group, heavy}, {group, insert_list}, ordered, ordered_match,
<a name="151"/>  151:      interface_equality, fixtable_next, fixtable_iter_bag, fixtable_insert,
<a name="152"/>  152:      rename, rename_unnamed, evil_rename, update_element, update_element_default,
<a name="153"/>  153:      update_counter, evil_update_counter,
<a name="154"/>  154:      update_counter_with_default,
<a name="155"/>  155:      update_counter_with_default_bad_pos,
<a name="156"/>  156:      partly_bound,
<a name="157"/>  157:      update_counter_table_growth,
<a name="158"/>  158:      match_heavy, {group, fold}, member, t_delete_object,
<a name="159"/>  159:      select_bound_chunk,
<a name="160"/>  160:      t_init_table, t_whitebox, t_delete_all_objects,
<a name="161"/>  161:      t_delete_all_objects_trap,
<a name="162"/>  162:      t_test_ms, t_select_delete, t_select_replace,
<a name="163"/>  163:      t_select_replace_next_bug,
<a name="164"/>  164:      t_select_pam_stack_overflow_bug,
<a name="165"/>  165:      t_select_flatmap_term_copy_bug,
<a name="166"/>  166:      t_select_hashmap_term_copy_bug,
<a name="167"/>  167:      t_ets_dets, memory, t_select_reverse, t_bucket_disappears,
<a name="168"/>  168:      t_named_select, select_fixtab_owner_change,
<a name="169"/>  169:      select_fail, t_insert_new, t_repair_continuation,
<a name="170"/>  170:      otp_5340, otp_6338, otp_6842_select_1000, otp_7665,
<a name="171"/>  171:      select_mbuf_trapping,
<a name="172"/>  172:      otp_8732, meta_wb, grow_shrink, grow_pseudo_deleted,
<a name="173"/>  173:      shrink_pseudo_deleted, {group, meta_smp}, smp_insert,
<a name="174"/>  174:      smp_fixed_delete, smp_unfix_fix, smp_select_replace,
<a name="175"/>  175:      smp_ordered_iteration,
<a name="176"/>  176:      smp_select_delete, otp_8166, exit_large_table_owner,
<a name="177"/>  177:      exit_many_large_table_owner, exit_many_tables_owner,
<a name="178"/>  178:      exit_many_many_tables_owner, write_concurrency, heir,
<a name="179"/>  179:      give_away, setopts, bad_table, types,
<a name="180"/>  180:      otp_10182,
<a name="181"/>  181:      otp_9932,
<a name="182"/>  182:      otp_9423,
<a name="183"/>  183:      compress_magic_ref,
<a name="184"/>  184:      ets_all,
<a name="185"/>  185:      massive_ets_all,
<a name="186"/>  186:      take,
<a name="187"/>  187:      whereis_table,
<a name="188"/>  188:      delete_unfix_race,
<a name="189"/>  189:      test_throughput_benchmark,
<a name="190"/>  190:      {group, benchmark},
<a name="191"/>  191:      test_table_size_concurrency,
<a name="192"/>  192:      test_table_memory_concurrency,
<a name="193"/>  193:      test_delete_table_while_size_snapshot,
<a name="194"/>  194:      test_decentralized_counters_setting,
<a name="195"/>  195:      ms_excessive_nesting,
<a name="196"/>  196:      error_info
<a name="197"/>  197:     ].
<a name="198"/>  198: 
<a name="199"/>  199: 
<a name="groups-0"/><a name="200"/>  200: <b>groups</b>() -&gt;
<a name="groups-last_expr"/><a name="201"/>  201:     [{new, [],
<a name="202"/>  202:       [default, setbag, badnew, verybadnew, named, keypos2,
<a name="203"/>  203:        privacy]},
<a name="204"/>  204:      {insert, [], [empty, badinsert]},
<a name="205"/>  205:      {lookup, [], [badlookup, lookup_order]},
<a name="206"/>  206:      {lookup_element, [], [lookup_element_mult, lookup_element_default]},
<a name="207"/>  207:      {delete, [],
<a name="208"/>  208:       [delete_elem, delete_tab, delete_large_tab,
<a name="209"/>  209:        delete_large_named_table, evil_delete, table_leak,
<a name="210"/>  210:        baddelete, match_delete, match_delete3]},
<a name="211"/>  211:      {match, [],
<a name="212"/>  212:       [match1, match2, match_object, match_object2]},
<a name="213"/>  213:      {misc, [],
<a name="214"/>  214:       [misc1, safe_fixtable, info, info_binary_stress, info_whereis_busy, dups, tab2list]},
<a name="215"/>  215:      {files, [],
<a name="216"/>  216:       [tab2file, tab2file2, tabfile_ext1,
<a name="217"/>  217:        tabfile_ext2, tabfile_ext3, tabfile_ext4, badfile]},
<a name="218"/>  218:      {heavy, [],
<a name="219"/>  219:       [heavy_lookup, heavy_lookup_element, heavy_concurrent]},
<a name="220"/>  220:      {fold, [],
<a name="221"/>  221:       [foldl_ordered, foldr_ordered, foldl, foldr,
<a name="222"/>  222:        fold_empty]},
<a name="223"/>  223:      {meta_smp, [],
<a name="224"/>  224:       [meta_lookup_unnamed_read, meta_lookup_unnamed_write,
<a name="225"/>  225:        meta_lookup_named_read, meta_lookup_named_write,
<a name="226"/>  226:        meta_newdel_unnamed, meta_newdel_named]},
<a name="227"/>  227:      {benchmark, [],
<a name="228"/>  228:       [long_throughput_benchmark]},
<a name="229"/>  229:      {insert_list, [],
<a name="230"/>  230:       [t_insert_list, t_insert_list_set, t_insert_list_bag,
<a name="231"/>  231:        t_insert_list_duplicate_bag, t_insert_list_delete_set,
<a name="232"/>  232:        t_insert_list_parallel, t_insert_list_delete_parallel,
<a name="233"/>  233:        t_insert_list_kill_process,
<a name="234"/>  234:        t_insert_list_insert_order_preserved,
<a name="235"/>  235:        insert_trap_delete,
<a name="236"/>  236:        insert_trap_rename]}].
<a name="237"/>  237: 
<a name="init_per_suite-1"/><a name="238"/>  238: <b>init_per_suite</b>(Config) -&gt;
<a name="239"/>  239:     erts_debug:set_internal_state(available_internal_state, true),
<a name="init_per_suite-last_expr"/><a name="240"/>  240: <b>    case erts_debug:set_internal_state</b>(ets_force_trap, true) of
<a name="241"/>  241:         ok -&gt;
<a name="242"/>  242:             [{ets_force_trap, true} | Config];
<a name="243"/>  243:         notsup -&gt;
<a name="244"/>  244:             Config
<a name="245"/>  245:     end.
<a name="246"/>  246: 
<a name="end_per_suite-1"/><a name="247"/>  247: <b>end_per_suite</b>(_Config) -&gt;
<a name="248"/>  248:     stop_spawn_logger(),
<a name="249"/>  249:     erts_debug:set_internal_state(ets_force_trap, false),
<a name="250"/>  250:     catch erts_debug:set_internal_state(available_internal_state, false),
<a name="end_per_suite-last_expr"/><a name="251"/>  251:     ok.
<a name="252"/>  252: 
<a name="init_per_group-2"/><a name="253"/>  253: <b>init_per_group</b>(benchmark, Config) -&gt;
<a name="254"/>  254:     P = self(),
<a name="255"/>  255:     %% Spawn owner of ETS table that is alive until end_per_group is run
<a name="256"/>  256:     EtsProcess =
<a name="257"/>  257:         spawn(
<a name="258"/>  258:           fun()-&gt;
<a name="259"/>  259:                   Tab = ets:new(ets_benchmark_result_summary_tab, [public]),
<a name="260"/>  260:                   P ! {the_table, Tab},
<a name="261"/>  261:                   receive
<a name="262"/>  262:                       kill -&gt; ok
<a name="263"/>  263:                   end
<a name="264"/>  264:           end),
<a name="265"/>  265:     Tab = receive {the_table, T} -&gt; T end,
<a name="266"/>  266:     CounterNames = [nr_of_benchmarks,
<a name="267"/>  267:                     total_throughput,
<a name="268"/>  268:                     nr_of_set_benchmarks,
<a name="269"/>  269:                     total_throughput_set,
<a name="270"/>  270:                     nr_of_ordered_set_benchmarks,
<a name="271"/>  271:                     total_throughput_ordered_set],
<a name="272"/>  272:     lists:foreach(fun(CtrName) -&gt;
<a name="273"/>  273:                           ets:insert(Tab, {CtrName, 0.0})
<a name="274"/>  274:                   end,
<a name="275"/>  275:                   CounterNames),
<a name="276"/>  276:     [{ets_benchmark_result_summary_tab, Tab},
<a name="277"/>  277:      {ets_benchmark_result_summary_tab_process, EtsProcess} | Config];
<a name="278"/>  278: <b>init_per_group</b>(_GroupName, Config) -&gt;
<a name="init_per_group-last_expr"/><a name="279"/>  279:     Config.
<a name="280"/>  280: 
<a name="end_per_group-2"/><a name="281"/>  281: <b>end_per_group</b>(benchmark, Config) -&gt;
<a name="282"/>  282:     T = proplists:get_value(ets_benchmark_result_summary_tab, Config),
<a name="283"/>  283:     EtsProcess = proplists:get_value(ets_benchmark_result_summary_tab_process, Config),
<a name="284"/>  284:     Report =
<a name="285"/>  285:         fun(NOfBenchmarksCtr, TotThroughputCtr, Name) -&gt;
<a name="286"/>  286:                 NBench = ets:lookup_element(T, NOfBenchmarksCtr, 2),
<a name="287"/>  287:                 Average = if
<a name="288"/>  288:                     NBench == 0 -&gt; 0;
<a name="289"/>  289:                     true -&gt; ets:lookup_element(T, TotThroughputCtr, 2) / NBench
<a name="290"/>  290:                 end,
<a name="291"/>  291:                 io:format(&quot;~p ~p~n&quot;, [Name, Average]),
<a name="292"/>  292:                 ct_event:notify(
<a name="293"/>  293:                   #event{name = benchmark_data,
<a name="294"/>  294:                          data = [{suite,&quot;ets_bench&quot;},
<a name="295"/>  295:                                  {name, Name},
<a name="296"/>  296:                                  {value, Average}]})
<a name="297"/>  297:         end,
<a name="298"/>  298:     Report(nr_of_benchmarks,
<a name="299"/>  299:            total_throughput,
<a name="300"/>  300:            &quot;Average Throughput&quot;),
<a name="301"/>  301:     Report(nr_of_set_benchmarks,
<a name="302"/>  302:            total_throughput_set,
<a name="303"/>  303:            &quot;Average Throughput Set&quot;),
<a name="304"/>  304:     Report(nr_of_ordered_set_benchmarks,
<a name="305"/>  305:            total_throughput_ordered_set,
<a name="306"/>  306:            &quot;Average Throughput Ordered Set&quot;),
<a name="307"/>  307:     ets:delete(T),
<a name="308"/>  308:     EtsProcess ! kill,
<a name="309"/>  309:     Config;
<a name="310"/>  310: <b>end_per_group</b>(_GroupName, Config) -&gt;
<a name="end_per_group-last_expr"/><a name="311"/>  311:     Config.
<a name="312"/>  312: 
<a name="313"/>  313: 
<a name="314"/>  314: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="315"/>  315: 
<a name="316"/>  316: <i>%% Test that a disappearing bucket during select of a non-fixed table works.</i>
<a name="t_bucket_disappears-1"/><a name="317"/>  317: <b>t_bucket_disappears</b>(Config) when is_list(Config) -&gt;
<a name="t_bucket_disappears-last_expr"/><a name="318"/>  318: <b>    repeat_for_opts</b>(fun t_bucket_disappears_do/1).
<a name="319"/>  319: 
<a name="t_bucket_disappears_do-1"/><a name="320"/>  320: <b>t_bucket_disappears_do</b>(Opts) -&gt;
<a name="321"/>  321:     EtsMem = etsmem(),
<a name="322"/>  322:     ets_new(abcd, [named_table, public, {keypos, 2} | Opts]),
<a name="323"/>  323:     ets:insert(abcd, {abcd,1,2}),
<a name="324"/>  324:     ets:insert(abcd, {abcd,2,2}),
<a name="325"/>  325:     ets:insert(abcd, {abcd,3,2}),
<a name="326"/>  326:     {_, Cont} = ets:select(abcd, [{{'_', '$1', '_'},
<a name="327"/>  327: 				   [{'&lt;', '$1', {const, 10}}],
<a name="328"/>  328: 				   ['$1']}], 1),
<a name="329"/>  329:     ets:delete(abcd, 2),
<a name="330"/>  330:     ets:select(Cont),
<a name="331"/>  331:     true = ets:delete(abcd),
<a name="t_bucket_disappears_do-last_expr"/><a name="332"/>  332: <b>    verify_etsmem</b>(EtsMem).
<a name="333"/>  333: 
<a name="334"/>  334: <i>%% OTP-21: Test that select/1 fails if named table was deleted and recreated</i>
<a name="335"/>  335: <i>%%         and succeeds if table was renamed.</i>
<a name="t_named_select-1"/><a name="336"/>  336: <b>t_named_select</b>(_Config) -&gt;
<a name="t_named_select-last_expr"/><a name="337"/>  337: <b>    repeat_for_opts</b>(fun t_named_select_do/1).
<a name="338"/>  338: 
<a name="t_named_select_do-1"/><a name="339"/>  339: <b>t_named_select_do</b>(Opts) -&gt;
<a name="340"/>  340:     EtsMem = etsmem(),
<a name="341"/>  341:     T = t_name_tid_select,
<a name="342"/>  342:     ets_new(T, [named_table | Opts]),
<a name="343"/>  343:     ets:insert(T, {1,11}),
<a name="344"/>  344:     ets:insert(T, {2,22}),
<a name="345"/>  345:     ets:insert(T, {3,33}),
<a name="346"/>  346:     MS = [{{'$1', 22}, [], ['$1']}],
<a name="347"/>  347:     {[2], Cont1} = ets:select(T, MS, 1),
<a name="348"/>  348:     ets:delete(T),
<a name="349"/>  349:     {'EXIT',{badarg,_}} = (catch ets:select(Cont1)),
<a name="350"/>  350:     ets_new(T, [named_table | Opts]),
<a name="351"/>  351:     {'EXIT',{badarg,_}} = (catch ets:select(Cont1)),
<a name="352"/>  352: 
<a name="353"/>  353:     true = ets:insert_new(T, {1,22}),
<a name="354"/>  354:     true = ets:insert_new(T, {2,22}),
<a name="355"/>  355:     true = ets:insert_new(T, {4,22}),
<a name="356"/>  356:     {[A,B], Cont2} = ets:select(T, MS, 2),
<a name="357"/>  357:     ets:rename(T, abcd),
<a name="358"/>  358:     {[C], '$end_of_table'} = ets:select(Cont2),
<a name="359"/>  359:     7 = A + B + C,
<a name="360"/>  360: 
<a name="361"/>  361:     true = ets:delete(abcd),
<a name="t_named_select_do-last_expr"/><a name="362"/>  362: <b>    verify_etsmem</b>(EtsMem).
<a name="363"/>  363: 
<a name="364"/>  364: 
<a name="365"/>  365: <i>%% Verify select and friends release fixtab as they should</i>
<a name="366"/>  366: <i>%% even when owneship is changed between traps.</i>
<a name="select_fixtab_owner_change-1"/><a name="367"/>  367: <b>select_fixtab_owner_change</b>(_Config) -&gt;
<a name="368"/>  368:     T = ets:new(xxx, [protected]),
<a name="369"/>  369:     NKeys = 2000,
<a name="370"/>  370:     [ets:insert(T,{K,K band 7}) || K &lt;- lists:seq(1,NKeys)],
<a name="371"/>  371: 
<a name="372"/>  372:     %% Buddy and Papa will ping-pong table ownership between them
<a name="373"/>  373:     %% and the aim is to give Buddy the table when he is
<a name="374"/>  374:     %% in the middle of a yielding select* call.
<a name="375"/>  375:     {Buddy,_} = spawn_opt(fun() -&gt; sfoc_buddy_loop(T, 1, undefined) end,
<a name="376"/>  376:                           [link,monitor]),
<a name="377"/>  377: 
<a name="378"/>  378:     sfoc_papa_loop(T, Buddy),
<a name="379"/>  379: 
<a name="380"/>  380:     receive {'DOWN', _, process, Buddy, _} -&gt; ok end,
<a name="381"/>  381:     ets:delete(T),
<a name="select_fixtab_owner_change-last_expr"/><a name="382"/>  382:     ok.
<a name="383"/>  383: 
<a name="sfoc_buddy_loop-3"/><a name="384"/>  384: <b>sfoc_buddy_loop</b>(T, I, State0) -&gt;
<a name="sfoc_buddy_loop-last_expr"/><a name="385"/>  385:     receive
<a name="386"/>  386:         {'ETS-TRANSFER', T, Papa, _} -&gt;
<a name="387"/>  387:             ets:give_away(T, Papa, State0),
<a name="388"/>  388:             case State0 of
<a name="389"/>  389:                 done -&gt;
<a name="390"/>  390:                     ok;
<a name="391"/>  391:                 _ -&gt;
<a name="392"/>  392:                     State1 = sfoc_traverse(T, I, State0),
<a name="393"/>  393:                     %% Verify no fixation left
<a name="394"/>  394:                     {I, false} = {I, ets:info(T, safe_fixed_monotonic_time)},
<a name="395"/>  395:                     sfoc_buddy_loop(T, I+1, State1)
<a name="396"/>  396:             end
<a name="397"/>  397:     end.
<a name="398"/>  398: 
<a name="sfoc_papa_loop-2"/><a name="399"/>  399: <b>sfoc_papa_loop</b>(T, Buddy) -&gt;
<a name="400"/>  400:     ets:give_away(T, Buddy, &quot;Catch!&quot;),
<a name="sfoc_papa_loop-last_expr"/><a name="401"/>  401:     receive
<a name="402"/>  402:         {'ETS-TRANSFER', T, Buddy, State} -&gt;
<a name="403"/>  403:             case State of
<a name="404"/>  404:                 done -&gt;
<a name="405"/>  405:                     ok;
<a name="406"/>  406:                 _ -&gt;
<a name="407"/>  407:                     sfoc_papa_loop(T, Buddy)
<a name="408"/>  408:             end
<a name="409"/>  409:     end.
<a name="410"/>  410: 
<a name="sfoc_traverse-3"/><a name="411"/>  411: <b>sfoc_traverse</b>(T, 1, S) -&gt;
<a name="412"/>  412:     ets:select(T, [{{'$1',7}, [], ['$1']}]), S;
<a name="413"/>  413: <b>sfoc_traverse</b>(T, 2, S) -&gt;
<a name="414"/>  414:     0 = ets:select_count(T, [{{'$1',7}, [], [false]}]), S;
<a name="415"/>  415: <b>sfoc_traverse</b>(T, 3, _) -&gt;
<a name="416"/>  416:     Limit = ets:info(T, size) div 2,
<a name="417"/>  417:     {_, Continuation} = ets:select(T, [{{'$1',7}, [], ['$1']}],
<a name="418"/>  418:                                    Limit),
<a name="419"/>  419:     Continuation;
<a name="420"/>  420: <b>sfoc_traverse</b>(_T, 4, Continuation) -&gt;
<a name="421"/>  421:     _ = ets:select(Continuation),
<a name="sfoc_traverse-last_expr"/><a name="422"/>  422:     done.
<a name="423"/>  423: 
<a name="424"/>  424: <i>%% Check ets:match_spec_run/2.</i>
<a name="t_match_spec_run-1"/><a name="425"/>  425: <b>t_match_spec_run</b>(Config) when is_list(Config) -&gt;
<a name="426"/>  426:     ct:timetrap({minutes,30}), %% valgrind needs a lot
<a name="427"/>  427:     init_externals(),
<a name="428"/>  428:     EtsMem = etsmem(),
<a name="429"/>  429: 
<a name="430"/>  430:     t_match_spec_run_test([{1},{2},{3}],
<a name="431"/>  431: 			  [{{'$1'},[{'&gt;','$1',1}],['$1']}],
<a name="432"/>  432: 			  [2,3]),
<a name="433"/>  433: 
<a name="434"/>  434:     Huge = [{X} || X &lt;- lists:seq(1,2500)],
<a name="435"/>  435:     L = lists:seq(2476,2500),
<a name="436"/>  436:     t_match_spec_run_test(Huge, [{{'$1'},[{'&gt;','$1',2475}],['$1']}], L),
<a name="437"/>  437: 
<a name="438"/>  438:     L2 = [{X*16#FFFFFFF} || X &lt;- L],
<a name="439"/>  439:     t_match_spec_run_test(Huge,
<a name="440"/>  440: 			  [{{'$1'}, [{'&gt;','$1',2475}], [{{{'*','$1',16#FFFFFFF}}}]}],
<a name="441"/>  441: 			  L2),
<a name="442"/>  442: 
<a name="443"/>  443:     t_match_spec_run_test(Huge, [{{'$1'}, [{'=:=',{'rem','$1',500},0}], ['$1']}],
<a name="444"/>  444: 			  [500,1000,1500,2000,2500]),
<a name="445"/>  445: 
<a name="446"/>  446:     %% More matching fun with several match clauses and guards,
<a name="447"/>  447:     %% applied to a variety of terms.
<a name="448"/>  448:     Fun = fun(Term) -&gt;
<a name="449"/>  449: 		  CTerm = {const, Term},
<a name="450"/>  450: 
<a name="451"/>  451: 		  N_List = [{Term, &quot;0&quot;, &quot;v-element&quot;},
<a name="452"/>  452: 			    {&quot;=hidden_node&quot;, &quot;0&quot;, Term},
<a name="453"/>  453: 			    {&quot;0&quot;, Term, Term},
<a name="454"/>  454: 			    {&quot;something&quot;, Term, &quot;something else&quot;},
<a name="455"/>  455: 			    {&quot;guard and res&quot;, Term, 872346},
<a name="456"/>  456: 			    {Term, {'and',Term,'again'}, 3.14},
<a name="457"/>  457: 			    {Term, {'and',Term,'again'}, &quot;m&amp;g&quot;},
<a name="458"/>  458: 			    {Term, {'and',Term,'again'}, &quot;m&amp;g&amp;r&quot;},
<a name="459"/>  459: 			    {[{second,Term}, 'and', &quot;tail&quot;], Term, ['and',&quot;tail&quot;]}],
<a name="460"/>  460: 
<a name="461"/>  461: 		  N_MS = [{{'$1','$2','$3'},
<a name="462"/>  462: 			   [{'=:=','$1',CTerm}, {'=:=','$2',{const,&quot;0&quot;}}],
<a name="463"/>  463: 			   [{{&quot;Guard only for $1&quot;,'$3'}}]},
<a name="464"/>  464: 
<a name="465"/>  465: 			  {{'$3','$1','$4'},
<a name="466"/>  466: 			   [{'=:=','$3',&quot;=hidden_node&quot;}, {'=:=','$1',{const,&quot;0&quot;}}],
<a name="467"/>  467: 			   [{{&quot;Result only for $4&quot;,'$4'}}]},
<a name="468"/>  468: 
<a name="469"/>  469: 			  {{'$2','$1','$1'},
<a name="470"/>  470: 			   [{'=:=','$2',{const,&quot;0&quot;}}],
<a name="471"/>  471: 			   [{{&quot;Match only for $1&quot;,'$2'}}]},
<a name="472"/>  472: 
<a name="473"/>  473: 			  {{'$2',Term,['$3'|'_']},
<a name="474"/>  474: 			   [{is_list,'$2'},{'=:=','$3',$s}],
<a name="475"/>  475: 			   [{{&quot;Matching term&quot;,'$2'}}]},
<a name="476"/>  476: 
<a name="477"/>  477: 			  {{'$1','$2',872346},
<a name="478"/>  478: 			   [{'=:=','$2',CTerm}, {is_list,'$1'}],
<a name="479"/>  479: 			   [{{&quot;Guard and result&quot;,'$2'}}]},
<a name="480"/>  480: 
<a name="481"/>  481: 			  {{'$1', {'and','$1','again'}, '$2'},
<a name="482"/>  482: 			   [{is_float,'$2'}],
<a name="483"/>  483: 			   [{{&quot;Match and result&quot;,'$1'}}]},
<a name="484"/>  484: 
<a name="485"/>  485: 			  {{'$1', {'and','$1','again'}, '$2'},
<a name="486"/>  486: 			   [{'=:=','$1',CTerm}, {'=:=', '$2', &quot;m&amp;g&quot;}],
<a name="487"/>  487: 			   [{{&quot;Match and guard&quot;,'$2'}}]},
<a name="488"/>  488: 
<a name="489"/>  489: 			  {{'$1', {'and','$1','again'}, &quot;m&amp;g&amp;r&quot;},
<a name="490"/>  490: 			   [{'=:=','$1',CTerm}],
<a name="491"/>  491: 			   [{{&quot;Match, guard and result&quot;,'$1'}}]},
<a name="492"/>  492: 
<a name="493"/>  493: 			  {{'$1', '$2', '$3'},
<a name="494"/>  494: 			   [{'=:=','$1',[{{second,'$2'}} | '$3']}],
<a name="495"/>  495: 			   [{{&quot;Building guard&quot;}}]}
<a name="496"/>  496: 			 ],
<a name="497"/>  497: 
<a name="498"/>  498: 		  N_Result = [{&quot;Guard only for $1&quot;, &quot;v-element&quot;},
<a name="499"/>  499: 			      {&quot;Result only for $4&quot;, Term},
<a name="500"/>  500: 			      {&quot;Match only for $1&quot;, &quot;0&quot;},
<a name="501"/>  501: 			      {&quot;Matching term&quot;,&quot;something&quot;},
<a name="502"/>  502: 			      {&quot;Guard and result&quot;,Term},
<a name="503"/>  503: 			      {&quot;Match and result&quot;,Term},
<a name="504"/>  504: 			      {&quot;Match and guard&quot;,&quot;m&amp;g&quot;},
<a name="505"/>  505: 			      {&quot;Match, guard and result&quot;,Term},
<a name="506"/>  506: 			      {&quot;Building guard&quot;}],
<a name="507"/>  507: 
<a name="508"/>  508: 		  F = fun(N_MS_Perm) -&gt;
<a name="509"/>  509: 			      t_match_spec_run_test(N_List, N_MS_Perm, N_Result)
<a name="510"/>  510: 		      end,
<a name="511"/>  511: 		  repeat_for_permutations(F, N_MS)
<a name="512"/>  512: 	  end,
<a name="513"/>  513:     test_terms(Fun, skip_refc_check),
<a name="514"/>  514: 
<a name="t_match_spec_run-last_expr"/><a name="515"/>  515: <b>    verify_etsmem</b>(EtsMem).
<a name="516"/>  516: 
<a name="t_match_spec_run_test-3"/><a name="517"/>  517: <b>t_match_spec_run_test</b>(List, MS, Result) -&gt;
<a name="518"/>  518: 
<a name="519"/>  519:     %%io:format(&quot;ms = ~p\n&quot;,[MS]),
<a name="520"/>  520: 
<a name="521"/>  521:     ?m(Result, ets:match_spec_run(List, ets:match_spec_compile(MS))),
<a name="522"/>  522: 
<a name="523"/>  523:     %% Check that ets:select agree
<a name="524"/>  524:     Tab = ets:new(xxx, [bag]),
<a name="525"/>  525:     ets:insert(Tab, List),
<a name="526"/>  526:     SRes = lists:sort(Result),
<a name="527"/>  527:     ?m(SRes, lists:sort(ets:select(Tab, MS))),
<a name="528"/>  528:     ets:delete(Tab),
<a name="529"/>  529: 
<a name="530"/>  530:     %% Check that tracing agree
<a name="531"/>  531:     Self = self(),
<a name="532"/>  532:     {Tracee, MonRef} = my_spawn_monitor(fun() -&gt; ms_tracee(Self, List) end),
<a name="533"/>  533:     receive {Tracee, ready} -&gt; ok end,
<a name="534"/>  534: 
<a name="535"/>  535:     MST = lists:map(fun(Clause) -&gt; ms_clause_ets_to_trace(Clause) end, MS),
<a name="536"/>  536: 
<a name="537"/>  537:     %%io:format(&quot;MS = ~p\nMST= ~p\n&quot;,[MS,MST]),
<a name="538"/>  538: 
<a name="539"/>  539:     erlang:trace_pattern({?MODULE,ms_tracee_dummy,'_'}, MST , [local]),
<a name="540"/>  540:     erlang:trace(Tracee, true, [call]),
<a name="541"/>  541:     Tracee ! start,
<a name="542"/>  542:     TRes = ms_tracer_collect(Tracee, MonRef, []),
<a name="543"/>  543:     case TRes of
<a name="544"/>  544: 	SRes -&gt; ok;
<a name="545"/>  545: 	_ -&gt;
<a name="546"/>  546: 	    io:format(&quot;TRACE MATCH FAILED\n&quot;),
<a name="547"/>  547: 	    io:format(&quot;Input = ~p\nMST = ~p\nExpected = ~p\nGot = ~p\n&quot;, [List, MST, SRes, TRes]),
<a name="548"/>  548: 	    ct:fail(&quot;TRACE MATCH FAILED&quot;)
<a name="549"/>  549:     end,
<a name="t_match_spec_run_test-last_expr"/><a name="550"/>  550:     ok.
<a name="551"/>  551: 
<a name="552"/>  552: 
<a name="553"/>  553: 
<a name="ms_tracer_collect-3"/><a name="554"/>  554: <b>ms_tracer_collect</b>(Tracee, Ref, Acc) -&gt;
<a name="ms_tracer_collect-last_expr"/><a name="555"/>  555:     receive
<a name="556"/>  556: 	{trace, Tracee, call, _Args, [Msg]} -&gt;
<a name="557"/>  557: 	    ms_tracer_collect(Tracee, Ref, [Msg | Acc]);
<a name="558"/>  558: 
<a name="559"/>  559: 	{'DOWN', Ref, process, Tracee, _} -&gt;
<a name="560"/>  560: 	    TDRef = erlang:trace_delivered(Tracee),
<a name="561"/>  561: 	    ms_tracer_collect(Tracee, TDRef, Acc);
<a name="562"/>  562: 
<a name="563"/>  563: 	{trace_delivered, Tracee, Ref} -&gt;
<a name="564"/>  564: 	    lists:sort(Acc);
<a name="565"/>  565: 
<a name="566"/>  566: 	Other -&gt;
<a name="567"/>  567: 	    io:format(&quot;Unexpected message = ~p\n&quot;, [Other]),
<a name="568"/>  568: 	    ct:fail(&quot;Unexpected tracer msg&quot;)
<a name="569"/>  569:     end.
<a name="570"/>  570: 
<a name="571"/>  571: 
<a name="ms_tracee-2"/><a name="572"/>  572: <b>ms_tracee</b>(Parent, CallArgList) -&gt;
<a name="573"/>  573:     Parent ! {self(), ready},
<a name="574"/>  574:     receive start -&gt; ok end,
<a name="575"/>  575:     F = fun({A1}) -&gt;
<a name="576"/>  576:                 ms_tracee_dummy(A1);
<a name="577"/>  577:            ({A1,A2}) -&gt;
<a name="578"/>  578:                    ms_tracee_dummy(A1, A2);
<a name="579"/>  579:            ({A1,A2,A3}) -&gt;
<a name="580"/>  580:                 ms_tracee_dummy(A1, A2, A3);
<a name="581"/>  581:            ({A1,A2,A3,A4}) -&gt;
<a name="582"/>  582:                 ms_tracee_dummy(A1, A2, A3, A4)
<a name="583"/>  583:         end,
<a name="ms_tracee-last_expr"/><a name="584"/>  584: <b>    lists:foreach</b>(F, CallArgList).
<a name="585"/>  585: 
<a name="ms_tracee_dummy-1"/><a name="ms_tracee_dummy-last_expr"/><a name="586"/>  586: <b>ms_tracee_dummy</b>(_) -&gt; ok.
<a name="ms_tracee_dummy-2"/><a name="ms_tracee_dummy-last_expr"/><a name="587"/>  587: <b>ms_tracee_dummy</b>(_,_) -&gt; ok.
<a name="ms_tracee_dummy-3"/><a name="ms_tracee_dummy-last_expr"/><a name="588"/>  588: <b>ms_tracee_dummy</b>(_,_,_) -&gt; ok.
<a name="ms_tracee_dummy-4"/><a name="ms_tracee_dummy-last_expr"/><a name="589"/>  589: <b>ms_tracee_dummy</b>(_,_,_,_) -&gt; ok.
<a name="590"/>  590: 
<a name="ms_clause_ets_to_trace-1"/><a name="591"/>  591: <b>ms_clause_ets_to_trace</b>({Head, Guard, Body}) -&gt;
<a name="ms_clause_ets_to_trace-last_expr"/><a name="592"/>  592: <b>    {tuple_to_list</b>(Head), Guard, [{message, Body}]}.
<a name="593"/>  593: 
<a name="assert_eq-2"/><a name="594"/>  594: <b>assert_eq</b>(A,A) -&gt; ok;
<a name="595"/>  595: <b>assert_eq</b>(A,B) -&gt;
<a name="596"/>  596:     io:format(&quot;FAILED MATCH:\n~p\n =/=\n~p\n&quot;,[A,B]),
<a name="assert_eq-last_expr"/><a name="597"/>  597: <b>    ct:fail</b>(&quot;assert_eq failed&quot;).
<a name="598"/>  598: 
<a name="599"/>  599: 
<a name="600"/>  600: <i>%% Test ets:repair_continuation/2.</i>
<a name="t_repair_continuation-1"/><a name="601"/>  601: <b>t_repair_continuation</b>(Config) when is_list(Config) -&gt;
<a name="t_repair_continuation-last_expr"/><a name="602"/>  602: <b>    repeat_for_opts</b>(fun t_repair_continuation_do/1).
<a name="603"/>  603: 
<a name="604"/>  604: 
<a name="t_repair_continuation_do-1"/><a name="605"/>  605: <b>t_repair_continuation_do</b>(OptsIn) -&gt;
<a name="606"/>  606:     EtsMem = etsmem(),
<a name="607"/>  607:     MS = [{'_',[],[true]}],
<a name="608"/>  608:     MS2 = [{{{'$1','_'},'_'},[],['$1']}],
<a name="609"/>  609:     run_if_valid_opts(
<a name="610"/>  610:       [ordered_set|OptsIn],
<a name="611"/>  611:       fun(Opts) -&gt;
<a name="612"/>  612: 	     T = ets_new(x, Opts),
<a name="613"/>  613: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt; ets:insert(T,{N,N}), F(N-1,F) end,
<a name="614"/>  614: 	     F(1000,F),
<a name="615"/>  615: 	     {_,C} = ets:select(T,MS,5),
<a name="616"/>  616: 	     C2 = erlang:setelement(5,C,&lt;&lt;&gt;&gt;),
<a name="617"/>  617: 	     {'EXIT',{badarg,_}} = (catch ets:select(C2)),
<a name="618"/>  618: 	     C3 = ets:repair_continuation(C2,MS),
<a name="619"/>  619: 	     {[true,true,true,true,true],_} = ets:select(C3),
<a name="620"/>  620: 	     {[true,true,true,true,true],_} = ets:select(C),
<a name="621"/>  621: 	     true = ets:delete(T)
<a name="622"/>  622:       end),
<a name="623"/>  623:     run_if_valid_opts(
<a name="624"/>  624:       [ordered_set|OptsIn],
<a name="625"/>  625:       fun(Opts) -&gt;
<a name="626"/>  626: 	     T = ets_new(x, Opts),
<a name="627"/>  627: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt; ets:insert(T,{N,N}), F(N-1,F) end,
<a name="628"/>  628: 	     F(1000,F),
<a name="629"/>  629: 	     {_,C} = ets:select(T,MS,1001),
<a name="630"/>  630: 	     C = '$end_of_table',
<a name="631"/>  631: 	     C3 = ets:repair_continuation(C,MS),
<a name="632"/>  632: 	     '$end_of_table' = ets:select(C3),
<a name="633"/>  633: 	     '$end_of_table' = ets:select(C),
<a name="634"/>  634: 	     true = ets:delete(T)
<a name="635"/>  635:       end),
<a name="636"/>  636: 
<a name="637"/>  637:     run_if_valid_opts(
<a name="638"/>  638:       [ordered_set|OptsIn],
<a name="639"/>  639:       fun(Opts) -&gt;
<a name="640"/>  640: 	     T = ets_new(x, Opts),
<a name="641"/>  641: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt;
<a name="642"/>  642: 			 ets:insert(T,{integer_to_list(N),N}),
<a name="643"/>  643: 			 F(N-1,F)
<a name="644"/>  644: 		 end,
<a name="645"/>  645: 	     F(1000,F),
<a name="646"/>  646: 	     {_,C} = ets:select(T,MS,5),
<a name="647"/>  647: 	     C2 = erlang:setelement(5,C,&lt;&lt;&gt;&gt;),
<a name="648"/>  648: 	     {'EXIT',{badarg,_}} = (catch ets:select(C2)),
<a name="649"/>  649: 	     C3 = ets:repair_continuation(C2,MS),
<a name="650"/>  650: 	     {[true,true,true,true,true],_} = ets:select(C3),
<a name="651"/>  651: 	     {[true,true,true,true,true],_} = ets:select(C),
<a name="652"/>  652: 	     true = ets:delete(T)
<a name="653"/>  653:       end),
<a name="654"/>  654:     run_if_valid_opts(
<a name="655"/>  655:       [ordered_set|OptsIn],
<a name="656"/>  656:       fun(Opts) -&gt;
<a name="657"/>  657: 	     T = ets_new(x, Opts),
<a name="658"/>  658: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt;
<a name="659"/>  659: 			 ets:insert(T,{{integer_to_list(N),N},N}),
<a name="660"/>  660: 			 F(N-1,F)
<a name="661"/>  661: 		 end,
<a name="662"/>  662: 	     F(1000,F),
<a name="663"/>  663: 	     {_,C} = ets:select(T,MS2,5),
<a name="664"/>  664: 	     C2 = erlang:setelement(5,C,&lt;&lt;&gt;&gt;),
<a name="665"/>  665: 	     {'EXIT',{badarg,_}} = (catch ets:select(C2)),
<a name="666"/>  666: 	     C3 = ets:repair_continuation(C2,MS2),
<a name="667"/>  667: 	     {[_,_,_,_,_],_} = ets:select(C3),
<a name="668"/>  668: 	     {[_,_,_,_,_],_} = ets:select(C),
<a name="669"/>  669: 	     true = ets:delete(T)
<a name="670"/>  670:       end),
<a name="671"/>  671: 
<a name="672"/>  672:     (fun() -&gt;
<a name="673"/>  673: 	     T = ets_new(x,[set|OptsIn]),
<a name="674"/>  674: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt;
<a name="675"/>  675: 			 ets:insert(T,{N,N}),
<a name="676"/>  676: 			 F(N-1,F)
<a name="677"/>  677: 		 end,
<a name="678"/>  678: 	     F(1000,F),
<a name="679"/>  679: 	     {_,C} = ets:select(T,MS,5),
<a name="680"/>  680: 	     C2 = erlang:setelement(4,C,&lt;&lt;&gt;&gt;),
<a name="681"/>  681: 	     {'EXIT',{badarg,_}} = (catch ets:select(C2)),
<a name="682"/>  682: 	     C3 = ets:repair_continuation(C2,MS),
<a name="683"/>  683: 	     {[true,true,true,true,true],_} = ets:select(C3),
<a name="684"/>  684: 	     {[true,true,true,true,true],_} = ets:select(C),
<a name="685"/>  685: 	     true = ets:delete(T)
<a name="686"/>  686:      end)(),
<a name="687"/>  687:     (fun() -&gt;
<a name="688"/>  688: 	     T = ets_new(x,[set|OptsIn]),
<a name="689"/>  689: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt;
<a name="690"/>  690: 			 ets:insert(T,{integer_to_list(N),N}),
<a name="691"/>  691: 			 F(N-1,F)
<a name="692"/>  692: 		 end,
<a name="693"/>  693: 	     F(1000,F),
<a name="694"/>  694: 	     {_,C} = ets:select(T,MS,5),
<a name="695"/>  695: 	     C2 = erlang:setelement(4,C,&lt;&lt;&gt;&gt;),
<a name="696"/>  696: 	     {'EXIT',{badarg,_}} = (catch ets:select(C2)),
<a name="697"/>  697: 	     C3 = ets:repair_continuation(C2,MS),
<a name="698"/>  698: 	     {[true,true,true,true,true],_} = ets:select(C3),
<a name="699"/>  699: 	     {[true,true,true,true,true],_} = ets:select(C),
<a name="700"/>  700: 	     true = ets:delete(T)
<a name="701"/>  701:      end)(),
<a name="702"/>  702:     (fun() -&gt;
<a name="703"/>  703: 	     T = ets_new(x,[bag|OptsIn]),
<a name="704"/>  704: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt;
<a name="705"/>  705: 			 ets:insert(T,{integer_to_list(N),N}),
<a name="706"/>  706: 			 F(N-1,F)
<a name="707"/>  707: 		 end,
<a name="708"/>  708: 	     F(1000,F),
<a name="709"/>  709: 	     {_,C} = ets:select(T,MS,5),
<a name="710"/>  710: 	     C2 = erlang:setelement(4,C,&lt;&lt;&gt;&gt;),
<a name="711"/>  711: 	     {'EXIT',{badarg,_}} = (catch ets:select(C2)),
<a name="712"/>  712: 	     C3 = ets:repair_continuation(C2,MS),
<a name="713"/>  713: 	     {[true,true,true,true,true],_} = ets:select(C3),
<a name="714"/>  714: 	     {[true,true,true,true,true],_} = ets:select(C),
<a name="715"/>  715: 	     true = ets:delete(T)
<a name="716"/>  716:      end)(),
<a name="717"/>  717:     (fun() -&gt;
<a name="718"/>  718: 	     T = ets_new(x,[duplicate_bag|OptsIn]),
<a name="719"/>  719: 	     F = fun(0,_)-&gt;ok;(N,F) -&gt;
<a name="720"/>  720: 			 ets:insert(T,{integer_to_list(N),N}),
<a name="721"/>  721: 			 F(N-1,F)
<a name="722"/>  722: 		 end,
<a name="723"/>  723: 	     F(1000,F),
<a name="724"/>  724: 	     {_,C} = ets:select(T,MS,5),
<a name="725"/>  725: 	     C2 = erlang:setelement(4,C,&lt;&lt;&gt;&gt;),
<a name="726"/>  726: 	     {'EXIT',{badarg,_}} = (catch ets:select(C2)),
<a name="727"/>  727: 	     C3 = ets:repair_continuation(C2,MS),
<a name="728"/>  728: 	     {[true,true,true,true,true],_} = ets:select(C3),
<a name="729"/>  729: 	     {[true,true,true,true,true],_} = ets:select(C),
<a name="730"/>  730: 	     true = ets:delete(T)
<a name="731"/>  731:      end)(),
<a name="732"/>  732:     false = ets:is_compiled_ms(&lt;&lt;&gt;&gt;),
<a name="733"/>  733:     true = ets:is_compiled_ms(ets:match_spec_compile(MS)),
<a name="t_repair_continuation_do-last_expr"/><a name="734"/>  734: <b>    verify_etsmem</b>(EtsMem).
<a name="735"/>  735: 
<a name="736"/>  736: 
<a name="737"/>  737: <i>%% Test correct default vaules of a new ets table.</i>
<a name="default-1"/><a name="738"/>  738: <b>default</b>(Config) when is_list(Config) -&gt;
<a name="739"/>  739:     %% Default should be set,protected
<a name="740"/>  740:     EtsMem = etsmem(),
<a name="741"/>  741:     Def = ets_new(def,[]),
<a name="742"/>  742:     set = ets:info(Def,type),
<a name="743"/>  743:     protected = ets:info(Def,protection),
<a name="744"/>  744:     Compressed = erlang:system_info(ets_always_compress),
<a name="745"/>  745:     Compressed = ets:info(Def,compressed),
<a name="746"/>  746:     Self = self(),
<a name="747"/>  747:     Self = ets:info(Def,owner),
<a name="748"/>  748:     none = ets:info(Def, heir),
<a name="749"/>  749:     false = ets:info(Def,named_table),
<a name="750"/>  750:     ets:delete(Def),
<a name="default-last_expr"/><a name="751"/>  751: <b>    verify_etsmem</b>(EtsMem).
<a name="752"/>  752: 
<a name="753"/>  753: <i>%% Test that select fails even if nothing can match.</i>
<a name="select_fail-1"/><a name="754"/>  754: <b>select_fail</b>(Config) when is_list(Config) -&gt;
<a name="755"/>  755:     EtsMem = etsmem(),
<a name="756"/>  756:     repeat_for_opts(fun select_fail_do/1,
<a name="757"/>  757:                     [all_types,write_concurrency]),
<a name="select_fail-last_expr"/><a name="758"/>  758: <b>    verify_etsmem</b>(EtsMem).
<a name="759"/>  759: 
<a name="select_fail_do-1"/><a name="760"/>  760: <b>select_fail_do</b>(Opts) -&gt;
<a name="761"/>  761:     T = ets_new(x,Opts),
<a name="762"/>  762:     ets:insert(T,{a,a}),
<a name="763"/>  763:     case (catch
<a name="764"/>  764: 	      ets:select(T,[{{a,'_'},[],[{snuffla}]}])) of
<a name="765"/>  765: 	{'EXIT',{badarg,_}} -&gt;
<a name="766"/>  766: 	    ok;
<a name="767"/>  767: 	Else0 -&gt;
<a name="768"/>  768: 	    exit({type,ets:info(T,type),
<a name="769"/>  769: 		  expected,'EXIT',got,Else0})
<a name="770"/>  770:     end,
<a name="771"/>  771:     case (catch
<a name="772"/>  772: 	      ets:select(T,[{{b,'_'},[],[{snuffla}]}])) of
<a name="773"/>  773: 	{'EXIT',{badarg,_}} -&gt;
<a name="774"/>  774: 	    ok;
<a name="775"/>  775: 	Else1 -&gt;
<a name="776"/>  776: 	    exit({type,ets:info(T,type),
<a name="777"/>  777: 		  expected,'EXIT',got,Else1})
<a name="778"/>  778:     end,
<a name="select_fail_do-last_expr"/><a name="779"/>  779: <b>    ets:delete</b>(T).
<a name="780"/>  780: 
<a name="781"/>  781: 
<a name="782"/>  782: <b>-define</b>(S(T),ets:info(T,memory)).
<a name="783"/>  783: 
<a name="784"/>  784: <i>%% Whitebox test of ets:info(X, memory).</i>
<a name="memory-1"/><a name="785"/>  785: <b>memory</b>(Config) when is_list(Config) -&gt;
<a name="786"/>  786:     ok = chk_normal_tab_struct_size(),
<a name="787"/>  787:     repeat_for_opts(fun memory_do/1, [compressed]),
<a name="memory-last_expr"/><a name="788"/>  788: <b>    catch erts_debug:set_internal_state</b>(available_internal_state, false).
<a name="789"/>  789: 
<a name="memory_do-1"/><a name="790"/>  790: <b>memory_do</b>(Opts) -&gt;
<a name="791"/>  791:     L = [T1,T2,T3,T4] = fill_sets_int(1000,Opts),
<a name="792"/>  792:     XR1 = case mem_mode(T1) of
<a name="793"/>  793: 	      {normal,_} -&gt;     {13836, 15346, 15346, 15346+6};
<a name="794"/>  794: 	      {compressed,4} -&gt; {11041, 12551, 12551, 12551+1};
<a name="795"/>  795: 	      {compressed,8} -&gt; {10050, 11560, 11560, 11560}
<a name="796"/>  796: 	  end,
<a name="797"/>  797:     XRes1 = adjust_xmem(L, XR1, 1),
<a name="798"/>  798:     Res1 = {?S(T1),?S(T2),?S(T3),?S(T4)},
<a name="799"/>  799:     lists:foreach(fun(T) -&gt;
<a name="800"/>  800: 			  Before = ets:info(T,size),
<a name="801"/>  801: 			  Key = 2, %894, %%ets:first(T),
<a name="802"/>  802: 			  Objs = ets:lookup(T,Key),
<a name="803"/>  803: 			  ets:delete(T,Key),
<a name="804"/>  804: 			  io:format(&quot;deleted key ~p from ~p changed size ~p to ~p: ~p\n&quot;,
<a name="805"/>  805: 				    [Key, ets:info(T,type), Before, ets:info(T,size), Objs])
<a name="806"/>  806: 		  end,
<a name="807"/>  807: 		  L),
<a name="808"/>  808:     XR2 = case mem_mode(T1) of
<a name="809"/>  809: 	      {normal,_} -&gt;     {13826, 15337, 15337-9, 15337-3};
<a name="810"/>  810: 	      {compressed,4} -&gt; {11031, 12542, 12542-9, 12542-8};
<a name="811"/>  811: 	      {compressed,8} -&gt; {10040, 11551, 11551-9, 11551-9}
<a name="812"/>  812: 	  end,
<a name="813"/>  813:     XRes2 = adjust_xmem(L, XR2, 1),
<a name="814"/>  814:     Res2 = {?S(T1),?S(T2),?S(T3),?S(T4)},
<a name="815"/>  815:     lists:foreach(fun(T) -&gt;
<a name="816"/>  816: 			  Before = ets:info(T,size),
<a name="817"/>  817: 			  Key = 4, %802, %ets:first(T),
<a name="818"/>  818: 			  Objs = ets:lookup(T,Key),
<a name="819"/>  819: 			  ets:match_delete(T,{Key,'_'}),
<a name="820"/>  820: 			  io:format(&quot;match_deleted key ~p from ~p changed size ~p to ~p: ~p\n&quot;,
<a name="821"/>  821: 				    [Key, ets:info(T,type), Before, ets:info(T,size), Objs])
<a name="822"/>  822: 		  end,
<a name="823"/>  823: 		  L),
<a name="824"/>  824:     XR3 = case mem_mode(T1) of
<a name="825"/>  825: 	      {normal,_} -&gt;     {13816, 15328, 15328-18, 15328-12};
<a name="826"/>  826: 	      {compressed,4} -&gt; {11021, 12533, 12533-18, 12533-17};
<a name="827"/>  827: 	      {compressed,8} -&gt; {10030, 11542, 11542-18, 11542-18}
<a name="828"/>  828: 	  end,
<a name="829"/>  829:     XRes3 = adjust_xmem(L, XR3, 1),
<a name="830"/>  830:     Res3 = {?S(T1),?S(T2),?S(T3),?S(T4)},
<a name="831"/>  831:     lists:foreach(fun(T) -&gt;
<a name="832"/>  832: 			  ets:delete_all_objects(T)
<a name="833"/>  833: 		  end,
<a name="834"/>  834: 		  L),
<a name="835"/>  835:     XRes4 = adjust_xmem(L, {50, 256, 256, 256}, 0),
<a name="836"/>  836:     Res4 = {?S(T1),?S(T2),?S(T3),?S(T4)},
<a name="837"/>  837:     lists:foreach(fun(T) -&gt;
<a name="838"/>  838: 			  ets:delete(T)
<a name="839"/>  839: 		  end,
<a name="840"/>  840: 		  L),
<a name="841"/>  841:     L2 =  [T11,T12,T13,T14] = fill_sets_int(1000),
<a name="842"/>  842:     lists:foreach(fun(T) -&gt;
<a name="843"/>  843: 			  ets:select_delete(T,[{'_',[],[true]}])
<a name="844"/>  844: 		  end,
<a name="845"/>  845: 		  L2),
<a name="846"/>  846:     XRes5 = adjust_xmem(L2, {50, 256, 256, 256}, 0),
<a name="847"/>  847:     Res5 = {?S(T11),?S(T12),?S(T13),?S(T14)},
<a name="848"/>  848:     io:format(&quot;XRes1 = ~p~n&quot;
<a name="849"/>  849: 	      &quot; Res1 = ~p~n~n&quot;
<a name="850"/>  850: 	      &quot;XRes2 = ~p~n&quot;
<a name="851"/>  851: 	      &quot; Res2 = ~p~n~n&quot;
<a name="852"/>  852: 	      &quot;XRes3 = ~p~n&quot;
<a name="853"/>  853: 	      &quot; Res3 = ~p~n~n&quot;
<a name="854"/>  854: 	      &quot;XRes4 = ~p~n&quot;
<a name="855"/>  855: 	      &quot; Res4 = ~p~n~n&quot;
<a name="856"/>  856: 	      &quot;XRes5 = ~p~n&quot;
<a name="857"/>  857: 	      &quot; Res5 = ~p~n~n&quot;,
<a name="858"/>  858: 	      [XRes1, Res1,
<a name="859"/>  859: 	       XRes2, Res2,
<a name="860"/>  860: 	       XRes3, Res3,
<a name="861"/>  861: 	       XRes4, Res4,
<a name="862"/>  862: 	       XRes5, Res5]),
<a name="863"/>  863:     XRes1 = Res1,
<a name="864"/>  864:     XRes2 = Res2,
<a name="865"/>  865:     XRes3 = Res3,
<a name="866"/>  866:     XRes4 = Res4,
<a name="867"/>  867:     XRes5 = Res5,
<a name="memory_do-last_expr"/><a name="868"/>  868:     ok.
<a name="869"/>  869: 
<a name="mem_mode-1"/><a name="870"/>  870: <b>mem_mode</b>(T) -&gt;
<a name="mem_mode-last_expr"/><a name="871"/>  871: <b>    {case ets:info</b>(T,compressed) of
<a name="872"/>  872: 	 true -&gt; compressed;
<a name="873"/>  873: 	 false -&gt; normal
<a name="874"/>  874:      end,
<a name="875"/>  875:      erlang:system_info(wordsize)}.
<a name="876"/>  876: 
<a name="chk_normal_tab_struct_size-0"/><a name="877"/>  877: <b>chk_normal_tab_struct_size</b>() -&gt;
<a name="878"/>  878:     System = {os:type(),
<a name="879"/>  879: 	      os:version(),
<a name="880"/>  880: 	      erlang:system_info(wordsize),
<a name="881"/>  881: 	      erlang:system_info(smp_support),
<a name="882"/>  882: 	      erlang:system_info(heap_type)},
<a name="883"/>  883:     io:format(&quot;System = ~p~n&quot;, [System]),
<a name="chk_normal_tab_struct_size-last_expr"/><a name="884"/>  884:     ok.
<a name="885"/>  885: 
<a name="adjust_xmem-3"/><a name="886"/>  886: <b>adjust_xmem</b>([_T1,_T2,_T3,_T4], {A0,B0,C0,D0} = _Mem0, EstCnt) -&gt;
<a name="887"/>  887:     %% Adjust for 64-bit, smp, and os:
<a name="888"/>  888:     %%   Table struct size may differ.
<a name="889"/>  889: 
<a name="890"/>  890:     {TabSz, EstSz} = erts_debug:get_internal_state('DbTable_words'),
<a name="891"/>  891:     HTabSz = TabSz + EstCnt*EstSz,
<a name="892"/>  892:     OrdSetExtra = case erlang:system_info(wordsize) of
<a name="893"/>  893:                       8 -&gt; 40; % larger stack on 64 bit architectures
<a name="894"/>  894:                       _ -&gt; 0
<a name="895"/>  895:                   end,
<a name="adjust_xmem-last_expr"/><a name="896"/>  896:     {A0+TabSz+OrdSetExtra, B0+HTabSz, C0+HTabSz, D0+HTabSz}.
<a name="897"/>  897: 
<a name="898"/>  898: <i>%% Misc. whitebox tests</i>
<a name="t_whitebox-1"/><a name="899"/>  899: <b>t_whitebox</b>(Config) when is_list(Config) -&gt;
<a name="900"/>  900:     EtsMem = etsmem(),
<a name="901"/>  901:     repeat_for_opts(fun whitebox_1/1),
<a name="902"/>  902:     repeat_for_opts(fun whitebox_1/1),
<a name="903"/>  903:     repeat_for_opts(fun whitebox_1/1),
<a name="904"/>  904:     repeat_for_opts(fun whitebox_2/1),
<a name="905"/>  905:     repeat_for_opts(fun whitebox_2/1),
<a name="906"/>  906:     repeat_for_opts(fun whitebox_2/1),
<a name="t_whitebox-last_expr"/><a name="907"/>  907: <b>    verify_etsmem</b>(EtsMem).
<a name="908"/>  908: 
<a name="whitebox_1-1"/><a name="909"/>  909: <b>whitebox_1</b>(Opts) -&gt;
<a name="910"/>  910:     T=ets_new(x,[bag | Opts]),
<a name="911"/>  911:     ets:insert(T,[{du,glade},{ta,en}]),
<a name="912"/>  912:     ets:insert(T,[{hej,hopp2},{du,glade2},{ta,en2}]),
<a name="913"/>  913:     {_,C}=ets:match(T,{ta,'$1'},1),
<a name="914"/>  914:     ets:select(C),
<a name="915"/>  915:     ets:match(C),
<a name="916"/>  916:     ets:delete(T),
<a name="whitebox_1-last_expr"/><a name="917"/>  917:     ok.
<a name="918"/>  918: 
<a name="whitebox_2-1"/><a name="919"/>  919: <b>whitebox_2</b>(OptsIn) -&gt;
<a name="920"/>  920:     run_if_valid_opts(
<a name="921"/>  921:       [ordered_set, {keypos,2} | OptsIn],
<a name="922"/>  922:       fun (Opts) -&gt;
<a name="923"/>  923:               T = ets_new(x, Opts),
<a name="924"/>  924:               0 = ets:select_delete(T,[{{hej},[],[true]}]),
<a name="925"/>  925:               0 = ets:select_delete(T,[{{hej,hopp},[],[true]}]),
<a name="926"/>  926:               ets:delete(T)
<a name="927"/>  927:       end),
<a name="928"/>  928: 
<a name="929"/>  929:     T2 = ets_new(x,[set, {keypos,2}| OptsIn]),
<a name="930"/>  930:     0 = ets:select_delete(T2,[{{hej},[],[true]}]),
<a name="931"/>  931:     0 = ets:select_delete(T2,[{{hej,hopp},[],[true]}]),
<a name="932"/>  932:     ets:delete(T2),
<a name="whitebox_2-last_expr"/><a name="933"/>  933:     ok.
<a name="934"/>  934: 
<a name="select_bound_chunk-1"/><a name="935"/>  935: <b>select_bound_chunk</b>(_Config) -&gt;
<a name="select_bound_chunk-last_expr"/><a name="936"/>  936: <b>    repeat_for_opts</b>(fun select_bound_chunk_do/1, [all_types]).
<a name="937"/>  937: 
<a name="select_bound_chunk_do-1"/><a name="938"/>  938: <b>select_bound_chunk_do</b>(Opts) -&gt;
<a name="939"/>  939:     T = ets_new(x, Opts),
<a name="940"/>  940:     ets:insert(T, [{key, 1}]),
<a name="941"/>  941:     {[{key, 1}], '$end_of_table'} = ets:select(T, [{{key,1},[],['$_']}], 100000),
<a name="select_bound_chunk_do-last_expr"/><a name="942"/>  942:     ok.
<a name="943"/>  943: 
<a name="944"/>  944: 
<a name="945"/>  945: <i>%% Test ets:to/from_dets.</i>
<a name="t_ets_dets-1"/><a name="946"/>  946: <b>t_ets_dets</b>(Config) when is_list(Config) -&gt;
<a name="t_ets_dets-last_expr"/><a name="947"/>  947: <b>    repeat_for_opts</b>(fun(Opts) -&gt; t_ets_dets(Config,Opts) end).
<a name="948"/>  948: 
<a name="t_ets_dets-2"/><a name="949"/>  949: <b>t_ets_dets</b>(Config, Opts) -&gt;
<a name="950"/>  950:     Fname = gen_dets_filename(Config,1),
<a name="951"/>  951:     (catch file:delete(Fname)),
<a name="952"/>  952:     {ok,DTab} = dets:open_file(testdets_1,
<a name="953"/>  953: 			       [{file, Fname}]),
<a name="954"/>  954:     ETab = ets_new(x,Opts),
<a name="955"/>  955:     filltabint(ETab,3000),
<a name="956"/>  956:     DTab = ets:to_dets(ETab,DTab),
<a name="957"/>  957:     ets:delete_all_objects(ETab),
<a name="958"/>  958:     0 = ets:info(ETab,size),
<a name="959"/>  959:     true = ets:from_dets(ETab,DTab),
<a name="960"/>  960:     3000 = ets:info(ETab,size),
<a name="961"/>  961:     ets:delete(ETab),
<a name="962"/>  962:     check_badarg(catch ets:to_dets(ETab,DTab),
<a name="963"/>  963: 		 ets, to_dets, [ETab,DTab]),
<a name="964"/>  964:     check_badarg(catch ets:from_dets(ETab,DTab),
<a name="965"/>  965: 		 ets, from_dets, [ETab,DTab]),
<a name="966"/>  966:     ETab2 = ets_new(x,Opts),
<a name="967"/>  967:     filltabint(ETab2,3000),
<a name="968"/>  968:     dets:close(DTab),
<a name="969"/>  969:     check_badarg(catch ets:to_dets(ETab2,DTab),
<a name="970"/>  970: 		 ets, to_dets, [ETab2,DTab]),
<a name="971"/>  971:     check_badarg(catch ets:from_dets(ETab2,DTab),
<a name="972"/>  972: 		 ets, from_dets, [ETab2,DTab]),
<a name="973"/>  973:     ets:delete(ETab2),
<a name="974"/>  974:     (catch file:delete(Fname)),
<a name="t_ets_dets-last_expr"/><a name="975"/>  975:     ok.
<a name="976"/>  976: 
<a name="check_badarg-4"/><a name="977"/>  977: <b>check_badarg</b>({'EXIT', {badarg, [{M,F,Args,_} | _]}}, M, F, Args) -&gt;
<a name="check_badarg-last_expr"/><a name="978"/>  978:     true.
<a name="979"/>  979: 
<a name="980"/>  980: <i>%% Test ets:delete_all_objects/1.</i>
<a name="t_delete_all_objects-1"/><a name="981"/>  981: <b>t_delete_all_objects</b>(Config) when is_list(Config) -&gt;
<a name="982"/>  982:     EtsMem = etsmem(),
<a name="983"/>  983:     repeat_for_opts_all_set_table_types(fun t_delete_all_objects_do/1),
<a name="t_delete_all_objects-last_expr"/><a name="984"/>  984: <b>    verify_etsmem</b>(EtsMem).
<a name="985"/>  985: 
<a name="get_kept_objects-1"/><a name="986"/>  986: <b>get_kept_objects</b>(T) -&gt;
<a name="get_kept_objects-last_expr"/><a name="987"/>  987: <b>    case ets:info</b>(T,stats) of
<a name="988"/>  988: 	{_,_,_,_,_,_,KO,_}  -&gt;
<a name="989"/>  989: 	    KO;
<a name="990"/>  990:         _ -&gt;
<a name="991"/>  991:             0
<a name="992"/>  992:     end.
<a name="993"/>  993: 
<a name="t_delete_all_objects_do-1"/><a name="994"/>  994: <b>t_delete_all_objects_do</b>(Opts) -&gt;
<a name="995"/>  995:     KeyRange = 40_000,
<a name="996"/>  996:     T=ets_new(x, Opts, KeyRange),
<a name="997"/>  997:     filltabint(T,KeyRange),
<a name="998"/>  998:     O=ets:first(T),
<a name="999"/>  999:     ets:next(T,O),
<a name="1000"/> 1000:     ets:safe_fixtable(T,true),
<a name="1001"/> 1001:     true = ets:delete_all_objects(T),
<a name="1002"/> 1002:     '$end_of_table' = ets:next(T,O),
<a name="1003"/> 1003:     0 = ets:info(T,size),
<a name="1004"/> 1004:     case ets:info(T,type) of
<a name="1005"/> 1005:         ordered_set -&gt; ok;
<a name="1006"/> 1006:         _ -&gt; KeyRange = get_kept_objects(T)
<a name="1007"/> 1007:     end,
<a name="1008"/> 1008:     ets:safe_fixtable(T,false),
<a name="1009"/> 1009:     0 = ets:info(T,size),
<a name="1010"/> 1010:     0 = get_kept_objects(T),
<a name="1011"/> 1011:     filltabint(T, KeyRange),
<a name="1012"/> 1012:     KeyRange = ets:info(T,size),
<a name="1013"/> 1013:     true = ets:delete_all_objects(T),
<a name="1014"/> 1014:     0 = ets:info(T,size),
<a name="1015"/> 1015:     ets:delete(T),
<a name="1016"/> 1016: 
<a name="1017"/> 1017:     %% Test delete_all_objects is atomic
<a name="1018"/> 1018:     T2 = ets_new(t_delete_all_objects, [public | Opts]),
<a name="1019"/> 1019:     Self = self(),
<a name="1020"/> 1020:     Inserters = [spawn_link(fun() -&gt; inserter(T2, 1, Self) end) || _ &lt;- [1,2,3,4]],
<a name="1021"/> 1021:     [receive {Ipid, running} -&gt; ok end || Ipid &lt;- Inserters],
<a name="1022"/> 1022: 
<a name="1023"/> 1023:     ets:delete_all_objects(T2),
<a name="1024"/> 1024:     erlang:yield(),
<a name="1025"/> 1025:     [Ipid ! stop || Ipid &lt;- Inserters],
<a name="1026"/> 1026:     Result = [receive {Ipid, stopped, Highest} -&gt; {Ipid,Highest} end || Ipid &lt;- Inserters],
<a name="1027"/> 1027: 
<a name="1028"/> 1028:     %% Verify unbroken sequences of objects inserted _after_ ets:delete_all_objects.
<a name="1029"/> 1029:     Sum = lists:foldl(fun({Ipid, Highest}, AccSum) -&gt;
<a name="1030"/> 1030:                               %% ets:fun2ms(fun({{K,Ipid}}) when K =&lt; Highest -&gt; true end),
<a name="1031"/> 1031:                               AliveMS = [{{{'$1',Ipid}},[{'=&lt;','$1',{const,Highest}}],[true]}],
<a name="1032"/> 1032:                               Alive = ets:select_count(T2, AliveMS),
<a name="1033"/> 1033:                               Lowest = Highest - (Alive-1),
<a name="1034"/> 1034: 
<a name="1035"/> 1035:                               %% ets:fun2ms(fun({{K,Ipid}}) when K &lt; Lowest -&gt; true end)
<a name="1036"/> 1036:                               DeletedMS = [{{{'$1',Ipid}},[{'&lt;','$1',{const,Lowest}}],[true]}],
<a name="1037"/> 1037:                               0 = ets:select_count(T2, DeletedMS),
<a name="1038"/> 1038:                               AccSum + Alive
<a name="1039"/> 1039:                       end,
<a name="1040"/> 1040:                       0,
<a name="1041"/> 1041:                       Result),
<a name="1042"/> 1042:     ok = case ets:info(T2, size) of
<a name="1043"/> 1043:              Sum -&gt; ok;
<a name="1044"/> 1044:              Size -&gt;
<a name="1045"/> 1045:                  io:format(&quot;Sum = ~p\nSize = ~p\n&quot;, [Sum, Size]),
<a name="1046"/> 1046:                  {Sum,Size}
<a name="1047"/> 1047:          end,
<a name="1048"/> 1048: 
<a name="t_delete_all_objects_do-last_expr"/><a name="1049"/> 1049: <b>    ets:delete</b>(T2).
<a name="1050"/> 1050: 
<a name="inserter-3"/><a name="1051"/> 1051: <b>inserter</b>(T, Next, Papa) -&gt;
<a name="1052"/> 1052:     Wait = case Next of
<a name="1053"/> 1053:                10*1000 -&gt;
<a name="1054"/> 1054:                    Papa ! {self(), running},
<a name="1055"/> 1055:                    0;
<a name="1056"/> 1056:                100*1000 -&gt; %% We most often don't reach this far
<a name="1057"/> 1057:                    io:format(&quot;Inserter ~p reached ~p objects\n&quot;,
<a name="1058"/> 1058:                              [self(), Next]),
<a name="1059"/> 1059:                    infinity;
<a name="1060"/> 1060:                _ -&gt;
<a name="1061"/> 1061:                    0
<a name="1062"/> 1062:            end,
<a name="1063"/> 1063: 
<a name="1064"/> 1064:     ets:insert(T, {{Next, self()}}),
<a name="inserter-last_expr"/><a name="1065"/> 1065:     receive
<a name="1066"/> 1066:         stop -&gt;
<a name="1067"/> 1067:             Papa ! {self(), stopped, Next},
<a name="1068"/> 1068:             ok
<a name="1069"/> 1069:     after Wait -&gt;
<a name="1070"/> 1070:             inserter(T, Next+1, Papa)
<a name="1071"/> 1071:     end.
<a name="1072"/> 1072: 
<a name="1073"/> 1073: 
<a name="1074"/> 1074: <i>%% Poke table during delete_all_objects</i>
<a name="t_delete_all_objects_trap-1"/><a name="1075"/> 1075: <b>t_delete_all_objects_trap</b>(Config) when is_list(Config) -&gt;
<a name="1076"/> 1076:     EtsMem = etsmem(),
<a name="1077"/> 1077:     repeat_for_opts_all_set_table_types(
<a name="1078"/> 1078:       fun(Opts) -&gt;
<a name="1079"/> 1079:               delete_all_objects_trap(Opts, unfix),
<a name="1080"/> 1080:               delete_all_objects_trap(Opts, exit),
<a name="1081"/> 1081:               delete_all_objects_trap(Opts, rename)
<a name="1082"/> 1082:       end),
<a name="1083"/> 1083:     verify_etsmem(EtsMem),
<a name="t_delete_all_objects_trap-last_expr"/><a name="1084"/> 1084:     ok.
<a name="1085"/> 1085: 
<a name="delete_all_objects_trap-2"/><a name="1086"/> 1086: <b>delete_all_objects_trap</b>(Opts, Mode) -&gt;
<a name="1087"/> 1087:     io:format(&quot;Opts = ~p\nMode = ~p\n&quot;, [Opts, Mode]),
<a name="1088"/> 1088:     Tester = self(),
<a name="1089"/> 1089:     KeyRange = 50_000,
<a name="1090"/> 1090:     TableName = delete_all_objects_trap,
<a name="1091"/> 1091:     {Tref,T} =
<a name="1092"/> 1092:         case Mode of
<a name="1093"/> 1093:             rename -&gt;
<a name="1094"/> 1094:                 TableName = ets_new(TableName, [named_table,public|Opts], KeyRange),
<a name="1095"/> 1095:                 {ets:whereis(TableName), TableName};
<a name="1096"/> 1096:             _ -&gt;
<a name="1097"/> 1097:                 Tid = ets_new(x, Opts, KeyRange),
<a name="1098"/> 1098:                 {Tid,Tid}
<a name="1099"/> 1099:         end,
<a name="1100"/> 1100:     filltabint(T, KeyRange),
<a name="1101"/> 1101:     KeyRange = ets:info(T,size),
<a name="1102"/> 1102:     FixerFun =
<a name="1103"/> 1103:         fun() -&gt;
<a name="1104"/> 1104:                 erlang:trace(Tester, true, [running]),
<a name="1105"/> 1105:                 case Mode of
<a name="1106"/> 1106:                     rename -&gt; ok;
<a name="1107"/> 1107:                     _ -&gt; ets:safe_fixtable(T, true)
<a name="1108"/> 1108:                 end,
<a name="1109"/> 1109:                 io:format(&quot;Wait for ets:delete_all_objects/1 to yield...\n&quot;, []),
<a name="1110"/> 1110:                 Tester ! {ready, self()},
<a name="1111"/> 1111:                 repeat_while(
<a name="1112"/> 1112:                   fun() -&gt;
<a name="1113"/> 1113:                           case receive_any() of
<a name="1114"/> 1114:                               {trace, Tester, out, {ets,internal_delete_all,2}} -&gt;
<a name="1115"/> 1115:                                   false;
<a name="1116"/> 1116:                               &quot;delete_all_objects done&quot; -&gt;
<a name="1117"/> 1117:                                   ct:fail(&quot;No trap detected&quot;);
<a name="1118"/> 1118:                               _M -&gt;
<a name="1119"/> 1119:                                   %%io:format(&quot;Ignored msg: ~p\n&quot;, [_M]),
<a name="1120"/> 1120:                                   true
<a name="1121"/> 1121:                           end
<a name="1122"/> 1122:                   end),
<a name="1123"/> 1123:                 case Mode of
<a name="1124"/> 1124:                     unfix -&gt;
<a name="1125"/> 1125:                         io:format(&quot;Unfix table and then exit...\n&quot;,[]),
<a name="1126"/> 1126:                         ets:safe_fixtable(T, false);
<a name="1127"/> 1127:                     exit -&gt;
<a name="1128"/> 1128:                         %%io:format(&quot;Exit and do auto-unfix...\n&quot;,[]),
<a name="1129"/> 1129:                         exit;
<a name="1130"/> 1130:                     rename -&gt;
<a name="1131"/> 1131:                         %%io:format(&quot;Rename table...\n&quot;,[]),
<a name="1132"/> 1132:                         renamed = ets:rename(T, renamed)
<a name="1133"/> 1133:                 end
<a name="1134"/> 1134:         end,
<a name="1135"/> 1135:     {Fixer, Mon} = spawn_opt(FixerFun, [link, monitor]),
<a name="1136"/> 1136:     {ready, Fixer} = receive_any(),
<a name="1137"/> 1137:     true = ets:delete_all_objects(T),
<a name="1138"/> 1138:     Fixer ! &quot;delete_all_objects done&quot;,
<a name="1139"/> 1139:     0 = ets:info(Tref,size),
<a name="1140"/> 1140:     {'DOWN', Mon, process, Fixer, normal} = receive_any(),
<a name="1141"/> 1141:     0 = get_kept_objects(Tref),
<a name="1142"/> 1142:     false = ets:info(Tref,safe_fixed),
<a name="1143"/> 1143:     ets:delete(Tref),
<a name="delete_all_objects_trap-last_expr"/><a name="1144"/> 1144:     ok.
<a name="1145"/> 1145: 
<a name="1146"/> 1146: 
<a name="1147"/> 1147: <i>%% Test ets:delete_object/2.</i>
<a name="t_delete_object-1"/><a name="1148"/> 1148: <b>t_delete_object</b>(Config) when is_list(Config) -&gt;
<a name="1149"/> 1149:     EtsMem = etsmem(),
<a name="1150"/> 1150:     repeat_for_opts(fun t_delete_object_do/1),
<a name="t_delete_object-last_expr"/><a name="1151"/> 1151: <b>    verify_etsmem</b>(EtsMem).
<a name="1152"/> 1152: 
<a name="t_delete_object_do-1"/><a name="1153"/> 1153: <b>t_delete_object_do</b>(Opts) -&gt;
<a name="1154"/> 1154:     T = ets_new(x,Opts),
<a name="1155"/> 1155:     filltabint(T,4000),
<a name="1156"/> 1156:     del_one_by_one_set(T,1,4001),
<a name="1157"/> 1157:     filltabint(T,4000),
<a name="1158"/> 1158:     del_one_by_one_set(T,4000,0),
<a name="1159"/> 1159:     filltabint(T,4000),
<a name="1160"/> 1160:     First = ets:first(T),
<a name="1161"/> 1161:     Next = ets:next(T,First),
<a name="1162"/> 1162:     ets:safe_fixtable(T,true),
<a name="1163"/> 1163:     ets:delete_object(T,{First, integer_to_list(First)}),
<a name="1164"/> 1164:     Next = ets:next(T,First),
<a name="1165"/> 1165:     3999 = ets:info(T,size),
<a name="1166"/> 1166:     1 = get_kept_objects(T),
<a name="1167"/> 1167:     ets:safe_fixtable(T,false),
<a name="1168"/> 1168:     3999 = ets:info(T,size),
<a name="1169"/> 1169:     0 = get_kept_objects(T),
<a name="1170"/> 1170:     ets:delete(T),
<a name="1171"/> 1171:     run_if_valid_opts(
<a name="1172"/> 1172:       [ordered_set | Opts],
<a name="1173"/> 1173:       fun (Opts1) -&gt;
<a name="1174"/> 1174:               T1 = ets_new(x, Opts1),
<a name="1175"/> 1175:               filltabint(T1,4000),
<a name="1176"/> 1176:               del_one_by_one_set(T1,1,4001),
<a name="1177"/> 1177:               filltabint(T1,4000),
<a name="1178"/> 1178:               del_one_by_one_set(T1,4000,0),
<a name="1179"/> 1179:               ets:delete(T1)
<a name="1180"/> 1180:       end),
<a name="1181"/> 1181:     T2 = ets_new(x,[bag | Opts]),
<a name="1182"/> 1182:     filltabint2(T2,4000),
<a name="1183"/> 1183:     del_one_by_one_bag(T2,1,4001),
<a name="1184"/> 1184:     filltabint2(T2,4000),
<a name="1185"/> 1185:     del_one_by_one_bag(T2,4000,0),
<a name="1186"/> 1186:     ets:delete(T2),
<a name="1187"/> 1187:     T3 = ets_new(x,[duplicate_bag | Opts]),
<a name="1188"/> 1188:     filltabint3(T3,4000),
<a name="1189"/> 1189:     del_one_by_one_dbag_1(T3,1,4001),
<a name="1190"/> 1190:     filltabint3(T3,4000),
<a name="1191"/> 1191:     del_one_by_one_dbag_1(T3,4000,0),
<a name="1192"/> 1192:     filltabint(T3,4000),
<a name="1193"/> 1193:     filltabint3(T3,4000),
<a name="1194"/> 1194:     del_one_by_one_dbag_2(T3,1,4001),
<a name="1195"/> 1195:     filltabint(T3,4000),
<a name="1196"/> 1196:     filltabint3(T3,4000),
<a name="1197"/> 1197:     del_one_by_one_dbag_2(T3,4000,0),
<a name="1198"/> 1198: 
<a name="1199"/> 1199:     filltabint2(T3,4000),
<a name="1200"/> 1200:     filltabint(T3,4000),
<a name="1201"/> 1201:     del_one_by_one_dbag_3(T3,4000,0),
<a name="1202"/> 1202:     ets:delete(T3),
<a name="t_delete_object_do-last_expr"/><a name="1203"/> 1203:     ok.
<a name="1204"/> 1204: 
<a name="make_init_fun-1"/><a name="1205"/> 1205: <b>make_init_fun</b>(N) when N &gt; 4000-&gt;
<a name="1206"/> 1206:     fun(read) -&gt;
<a name="1207"/> 1207: 	    end_of_input;
<a name="1208"/> 1208:        (close) -&gt;
<a name="1209"/> 1209: 	    exit(close_not_expected)
<a name="1210"/> 1210:     end;
<a name="1211"/> 1211: <b>make_init_fun</b>(N) -&gt;
<a name="make_init_fun-last_expr"/><a name="1212"/> 1212: <b>    fun</b>(read) -&gt;
<a name="1213"/> 1213: 	    case N rem 2 of
<a name="1214"/> 1214: 		0 -&gt;
<a name="1215"/> 1215: 		    {[{N, integer_to_list(N)}, {N, integer_to_list(N)}],
<a name="1216"/> 1216: 		     make_init_fun(N + 1)};
<a name="1217"/> 1217: 		1 -&gt;
<a name="1218"/> 1218: 		    {[], make_init_fun(N + 1)}
<a name="1219"/> 1219: 	    end;
<a name="1220"/> 1220:        (close) -&gt;
<a name="1221"/> 1221: 	    exit(close_not_expected)
<a name="1222"/> 1222:     end.
<a name="1223"/> 1223: 
<a name="1224"/> 1224: <i>%% Test ets:init_table/2.</i>
<a name="t_init_table-1"/><a name="1225"/> 1225: <b>t_init_table</b>(Config) when is_list(Config)-&gt;
<a name="1226"/> 1226:     EtsMem = etsmem(),
<a name="1227"/> 1227:     repeat_for_opts(fun t_init_table_do/1),
<a name="t_init_table-last_expr"/><a name="1228"/> 1228: <b>    verify_etsmem</b>(EtsMem).
<a name="1229"/> 1229: 
<a name="t_init_table_do-1"/><a name="1230"/> 1230: <b>t_init_table_do</b>(Opts) -&gt;
<a name="1231"/> 1231:     T = ets_new(x,[duplicate_bag | Opts]),
<a name="1232"/> 1232:     filltabint(T,4000),
<a name="1233"/> 1233:     ets:init_table(T, make_init_fun(1)),
<a name="1234"/> 1234:     del_one_by_one_dbag_1(T,4000,0),
<a name="1235"/> 1235:     ets:delete(T),
<a name="t_init_table_do-last_expr"/><a name="1236"/> 1236:     ok.
<a name="1237"/> 1237: 
<a name="do_fill_dbag_using_lists-2"/><a name="1238"/> 1238: <b>do_fill_dbag_using_lists</b>(T,0) -&gt;
<a name="1239"/> 1239:     T;
<a name="1240"/> 1240: <b>do_fill_dbag_using_lists</b>(T,N) -&gt;
<a name="1241"/> 1241:     ets:insert(T,[{N,integer_to_list(N)},
<a name="1242"/> 1242: 		  {N + N rem 2,integer_to_list(N + N rem 2)}]),
<a name="do_fill_dbag_using_lists-last_expr"/><a name="1243"/> 1243: <b>    do_fill_dbag_using_lists</b>(T,N - 1).
<a name="1244"/> 1244: 
<a name="1245"/> 1245: 
<a name="1246"/> 1246: <i>%% Test the insert_new function.</i>
<a name="t_insert_new-1"/><a name="1247"/> 1247: <b>t_insert_new</b>(Config) when is_list(Config) -&gt;
<a name="1248"/> 1248:     EtsMem = etsmem(),
<a name="1249"/> 1249:     L = fill_sets_int(1000) ++ fill_sets_int(1000,[{write_concurrency,true}]),
<a name="1250"/> 1250:     lists:foreach(fun(Tab) -&gt;
<a name="1251"/> 1251: 			  false = ets:insert_new(Tab,{2,&quot;2&quot;}),
<a name="1252"/> 1252: 			  true = ets:insert_new(Tab,{2002,&quot;2002&quot;}),
<a name="1253"/> 1253: 			  false = ets:insert_new(Tab,{2002,&quot;2002&quot;}),
<a name="1254"/> 1254: 			  true = ets:insert(Tab,{2002,&quot;2002&quot;}),
<a name="1255"/> 1255: 			  false =  ets:insert_new(Tab,[{2002,&quot;2002&quot;}]),
<a name="1256"/> 1256: 			  false =  ets:insert_new(Tab,[{2002,&quot;2002&quot;},
<a name="1257"/> 1257: 						       {2003,&quot;2003&quot;}]),
<a name="1258"/> 1258: 			  false =  ets:insert_new(Tab,[{2001,&quot;2001&quot;},
<a name="1259"/> 1259: 						       {2002,&quot;2002&quot;},
<a name="1260"/> 1260: 						       {2003,&quot;2003&quot;}]),
<a name="1261"/> 1261: 			  false =  ets:insert_new(Tab,[{2001,&quot;2001&quot;},
<a name="1262"/> 1262: 						       {2002,&quot;2002&quot;}]),
<a name="1263"/> 1263: 			  true =  ets:insert_new(Tab,[{2001,&quot;2001&quot;},
<a name="1264"/> 1264: 						      {2003,&quot;2003&quot;}]),
<a name="1265"/> 1265: 			  false = ets:insert_new(Tab,{2001,&quot;2001&quot;}),
<a name="1266"/> 1266: 			  false = ets:insert_new(Tab,{2002,&quot;2002&quot;}),
<a name="1267"/> 1267: 			  false = ets:insert_new(Tab,{2003,&quot;2003&quot;}),
<a name="1268"/> 1268: 			  true = ets:insert_new(Tab,{2004,&quot;2004&quot;}),
<a name="1269"/> 1269: 			  true = ets:insert_new(Tab,{2000,&quot;2000&quot;}),
<a name="1270"/> 1270: 			  true = ets:insert_new(Tab,[{2005,&quot;2005&quot;},
<a name="1271"/> 1271: 						     {2006,&quot;2006&quot;},
<a name="1272"/> 1272: 						     {2007,&quot;2007&quot;}]),
<a name="1273"/> 1273: 			  Num =
<a name="1274"/> 1274: 			      case ets:info(Tab,type) of
<a name="1275"/> 1275: 				  bag -&gt;
<a name="1276"/> 1276: 				      true =
<a name="1277"/> 1277: 					  ets:insert(Tab,{2004,&quot;2004-2&quot;}),
<a name="1278"/> 1278: 				      false =
<a name="1279"/> 1279: 					  ets:insert_new(Tab,{2004,&quot;2004-3&quot;}),
<a name="1280"/> 1280: 				      1009;
<a name="1281"/> 1281: 				  duplicate_bag -&gt;
<a name="1282"/> 1282: 				      true =
<a name="1283"/> 1283: 					  ets:insert(Tab,{2004,&quot;2004&quot;}),
<a name="1284"/> 1284: 				      false =
<a name="1285"/> 1285: 					  ets:insert_new(Tab,{2004,&quot;2004&quot;}),
<a name="1286"/> 1286: 				      1010;
<a name="1287"/> 1287: 				  _ -&gt;
<a name="1288"/> 1288: 				      1008
<a name="1289"/> 1289: 			      end,
<a name="1290"/> 1290: 			  Num = ets:info(Tab,size),
<a name="1291"/> 1291: 			  List = ets:tab2list(Tab),
<a name="1292"/> 1292: 			  ets:delete_all_objects(Tab),
<a name="1293"/> 1293: 			  true = ets:insert_new(Tab,List),
<a name="1294"/> 1294: 			  false = ets:insert_new(Tab,List),
<a name="1295"/> 1295: 			  ets:delete(Tab)
<a name="1296"/> 1296: 		  end,
<a name="1297"/> 1297: 		  L),
<a name="t_insert_new-last_expr"/><a name="1298"/> 1298: <b>    verify_etsmem</b>(EtsMem).
<a name="1299"/> 1299: 
<a name="1300"/> 1300: <i>%% Test ets:insert/2 with list of objects into duplicate bag table.</i>
<a name="t_insert_list-1"/><a name="1301"/> 1301: <b>t_insert_list</b>(Config) when is_list(Config) -&gt;
<a name="1302"/> 1302:     EtsMem = etsmem(),
<a name="1303"/> 1303:     repeat_for_opts(fun t_insert_list_do/1),
<a name="t_insert_list-last_expr"/><a name="1304"/> 1304: <b>    verify_etsmem</b>(EtsMem).
<a name="1305"/> 1305: 
<a name="t_insert_list_do-1"/><a name="1306"/> 1306: <b>t_insert_list_do</b>(Opts) -&gt;
<a name="1307"/> 1307:     T = ets_new(x,[duplicate_bag | Opts]),
<a name="1308"/> 1308:     do_fill_dbag_using_lists(T,4000),
<a name="1309"/> 1309:     del_one_by_one_dbag_2(T,4000,0),
<a name="t_insert_list_do-last_expr"/><a name="1310"/> 1310: <b>    ets:delete</b>(T).
<a name="1311"/> 1311: 
<a name="1312"/> 1312: <i>% Insert a long list twice in a bag</i>
<a name="t_insert_list_bag-1"/><a name="1313"/> 1313: <b>t_insert_list_bag</b>(Config) when is_list(Config) -&gt;
<a name="1314"/> 1314:     EtsMem = etsmem(),
<a name="1315"/> 1315:     repeat_for_opts(fun t_insert_list_bag_do/1,
<a name="1316"/> 1316:                     [write_concurrency, compressed]),
<a name="t_insert_list_bag-last_expr"/><a name="1317"/> 1317: <b>    verify_etsmem</b>(EtsMem).
<a name="1318"/> 1318: 
<a name="t_insert_list_bag_do-1"/><a name="1319"/> 1319: <b>t_insert_list_bag_do</b>(Opts) -&gt;
<a name="1320"/> 1320:     T = ets:new(t, [bag | Opts]),
<a name="1321"/> 1321:     ListSize = 25000,
<a name="1322"/> 1322:     List = [ {N} || N &lt;- lists:seq(1, ListSize)],
<a name="1323"/> 1323:     ets:insert(T, List),
<a name="1324"/> 1324:     ets:insert(T, List),
<a name="1325"/> 1325:     ListSize = ets:info(T, size),
<a name="1326"/> 1326: 
<a name="1327"/> 1327:     %% Insert different sized objects to better test (compressed) object comparison
<a name="1328"/> 1328:     List2 = [begin Bits=(N rem 71), {N div 7, &lt;&lt;N:Bits&gt;&gt;} end || {N} &lt;- List],
<a name="1329"/> 1329:     ets:insert(T, List2),
<a name="1330"/> 1330:     List2Sz = ListSize * 2,
<a name="1331"/> 1331:     List2Sz = ets:info(T, size),
<a name="1332"/> 1332:     ets:delete(T),
<a name="t_insert_list_bag_do-last_expr"/><a name="1333"/> 1333:     ok.
<a name="1334"/> 1334: 
<a name="1335"/> 1335: <i>% Insert a long list twice in a duplicate_bag</i>
<a name="t_insert_list_duplicate_bag-1"/><a name="1336"/> 1336: <b>t_insert_list_duplicate_bag</b>(Config) when is_list(Config) -&gt;
<a name="1337"/> 1337:     EtsMem = etsmem(),
<a name="1338"/> 1338:     T = ets:new(t, [duplicate_bag]),
<a name="1339"/> 1339:     ListSize = 25000,
<a name="1340"/> 1340:     List = [ {N} || N &lt;- lists:seq(1, ListSize)],
<a name="1341"/> 1341:     ets:insert(T, List),
<a name="1342"/> 1342:     ets:insert(T, List),
<a name="1343"/> 1343:     DoubleListSize = ListSize * 2,
<a name="1344"/> 1344:     DoubleListSize = ets:info(T, size),
<a name="1345"/> 1345:     ets:delete(T),
<a name="t_insert_list_duplicate_bag-last_expr"/><a name="1346"/> 1346: <b>    verify_etsmem</b>(EtsMem).
<a name="1347"/> 1347: 
<a name="1348"/> 1348: <i>%% Test ets:insert/2 with list of objects into set tables.</i>
<a name="t_insert_list_set-1"/><a name="1349"/> 1349: <b>t_insert_list_set</b>(Config) when is_list(Config) -&gt;
<a name="1350"/> 1350:     EtsMem = etsmem(),
<a name="1351"/> 1351:     repeat_for_opts(fun t_insert_list_set_do/1, [set_types]),
<a name="t_insert_list_set-last_expr"/><a name="1352"/> 1352: <b>    verify_etsmem</b>(EtsMem).
<a name="1353"/> 1353: 
<a name="t_insert_list_set_do-1"/><a name="1354"/> 1354: <b>t_insert_list_set_do</b>(Opts) -&gt;
<a name="1355"/> 1355:     Nr = 2,
<a name="1356"/> 1356:     t_insert_list_set_do(Opts, fun ets_insert_with_check/2, Nr, 1, Nr+1),
<a name="1357"/> 1357:     t_insert_list_set_do(Opts, fun ets_insert_with_check/2, Nr*2, 2, Nr*2),
<a name="1358"/> 1358:     InsertNewWithCheck =
<a name="1359"/> 1359:         fun(T,E) -&gt;
<a name="1360"/> 1360:                 Res = ets:insert_new(T,E),
<a name="1361"/> 1361:                 Seq = element(1, lists:nth(1, E)),
<a name="1362"/> 1362:                 case Seq rem 2 =:= 0 of
<a name="1363"/> 1363:                     true -&gt; Res = false;
<a name="1364"/> 1364:                     false -&gt; Res = true
<a name="1365"/> 1365:                 end
<a name="1366"/> 1366:         end,
<a name="1367"/> 1367:     t_insert_list_set_do(Opts, InsertNewWithCheck, Nr, 1, Nr),
<a name="1368"/> 1368:     t_insert_list_set_do(Opts, fun ets:insert_new/2, Nr*2, 2, Nr*2),
<a name="t_insert_list_set_do-last_expr"/><a name="1369"/> 1369:     ok.
<a name="1370"/> 1370: 
<a name="t_insert_list_set_do-5"/><a name="1371"/> 1371: <b>t_insert_list_set_do</b>(Opts, InsertFun, Nr, Step, ExpectedSize) -&gt;
<a name="1372"/> 1372:     T = ets_new(x,Opts),
<a name="1373"/> 1373:     [InsertFun(T,[{X,X}, {X+1,X}]) || X &lt;- lists:seq(1,Nr,Step)],
<a name="1374"/> 1374:     ExpectedSize = ets:info(T,size),
<a name="t_insert_list_set_do-last_expr"/><a name="1375"/> 1375: <b>    ets:delete</b>(T).
<a name="1376"/> 1376: 
<a name="1377"/> 1377: <i>%% Test ets:insert/2 with list of objects into set tables in parallel.</i>
<a name="t_insert_list_parallel-1"/><a name="1378"/> 1378: <b>t_insert_list_parallel</b>(Config) when is_list(Config) -&gt;
<a name="1379"/> 1379:     EtsMem = etsmem(),
<a name="1380"/> 1380:     repeat_for_opts(fun t_insert_list_parallel_do/1, [[public], set_types]),
<a name="t_insert_list_parallel-last_expr"/><a name="1381"/> 1381: <b>    verify_etsmem</b>(EtsMem).
<a name="1382"/> 1382: 
<a name="ets_insert_with_check-2"/><a name="1383"/> 1383: <b>ets_insert_with_check</b>(Table, ToInsert) -&gt;
<a name="1384"/> 1384:     true = ets:insert(Table, ToInsert),
<a name="ets_insert_with_check-last_expr"/><a name="1385"/> 1385:     true.
<a name="1386"/> 1386: 
<a name="ets_insert_new_with_check-2"/><a name="1387"/> 1387: <b>ets_insert_new_with_check</b>(Table, ToInsert) -&gt;
<a name="1388"/> 1388:     ExpectedRes =
<a name="1389"/> 1389:         case put(is_first_insert_for_list, true) of
<a name="1390"/> 1390:             undefined -&gt; true;
<a name="1391"/> 1391:             true -&gt; false
<a name="1392"/> 1392:         end,
<a name="1393"/> 1393:     ExpectedRes = ets:insert_new(Table, ToInsert),
<a name="ets_insert_new_with_check-last_expr"/><a name="1394"/> 1394:     ExpectedRes.
<a name="1395"/> 1395: 
<a name="t_insert_list_parallel_do-1"/><a name="1396"/> 1396: <b>t_insert_list_parallel_do</b>(Opts) -&gt;
<a name="t_insert_list_parallel_do-last_expr"/><a name="1397"/> 1397: <b>    [</b>(fun(I) -&gt;
<a name="1398"/> 1398:              t_insert_list_parallel_do(Opts, I, 2, 100, 500),
<a name="1399"/> 1399:              t_insert_list_parallel_do(Opts, I, 10, 100, 100),
<a name="1400"/> 1400:              t_insert_list_parallel_do(Opts, I, 1000, 100, 10),
<a name="1401"/> 1401:              t_insert_list_parallel_do(Opts, I, 50000, 3, 1)
<a name="1402"/> 1402:       end)(InsertFun) || InsertFun &lt;- [fun ets_insert_with_check/2,
<a name="1403"/> 1403:                                        fun ets_insert_new_with_check/2]].
<a name="1404"/> 1404: 
<a name="t_insert_list_parallel_do-5"/><a name="1405"/> 1405: <b>t_insert_list_parallel_do</b>(Opts, InsertFun, ListLength, NrOfProcesses, NrOfInsertsPerProcess) -&gt;
<a name="1406"/> 1406:     T = ets_new(x,Opts),
<a name="1407"/> 1407:     t_insert_list_parallel_do_helper(self(), T, 0, InsertFun, ListLength, NrOfProcesses, NrOfInsertsPerProcess),
<a name="1408"/> 1408:     receive done -&gt; ok end,
<a name="1409"/> 1409:     ExpectedSize = ListLength * NrOfProcesses,
<a name="1410"/> 1410:     ExpectedSize = length(ets:match_object(T, {'$0', '$1'})),
<a name="1411"/> 1411:     ExpectedSize = ets:info(T, size),
<a name="1412"/> 1412:     ets:delete(T),
<a name="t_insert_list_parallel_do-last_expr"/><a name="1413"/> 1413:     ok.
<a name="1414"/> 1414: 
<a name="t_insert_list_delete_parallel-1"/><a name="1415"/> 1415: <b>t_insert_list_delete_parallel</b>(Config) when is_list(Config) -&gt;
<a name="1416"/> 1416:     EtsMem = etsmem(),
<a name="1417"/> 1417:     repeat_for_opts(fun t_insert_list_delete_parallel_do/1, [[public], set_types]),
<a name="t_insert_list_delete_parallel-last_expr"/><a name="1418"/> 1418: <b>    verify_etsmem</b>(EtsMem).
<a name="1419"/> 1419: 
<a name="t_insert_list_delete_parallel_do-1"/><a name="1420"/> 1420: <b>t_insert_list_delete_parallel_do</b>(Opts) -&gt;
<a name="1421"/> 1421:     [(fun(I) -&gt;
<a name="1422"/> 1422:               t_insert_list_delete_parallel_do(Opts, I, 30, 32, 1000000),
<a name="1423"/> 1423:               t_insert_list_delete_parallel_do(Opts, I, 300, 8, 1000000),
<a name="1424"/> 1424:               t_insert_list_delete_parallel_do(Opts, I, 3000, 4, 1000000),
<a name="1425"/> 1425:               t_insert_list_delete_parallel_do(Opts, I, 9000, 4, 1000000)
<a name="1426"/> 1426:       end)(InsertFun) || InsertFun &lt;- [fun ets_insert_with_check/2,
<a name="1427"/> 1427:                                        fun ets_insert_new_with_check/2]],
<a name="t_insert_list_delete_parallel_do-last_expr"/><a name="1428"/> 1428:     ok.
<a name="1429"/> 1429: 
<a name="t_insert_list_delete_parallel_do-5"/><a name="1430"/> 1430: <b>t_insert_list_delete_parallel_do</b>(Opts, InsertFun, ListLength, NrOfProcesses, NrOfInsertsPerProcess) -&gt;
<a name="1431"/> 1431:     T = ets_new(x,Opts),
<a name="1432"/> 1432:     CompletedInsertsCtr = counters:new(1,[]),
<a name="1433"/> 1433:     NewInsertFun =
<a name="1434"/> 1434:         fun(Table, ToInsert) -&gt;
<a name="1435"/> 1435:                 try
<a name="1436"/> 1436:                     InsertFun(Table, ToInsert),
<a name="1437"/> 1437:                     counters:add(CompletedInsertsCtr, 1, 1)
<a name="1438"/> 1438:                 catch
<a name="1439"/> 1439:                     error:badarg -&gt; put(stop,yes)
<a name="1440"/> 1440:                 end
<a name="1441"/> 1441:         end,
<a name="1442"/> 1442:     Self = self(),
<a name="1443"/> 1443:     spawn(fun()-&gt;
<a name="1444"/> 1444:                   t_insert_list_parallel_do_helper(self(), T, 0, NewInsertFun, ListLength, NrOfProcesses, NrOfInsertsPerProcess),
<a name="1445"/> 1445:                   receive done -&gt; Self ! done_parallel_insert end
<a name="1446"/> 1446:           end),
<a name="1447"/> 1447:     receive after 3 -&gt; ok end,
<a name="1448"/> 1448:     spawn(fun()-&gt;
<a name="1449"/> 1449:                   spawn(fun()-&gt;
<a name="1450"/> 1450:                                 receive after 7 -&gt; ok end,
<a name="1451"/> 1451:                                 ets:delete(T),
<a name="1452"/> 1452:                                 Self ! done_delete
<a name="1453"/> 1453:                         end)
<a name="1454"/> 1454:           end),
<a name="1455"/> 1455:     receive done_delete -&gt; ok end,
<a name="1456"/> 1456:     receive done_parallel_insert -&gt; ok end,
<a name="t_insert_list_delete_parallel_do-last_expr"/><a name="1457"/> 1457: <b>    io:format</b>(&quot;~p/~p completed&quot;,
<a name="1458"/> 1458:               [counters:get(CompletedInsertsCtr, 1),
<a name="1459"/> 1459:                NrOfProcesses * NrOfInsertsPerProcess]).
<a name="1460"/> 1460: 
<a name="1461"/> 1461: 
<a name="t_insert_list_parallel_do_helper-7"/><a name="1462"/> 1462: <b>t_insert_list_parallel_do_helper</b>(Parent, T, StartKey, InsertFun, ListLength, 1, NrOfInsertsPerProcess) -&gt;
<a name="1463"/> 1463:     try
<a name="1464"/> 1464:         repeat(fun()-&gt;
<a name="1465"/> 1465:                        case get(stop) of
<a name="1466"/> 1466:                            yes -&gt; throw(end_repeat);
<a name="1467"/> 1467:                            _ -&gt; ok
<a name="1468"/> 1468:                        end,
<a name="1469"/> 1469:                        InsertFun(T,[{X,X} || X &lt;- lists:seq(StartKey,StartKey+ListLength-1,1)])
<a name="1470"/> 1470:                end, NrOfInsertsPerProcess)
<a name="1471"/> 1471:     catch
<a name="1472"/> 1472:         throw:end_repeat -&gt; ok
<a name="1473"/> 1473:     end,
<a name="1474"/> 1474:     Parent ! done;
<a name="1475"/> 1475: <b>t_insert_list_parallel_do_helper</b>(Parent, T, StartKey, InsertFun, ListLength, NrOfProcesses, NrOfInsertsPerProcess) -&gt;
<a name="1476"/> 1476:     Self = self(),
<a name="1477"/> 1477:     spawn(fun() -&gt;
<a name="1478"/> 1478:                   t_insert_list_parallel_do_helper(Self,
<a name="1479"/> 1479:                                                    T,
<a name="1480"/> 1480:                                                    StartKey,
<a name="1481"/> 1481:                                                    InsertFun,
<a name="1482"/> 1482:                                                    ListLength,
<a name="1483"/> 1483:                                                    NrOfProcesses div 2,
<a name="1484"/> 1484:                                                    NrOfInsertsPerProcess) end),
<a name="1485"/> 1485:     spawn(fun() -&gt;
<a name="1486"/> 1486:                   t_insert_list_parallel_do_helper(Self,
<a name="1487"/> 1487:                                                    T,
<a name="1488"/> 1488:                                                    StartKey + ListLength*(NrOfProcesses div 2),
<a name="1489"/> 1489:                                                    InsertFun,
<a name="1490"/> 1490:                                                    ListLength,
<a name="1491"/> 1491:                                                    (NrOfProcesses div 2) + (NrOfProcesses rem 2),
<a name="1492"/> 1492:                                                    NrOfInsertsPerProcess)
<a name="1493"/> 1493:           end),
<a name="1494"/> 1494:     receive done -&gt; ok end,
<a name="1495"/> 1495:     receive done -&gt; ok end,
<a name="t_insert_list_parallel_do_helper-last_expr"/><a name="1496"/> 1496:     Parent ! done.
<a name="1497"/> 1497: 
<a name="t_insert_list_delete_set-1"/><a name="1498"/> 1498: <b>t_insert_list_delete_set</b>(Config) when is_list(Config) -&gt;
<a name="1499"/> 1499:     EtsMem = etsmem(),
<a name="1500"/> 1500:     repeat_for_opts(fun t_insert_list_delete_set_do/1, [[public],set_types]),
<a name="t_insert_list_delete_set-last_expr"/><a name="1501"/> 1501: <b>    verify_etsmem</b>(EtsMem).
<a name="1502"/> 1502: 
<a name="t_insert_list_delete_set_do-1"/><a name="1503"/> 1503: <b>t_insert_list_delete_set_do</b>(Opts) -&gt;
<a name="1504"/> 1504:     [(fun(I) -&gt;
<a name="1505"/> 1505:               t_insert_list_delete_set_do(Opts, I, 1000000, 1, 1),
<a name="1506"/> 1506:               t_insert_list_delete_set_do(Opts, I, 100000, 10, 5),
<a name="1507"/> 1507:               t_insert_list_delete_set_do(Opts, I, 10000, 100, 50),
<a name="1508"/> 1508:               t_insert_list_delete_set_do(Opts, I, 1000, 1000, 500)
<a name="1509"/> 1509:       end)(InsertFun) || InsertFun &lt;- [fun ets_insert_with_check/2,
<a name="1510"/> 1510:                                        fun ets_insert_new_with_check/2]],
<a name="t_insert_list_delete_set_do-last_expr"/><a name="1511"/> 1511:     ok.
<a name="1512"/> 1512: 
<a name="1513"/> 1513: 
<a name="t_insert_list_delete_set_do-5"/><a name="1514"/> 1514: <b>t_insert_list_delete_set_do</b>(Opts, InsertFun, ListLength, NrOfTables, NrOfInserts) -&gt;
<a name="1515"/> 1515:     CompletedInsertsCtr = counters:new(1,[]),
<a name="1516"/> 1516:     Parent = self(),
<a name="1517"/> 1517:     [(fun() -&gt;
<a name="1518"/> 1518:               T = ets_new(x,Opts),
<a name="1519"/> 1519:               spawn(
<a name="1520"/> 1520:                 fun() -&gt;
<a name="1521"/> 1521:                         try
<a name="1522"/> 1522:                             repeat(
<a name="1523"/> 1523:                               fun() -&gt;
<a name="1524"/> 1524:                                       InsertFun(T,[{Z,Z} ||
<a name="1525"/> 1525:                                                       Z &lt;- lists:seq(1,ListLength)]),
<a name="1526"/> 1526:                                       counters:add(CompletedInsertsCtr, 1, 1)%,
<a name="1527"/> 1527:                               end, NrOfInserts)
<a name="1528"/> 1528:                         catch
<a name="1529"/> 1529:                             error:badarg -&gt; ok
<a name="1530"/> 1530:                         end,
<a name="1531"/> 1531:                         Parent ! done
<a name="1532"/> 1532:                 end),
<a name="1533"/> 1533:               receive after 1 -&gt; ok end,
<a name="1534"/> 1534:               ets:delete(T)
<a name="1535"/> 1535:       end)() || _ &lt;- lists:seq(1,NrOfTables)],
<a name="1536"/> 1536:     [receive done -&gt; ok end || _ &lt;- lists:seq(1,NrOfTables)],
<a name="t_insert_list_delete_set_do-last_expr"/><a name="1537"/> 1537: <b>    io:format</b>(&quot;~p/~p completed&quot;,
<a name="1538"/> 1538:               [counters:get(CompletedInsertsCtr, 1),
<a name="1539"/> 1539:                NrOfTables * NrOfInserts]).
<a name="1540"/> 1540: 
<a name="1541"/> 1541: 
<a name="t_insert_list_kill_process-1"/><a name="1542"/> 1542: <b>t_insert_list_kill_process</b>(Config) when is_list(Config) -&gt;
<a name="1543"/> 1543:     EtsMem = etsmem(),
<a name="1544"/> 1544:     repeat_for_opts(fun t_insert_list_kill_process_do/1, [[public], set_types]),
<a name="t_insert_list_kill_process-last_expr"/><a name="1545"/> 1545: <b>    verify_etsmem</b>(EtsMem).
<a name="1546"/> 1546: 
<a name="1547"/> 1547: 
<a name="t_insert_list_kill_process_do-1"/><a name="1548"/> 1548: <b>t_insert_list_kill_process_do</b>(Opts) -&gt;
<a name="1549"/> 1549:     [(fun(I) -&gt;
<a name="1550"/> 1550:               [(fun(Time) -&gt;
<a name="1551"/> 1551:                         T = ets_new(x,Opts),
<a name="1552"/> 1552:                         List = lists:seq(1,600000),
<a name="1553"/> 1553:                         TupleList = [{E,E} || E &lt;- List],
<a name="1554"/> 1554:                         Pid = spawn(fun() -&gt; I(T, TupleList) end),
<a name="1555"/> 1555:                         receive after Time -&gt; ok end,
<a name="1556"/> 1556:                         exit(Pid, kill),
<a name="1557"/> 1557:                         ets:delete(T)
<a name="1558"/> 1558:                 end)(TheTime) || TheTime &lt;- [1,3,5] ++ lists:seq(7,29,7)]
<a name="1559"/> 1559:       end)(InsertFun) || InsertFun &lt;- [fun ets:insert/2,
<a name="1560"/> 1560:                                        fun ets:insert_new/2]],
<a name="t_insert_list_kill_process_do-last_expr"/><a name="1561"/> 1561:     ok.
<a name="1562"/> 1562: 
<a name="t_insert_list_insert_order_preserved-1"/><a name="1563"/> 1563: <b>t_insert_list_insert_order_preserved</b>(Config) when is_list(Config) -&gt;
<a name="1564"/> 1564:     insert_list_insert_order_preserved(bag),
<a name="1565"/> 1565:     insert_list_insert_order_preserved(duplicate_bag),
<a name="t_insert_list_insert_order_preserved-last_expr"/><a name="1566"/> 1566:     ok.
<a name="1567"/> 1567: 
<a name="insert_list_insert_order_preserved-1"/><a name="1568"/> 1568: <b>insert_list_insert_order_preserved</b>(Type) -&gt;
<a name="1569"/> 1569:     Tab = ets:new(?FUNCTION_NAME, [Type]),
<a name="1570"/> 1570:     K = a,
<a name="1571"/> 1571:     Values1 = [{K, 1}, {K, 2}, {K, 3}],
<a name="1572"/> 1572:     Values2 = [{K, 4}, {K, 5}, {K, 6}],
<a name="1573"/> 1573:     ets:insert(Tab, Values1),
<a name="1574"/> 1574:     ets:insert(Tab, Values2),
<a name="1575"/> 1575:     [{K, 1}, {K, 2}, {K, 3}, {K, 4}, {K, 5}, {K, 6}] = ets:lookup(Tab, K),
<a name="1576"/> 1576: 
<a name="1577"/> 1577:     ets:delete(Tab, K),
<a name="1578"/> 1578:     [] = ets:lookup(Tab, K),
<a name="1579"/> 1579: 
<a name="1580"/> 1580:     %% Insert order in duplicate_bag depended on reductions left
<a name="1581"/> 1581:     ITERATIONS_PER_RED = 8,
<a name="1582"/> 1582:     NTuples = 4000 * ITERATIONS_PER_RED + 10,
<a name="1583"/> 1583:     LongList = [{K, V} || V &lt;- lists:seq(1, NTuples)],
<a name="1584"/> 1584:     ets:insert(Tab, LongList),
<a name="1585"/> 1585:     LongList = ets:lookup(Tab, K),
<a name="1586"/> 1586: 
<a name="insert_list_insert_order_preserved-last_expr"/><a name="1587"/> 1587: <b>    ets:delete</b>(Tab).
<a name="1588"/> 1588: 
<a name="1589"/> 1589: <i>%% Test interface of ets:test_ms/2.</i>
<a name="t_test_ms-1"/><a name="1590"/> 1590: <b>t_test_ms</b>(Config) when is_list(Config) -&gt;
<a name="1591"/> 1591:     EtsMem = etsmem(),
<a name="1592"/> 1592:     {ok,[a,b]} = ets:test_ms({a,b},
<a name="1593"/> 1593: 			     [{{'$1','$2'},[{'&lt;','$1','$2'}],['$$']}]),
<a name="1594"/> 1594:     {ok,false} = ets:test_ms({a,b},
<a name="1595"/> 1595: 			     [{{'$1','$2'},[{'&gt;','$1','$2'}],['$$']}]),
<a name="1596"/> 1596:     Tpl = {a,gb_sets:new()},
<a name="1597"/> 1597:     {ok,Tpl} = ets:test_ms(Tpl, [{{'_','_'},  [], ['$_']}]), % OTP-10190
<a name="1598"/> 1598:     {error,[{error,String}]} = ets:test_ms({a,b},
<a name="1599"/> 1599: 					   [{{'$1','$2'},
<a name="1600"/> 1600: 					     [{'flurp','$1','$2'}],
<a name="1601"/> 1601: 					     ['$$']}]),
<a name="1602"/> 1602:     true = (if is_list(String) -&gt; true; true -&gt; false end),
<a name="t_test_ms-last_expr"/><a name="1603"/> 1603: <b>    verify_etsmem</b>(EtsMem).
<a name="1604"/> 1604: 
<a name="1605"/> 1605: <i>%% Test the select reverse BIFs.</i>
<a name="t_select_reverse-1"/><a name="1606"/> 1606: <b>t_select_reverse</b>(Config) when is_list(Config) -&gt;
<a name="1607"/> 1607:     Table = ets_new(xxx, [ordered_set]),
<a name="1608"/> 1608:     filltabint(Table,1000),
<a name="1609"/> 1609:     A = lists:reverse(ets:select(Table,[{{'$1', '_'},
<a name="1610"/> 1610: 					 [{'&gt;',
<a name="1611"/> 1611: 					   {'rem',
<a name="1612"/> 1612: 					    '$1', 5},
<a name="1613"/> 1613: 					   2}],
<a name="1614"/> 1614: 					 ['$_']}])),
<a name="1615"/> 1615:     A = ets:select_reverse(Table,[{{'$1', '_'},
<a name="1616"/> 1616: 				   [{'&gt;',
<a name="1617"/> 1617: 				     {'rem',
<a name="1618"/> 1618: 				      '$1', 5},
<a name="1619"/> 1619: 				     2}],
<a name="1620"/> 1620: 				   ['$_']}]),
<a name="1621"/> 1621:     A = reverse_chunked(Table,[{{'$1', '_'},
<a name="1622"/> 1622: 				[{'&gt;',
<a name="1623"/> 1623: 				  {'rem',
<a name="1624"/> 1624: 				   '$1', 5},
<a name="1625"/> 1625: 				  2}],
<a name="1626"/> 1626: 				['$_']}],3),
<a name="1627"/> 1627:     %% A set/bag/duplicate_bag should get the same result regardless
<a name="1628"/> 1628:     %% of select or select_reverse
<a name="1629"/> 1629:     Table2 = ets_new(xxx, [set]),
<a name="1630"/> 1630:     filltabint(Table2,1000),
<a name="1631"/> 1631:     Table3 = ets_new(xxx, [bag]),
<a name="1632"/> 1632:     filltabint(Table3,1000),
<a name="1633"/> 1633:     Table4 = ets_new(xxx, [duplicate_bag]),
<a name="1634"/> 1634:     filltabint(Table4,1000),
<a name="1635"/> 1635:     lists:map(fun(Tab) -&gt;
<a name="1636"/> 1636: 		      B = ets:select(Tab,[{{'$1', '_'},
<a name="1637"/> 1637: 					   [{'&gt;',
<a name="1638"/> 1638: 					     {'rem',
<a name="1639"/> 1639: 					      '$1', 5},
<a name="1640"/> 1640: 					     2}],
<a name="1641"/> 1641: 					   ['$_']}]),
<a name="1642"/> 1642: 		      B = ets:select_reverse(Tab,[{{'$1', '_'},
<a name="1643"/> 1643: 						   [{'&gt;',
<a name="1644"/> 1644: 						     {'rem',
<a name="1645"/> 1645: 						      '$1', 5},
<a name="1646"/> 1646: 						     2}],
<a name="1647"/> 1647: 						   ['$_']}])
<a name="1648"/> 1648: 	      end,[Table2, Table3, Table4]),
<a name="t_select_reverse-last_expr"/><a name="1649"/> 1649:     ok.
<a name="1650"/> 1650: 
<a name="1651"/> 1651: 
<a name="1652"/> 1652: 
<a name="reverse_chunked-3"/><a name="1653"/> 1653: <b>reverse_chunked</b>(T,MS,N) -&gt;
<a name="reverse_chunked-last_expr"/><a name="1654"/> 1654: <b>    do_reverse_chunked</b>(ets:select_reverse(T,MS,N),[]).
<a name="1655"/> 1655: 
<a name="do_reverse_chunked-2"/><a name="1656"/> 1656: <b>do_reverse_chunked</b>('$end_of_table',Acc) -&gt;
<a name="1657"/> 1657:     lists:reverse(Acc);
<a name="1658"/> 1658: <b>do_reverse_chunked</b>({L,C},Acc) -&gt;
<a name="1659"/> 1659:     NewAcc = lists:reverse(L)++Acc,
<a name="do_reverse_chunked-last_expr"/><a name="1660"/> 1660: <b>    do_reverse_chunked</b>(ets:select_reverse(C), NewAcc).
<a name="1661"/> 1661: 
<a name="1662"/> 1662: 
<a name="1663"/> 1663: <i>%% Test the ets:select_delete/2 and ets:select_count/2 BIFs.</i>
<a name="t_select_delete-1"/><a name="1664"/> 1664: <b>t_select_delete</b>(Config) when is_list(Config) -&gt;
<a name="1665"/> 1665:     ct:timetrap({minutes,30}), %% valgrind needs a lot
<a name="1666"/> 1666:     EtsMem = etsmem(),
<a name="1667"/> 1667:     Tables = fill_sets_int(10000) ++ fill_sets_int(10000,[{write_concurrency,true}]),
<a name="1668"/> 1668:     lists:foreach
<a name="1669"/> 1669:       (fun(Table) -&gt;
<a name="1670"/> 1670: 	       4000 = ets:select_count(Table,[{{'$1', '_'},
<a name="1671"/> 1671: 					       [{'&gt;',
<a name="1672"/> 1672: 						 {'rem',
<a name="1673"/> 1673: 						  '$1', 5},
<a name="1674"/> 1674: 						 2}],
<a name="1675"/> 1675: 					       [true]}]),
<a name="1676"/> 1676: 	       4000 = ets:select_delete(Table,[{{'$1', '_'},
<a name="1677"/> 1677: 						[{'&gt;',
<a name="1678"/> 1678: 						  {'rem',
<a name="1679"/> 1679: 						   '$1', 5},
<a name="1680"/> 1680: 						  2}],
<a name="1681"/> 1681: 						[true]}]),
<a name="1682"/> 1682: 	       check(Table,
<a name="1683"/> 1683: 		     fun({N,_}) when (N rem 5) =&lt; 2 -&gt;
<a name="1684"/> 1684: 			     true;
<a name="1685"/> 1685: 			(_) -&gt;
<a name="1686"/> 1686: 			     false
<a name="1687"/> 1687: 		     end,
<a name="1688"/> 1688: 		     6000)
<a name="1689"/> 1689: 
<a name="1690"/> 1690:        end,
<a name="1691"/> 1691:        Tables),
<a name="1692"/> 1692:     lists:foreach
<a name="1693"/> 1693:       (fun(Table) -&gt;
<a name="1694"/> 1694: 	       ets:select_delete(Table,[{'_',[],[true]}]),
<a name="1695"/> 1695: 	       xfilltabint(Table,4000),
<a name="1696"/> 1696: 	       successive_delete(Table,1,4001,bound),
<a name="1697"/> 1697: 	       0 = ets:info(Table,size),
<a name="1698"/> 1698: 	       xfilltabint(Table,4000),
<a name="1699"/> 1699: 	       successive_delete(Table,4000,0, bound),
<a name="1700"/> 1700: 	       0 = ets:info(Table,size),
<a name="1701"/> 1701: 	       xfilltabint(Table,4000),
<a name="1702"/> 1702: 	       successive_delete(Table,1,4001,unbound),
<a name="1703"/> 1703: 	       0 = ets:info(Table,size),
<a name="1704"/> 1704: 	       xfilltabint(Table,4000),
<a name="1705"/> 1705: 	       successive_delete(Table,4000,0, unbound),
<a name="1706"/> 1706: 	       0 = ets:info(Table,size)
<a name="1707"/> 1707: 
<a name="1708"/> 1708:        end,
<a name="1709"/> 1709:        Tables),
<a name="1710"/> 1710:     lists:foreach
<a name="1711"/> 1711:       (fun(Table) -&gt;
<a name="1712"/> 1712: 	       F = case ets:info(Table,type) of
<a name="1713"/> 1713: 		       X when X == bag; X == duplicate_bag -&gt;
<a name="1714"/> 1714: 			   2;
<a name="1715"/> 1715: 		       _ -&gt;
<a name="1716"/> 1716: 			   1
<a name="1717"/> 1717: 		   end,
<a name="1718"/> 1718: 	       xfilltabstr(Table, 4000),
<a name="1719"/> 1719: 	       1000 = ets:select_count(Table,
<a name="1720"/> 1720: 				       [{{[$3 | '$1'], '_'},
<a name="1721"/> 1721: 					 [{'==',
<a name="1722"/> 1722: 					   {'length', '$1'},
<a name="1723"/> 1723: 					   3}],[true]}]) div F,
<a name="1724"/> 1724: 	       1000 = ets:select_delete(Table,
<a name="1725"/> 1725: 					[{{[$3 | '$1'], '_'},
<a name="1726"/> 1726: 					  [{'==',
<a name="1727"/> 1727: 					    {'length', '$1'},
<a name="1728"/> 1728: 					    3}],[true]}]) div F,
<a name="1729"/> 1729: 	       check(Table, fun({[3,_,_,_],_}) -&gt; false;
<a name="1730"/> 1730: 			       (_) -&gt; true
<a name="1731"/> 1731: 			    end, 3000*F),
<a name="1732"/> 1732: 	       8 = ets:select_count(Table,
<a name="1733"/> 1733: 				    [{{&quot;7&quot;,'_'},[],[false]},
<a name="1734"/> 1734: 				     {{['_'], '_'},
<a name="1735"/> 1735: 				      [],[true]}]) div F,
<a name="1736"/> 1736: 	       8 = ets:select_delete(Table,
<a name="1737"/> 1737: 				     [{{&quot;7&quot;,'_'},[],[false]},
<a name="1738"/> 1738: 				      {{['_'], '_'},
<a name="1739"/> 1739: 				       [],[true]}]) div F,
<a name="1740"/> 1740: 	       check(Table, fun({&quot;7&quot;,_}) -&gt; true;
<a name="1741"/> 1741: 			       ({[_],_}) -&gt; false;
<a name="1742"/> 1742: 			       (_) -&gt; true
<a name="1743"/> 1743: 			    end, 2992*F),
<a name="1744"/> 1744: 	       xfilltabstr(Table, 4000),
<a name="1745"/> 1745: 	       %% This happens to be interesting for other select types too
<a name="1746"/> 1746: 	       200 = length(ets:select(Table,
<a name="1747"/> 1747: 				       [{{[$3,'_','_'],'_'},
<a name="1748"/> 1748: 					 [],[true]},
<a name="1749"/> 1749: 					{{[$1,'_','_'],'_'},
<a name="1750"/> 1750: 					 [],[true]}])) div F,
<a name="1751"/> 1751: 	       200 = ets:select_count(Table,
<a name="1752"/> 1752: 				      [{{[$3,'_','_'],'_'},
<a name="1753"/> 1753: 					[],[true]},
<a name="1754"/> 1754: 				       {{[$1,'_','_'],'_'},
<a name="1755"/> 1755: 					[],[true]}]) div F,
<a name="1756"/> 1756: 	       200 = length(element(1,ets:select(Table,
<a name="1757"/> 1757: 						 [{{[$3,'_','_'],'_'},
<a name="1758"/> 1758: 						   [],[true]},
<a name="1759"/> 1759: 						  {{[$1,'_','_'],'_'},
<a name="1760"/> 1760: 						   [],[true]}],
<a name="1761"/> 1761: 						 1000))) div F,
<a name="1762"/> 1762: 	       200 = length(
<a name="1763"/> 1763: 		       ets:select_reverse(Table,
<a name="1764"/> 1764: 					  [{{[$3,'_','_'],'_'},
<a name="1765"/> 1765: 					    [],[true]},
<a name="1766"/> 1766: 					   {{[$1,'_','_'],'_'},
<a name="1767"/> 1767: 					    [],[true]}])) div F,
<a name="1768"/> 1768: 	       200 = length(
<a name="1769"/> 1769: 		       element(1,
<a name="1770"/> 1770: 			       ets:select_reverse
<a name="1771"/> 1771: 				 (Table,
<a name="1772"/> 1772: 				  [{{[$3,'_','_'],'_'},
<a name="1773"/> 1773: 				    [],[true]},
<a name="1774"/> 1774: 				   {{[$1,'_','_'],'_'},
<a name="1775"/> 1775: 				    [],[true]}],
<a name="1776"/> 1776: 				  1000))) div F,
<a name="1777"/> 1777: 	       200 = ets:select_delete(Table,
<a name="1778"/> 1778: 				       [{{[$3,'_','_'],'_'},
<a name="1779"/> 1779: 					 [],[true]},
<a name="1780"/> 1780: 					{{[$1,'_','_'],'_'},
<a name="1781"/> 1781: 					 [],[true]}]) div F,
<a name="1782"/> 1782: 	       0 = ets:select_count(Table,
<a name="1783"/> 1783: 				    [{{[$3,'_','_'],'_'},
<a name="1784"/> 1784: 				      [],[true]},
<a name="1785"/> 1785: 				     {{[$1,'_','_'],'_'},
<a name="1786"/> 1786: 				      [],[true]}]) div F,
<a name="1787"/> 1787: 	       check(Table, fun({[$3,_,_],_}) -&gt; false;
<a name="1788"/> 1788: 			       ({[$1,_,_],_}) -&gt; false;
<a name="1789"/> 1789: 			       (_) -&gt; true
<a name="1790"/> 1790: 			    end, 3800*F)
<a name="1791"/> 1791:        end,
<a name="1792"/> 1792:        Tables),
<a name="1793"/> 1793:     lists:foreach(fun(Tab) -&gt; ets:delete(Tab) end,Tables),
<a name="t_select_delete-last_expr"/><a name="1794"/> 1794: <b>    verify_etsmem</b>(EtsMem).
<a name="1795"/> 1795: 
<a name="1796"/> 1796: <i>%% Tests the ets:select_replace/2 BIF</i>
<a name="t_select_replace-1"/><a name="1797"/> 1797: <b>t_select_replace</b>(Config) when is_list(Config) -&gt;
<a name="1798"/> 1798:     EtsMem = etsmem(),
<a name="1799"/> 1799:     repeat_for_opts(fun do_select_replace/1),
<a name="t_select_replace-last_expr"/><a name="1800"/> 1800: <b>    verify_etsmem</b>(EtsMem).
<a name="1801"/> 1801: 
<a name="do_select_replace-1"/><a name="1802"/> 1802: <b>do_select_replace</b>(Opts) -&gt;
<a name="1803"/> 1803:     Tables = fill_sets_intup(10000, Opts),
<a name="1804"/> 1804: 
<a name="1805"/> 1805:     TestFun = fun (Table, TableType) when TableType =:= bag -&gt;
<a name="1806"/> 1806:                       % Operation not supported; bag implementation
<a name="1807"/> 1807:                       % presented both semantic consistency and performance issues.
<a name="1808"/> 1808:                       10000 = ets:select_delete(Table, [{'_',[],[true]}]);
<a name="1809"/> 1809: 
<a name="1810"/> 1810:                   (Table, TableType) -&gt;
<a name="1811"/> 1811:                       % Invalid replacement doesn't keep the key
<a name="1812"/> 1812:                       MatchSpec1 = [{{{'$1','$3'}, '$2'},
<a name="1813"/> 1813:                                      [{'=:=', {'band', '$1', 2#11}, 2#11},
<a name="1814"/> 1814:                                       {'=/=', {'hd', '$2'}, $x}],
<a name="1815"/> 1815:                                      [{{{{'$2','$3'}}, '$1'}}]}],
<a name="1816"/> 1816:                       {'EXIT',{badarg,_}} = (catch ets:select_replace(Table, MatchSpec1)),
<a name="1817"/> 1817: 
<a name="1818"/> 1818:                       % Invalid replacement doesn't keep the key (even though it would be the same value)
<a name="1819"/> 1819:                       MatchSpec2 = [{{{'$1','$3'}, '$2'},
<a name="1820"/> 1820:                                      [{'=:=', {'band', '$1', 2#11}, 2#11}],
<a name="1821"/> 1821:                                      [{{{{{'+', '$1', 0},'$3'}}, '$2'}}]},
<a name="1822"/> 1822:                                     {{{'$1','$3'}, '$2'},
<a name="1823"/> 1823:                                      [{'=/=', {'band', '$1', 2#11}, 2#11}],
<a name="1824"/> 1824:                                      [{{{{{'-', '$1', 0},'$3'}}, '$2'}}]}],
<a name="1825"/> 1825:                       {'EXIT',{badarg,_}} = (catch ets:select_replace(Table, MatchSpec2)),
<a name="1826"/> 1826: 
<a name="1827"/> 1827:                       % Invalid replacement changes key to float equivalent
<a name="1828"/> 1828:                       MatchSpec3 = [{{{'$1','$3'}, '$2'},
<a name="1829"/> 1829:                                      [{'=:=', {'band', '$1', 2#11}, 2#11},
<a name="1830"/> 1830:                                       {'=/=', {'hd', '$2'}, $x}],
<a name="1831"/> 1831:                                      [{{{{{'*', '$1', 1.0},'$3'}}, '$2'}}]}],
<a name="1832"/> 1832:                       {'EXIT',{badarg,_}} = (catch ets:select_replace(Table, MatchSpec3)),
<a name="1833"/> 1833: 
<a name="1834"/> 1834:                       % Replacements are differently-sized tuples
<a name="1835"/> 1835:                       MatchSpec4_A = [{{{'$1','$3'},'$2'},
<a name="1836"/> 1836:                                        [{'&lt;', {'rem', '$1', 5}, 2}],
<a name="1837"/> 1837:                                        [{{{{'$1','$3'}}, [$x | '$2'], stuff}}]}],
<a name="1838"/> 1838:                       MatchSpec4_B = [{{{'$1','$3'},'$2','_'},
<a name="1839"/> 1839:                                        [],
<a name="1840"/> 1840:                                        [{{{{'$1','$3'}},'$2'}}]}],
<a name="1841"/> 1841:                       4000 = ets:select_replace(Table, MatchSpec4_A),
<a name="1842"/> 1842:                       4000 = ets:select_replace(Table, MatchSpec4_B),
<a name="1843"/> 1843: 
<a name="1844"/> 1844:                       % Replacement is the same tuple
<a name="1845"/> 1845:                       MatchSpec5 = [{{{'$1','$3'}, '$2'},
<a name="1846"/> 1846:                                      [{'&gt;', {'rem', '$1', 5}, 3}],
<a name="1847"/> 1847:                                      ['$_']}],
<a name="1848"/> 1848:                       2000 = ets:select_replace(Table, MatchSpec5),
<a name="1849"/> 1849: 
<a name="1850"/> 1850:                       % Replacement reconstructs an equal tuple
<a name="1851"/> 1851:                       MatchSpec6 = [{{{'$1','$3'}, '$2'},
<a name="1852"/> 1852:                                      [{'&gt;', {'rem', '$1', 5}, 3}],
<a name="1853"/> 1853:                                      [{{{{'$1','$3'}}, '$2'}}]}],
<a name="1854"/> 1854:                       2000 = ets:select_replace(Table, MatchSpec6),
<a name="1855"/> 1855: 
<a name="1856"/> 1856:                       % Replacement uses {element,KeyPos,T} for key
<a name="1857"/> 1857:                       2000 = ets:select_replace(Table,
<a name="1858"/> 1858:                                                 [{{{'$1','$3'}, '$2'},
<a name="1859"/> 1859:                                                   [{'&gt;', {'rem', '$1', 5}, 3}],
<a name="1860"/> 1860:                                                   [{{{element, 1, '$_'}, '$2'}}]}]),
<a name="1861"/> 1861: 
<a name="1862"/> 1862:                       % Replacement uses wrong {element,KeyPos,T} for key
<a name="1863"/> 1863:                       {'EXIT',{badarg,_}} = (catch ets:select_replace(Table,
<a name="1864"/> 1864:                                                                      [{{{'$1','$3'}, '$2'},
<a name="1865"/> 1865:                                                                        [],
<a name="1866"/> 1866:                                                                        [{{{element, 2, '$_'}, '$2'}}]}])),
<a name="1867"/> 1867: 
<a name="1868"/> 1868:                       check(Table,
<a name="1869"/> 1869:                             fun ({{N,_}, [$x, C | _]}) when ((N rem 5) &lt; 2) -&gt; (C &gt;= $0) andalso (C =&lt; $9);
<a name="1870"/> 1870:                                 ({{N,_}, [C | _]}) when is_float(N) -&gt; (C &gt;= $0) andalso (C =&lt; $9);
<a name="1871"/> 1871:                                 ({{N,_}, [C | _]}) when ((N rem 5) &gt; 3) -&gt; (C &gt;= $0) andalso (C =&lt; $9);
<a name="1872"/> 1872:                                 ({_, [C | _]}) -&gt; (C &gt;= $0) andalso (C =&lt; $9)
<a name="1873"/> 1873:                             end,
<a name="1874"/> 1874:                             10000),
<a name="1875"/> 1875: 
<a name="1876"/> 1876:                       % Replace unbound range (&gt;)
<a name="1877"/> 1877:                       MatchSpec7 = [{{{'$1','$3'}, '$2'},
<a name="1878"/> 1878:                                      [{'&gt;', '$1', 7000}],
<a name="1879"/> 1879:                                      [{{{{'$1','$3'}}, {{gt_range, '$2'}}}}]}],
<a name="1880"/> 1880:                       3000 = ets:select_replace(Table, MatchSpec7),
<a name="1881"/> 1881: 
<a name="1882"/> 1882:                       % Replace unbound range (&lt;)
<a name="1883"/> 1883:                       MatchSpec8 = [{{{'$1','$3'}, '$2'},
<a name="1884"/> 1884:                                      [{'&lt;', '$1', 3000}],
<a name="1885"/> 1885:                                      [{{{{'$1','$3'}}, {{le_range, '$2'}}}}]}],
<a name="1886"/> 1886:                       case TableType of
<a name="1887"/> 1887:                           ordered_set -&gt;   2999 = ets:select_replace(Table, MatchSpec8);
<a name="1888"/> 1888:                           set -&gt;           2999 = ets:select_replace(Table, MatchSpec8);
<a name="1889"/> 1889:                           duplicate_bag -&gt; 2998 = ets:select_replace(Table, MatchSpec8)
<a name="1890"/> 1890:                       end,
<a name="1891"/> 1891: 
<a name="1892"/> 1892:                       % Replace bound range
<a name="1893"/> 1893:                       MatchSpec9 = [{{{'$1','$3'}, '$2'},
<a name="1894"/> 1894:                                      [{'&gt;=', '$1', 3001},
<a name="1895"/> 1895:                                       {'&lt;', '$1', 7000}],
<a name="1896"/> 1896:                                      [{{{{'$1','$3'}}, {{range, '$2'}}}}]}],
<a name="1897"/> 1897:                       case TableType of
<a name="1898"/> 1898:                           ordered_set -&gt;   3999 = ets:select_replace(Table, MatchSpec9);
<a name="1899"/> 1899:                           set -&gt;           3999 = ets:select_replace(Table, MatchSpec9);
<a name="1900"/> 1900:                           duplicate_bag -&gt; 3998 = ets:select_replace(Table, MatchSpec9)
<a name="1901"/> 1901:                       end,
<a name="1902"/> 1902: 
<a name="1903"/> 1903:                       % Replace particular keys
<a name="1904"/> 1904:                       MatchSpec10 = [{{{'$1','$3'}, '$2'},
<a name="1905"/> 1905:                                      [{'==', '$1', 3000}],
<a name="1906"/> 1906:                                      [{{{{'$1','$3'}}, {{specific1, '$2'}}}}]},
<a name="1907"/> 1907:                                     {{{'$1','$3'}, '$2'},
<a name="1908"/> 1908:                                      [{'==', '$1', 7000}],
<a name="1909"/> 1909:                                      [{{{{'$1','$3'}}, {{specific2, '$2'}}}}]}],
<a name="1910"/> 1910:                       case TableType of
<a name="1911"/> 1911:                           ordered_set -&gt;   2 = ets:select_replace(Table, MatchSpec10);
<a name="1912"/> 1912:                           set -&gt;           2 = ets:select_replace(Table, MatchSpec10);
<a name="1913"/> 1913:                           duplicate_bag -&gt; 4 = ets:select_replace(Table, MatchSpec10)
<a name="1914"/> 1914:                       end,
<a name="1915"/> 1915: 
<a name="1916"/> 1916:                       check(Table,
<a name="1917"/> 1917:                             fun ({{N,_}, {gt_range, _}}) -&gt; N &gt; 7000;
<a name="1918"/> 1918:                                 ({{N,_}, {le_range, _}}) -&gt; N &lt; 3000;
<a name="1919"/> 1919:                                 ({{N,_}, {range, _}}) -&gt; (N &gt;= 3001) andalso (N &lt; 7000);
<a name="1920"/> 1920:                                 ({{N,_}, {specific1, _}}) -&gt; N == 3000;
<a name="1921"/> 1921:                                 ({{N,_}, {specific2, _}}) -&gt; N == 7000
<a name="1922"/> 1922:                             end,
<a name="1923"/> 1923:                             10000),
<a name="1924"/> 1924: 
<a name="1925"/> 1925:                       10000 = ets:select_delete(Table, [{'_',[],[true]}]),
<a name="1926"/> 1926:                       check(Table, fun (_) -&gt; false end, 0)
<a name="1927"/> 1927:               end,
<a name="1928"/> 1928: 
<a name="1929"/> 1929:     lists:foreach(
<a name="1930"/> 1930:       fun(Table) -&gt;
<a name="1931"/> 1931:               TestFun(Table, ets:info(Table, type)),
<a name="1932"/> 1932:               ets:delete(Table)
<a name="1933"/> 1933:       end,
<a name="1934"/> 1934:       Tables),
<a name="1935"/> 1935: 
<a name="1936"/> 1936:     %% Test key-safe match-specs are accepted
<a name="1937"/> 1937:     BigNum = (123 bsl 123),
<a name="1938"/> 1938:     RefcBin = list_to_binary(lists:seq(1,?heap_binary_size+1)),
<a name="1939"/> 1939:     Terms = [a, &quot;hej&quot;, 123, 1.23, BigNum , &lt;&lt;&quot;123&quot;&gt;&gt;, RefcBin, TestFun, self()],
<a name="1940"/> 1940:     EqPairs = fun(X,Y) -&gt;
<a name="1941"/> 1941:                       [{ '$1', '$1'},
<a name="1942"/> 1942:                        { {X, Y}, {{X, Y}}},
<a name="1943"/> 1943:                        { {'$1', Y}, {{'$1', Y}}},
<a name="1944"/> 1944:                        { {{X, Y}}, {{{{X, Y}}}}},
<a name="1945"/> 1945:                        { {X}, {{X}}},
<a name="1946"/> 1946:                        { X, {const, X}},
<a name="1947"/> 1947:                        { {X,Y}, {const, {X,Y}}},
<a name="1948"/> 1948:                        { {X}, {const, {X}}},
<a name="1949"/> 1949:                        { {X, Y}, {{X, {const, Y}}}},
<a name="1950"/> 1950:                        { {X, {Y,'$1'}}, {{{const, X}, {{Y,'$1'}}}}},
<a name="1951"/> 1951:                        { [X, Y | '$1'], [X, Y | '$1']},
<a name="1952"/> 1952:                        { [{X, '$1'}, Y], [{{X, '$1'}}, Y]},
<a name="1953"/> 1953:                        { [{X, Y} | '$1'], [{const, {X, Y}} | '$1']},
<a name="1954"/> 1954:                        { [$p,$r,$e,$f,$i,$x | '$1'], [$p,$r,$e,$f,$i,$x | '$1']},
<a name="1955"/> 1955:                        { {[{X,Y}]}, {{[{{X,Y}}]}}},
<a name="1956"/> 1956:                        { {[{X,Y}]}, {{{const, [{X,Y}]}}}},
<a name="1957"/> 1957:                        { {[{X,Y}]}, {{[{const,{X,Y}}]}}}
<a name="1958"/> 1958:                       ]
<a name="1959"/> 1959:               end,
<a name="1960"/> 1960: 
<a name="1961"/> 1961:     T2 = ets:new(x, Opts),
<a name="1962"/> 1962:     [lists:foreach(fun({A, B}) -&gt;
<a name="1963"/> 1963:                            %% just check that matchspec is accepted
<a name="1964"/> 1964:                            0 = ets:select_replace(T2, [{{A, '$2', '$3'}, [], [{{B, '$3', '$2'}}]}])
<a name="1965"/> 1965:                    end,
<a name="1966"/> 1966:                    EqPairs(X,Y)) || X &lt;- Terms, Y &lt;- Terms],
<a name="1967"/> 1967: 
<a name="1968"/> 1968:     %% Test key-unsafe matchspecs are rejected
<a name="1969"/> 1969:     NeqPairs = fun(X, Y) -&gt;
<a name="1970"/> 1970:                       [{'$1', '$2'},
<a name="1971"/> 1971:                        {{X, Y}, {X, Y}},
<a name="1972"/> 1972:                        {{{X, Y}}, {{{X, Y}}}},
<a name="1973"/> 1973:                        {{X}, {{{X}}}},
<a name="1974"/> 1974:                        {{const, X}, {const, X}},
<a name="1975"/> 1975:                        {{const, {X,Y}}, {const, {X,Y}}},
<a name="1976"/> 1976:                        {'$1', {const, '$1'}},
<a name="1977"/> 1977:                        {{X}, {const, {{X}}}},
<a name="1978"/> 1978:                        {{X, {Y,'$1'}}, {{{const, X}, {Y,'$1'}}}},
<a name="1979"/> 1979:                        {[X, Y | '$1'], [X, Y]},
<a name="1980"/> 1980:                        {[X, Y], [X, Y | '$1']},
<a name="1981"/> 1981:                        {[{X, '$1'}, Y], [{X, '$1'}, Y]},
<a name="1982"/> 1982:                        {[$p,$r,$e,$f,$i,$x | '$1'], [$p,$r,$e,$f,$I,$x | '$1']},
<a name="1983"/> 1983:                        { {[{X,Y}]}, {{[{X,Y}]}}},
<a name="1984"/> 1984:                        { {[{X,Y}]}, {{{const, [{{X,Y}}]}}}},
<a name="1985"/> 1985:                        { {[{X,Y}]}, {{[{const,{{X,Y}}}]}}},
<a name="1986"/> 1986:                        {'_', '_'},
<a name="1987"/> 1987:                        {'$_', '$_'},
<a name="1988"/> 1988:                        {'$$', '$$'},
<a name="1989"/> 1989:                        {#{}, #{}},
<a name="1990"/> 1990:                        {#{X =&gt; '$1'}, #{X =&gt; '$1'}}
<a name="1991"/> 1991:                       ]
<a name="1992"/> 1992:               end,
<a name="1993"/> 1993: 
<a name="1994"/> 1994:     [lists:foreach(fun({A, B}) -&gt;
<a name="1995"/> 1995:                            %% just check that matchspec is rejected
<a name="1996"/> 1996:                            {'EXIT',{badarg,_}} = (catch ets:select_replace(T2, [{{A, '$2', '$3'}, [], [{{B, '$3', '$2'}}]}]))
<a name="1997"/> 1997:                    end,
<a name="1998"/> 1998:                    NeqPairs(X,Y)) || X &lt;- Terms, Y &lt;- Terms],
<a name="1999"/> 1999: 
<a name="2000"/> 2000: 
<a name="2001"/> 2001:     %% Wrap entire tuple with 'const'
<a name="2002"/> 2002:     [[begin
<a name="2003"/> 2003:           Old = {Key, 1, 2},
<a name="2004"/> 2004:           ets:insert(T2, Old),
<a name="2005"/> 2005:           1 = ets:select_replace(T2, [{Old, [], [{const, New}]}]),
<a name="2006"/> 2006:           [New] = ets:lookup(T2, Key),
<a name="2007"/> 2007:           ets:delete(T2, Key)
<a name="2008"/> 2008:       end || New &lt;- [{Key, 1, 2}, {Key, 3, 4}, {Key, 1}, {Key, 1, 2, 3}, {Key}]
<a name="2009"/> 2009:      ]
<a name="2010"/> 2010:      || Key &lt;- [{1, tuple}, {nested, {tuple, {a,b}}} | Terms]],
<a name="2011"/> 2011: 
<a name="2012"/> 2012:     %% 'const' wrap does not work with maps or variables in keys
<a name="2013"/> 2013:     [[begin
<a name="2014"/> 2014:           Old = {Key, 1, 2},
<a name="2015"/> 2015:           {'EXIT',{badarg,_}} = (catch ets:select_replace(T2, [{Old, [], [{const, New}]}]))
<a name="2016"/> 2016:       end || New &lt;- [{Key, 1, 2}, {Key, 3, 4}, {Key, 1}, {Key, 1, 2, 3}, {Key}]
<a name="2017"/> 2017:      ]
<a name="2018"/> 2018:      || Key &lt;- [#{a =&gt; 1}, {nested, #{a =&gt; 1}}, '$1']],
<a name="2019"/> 2019: 
<a name="2020"/> 2020: 
<a name="2021"/> 2021:     ets:delete(T2),
<a name="do_select_replace-last_expr"/><a name="2022"/> 2022:     ok.
<a name="2023"/> 2023: 
<a name="2024"/> 2024: <i>%% OTP-15346: Bug caused select_replace of bound key to corrupt static stack</i>
<a name="2025"/> 2025: <i>%% used by ets:next and ets:prev.</i>
<a name="t_select_replace_next_bug-1"/><a name="2026"/> 2026: <b>t_select_replace_next_bug</b>(Config) when is_list(Config) -&gt;
<a name="2027"/> 2027:     T = ets:new(k, [ordered_set]),
<a name="2028"/> 2028:     [ets:insert(T, {I, value}) || I &lt;- lists:seq(1,10)],
<a name="2029"/> 2029:     1 = ets:first(T),
<a name="2030"/> 2030: 
<a name="2031"/> 2031:     %% Make sure select_replace does not leave pointer
<a name="2032"/> 2032:     %% to deallocated {2,value} in static stack.
<a name="2033"/> 2033:     MS = [{{2,value}, [], [{{2,&quot;new_value&quot;}}]}],
<a name="2034"/> 2034:     1 = ets:select_replace(T, MS),
<a name="2035"/> 2035: 
<a name="2036"/> 2036:     %% This would crash or give wrong result at least on DEBUG emulator
<a name="2037"/> 2037:     %% where deallocated memory is overwritten.
<a name="2038"/> 2038:     2 = ets:next(T, 1),
<a name="2039"/> 2039: 
<a name="t_select_replace_next_bug-last_expr"/><a name="2040"/> 2040: <b>    ets:delete</b>(T).
<a name="2041"/> 2041: 
<a name="2042"/> 2042: 
<a name="2043"/> 2043: <i>%% OTP-17379</i>
<a name="t_select_pam_stack_overflow_bug-1"/><a name="2044"/> 2044: <b>t_select_pam_stack_overflow_bug</b>(_Config) -&gt;
<a name="2045"/> 2045:     T = ets:new(k, []),
<a name="2046"/> 2046:     ets:insert(T,[{x,17}]),
<a name="2047"/> 2047:     [{x,18}] = ets:select(T,[{{x,17}, [], [{{{element,1,'$_'},{const,18}}}]}]),
<a name="2048"/> 2048:     ets:delete(T),
<a name="t_select_pam_stack_overflow_bug-last_expr"/><a name="2049"/> 2049:     ok.
<a name="2050"/> 2050: 
<a name="2051"/> 2051: <i>%% When a variable was used as key in ms body, the matched value would</i>
<a name="2052"/> 2052: <i>%% not be copied to the heap of the calling process.</i>
<a name="t_select_flatmap_term_copy_bug-1"/><a name="2053"/> 2053: <b>t_select_flatmap_term_copy_bug</b>(_Config) -&gt;
<a name="2054"/> 2054:     T = ets:new(a,[]),
<a name="2055"/> 2055:     ets:insert(T, {list_to_binary(lists:duplicate(36,$a))}),
<a name="2056"/> 2056:     V1 = ets:select(T, [{{'$1'},[],[#{ '$1' =&gt; a }]}]),
<a name="2057"/> 2057:     erlang:garbage_collect(),
<a name="2058"/> 2058:     V1 = ets:select(T, [{{'$1'},[],[#{ '$1' =&gt; a }]}]),
<a name="2059"/> 2059:     erlang:garbage_collect(),
<a name="2060"/> 2060:     V2 = ets:select(T, [{{'$1'},[],[#{ a =&gt; '$1' }]}]),
<a name="2061"/> 2061:     erlang:garbage_collect(),
<a name="2062"/> 2062:     V2 = ets:select(T, [{{'$1'},[],[#{ a =&gt; '$1' }]}]),
<a name="2063"/> 2063:     erlang:garbage_collect(),
<a name="2064"/> 2064:     V3 = ets:select(T, [{{'$1'},[],[#{ '$1' =&gt; '$1' }]}]),
<a name="2065"/> 2065:     erlang:garbage_collect(),
<a name="2066"/> 2066:     V3 = ets:select(T, [{{'$1'},[],[#{ '$1' =&gt; '$1' }]}]),
<a name="2067"/> 2067:     erlang:garbage_collect(),
<a name="2068"/> 2068:     V4 = ets:select(T, [{{'$1'},[],[#{ a =&gt; a }]}]),
<a name="2069"/> 2069:     erlang:garbage_collect(),
<a name="2070"/> 2070:     V4 = ets:select(T, [{{'$1'},[],[#{ a =&gt; a }]}]),
<a name="2071"/> 2071:     erlang:garbage_collect(),
<a name="2072"/> 2072:     ets:delete(T),
<a name="t_select_flatmap_term_copy_bug-last_expr"/><a name="2073"/> 2073:     ok.
<a name="2074"/> 2074: 
<a name="2075"/> 2075: <i>%% When a variable was used as key or value in ms body,</i>
<a name="2076"/> 2076: <i>%% the matched value would not be copied to the heap of</i>
<a name="2077"/> 2077: <i>%% the calling process.</i>
<a name="t_select_hashmap_term_copy_bug-1"/><a name="2078"/> 2078: <b>t_select_hashmap_term_copy_bug</b>(_Config) -&gt;
<a name="2079"/> 2079: 
<a name="2080"/> 2080:     T = ets:new(a,[]),
<a name="2081"/> 2081:     Dollar1 = list_to_binary(lists:duplicate(36,$a)),
<a name="2082"/> 2082:     ets:insert(T, {Dollar1}),
<a name="2083"/> 2083: 
<a name="2084"/> 2084:     {LargeMapSize, FlatmapSize} =
<a name="2085"/> 2085:         case erlang:system_info(emu_type) of
<a name="2086"/> 2086:             debug -&gt; {40, 3};
<a name="2087"/> 2087:             _ -&gt; {250, 32}
<a name="2088"/> 2088:         end,
<a name="2089"/> 2089: 
<a name="2090"/> 2090:     LM = maps:from_keys(lists:seq(1,LargeMapSize), 1),
<a name="2091"/> 2091: 
<a name="2092"/> 2092:     lists:foreach(
<a name="2093"/> 2093:       fun(Key) -&gt;
<a name="2094"/> 2094:               V = ets:select(T, [{{'$1'},[], [LM#{ Key =&gt; '$1' }]}]),
<a name="2095"/> 2095:               erlang:garbage_collect(),
<a name="2096"/> 2096:               V = ets:select(T, [{{'$1'},[], [LM#{ Key =&gt; '$1' }]}]),
<a name="2097"/> 2097:               erlang:garbage_collect(),
<a name="2098"/> 2098: 
<a name="2099"/> 2099:               V = [LM#{ Key =&gt; Dollar1 }]
<a name="2100"/> 2100:       end, maps:keys(LM)),
<a name="2101"/> 2101: 
<a name="2102"/> 2102:     %% Create a hashmap with enough keys before and after the '$1' for it to
<a name="2103"/> 2103:     %% remain a hashmap when we remove those keys.
<a name="2104"/> 2104:     LMWithDollar = make_lm_with_dollar(LM#{ '$1' =&gt; a }, LargeMapSize, FlatmapSize),
<a name="2105"/> 2105: 
<a name="2106"/> 2106:     %% Test that hashmap with '$1' in first position works
<a name="2107"/> 2107:     %% We rely on that fact that maps:keys return the keys
<a name="2108"/> 2108:     %% in iteration order.
<a name="2109"/> 2109:     lists:foldl(
<a name="2110"/> 2110:       fun
<a name="2111"/> 2111:           (Key, M = #{ '$1' := A }) when map_size(M) &gt; FlatmapSize -&gt;
<a name="2112"/> 2112: 
<a name="2113"/> 2113:               V = ets:select(T, [{{'$1'},[], [M]}]),
<a name="2114"/> 2114:               erlang:garbage_collect(),
<a name="2115"/> 2115:               V = ets:select(T, [{{'$1'},[], [M]}]),
<a name="2116"/> 2116:               erlang:garbage_collect(),
<a name="2117"/> 2117: 
<a name="2118"/> 2118:               V = [(maps:remove('$1',M))#{ Dollar1 =&gt; A }],
<a name="2119"/> 2119: 
<a name="2120"/> 2120:               maps:remove(Key, M);
<a name="2121"/> 2121:           (_, M) when map_size(M) &gt; FlatmapSize -&gt;
<a name="2122"/> 2122:               M
<a name="2123"/> 2123:       end, LMWithDollar, maps:keys(LMWithDollar)),
<a name="2124"/> 2124: 
<a name="2125"/> 2125:     %% Test that hashmap with '$1' in last position works
<a name="2126"/> 2126:     %% We rely on that fact that maps:keys return the keys
<a name="2127"/> 2127:     %% in iteration order.
<a name="2128"/> 2128:     lists:foldl(
<a name="2129"/> 2129:       fun
<a name="2130"/> 2130:           (Key, M = #{ '$1' := A }) -&gt;
<a name="2131"/> 2131: 
<a name="2132"/> 2132:               V = ets:select(T, [{{'$1'},[], [M]}]),
<a name="2133"/> 2133:               erlang:garbage_collect(),
<a name="2134"/> 2134:               V = ets:select(T, [{{'$1'},[], [M]}]),
<a name="2135"/> 2135:               erlang:garbage_collect(),
<a name="2136"/> 2136: 
<a name="2137"/> 2137:               V = [(maps:remove('$1',M))#{ Dollar1 =&gt; A }],
<a name="2138"/> 2138: 
<a name="2139"/> 2139:               maps:remove(Key, M);
<a name="2140"/> 2140:           (_, M) when map_size(M) &gt; FlatmapSize -&gt;
<a name="2141"/> 2141:               M
<a name="2142"/> 2142:       end, LMWithDollar, lists:reverse(maps:keys(LMWithDollar))),
<a name="2143"/> 2143: 
<a name="2144"/> 2144:     %% Test hashmap with a key-value pair that are variable
<a name="2145"/> 2145:     V3 = ets:select(T, [{{'$1'},[], [LM#{ '$1' =&gt; '$1' }]}]),
<a name="2146"/> 2146:     erlang:garbage_collect(),
<a name="2147"/> 2147:     V3 = ets:select(T, [{{'$1'},[], [LM#{ '$1' =&gt; '$1' }]}]),
<a name="2148"/> 2148:     erlang:garbage_collect(),
<a name="2149"/> 2149: 
<a name="2150"/> 2150:     V3 = [LM#{ Dollar1 =&gt; Dollar1 }],
<a name="2151"/> 2151: 
<a name="2152"/> 2152:     %% Test hashmap with all constant keys and values
<a name="2153"/> 2153:     V4 = ets:select(T, [{{'$1'},[], [LM#{ a =&gt; a }]}]),
<a name="2154"/> 2154:     erlang:garbage_collect(),
<a name="2155"/> 2155:     V4 = ets:select(T, [{{'$1'},[], [LM#{ a =&gt; a }]}]),
<a name="2156"/> 2156:     erlang:garbage_collect(),
<a name="2157"/> 2157: 
<a name="2158"/> 2158:     V4 = [LM#{ a =&gt; a }],
<a name="2159"/> 2159: 
<a name="2160"/> 2160:     ets:delete(T),
<a name="t_select_hashmap_term_copy_bug-last_expr"/><a name="2161"/> 2161:     ok.
<a name="2162"/> 2162: 
<a name="2163"/> 2163: <i>%% Create a hashmap that always has FlatmapSize keys before and after '$1'.</i>
<a name="2164"/> 2164: <i>%% Since the atom index of '$1' is used as hash, we cannot know before the</i>
<a name="2165"/> 2165: <i>%% code is run where exactly it will be placed, so in the rare cases when</i>
<a name="2166"/> 2166: <i>%% there isn't enough keys in the map, we insert more until there are enough.</i>
<a name="make_lm_with_dollar-3"/><a name="2167"/> 2167: <b>make_lm_with_dollar</b>(Map, LargeMapSize, FlatmapSize) -&gt;
<a name="2168"/> 2168:     {KeysBefore, KeysAfter} = lists:splitwith(fun erlang:is_integer/1, maps:keys(Map)),
<a name="make_lm_with_dollar-last_expr"/><a name="2169"/> 2169: <b>    if length</b>(KeysBefore) =&lt; FlatmapSize;
<a name="2170"/> 2170:        length(KeysAfter) - 1 =&lt; FlatmapSize -&gt;
<a name="2171"/> 2171:             NewMap = maps:from_keys(lists:seq(LargeMapSize, LargeMapSize*2), 1),
<a name="2172"/> 2172:             make_lm_with_dollar(maps:merge(Map, NewMap), LargeMapSize*2, FlatmapSize);
<a name="2173"/> 2173:        true -&gt;
<a name="2174"/> 2174:             Map
<a name="2175"/> 2175:     end.
<a name="2176"/> 2176: 
<a name="2177"/> 2177: <i>%% Test that partly bound keys gives faster matches.</i>
<a name="partly_bound-1"/><a name="2178"/> 2178: <b>partly_bound</b>(Config) when is_list(Config) -&gt;
<a name="partly_bound-last_expr"/><a name="2179"/> 2179: <b>    case os:type</b>() of
<a name="2180"/> 2180: 	{win32,_} -&gt;
<a name="2181"/> 2181: 	    {skip,&quot;Inaccurate measurements on Windows&quot;};
<a name="2182"/> 2182: 	_ -&gt;
<a name="2183"/> 2183: 	    EtsMem = etsmem(),
<a name="2184"/> 2184: 	    dont_make_worse(),
<a name="2185"/> 2185: 	    make_better(),
<a name="2186"/> 2186: 	    verify_etsmem(EtsMem)
<a name="2187"/> 2187:     end.
<a name="2188"/> 2188: 
<a name="dont_make_worse-0"/><a name="2189"/> 2189: <b>dont_make_worse</b>() -&gt;
<a name="dont_make_worse-last_expr"/><a name="2190"/> 2190: <b>    seventyfive_percent_success</b>(fun dont_make_worse_sub/0, 0, 0, 10).
<a name="2191"/> 2191: 
<a name="dont_make_worse_sub-0"/><a name="2192"/> 2192: <b>dont_make_worse_sub</b>() -&gt;
<a name="2193"/> 2193:     T = build_table([a,b],[a,b],15000),
<a name="2194"/> 2194:     T1 = time_match_object(T,{'_',a,a,1500}, [{{a,a,1500},a,a,1500}]),
<a name="2195"/> 2195:     T2 = time_match_object(T,{{a,a,'_'},a,a,1500},
<a name="2196"/> 2196: 			   [{{a,a,1500},a,a,1500}]),
<a name="2197"/> 2197:     ets:delete(T),
<a name="2198"/> 2198:     true = (T1 &gt; T2),
<a name="dont_make_worse_sub-last_expr"/><a name="2199"/> 2199:     ok.
<a name="2200"/> 2200: 
<a name="make_better-0"/><a name="2201"/> 2201: <b>make_better</b>() -&gt;
<a name="2202"/> 2202:     fifty_percent_success(fun make_better_sub2/0, 0, 0, 10),
<a name="make_better-last_expr"/><a name="2203"/> 2203: <b>    fifty_percent_success</b>(fun make_better_sub1/0, 0, 0, 10).
<a name="2204"/> 2204: 
<a name="make_better_sub1-0"/><a name="2205"/> 2205: <b>make_better_sub1</b>() -&gt;
<a name="2206"/> 2206:     T = build_table2([a,b],[a,b],15000),
<a name="2207"/> 2207:     T1 = time_match_object(T,{'_',1500,a,a}, [{{1500,a,a},1500,a,a}]),
<a name="2208"/> 2208:     T2 = time_match_object(T,{{1500,a,'_'},1500,a,a},
<a name="2209"/> 2209: 			   [{{1500,a,a},1500,a,a}]),
<a name="2210"/> 2210:     ets:delete(T),
<a name="2211"/> 2211:     io:format(&quot;~p&gt;~p~n&quot;,[(T1 / 100),T2]),
<a name="2212"/> 2212:     true = ((T1 / 100) &gt; T2), % More marginal than needed.
<a name="make_better_sub1-last_expr"/><a name="2213"/> 2213:     ok.
<a name="2214"/> 2214: 
<a name="make_better_sub2-0"/><a name="2215"/> 2215: <b>make_better_sub2</b>() -&gt;
<a name="2216"/> 2216:     T = build_table2([a,b],[a,b],15000),
<a name="2217"/> 2217:     T1 = time_match(T,{'$1',1500,a,a}),
<a name="2218"/> 2218:     T2 = time_match(T,{{1500,a,'$1'},1500,a,a}),
<a name="2219"/> 2219:     ets:delete(T),
<a name="2220"/> 2220:     io:format(&quot;~p&gt;~p~n&quot;,[(T1 / 100),T2]),
<a name="2221"/> 2221:     true = ((T1 / 100) &gt; T2), % More marginal than needed.
<a name="make_better_sub2-last_expr"/><a name="2222"/> 2222:     ok.
<a name="2223"/> 2223: 
<a name="2224"/> 2224: 
<a name="2225"/> 2225: <i>%% Heavy random matching, comparing set with ordered_set.</i>
<a name="match_heavy-1"/><a name="2226"/> 2226: <b>match_heavy</b>(Config) when is_list(Config) -&gt;
<a name="2227"/> 2227:     PrivDir = proplists:get_value(priv_dir,Config),
<a name="2228"/> 2228:     DataDir = proplists:get_value(data_dir, Config),
<a name="2229"/> 2229:     %% Easier to have in process dictionary when manually
<a name="2230"/> 2230:     %% running the test function.
<a name="2231"/> 2231:     put(where_to_read,DataDir),
<a name="2232"/> 2232:     put(where_to_write,PrivDir),
<a name="2233"/> 2233:     random_test(),
<a name="2234"/> 2234:     drop_match(),
<a name="match_heavy-last_expr"/><a name="2235"/> 2235:     ok.
<a name="2236"/> 2236: 
<a name="2237"/> 2237: <i>%%% Extra safety for the very low probability that this is not</i>
<a name="2238"/> 2238: <i>%%% caught by the random test (Statistically impossible???)</i>
<a name="drop_match-0"/><a name="2239"/> 2239: <b>drop_match</b>() -&gt;
<a name="2240"/> 2240:     EtsMem = etsmem(),
<a name="2241"/> 2241:     T = build_table([a,b],[a],1500),
<a name="2242"/> 2242:     [{{a,a,1},a,a,1},{{b,a,1},b,a,1}] =
<a name="2243"/> 2243: 	ets:match_object(T, {'_','_','_',1}),
<a name="2244"/> 2244:     true = ets:delete(T),
<a name="drop_match-last_expr"/><a name="2245"/> 2245: <b>    verify_etsmem</b>(EtsMem).
<a name="2246"/> 2246: 
<a name="2247"/> 2247: 
<a name="2248"/> 2248: 
<a name="ets_match-2"/><a name="2249"/> 2249: <b>ets_match</b>(Tab,Expr) -&gt;
<a name="ets_match-last_expr"/><a name="2250"/> 2250: <b>    case rand:uniform</b>(2) of
<a name="2251"/> 2251: 	1 -&gt;
<a name="2252"/> 2252: 	    ets:match(Tab,Expr);
<a name="2253"/> 2253: 	_ -&gt;
<a name="2254"/> 2254: 	    match_chunked(Tab,Expr)
<a name="2255"/> 2255:     end.
<a name="2256"/> 2256: 
<a name="match_chunked-2"/><a name="2257"/> 2257: <b>match_chunked</b>(Tab,Expr) -&gt;
<a name="match_chunked-last_expr"/><a name="2258"/> 2258: <b>    match_chunked_collect</b>(ets:match(Tab,Expr,
<a name="2259"/> 2259: 				    rand:uniform(1999) + 1)).
<a name="match_chunked_collect-1"/><a name="2260"/> 2260: <b>match_chunked_collect</b>('$end_of_table') -&gt;
<a name="2261"/> 2261:     [];
<a name="2262"/> 2262: <b>match_chunked_collect</b>({Results, Continuation}) -&gt;
<a name="match_chunked_collect-last_expr"/><a name="2263"/> 2263: <b>    Results ++ match_chunked_collect</b>(ets:match(Continuation)).
<a name="2264"/> 2264: 
<a name="ets_match_object-2"/><a name="2265"/> 2265: <b>ets_match_object</b>(Tab,Expr) -&gt;
<a name="ets_match_object-last_expr"/><a name="2266"/> 2266: <b>    case rand:uniform</b>(2) of
<a name="2267"/> 2267: 	1 -&gt;
<a name="2268"/> 2268: 	    ets:match_object(Tab,Expr);
<a name="2269"/> 2269: 	_ -&gt;
<a name="2270"/> 2270: 	    match_object_chunked(Tab,Expr)
<a name="2271"/> 2271:     end.
<a name="2272"/> 2272: 
<a name="match_object_chunked-2"/><a name="2273"/> 2273: <b>match_object_chunked</b>(Tab,Expr) -&gt;
<a name="match_object_chunked-last_expr"/><a name="2274"/> 2274: <b>    match_object_chunked_collect</b>(ets:match_object(Tab,Expr,
<a name="2275"/> 2275: 						  rand:uniform(1999) + 1)).
<a name="match_object_chunked_collect-1"/><a name="2276"/> 2276: <b>match_object_chunked_collect</b>('$end_of_table') -&gt;
<a name="2277"/> 2277:     [];
<a name="2278"/> 2278: <b>match_object_chunked_collect</b>({Results, Continuation}) -&gt;
<a name="match_object_chunked_collect-last_expr"/><a name="2279"/> 2279: <b>    Results ++ match_object_chunked_collect</b>(ets:match_object(Continuation)).
<a name="2280"/> 2280: 
<a name="2281"/> 2281: 
<a name="2282"/> 2282: 
<a name="random_test-0"/><a name="2283"/> 2283: <b>random_test</b>() -&gt;
<a name="2284"/> 2284:     ReadDir = get(where_to_read),
<a name="2285"/> 2285:     WriteDir = get(where_to_write),
<a name="2286"/> 2286:     (catch file:make_dir(WriteDir)),
<a name="2287"/> 2287:     case file:consult(filename:join([ReadDir,&quot;preset_random_seed.txt&quot;])) of
<a name="2288"/> 2288: 	{ok,[X]} -&gt;
<a name="2289"/> 2289: 	    rand:seed(X);
<a name="2290"/> 2290: 	_ -&gt;
<a name="2291"/> 2291: 	    rand:seed(default)
<a name="2292"/> 2292:     end,
<a name="2293"/> 2293:     Seed = rand:export_seed(),
<a name="2294"/> 2294:     {ok,F} = file:open(filename:join([WriteDir,&quot;last_random_seed.txt&quot;]),
<a name="2295"/> 2295: 		       [write]),
<a name="2296"/> 2296:     io:format(F,&quot;~p. ~n&quot;,[Seed]),
<a name="2297"/> 2297:     file:close(F),
<a name="2298"/> 2298:     io:format(&quot;Random seed ~p written to ~s, copy to ~s to rerun with &quot;
<a name="2299"/> 2299: 	      &quot;same seed.&quot;,[Seed,
<a name="2300"/> 2300: 			    filename:join([WriteDir, &quot;last_random_seed.txt&quot;]),
<a name="2301"/> 2301: 			    filename:join([ReadDir,
<a name="2302"/> 2302: 					   &quot;preset_random_seed.txt&quot;])]),
<a name="random_test-last_expr"/><a name="2303"/> 2303: <b>    do_random_test</b>().
<a name="2304"/> 2304: 
<a name="do_random_test-0"/><a name="2305"/> 2305: <b>do_random_test</b>() -&gt;
<a name="2306"/> 2306:     EtsMem = etsmem(),
<a name="2307"/> 2307:     OrdSet = ets_new(xxx,[ordered_set]),
<a name="2308"/> 2308:     Set = ets_new(xxx,[]),
<a name="2309"/> 2309:     do_n_times(fun() -&gt;
<a name="2310"/> 2310: 		       Key = create_random_string(25),
<a name="2311"/> 2311: 		       Value = create_random_tuple(25),
<a name="2312"/> 2312: 		       ets:insert(OrdSet,{Key,Value}),
<a name="2313"/> 2313: 		       ets:insert(Set,{Key,Value})
<a name="2314"/> 2314: 	       end, 5000),
<a name="2315"/> 2315:     io:format(&quot;~nData inserted~n&quot;),
<a name="2316"/> 2316:     do_n_times(fun() -&gt;
<a name="2317"/> 2317: 		       I = rand:uniform(25),
<a name="2318"/> 2318: 		       Key = create_random_string(I) ++ '_',
<a name="2319"/> 2319: 		       L1 = ets_match_object(OrdSet,{Key,'_'}),
<a name="2320"/> 2320: 		       L2 = lists:sort(ets_match_object(Set,{Key,'_'})),
<a name="2321"/> 2321: 		       case L1 == L2 of
<a name="2322"/> 2322: 			   false -&gt;
<a name="2323"/> 2323: 			       io:format(&quot;~p != ~p~n&quot;,
<a name="2324"/> 2324: 					 [L1,L2]),
<a name="2325"/> 2325: 			       exit({not_eq, L1, L2});
<a name="2326"/> 2326: 			   true -&gt;
<a name="2327"/> 2327: 			       ok
<a name="2328"/> 2328: 		       end
<a name="2329"/> 2329: 	       end,
<a name="2330"/> 2330: 	       2000),
<a name="2331"/> 2331:     io:format(&quot;~nData matched~n&quot;),
<a name="2332"/> 2332:     ets:match_delete(OrdSet,'_'),
<a name="2333"/> 2333:     ets:match_delete(Set,'_'),
<a name="2334"/> 2334:     do_n_times(fun() -&gt;
<a name="2335"/> 2335: 		       Value = create_random_string(25),
<a name="2336"/> 2336: 		       Key = create_random_tuple(25),
<a name="2337"/> 2337: 		       ets:insert(OrdSet,{Key,Value}),
<a name="2338"/> 2338: 		       ets:insert(Set,{Key,Value})
<a name="2339"/> 2339: 	       end, 2000),
<a name="2340"/> 2340:     io:format(&quot;~nData inserted~n&quot;),
<a name="2341"/> 2341:     (fun() -&gt;
<a name="2342"/> 2342: 	     Key = list_to_tuple(lists:duplicate(25,'_')),
<a name="2343"/> 2343: 	     L1 = ets_match_object(OrdSet,{Key,'_'}),
<a name="2344"/> 2344: 	     L2 = lists:sort(ets_match_object(Set,{Key,'_'})),
<a name="2345"/> 2345: 	     2000 = length(L1),
<a name="2346"/> 2346: 	     case L1 == L2 of
<a name="2347"/> 2347: 		 false -&gt;
<a name="2348"/> 2348: 		     io:format(&quot;~p != ~p~n&quot;,
<a name="2349"/> 2349: 			       [L1,L2]),
<a name="2350"/> 2350: 		     exit({not_eq, L1, L2});
<a name="2351"/> 2351: 		 true -&gt;
<a name="2352"/> 2352: 		     ok
<a name="2353"/> 2353: 	     end
<a name="2354"/> 2354:      end)(),
<a name="2355"/> 2355:     (fun() -&gt;
<a name="2356"/> 2356: 	     Key = {'$1','$2','$3','$4',
<a name="2357"/> 2357: 		    '$5','$6','$7','$8',
<a name="2358"/> 2358: 		    '$9','$10','$11','$12',
<a name="2359"/> 2359: 		    '$13','$14','$15','$16',
<a name="2360"/> 2360: 		    '$17','$18','$19','$20',
<a name="2361"/> 2361: 		    '$21','$22','$23','$24',
<a name="2362"/> 2362: 		    '$25'},
<a name="2363"/> 2363: 	     L1 = ets_match_object(OrdSet,{Key,'_'}),
<a name="2364"/> 2364: 	     L2 = lists:sort(ets_match_object(Set,{Key,'_'})),
<a name="2365"/> 2365: 	     2000 = length(L1),
<a name="2366"/> 2366: 	     case L1 == L2 of
<a name="2367"/> 2367: 		 false -&gt;
<a name="2368"/> 2368: 		     io:format(&quot;~p != ~p~n&quot;,
<a name="2369"/> 2369: 			       [L1,L2]),
<a name="2370"/> 2370: 		     exit({not_eq, L1, L2});
<a name="2371"/> 2371: 		 true -&gt;
<a name="2372"/> 2372: 		     ok
<a name="2373"/> 2373: 	     end
<a name="2374"/> 2374:      end)(),
<a name="2375"/> 2375:     (fun() -&gt;
<a name="2376"/> 2376: 	     Key = {'$1','$2','$3','$4',
<a name="2377"/> 2377: 		    '$5','$6','$7','$8',
<a name="2378"/> 2378: 		    '$9','$10','$11','$12',
<a name="2379"/> 2379: 		    '$13','$14','$15','$16',
<a name="2380"/> 2380: 		    '$17','$18','$19','$20',
<a name="2381"/> 2381: 		    '$21','$22','$23','$24',
<a name="2382"/> 2382: 		    '$25'},
<a name="2383"/> 2383: 	     L1 = ets_match(OrdSet,{Key,'_'}),
<a name="2384"/> 2384: 	     L2 = lists:sort(ets_match(Set,{Key,'_'})),
<a name="2385"/> 2385: 	     2000 = length(L1),
<a name="2386"/> 2386: 	     case L1 == L2 of
<a name="2387"/> 2387: 		 false -&gt;
<a name="2388"/> 2388: 		     io:format(&quot;~p != ~p~n&quot;,
<a name="2389"/> 2389: 			       [L1,L2]),
<a name="2390"/> 2390: 		     exit({not_eq, L1, L2});
<a name="2391"/> 2391: 		 true -&gt;
<a name="2392"/> 2392: 		     ok
<a name="2393"/> 2393: 	     end
<a name="2394"/> 2394:      end)(),
<a name="2395"/> 2395:     ets:match_delete(OrdSet,'_'),
<a name="2396"/> 2396:     ets:match_delete(Set,'_'),
<a name="2397"/> 2397:     do_n_times(fun() -&gt;
<a name="2398"/> 2398: 		       Value = create_random_string(25),
<a name="2399"/> 2399: 		       Key = create_random_tuple(25),
<a name="2400"/> 2400: 		       ets:insert(OrdSet,{Key,Value}),
<a name="2401"/> 2401: 		       ets:insert(Set,{Key,Value})
<a name="2402"/> 2402: 	       end, 2000),
<a name="2403"/> 2403:     io:format(&quot;~nData inserted~n&quot;),
<a name="2404"/> 2404:     do_n_times(fun() -&gt;
<a name="2405"/> 2405: 		       Key = create_partly_bound_tuple(25),
<a name="2406"/> 2406: 		       L1 = ets_match_object(OrdSet,{Key,'_'}),
<a name="2407"/> 2407: 		       L2 = lists:sort(ets_match_object(Set,{Key,'_'})),
<a name="2408"/> 2408: 		       case L1 == L2 of
<a name="2409"/> 2409: 			   false -&gt;
<a name="2410"/> 2410: 			       io:format(&quot;~p != ~p~n&quot;,
<a name="2411"/> 2411: 					 [L1,L2]),
<a name="2412"/> 2412: 			       exit({not_eq, L1, L2});
<a name="2413"/> 2413: 			   true -&gt;
<a name="2414"/> 2414: 			       ok
<a name="2415"/> 2415: 		       end
<a name="2416"/> 2416: 	       end,
<a name="2417"/> 2417: 	       2000),
<a name="2418"/> 2418:     do_n_times(fun() -&gt;
<a name="2419"/> 2419: 		       Key = create_partly_bound_tuple2(25),
<a name="2420"/> 2420: 		       L1 = ets_match_object(OrdSet,{Key,'_'}),
<a name="2421"/> 2421: 		       L2 = lists:sort(ets_match_object(Set,{Key,'_'})),
<a name="2422"/> 2422: 		       case L1 == L2 of
<a name="2423"/> 2423: 			   false -&gt;
<a name="2424"/> 2424: 			       io:format(&quot;~p != ~p~n&quot;,
<a name="2425"/> 2425: 					 [L1,L2]),
<a name="2426"/> 2426: 			       exit({not_eq, L1, L2});
<a name="2427"/> 2427: 			   true -&gt;
<a name="2428"/> 2428: 			       ok
<a name="2429"/> 2429: 		       end
<a name="2430"/> 2430: 	       end,
<a name="2431"/> 2431: 	       2000),
<a name="2432"/> 2432:     do_n_times(fun() -&gt;
<a name="2433"/> 2433: 		       Key = create_partly_bound_tuple2(25),
<a name="2434"/> 2434: 		       L1 = ets_match(OrdSet,{Key,'_'}),
<a name="2435"/> 2435: 		       L2 = lists:sort(ets_match(Set,{Key,'_'})),
<a name="2436"/> 2436: 		       case L1 == L2 of
<a name="2437"/> 2437: 			   false -&gt;
<a name="2438"/> 2438: 			       io:format(&quot;~p != ~p~n&quot;,
<a name="2439"/> 2439: 					 [L1,L2]),
<a name="2440"/> 2440: 			       exit({not_eq, L1, L2});
<a name="2441"/> 2441: 			   true -&gt;
<a name="2442"/> 2442: 			       ok
<a name="2443"/> 2443: 		       end
<a name="2444"/> 2444: 	       end,
<a name="2445"/> 2445: 	       2000),
<a name="2446"/> 2446:     io:format(&quot;~nData matched~n&quot;),
<a name="2447"/> 2447:     ets:match_delete(OrdSet,'_'),
<a name="2448"/> 2448:     ets:match_delete(Set,'_'),
<a name="2449"/> 2449:     do_n_times(fun() -&gt;
<a name="2450"/> 2450: 		       do_n_times(fun() -&gt;
<a name="2451"/> 2451: 					  Value =
<a name="2452"/> 2452: 					      create_random_string(25),
<a name="2453"/> 2453: 					  Key = create_random_tuple(25),
<a name="2454"/> 2454: 					  ets:insert(OrdSet,{Key,Value}),
<a name="2455"/> 2455: 					  ets:insert(Set,{Key,Value})
<a name="2456"/> 2456: 				  end, 500),
<a name="2457"/> 2457: 		       io:format(&quot;~nData inserted~n&quot;),
<a name="2458"/> 2458: 		       do_n_times(fun() -&gt;
<a name="2459"/> 2459: 					  Key =
<a name="2460"/> 2460: 					      create_partly_bound_tuple(25),
<a name="2461"/> 2461: 					  ets:match_delete(OrdSet,{Key,'_'}),
<a name="2462"/> 2462: 					  ets:match_delete(Set,{Key,'_'}),
<a name="2463"/> 2463: 					  L1 = ets:info(OrdSet,size),
<a name="2464"/> 2464: 					  L2 = ets:info(Set,size),
<a name="2465"/> 2465: 					  [] = ets_match_object(OrdSet,
<a name="2466"/> 2466: 								{Key,'_'}),
<a name="2467"/> 2467: 					  case L1 == L2 of
<a name="2468"/> 2468: 					      false -&gt;
<a name="2469"/> 2469: 						  io:format(&quot;~p != ~p &quot;
<a name="2470"/> 2470: 							    &quot;(deleted ~p)~n&quot;,
<a name="2471"/> 2471: 							    [L1,L2,Key]),
<a name="2472"/> 2472: 						  exit({not_eq, L1, L2,
<a name="2473"/> 2473: 							{deleted,Key}});
<a name="2474"/> 2474: 					      true -&gt;
<a name="2475"/> 2475: 						  ok
<a name="2476"/> 2476: 					  end
<a name="2477"/> 2477: 				  end,
<a name="2478"/> 2478: 				  50),
<a name="2479"/> 2479: 		       io:format(&quot;~nData deleted~n&quot;)
<a name="2480"/> 2480: 	       end,
<a name="2481"/> 2481: 	       10),
<a name="2482"/> 2482:     ets:delete(OrdSet),
<a name="2483"/> 2483:     ets:delete(Set),
<a name="do_random_test-last_expr"/><a name="2484"/> 2484: <b>    verify_etsmem</b>(EtsMem).
<a name="2485"/> 2485: 
<a name="2486"/> 2486: <i>%% Test various variants of update_element.</i>
<a name="update_element-1"/><a name="2487"/> 2487: <b>update_element</b>(Config) when is_list(Config) -&gt;
<a name="2488"/> 2488:     EtsMem = etsmem(),
<a name="2489"/> 2489:     repeat_for_opts(fun update_element_opts/1),
<a name="update_element-last_expr"/><a name="2490"/> 2490: <b>    verify_etsmem</b>(EtsMem).
<a name="2491"/> 2491: 
<a name="update_element_opts-1"/><a name="2492"/> 2492: <b>update_element_opts</b>(Opts) -&gt;
<a name="2493"/> 2493:     TupleCases = [{{key,val}, 1 ,2},
<a name="2494"/> 2494: 		  {{val,key}, 2, 1},
<a name="2495"/> 2495: 		  {{key,val}, 1 ,[2]},
<a name="2496"/> 2496: 		  {{key,val,val}, 1, [2,3]},
<a name="2497"/> 2497: 		  {{val,key,val,val}, 2, [3,4,1]},
<a name="2498"/> 2498: 		  {{val,val,key,val}, 3, [1,4,1,2]}, % update pos1 twice
<a name="2499"/> 2499: 		  {{val,val,val,key}, 4, [2,1,2,3]}],% update pos2 twice
<a name="2500"/> 2500: 
<a name="2501"/> 2501:     lists:foreach(fun({Tuple,KeyPos,UpdPos}) -&gt; update_element_opts(Tuple,KeyPos,UpdPos,Opts) end,
<a name="2502"/> 2502: 		  TupleCases),
<a name="2503"/> 2503: 
<a name="update_element_opts-last_expr"/><a name="2504"/> 2504: <b>    update_element_neg</b>(Opts).
<a name="2505"/> 2505: 
<a name="2506"/> 2506: 
<a name="2507"/> 2507: 
<a name="update_element_opts-4"/><a name="2508"/> 2508: <b>update_element_opts</b>(Tuple,KeyPos,UpdPos,Opts) -&gt;
<a name="2509"/> 2509:     Set = ets_new(set,[{keypos,KeyPos} | Opts]),
<a name="2510"/> 2510:     update_element(Set,Tuple,KeyPos,UpdPos),
<a name="2511"/> 2511:     true = ets:delete(Set),
<a name="2512"/> 2512: 
<a name="2513"/> 2513:     run_if_valid_opts(
<a name="2514"/> 2514:       [ordered_set,{keypos,KeyPos} | Opts],
<a name="2515"/> 2515:       fun (OptsOrdSet) -&gt;
<a name="2516"/> 2516:               OrdSet = ets_new(ordered_set, OptsOrdSet),
<a name="2517"/> 2517:               update_element(OrdSet,Tuple,KeyPos,UpdPos),
<a name="2518"/> 2518:               true = ets:delete(OrdSet)
<a name="2519"/> 2519:       end),
<a name="update_element_opts-last_expr"/><a name="2520"/> 2520:     ok.
<a name="2521"/> 2521: 
<a name="update_element-4"/><a name="2522"/> 2522: <b>update_element</b>(T,Tuple,KeyPos,UpdPos) -&gt;
<a name="2523"/> 2523:     KeyList = [17,&quot;seventeen&quot;,&lt;&lt;&quot;seventeen&quot;&gt;&gt;,{17},list_to_binary(lists:seq(1,100)),make_ref(), self()],
<a name="update_element-last_expr"/><a name="2524"/> 2524: <b>    lists:foreach</b>(fun(Key) -&gt;
<a name="2525"/> 2525: 			  TupleWithKey = setelement(KeyPos,Tuple,Key),
<a name="2526"/> 2526: 			  update_element_do(T,TupleWithKey,Key,UpdPos)
<a name="2527"/> 2527: 		  end,
<a name="2528"/> 2528: 		  KeyList).
<a name="2529"/> 2529: 
<a name="update_element_do-4"/><a name="2530"/> 2530: <b>update_element_do</b>(Tab,Tuple,Key,UpdPos) -&gt;
<a name="2531"/> 2531: 
<a name="2532"/> 2532:     %% Strategy: Step around in Values array and call ets:update_element for the values.
<a name="2533"/> 2533:     %% Take Length number of steps of size 1, then of size 2, ..., Length-1.
<a name="2534"/> 2534:     %% This will try all combinations of {fromValue,toValue}
<a name="2535"/> 2535:     %%
<a name="2536"/> 2536:     %% IMPORTANT: size(Values) must be a prime number for this to work!!!
<a name="2537"/> 2537: 
<a name="2538"/> 2538:     Big32 = 16#12345678,
<a name="2539"/> 2539:     Big64 = 16#123456789abcdef0,
<a name="2540"/> 2540:     RefcBin = list_to_binary(lists:seq(1,100)),
<a name="2541"/> 2541:     BigMap1 = maps:from_list([{N,N} || N &lt;- lists:seq(1,33)]),
<a name="2542"/> 2542:     BigMap2 = BigMap1#{key =&gt; RefcBin, RefcBin =&gt; value},
<a name="2543"/> 2543:     Values = { 623, -27, Big32, -Big32, Big64, -Big64, Big32*Big32,
<a name="2544"/> 2544: 	       -Big32*Big32, Big32*Big64, -Big32*Big64, Big64*Big64, -Big64*Big64,
<a name="2545"/> 2545: 	       &quot;A&quot;, &quot;Sverker&quot;, [], {12,-132}, {},
<a name="2546"/> 2546: 	       &lt;&lt;45,232,0,12,133&gt;&gt;, &lt;&lt;234,12,23&gt;&gt;, RefcBin,
<a name="2547"/> 2547: 	       (fun(X) -&gt; X*Big32 end),
<a name="2548"/> 2548: 	       make_ref(), make_ref(), self(), ok, update_element,
<a name="2549"/> 2549:                #{a =&gt; value, &quot;hello&quot; =&gt; &quot;world&quot;, 1.0 =&gt; RefcBin },
<a name="2550"/> 2550:                BigMap1, BigMap2},
<a name="2551"/> 2551:     Length = tuple_size(Values),
<a name="2552"/> 2552:     29 = Length,
<a name="2553"/> 2553: 
<a name="2554"/> 2554:     PosValArgF = fun MeF(ToIx, ResList, [Pos | PosTail], Rand) -&gt;
<a name="2555"/> 2555: 			 NextIx = (ToIx+Rand) rem Length,
<a name="2556"/> 2556: 			 MeF(NextIx, [{Pos,element(ToIx+1,Values)} | ResList], PosTail, Rand);
<a name="2557"/> 2557: 
<a name="2558"/> 2558: 		     MeF(_ToIx, ResList, [], _Rand) -&gt;
<a name="2559"/> 2559: 			 ResList;
<a name="2560"/> 2560: 
<a name="2561"/> 2561: 		     MeF(ToIx, [], Pos, _Rand) -&gt;
<a name="2562"/> 2562: 			 {Pos, element(ToIx+1,Values)}   % single {pos,value} arg
<a name="2563"/> 2563: 		 end,
<a name="2564"/> 2564: 
<a name="2565"/> 2565:     UpdateF = fun(ToIx,Rand) -&gt;
<a name="2566"/> 2566:                       PosValArg = PosValArgF(ToIx,[],UpdPos,Rand),
<a name="2567"/> 2567:                       %%io:format(&quot;update_element(~p)~n&quot;,[PosValArg]),
<a name="2568"/> 2568:                       ArgHash = erlang:phash2({Tab,Key,PosValArg}),
<a name="2569"/> 2569:                       true = ets:update_element(Tab, Key, PosValArg),
<a name="2570"/> 2570:                       [DefaultObj] = ets:lookup(Tab, Key),
<a name="2571"/> 2571:                       NewKey = make_ref(),
<a name="2572"/> 2572:                       true = ets:update_element(Tab, NewKey, PosValArg, DefaultObj),
<a name="2573"/> 2573:                       true = [update_tuple({ets:info(Tab, keypos), NewKey}, DefaultObj)] =:= ets:lookup(Tab, NewKey),
<a name="2574"/> 2574:                       ArgHash = erlang:phash2({Tab,Key,PosValArg}),
<a name="2575"/> 2575:                       NewTuple = update_tuple(PosValArg,Tuple),
<a name="2576"/> 2576:                       [NewTuple] = ets:lookup(Tab,Key),
<a name="2577"/> 2577:                       [begin
<a name="2578"/> 2578:                            Elem = element(I, NewTuple),
<a name="2579"/> 2579:                            Elem = ets:lookup_element(Tab, Key, I)
<a name="2580"/> 2580:                        end
<a name="2581"/> 2581:                        || I &lt;- lists:seq(1, tuple_size(NewTuple))]
<a name="2582"/> 2582: 	      end,
<a name="2583"/> 2583: 
<a name="2584"/> 2584:     LoopF = fun MeF(_FromIx, Incr, _Times, Checksum) when Incr &gt;= Length -&gt;
<a name="2585"/> 2585: 		    Checksum; % done
<a name="2586"/> 2586: 
<a name="2587"/> 2587: 		MeF(FromIx, Incr, 0, Checksum) -&gt;
<a name="2588"/> 2588: 		    MeF(FromIx, Incr+1, Length, Checksum);
<a name="2589"/> 2589: 
<a name="2590"/> 2590: 		MeF(FromIx, Incr, Times, Checksum) -&gt;
<a name="2591"/> 2591: 		    ToIx = (FromIx + Incr) rem Length,
<a name="2592"/> 2592: 		    UpdateF(ToIx,Checksum),
<a name="2593"/> 2593: 		    if
<a name="2594"/> 2594: 			Incr =:= 0 -&gt; UpdateF(ToIx,Checksum);  % extra update to same value
<a name="2595"/> 2595: 			true -&gt; true
<a name="2596"/> 2596: 		    end,
<a name="2597"/> 2597: 		    MeF(ToIx, Incr, Times-1, Checksum+ToIx+1)
<a name="2598"/> 2598: 	    end,
<a name="2599"/> 2599: 
<a name="2600"/> 2600:     FirstTuple = Tuple,
<a name="2601"/> 2601:     true = ets:insert(Tab,FirstTuple),
<a name="2602"/> 2602:     [FirstTuple] = ets:lookup(Tab,Key),
<a name="2603"/> 2603: 
<a name="2604"/> 2604:     Checksum = LoopF(0, 1, Length, 0),
<a name="2605"/> 2605:     Checksum = (Length-1)*Length*(Length+1) div 2,  % if Length is a prime
<a name="update_element_do-last_expr"/><a name="2606"/> 2606:     ok.
<a name="2607"/> 2607: 
<a name="update_tuple-2"/><a name="2608"/> 2608: <b>update_tuple</b>({Pos,Val}, Tpl) -&gt;
<a name="2609"/> 2609:     setelement(Pos, Tpl, Val);
<a name="2610"/> 2610: <b>update_tuple</b>([{Pos,Val} | Tail], Tpl) -&gt;
<a name="2611"/> 2611:     update_tuple(Tail,setelement(Pos, Tpl, Val));
<a name="2612"/> 2612: <b>update_tuple</b>([], Tpl) -&gt;
<a name="update_tuple-last_expr"/><a name="2613"/> 2613:     Tpl.
<a name="2614"/> 2614: 
<a name="2615"/> 2615: 
<a name="2616"/> 2616: 
<a name="update_element_neg-1"/><a name="2617"/> 2617: <b>update_element_neg</b>(Opts) -&gt;
<a name="2618"/> 2618:     Set = ets_new(set,Opts),
<a name="2619"/> 2619:     update_element_neg_do(Set),
<a name="2620"/> 2620:     ets:delete(Set),
<a name="2621"/> 2621:     {'EXIT',{badarg,_}} = (catch ets:update_element(Set,key,{2,1})),
<a name="2622"/> 2622:     {'EXIT',{badarg,_}} = (catch ets:update_element(Set,key,{2,1},{a,b})),
<a name="2623"/> 2623: 
<a name="2624"/> 2624:     run_if_valid_opts(
<a name="2625"/> 2625:       [ordered_set | Opts],
<a name="2626"/> 2626:       fun(OptsOrdSet) -&gt;
<a name="2627"/> 2627:               OrdSet = ets_new(ordered_set, OptsOrdSet),
<a name="2628"/> 2628:               update_element_neg_do(OrdSet),
<a name="2629"/> 2629:               ets:delete(OrdSet),
<a name="2630"/> 2630:               {'EXIT',{badarg,_}} = (catch ets:update_element(OrdSet,key,{2,1})),
<a name="2631"/> 2631:               {'EXIT',{badarg,_}} = (catch ets:update_element(OrdSet,key2,{2,1},{a,b}))
<a name="2632"/> 2632:       end),
<a name="2633"/> 2633: 
<a name="2634"/> 2634:     Bag = ets_new(bag,[bag | Opts]),
<a name="2635"/> 2635:     DBag = ets_new(duplicate_bag,[duplicate_bag | Opts]),
<a name="2636"/> 2636:     {'EXIT',{badarg,_}} = (catch ets:update_element(Bag,key,{2,1})),
<a name="2637"/> 2637:     {'EXIT',{badarg,_}} = (catch ets:update_element(Bag,key,{2,1},{key,0})),
<a name="2638"/> 2638:     {'EXIT',{badarg,_}} = (catch ets:update_element(DBag,key,{2,1})),
<a name="2639"/> 2639:     {'EXIT',{badarg,_}} = (catch ets:update_element(DBag,key,{2,1},{key,0})),
<a name="2640"/> 2640:     true = ets:delete(Bag),
<a name="2641"/> 2641:     true = ets:delete(DBag),
<a name="update_element_neg-last_expr"/><a name="2642"/> 2642:     ok.
<a name="2643"/> 2643: 
<a name="2644"/> 2644: 
<a name="update_element_neg_do-1"/><a name="2645"/> 2645: <b>update_element_neg_do</b>(T) -&gt;
<a name="2646"/> 2646:     Object = {key, 0, &quot;Hej&quot;},
<a name="2647"/> 2647:     true = ets:insert(T,Object),
<a name="2648"/> 2648: 
<a name="2649"/> 2649:     UpdateF = fun(Arg3) -&gt;
<a name="2650"/> 2650: 		      ArgHash = erlang:phash2({T,key,Arg3}),
<a name="2651"/> 2651: 		      {'EXIT',{badarg,_}} = (catch ets:update_element(T,key,Arg3)),
<a name="2652"/> 2652: 		      ArgHash = erlang:phash2({T,key,Arg3}),
<a name="2653"/> 2653: 		      {'EXIT',{badarg,_}} = (catch ets:update_element(T,key2,Arg3,Object)),
<a name="2654"/> 2654: 		      ArgHash = erlang:phash2({T,key,Arg3}),
<a name="2655"/> 2655: 		      [Object] = ets:lookup(T,key)
<a name="2656"/> 2656: 	      end,
<a name="2657"/> 2657: 
<a name="2658"/> 2658:     %% List of invalid {Pos,Value} tuples
<a name="2659"/> 2659:     InvList = [false, {2}, {2,1,false}, {false,1}, {0,1}, {1,1}, {-1,1}, {4,1}],
<a name="2660"/> 2660: 
<a name="2661"/> 2661:     lists:foreach(UpdateF, InvList),
<a name="2662"/> 2662:     lists:foreach(fun(InvTpl) -&gt; UpdateF([{2,1},InvTpl]) end, InvList),
<a name="2663"/> 2663:     lists:foreach(fun(InvTpl) -&gt; UpdateF([InvTpl,{2,1}]) end, InvList),
<a name="2664"/> 2664:     lists:foreach(fun(InvTpl) -&gt; UpdateF([{2,1},{3,&quot;Hello&quot;},InvTpl]) end, InvList),
<a name="2665"/> 2665:     lists:foreach(fun(InvTpl) -&gt; UpdateF([{3,&quot;Hello&quot;},{2,1},InvTpl]) end, InvList),
<a name="2666"/> 2666:     lists:foreach(fun(InvTpl) -&gt; UpdateF([{2,1},InvTpl,{3,&quot;Hello&quot;}]) end, InvList),
<a name="2667"/> 2667:     lists:foreach(fun(InvTpl) -&gt; UpdateF([InvTpl,{3,&quot;Hello&quot;},{2,1}]) end, InvList),
<a name="2668"/> 2668:     UpdateF([{2,1} | {3,1}]),
<a name="2669"/> 2669:     lists:foreach(fun(InvTpl) -&gt; UpdateF([{2,1} | InvTpl]) end, InvList),
<a name="2670"/> 2670: 
<a name="2671"/> 2671:     true = ets:update_element(T,key,[]),
<a name="2672"/> 2672:     false = ets:update_element(T,false,[]),
<a name="2673"/> 2673:     false = ets:update_element(T,false,{2,1}),
<a name="2674"/> 2674:     ets:delete(T,key),
<a name="2675"/> 2675:     false = ets:update_element(T,key,{2,1}),
<a name="update_element_neg_do-last_expr"/><a name="2676"/> 2676:     ok.
<a name="2677"/> 2677: 
<a name="2678"/> 2678: 
<a name="update_element_default-1"/><a name="2679"/> 2679: <b>update_element_default</b>(Config) when is_list(Config) -&gt;
<a name="2680"/> 2680:     EtsMem = etsmem(),
<a name="2681"/> 2681:     repeat_for_opts(fun update_element_default_opts/1),
<a name="update_element_default-last_expr"/><a name="2682"/> 2682: <b>    verify_etsmem</b>(EtsMem).
<a name="2683"/> 2683: 
<a name="2684"/> 2684: 
<a name="update_element_default_opts-1"/><a name="2685"/> 2685: <b>update_element_default_opts</b>(Opts) -&gt;
<a name="2686"/> 2686:     lists:foreach(
<a name="2687"/> 2687:         fun({Type, {Key, Pos}}) -&gt;
<a name="2688"/> 2688:             run_if_valid_opts(
<a name="2689"/> 2689:                 [Type, {keypos, Pos} | Opts],
<a name="2690"/> 2690: 		fun(TabOpts) -&gt;
<a name="2691"/> 2691:                     Tab = ets_new(Type, TabOpts),
<a name="2692"/> 2692: 		    true = ets:update_element(Tab, Key, {3, b}, {key1, key2, a, x}),
<a name="2693"/> 2693: 		    [{key1, key2, b, x}] = ets:lookup(Tab, Key),
<a name="2694"/> 2694: 		    true = ets:update_element(Tab, Key, {3, c}, {key1, key2, a, y}),
<a name="2695"/> 2695: 		    [{key1, key2, c, x}] = ets:lookup(Tab, Key),
<a name="2696"/> 2696: 		    ets:delete(Tab)
<a name="2697"/> 2697:                 end
<a name="2698"/> 2698: 	    )
<a name="2699"/> 2699: 	end,
<a name="2700"/> 2700: 	[{Type, KeyPos} || Type &lt;- [set, ordered_set], KeyPos &lt;- [{key1, 1}, {key2, 2}]]
<a name="2701"/> 2701:     ),
<a name="update_element_default_opts-last_expr"/><a name="2702"/> 2702:     ok.
<a name="2703"/> 2703: 
<a name="2704"/> 2704: 
<a name="2705"/> 2705: <i>%% test various variants of update_counter.</i>
<a name="update_counter-1"/><a name="2706"/> 2706: <b>update_counter</b>(Config) when is_list(Config) -&gt;
<a name="2707"/> 2707:     EtsMem = etsmem(),
<a name="2708"/> 2708:     repeat_for_opts(fun update_counter_do/1),
<a name="update_counter-last_expr"/><a name="2709"/> 2709: <b>    verify_etsmem</b>(EtsMem).
<a name="2710"/> 2710: 
<a name="update_counter_do-1"/><a name="2711"/> 2711: <b>update_counter_do</b>(Opts) -&gt;
<a name="2712"/> 2712:     Set = ets_new(set,Opts),
<a name="2713"/> 2713:     update_counter_for(Set),
<a name="2714"/> 2714:     ets:delete_all_objects(Set),
<a name="2715"/> 2715:     ets:safe_fixtable(Set, true),
<a name="2716"/> 2716:     update_counter_for(Set),
<a name="2717"/> 2717:     ets:safe_fixtable(Set, false),
<a name="2718"/> 2718:     ets:delete(Set),
<a name="2719"/> 2719: 
<a name="2720"/> 2720:     run_if_valid_opts(
<a name="2721"/> 2721:       [ordered_set | Opts],
<a name="2722"/> 2722:       fun (OptsOrdSet) -&gt;
<a name="2723"/> 2723:               OrdSet = ets_new(ordered_set, OptsOrdSet),
<a name="2724"/> 2724:               update_counter_for(OrdSet),
<a name="2725"/> 2725:               ets:delete_all_objects(OrdSet),
<a name="2726"/> 2726:               ets:safe_fixtable(OrdSet, true),
<a name="2727"/> 2727:               update_counter_for(OrdSet),
<a name="2728"/> 2728:               ets:safe_fixtable(OrdSet, false),
<a name="2729"/> 2729:               ets:delete(OrdSet)
<a name="2730"/> 2730:       end),
<a name="2731"/> 2731: 
<a name="update_counter_do-last_expr"/><a name="2732"/> 2732: <b>    update_counter_neg</b>(Opts).
<a name="2733"/> 2733: 
<a name="update_counter_for-1"/><a name="2734"/> 2734: <b>update_counter_for</b>(T) -&gt;
<a name="2735"/> 2735:     ets:insert(T,{a,1,1}),
<a name="2736"/> 2736:     101 = ets:update_counter(T,a,100),
<a name="2737"/> 2737:     [{a,101,1}] = ets:lookup(T,a),
<a name="2738"/> 2738:     101 = ets:update_counter(T,a,{3,100}),
<a name="2739"/> 2739:     [{a,101,101}] = ets:lookup(T,a),
<a name="2740"/> 2740: 
<a name="2741"/> 2741: 
<a name="2742"/> 2742:     LooperF = fun(Obj, 0, _, _) -&gt;
<a name="2743"/> 2743: 		      Obj;
<a name="2744"/> 2744: 
<a name="2745"/> 2745: 		 (Obj, Times, Arg3, Myself) -&gt;
<a name="2746"/> 2746: 		      {NewObj, Ret} = uc_mimic(Obj,Arg3),
<a name="2747"/> 2747: 		      ArgHash = erlang:phash2({T,a,Arg3}),
<a name="2748"/> 2748: 		      %%io:format(&quot;update_counter(~p, ~p, ~p) expecting ~p\n&quot;,[T,a,Arg3,Ret]),
<a name="2749"/> 2749:                       [DefaultObj] = ets:lookup(T, a),
<a name="2750"/> 2750: 		      Ret = ets:update_counter(T,a,Arg3),
<a name="2751"/> 2751:                       Ret = ets:update_counter(T, b, Arg3, DefaultObj),   % Use other key
<a name="2752"/> 2752: 		      ArgHash = erlang:phash2({T,a,Arg3}),
<a name="2753"/> 2753: 		      %%io:format(&quot;NewObj=~p~n &quot;,[NewObj]),
<a name="2754"/> 2754: 		      [NewObj] = ets:lookup(T,a),
<a name="2755"/> 2755:                       true = ets:lookup(T, b) =:= [setelement(1, NewObj, b)],
<a name="2756"/> 2756:                       ets:delete(T, b),
<a name="2757"/> 2757: 		      Myself(NewObj,Times-1,Arg3,Myself)
<a name="2758"/> 2758: 	      end,
<a name="2759"/> 2759: 
<a name="2760"/> 2760:     LoopF = fun(Obj, Times, Arg3) -&gt;
<a name="2761"/> 2761: 		    %%io:format(&quot;Loop start:\nObj = ~p\nArg3=~p\n&quot;,[Obj,Arg3]),
<a name="2762"/> 2762: 		    LooperF(Obj,Times,Arg3,LooperF)
<a name="2763"/> 2763: 	    end,
<a name="2764"/> 2764: 
<a name="2765"/> 2765:     SmallMax32 = (1 bsl 27) - 1,
<a name="2766"/> 2766:     SmallMax64 = (1 bsl (27+32)) - 1,
<a name="2767"/> 2767:     Big1Max32 = (1 bsl 32) - 1,
<a name="2768"/> 2768:     Big1Max64 = (1 bsl 64) - 1,
<a name="2769"/> 2769: 
<a name="2770"/> 2770:     Steps = 100,
<a name="2771"/> 2771:     Obj0 = {a,0,0,0,0},
<a name="2772"/> 2772:     ets:insert(T,Obj0),
<a name="2773"/> 2773:     Obj1 = LoopF(Obj0, Steps, {2,(SmallMax32 div Steps)*2}),
<a name="2774"/> 2774:     Obj2 = LoopF(Obj1, Steps, {3,(SmallMax64 div Steps)*2}),
<a name="2775"/> 2775:     Obj3 = LoopF(Obj2, Steps, {4,(Big1Max32 div Steps)*2}),
<a name="2776"/> 2776:     Obj4 = LoopF(Obj3, Steps, {5,(Big1Max64 div Steps)*2}),
<a name="2777"/> 2777: 
<a name="2778"/> 2778:     Obj5 = LoopF(Obj4, Steps, {2,-(SmallMax32 div Steps)*4}),
<a name="2779"/> 2779:     Obj6 = LoopF(Obj5, Steps, {3,-(SmallMax64 div Steps)*4}),
<a name="2780"/> 2780:     Obj7 = LoopF(Obj6, Steps, {4,-(Big1Max32 div Steps)*4}),
<a name="2781"/> 2781:     Obj8 = LoopF(Obj7, Steps, {5,-(Big1Max64 div Steps)*4}),
<a name="2782"/> 2782: 
<a name="2783"/> 2783:     Obj9 = LoopF(Obj8, Steps, {2,(SmallMax32 div Steps)*2}),
<a name="2784"/> 2784:     ObjA = LoopF(Obj9, Steps, {3,(SmallMax64 div Steps)*2}),
<a name="2785"/> 2785:     ObjB = LoopF(ObjA, Steps, {4,(Big1Max32 div Steps)*2}),
<a name="2786"/> 2786:     Obj0 = LoopF(ObjB, Steps, {5,(Big1Max64 div Steps)*2}),
<a name="2787"/> 2787: 
<a name="2788"/> 2788:     %% back at zero, same trip again with lists
<a name="2789"/> 2789: 
<a name="2790"/> 2790:     Obj4 = LoopF(Obj0,Steps,[{2, (SmallMax32 div Steps)*2},
<a name="2791"/> 2791: 			     {3, (SmallMax64 div Steps)*2},
<a name="2792"/> 2792: 			     {4, (Big1Max32 div Steps)*2},
<a name="2793"/> 2793: 			     {5, (Big1Max64 div Steps)*2}]),
<a name="2794"/> 2794: 
<a name="2795"/> 2795:     Obj8 = LoopF(Obj4,Steps,[{4, -(Big1Max32 div Steps)*4},
<a name="2796"/> 2796: 			     {2, -(SmallMax32 div Steps)*4},
<a name="2797"/> 2797: 			     {5, -(Big1Max64 div Steps)*4},
<a name="2798"/> 2798: 			     {3, -(SmallMax64 div Steps)*4}]),
<a name="2799"/> 2799: 
<a name="2800"/> 2800:     Obj0 = LoopF(Obj8,Steps,[{5, (Big1Max64 div Steps)*2},
<a name="2801"/> 2801: 			     {2, (SmallMax32 div Steps)*2},
<a name="2802"/> 2802: 			     {4, (Big1Max32 div Steps)*2},
<a name="2803"/> 2803: 			     {3, (SmallMax64 div Steps)*2}]),
<a name="2804"/> 2804: 
<a name="2805"/> 2805:     %% make them shift size at the same time
<a name="2806"/> 2806:     ObjC = LoopF(Obj0,Steps,[{5, (Big1Max64 div Steps)*2},
<a name="2807"/> 2807: 			     {3, (Big1Max64 div Steps)*2 + 1},
<a name="2808"/> 2808: 			     {2, -(Big1Max64 div Steps)*2},
<a name="2809"/> 2809: 			     {4, -(Big1Max64 div Steps)*2 + 1}]),
<a name="2810"/> 2810: 
<a name="2811"/> 2811:     %% update twice in same list
<a name="2812"/> 2812:     ObjD = LoopF(ObjC,Steps,[{5, -(Big1Max64 div Steps) + 1},
<a name="2813"/> 2813: 			     {3, -(Big1Max64 div Steps)*2 - 1},
<a name="2814"/> 2814: 			     {5, -(Big1Max64 div Steps) - 1},
<a name="2815"/> 2815: 			     {4, (Big1Max64 div Steps)*2 - 1}]),
<a name="2816"/> 2816: 
<a name="2817"/> 2817:     Obj0 = LoopF(ObjD,Steps,[{2, (Big1Max64 div Steps) - 1},
<a name="2818"/> 2818: 			     {4, Big1Max64*2},
<a name="2819"/> 2819: 			     {2, (Big1Max64 div Steps) + 1},
<a name="2820"/> 2820: 			     {4, -Big1Max64*2}]),
<a name="2821"/> 2821: 
<a name="2822"/> 2822:     %% warping with list
<a name="2823"/> 2823:     ObjE = LoopF(Obj0,1000,
<a name="2824"/> 2824: 		 [{3,SmallMax32*4 div 5,SmallMax32*2,-SmallMax32*2},
<a name="2825"/> 2825: 		  {5,-SmallMax64*4 div 7,-SmallMax64*2,SmallMax64*2},
<a name="2826"/> 2826: 		  {4,-Big1Max32*4 div 11,-Big1Max32*2,Big1Max32*2},
<a name="2827"/> 2827: 		  {2,Big1Max64*4 div 13,Big1Max64*2,-Big1Max64*2}]),
<a name="2828"/> 2828: 
<a name="2829"/> 2829:     %% warping without list
<a name="2830"/> 2830:     ObjF = LoopF(ObjE,1000,{3,SmallMax32*4 div 5,SmallMax32*2,-SmallMax32*2}),
<a name="2831"/> 2831:     ObjG = LoopF(ObjF,1000,{5,-SmallMax64*4 div 7,-SmallMax64*2,SmallMax64*2}),
<a name="2832"/> 2832:     ObjH = LoopF(ObjG,1000,{4,-Big1Max32*4 div 11,-Big1Max32*2,Big1Max32*2}),
<a name="2833"/> 2833:     ObjI = LoopF(ObjH,1000,{2,Big1Max64*4 div 13,Big1Max64*2,-Big1Max64*2}),
<a name="2834"/> 2834: 
<a name="2835"/> 2835:     %% mixing it up
<a name="2836"/> 2836:     LoopF(ObjI,1000,
<a name="2837"/> 2837: 	  [{3,SmallMax32*4 div 5,SmallMax32*2,-SmallMax32*2},
<a name="2838"/> 2838: 	   {5,-SmallMax64*4 div 3},
<a name="2839"/> 2839: 	   {3,-SmallMax32*4 div 11},
<a name="2840"/> 2840: 	   {5,0},
<a name="2841"/> 2841: 	   {4,1},
<a name="2842"/> 2842: 	   {5,-SmallMax64*4 div 7,-SmallMax64*2,SmallMax64*2},
<a name="2843"/> 2843: 	   {2,Big1Max64*4 div 13,Big1Max64*2,-Big1Max64*2}]),
<a name="update_counter_for-last_expr"/><a name="2844"/> 2844:     ok.
<a name="2845"/> 2845: 
<a name="2846"/> 2846: <i>%% uc_mimic works kind of like the real ets:update_counter</i>
<a name="2847"/> 2847: <i>%% Obj = Tuple in ets</i>
<a name="2848"/> 2848: <i>%% Pits = {Pos,Incr} | {Pos,Incr,Thres,Warp}</i>
<a name="2849"/> 2849: <i>%% Returns {Updated tuple in ets, Return value from update_counter}</i>
<a name="uc_mimic-2"/><a name="2850"/> 2850: <b>uc_mimic</b>(Obj, Pits) when is_tuple(Pits) -&gt;
<a name="2851"/> 2851:     Pos = element(1,Pits),
<a name="2852"/> 2852:     NewObj = setelement(Pos, Obj, uc_adder(element(Pos,Obj),Pits)),
<a name="2853"/> 2853:     {NewObj, element(Pos,NewObj)};
<a name="2854"/> 2854: 
<a name="2855"/> 2855: <b>uc_mimic</b>(Obj, PitsList) when is_list(PitsList) -&gt;
<a name="2856"/> 2856:     {NewObj,ValList} = uc_mimic(Obj,PitsList,[]),
<a name="uc_mimic-last_expr"/><a name="2857"/> 2857: <b>    {NewObj,lists:reverse</b>(ValList)}.
<a name="2858"/> 2858: 
<a name="uc_mimic-3"/><a name="2859"/> 2859: <b>uc_mimic</b>(Obj, [], Acc) -&gt;
<a name="2860"/> 2860:     {Obj,Acc};
<a name="2861"/> 2861: <b>uc_mimic</b>(Obj, [Pits|Tail], Acc) -&gt;
<a name="2862"/> 2862:     {NewObj,NewVal} = uc_mimic(Obj,Pits),
<a name="uc_mimic-last_expr"/><a name="2863"/> 2863: <b>    uc_mimic</b>(NewObj,Tail,[NewVal|Acc]).
<a name="2864"/> 2864: 
<a name="uc_adder-2"/><a name="2865"/> 2865: <b>uc_adder</b>(Init, {_Pos, Add}) -&gt;
<a name="2866"/> 2866:     Init + Add;
<a name="2867"/> 2867: <b>uc_adder</b>(Init, {_Pos, Add, Thres, Warp}) -&gt;
<a name="uc_adder-last_expr"/><a name="2868"/> 2868:     case Init + Add of
<a name="2869"/> 2869: 	X when X &gt; Thres, Add &gt; 0 -&gt;
<a name="2870"/> 2870: 	    Warp;
<a name="2871"/> 2871: 	Y when Y &lt; Thres, Add &lt; 0 -&gt;
<a name="2872"/> 2872: 	    Warp;
<a name="2873"/> 2873: 	Z -&gt;
<a name="2874"/> 2874: 	    Z
<a name="2875"/> 2875:     end.
<a name="2876"/> 2876: 
<a name="update_counter_neg-1"/><a name="2877"/> 2877: <b>update_counter_neg</b>(Opts) -&gt;
<a name="2878"/> 2878:     Set = ets_new(set,Opts),
<a name="2879"/> 2879:     update_counter_neg_for(Set),
<a name="2880"/> 2880:     ets:delete(Set),
<a name="2881"/> 2881:     {'EXIT',{badarg,_}} = (catch ets:update_counter(Set,key,1)),
<a name="2882"/> 2882: 
<a name="2883"/> 2883:     run_if_valid_opts(
<a name="2884"/> 2884:       [ordered_set | Opts],
<a name="2885"/> 2885:       fun (OptsOrdSet) -&gt;
<a name="2886"/> 2886:               OrdSet = ets_new(ordered_set, OptsOrdSet),
<a name="2887"/> 2887:               update_counter_neg_for(OrdSet),
<a name="2888"/> 2888:               ets:delete(OrdSet),
<a name="2889"/> 2889:               {'EXIT',{badarg,_}} = (catch ets:update_counter(OrdSet,key,1))
<a name="2890"/> 2890:       end),
<a name="2891"/> 2891: 
<a name="2892"/> 2892:     Bag = ets_new(bag,[bag | Opts]),
<a name="2893"/> 2893:     DBag = ets_new(duplicate_bag,[duplicate_bag | Opts]),
<a name="2894"/> 2894:     {'EXIT',{badarg,_}} = (catch ets:update_counter(Bag,key,1)),
<a name="2895"/> 2895:     {'EXIT',{badarg,_}} = (catch ets:update_counter(DBag,key,1)),
<a name="2896"/> 2896:     true = ets:delete(Bag),
<a name="2897"/> 2897:     true = ets:delete(DBag),
<a name="update_counter_neg-last_expr"/><a name="2898"/> 2898:     ok.
<a name="2899"/> 2899: 
<a name="update_counter_neg_for-1"/><a name="2900"/> 2900: <b>update_counter_neg_for</b>(T) -&gt;
<a name="2901"/> 2901:     Object = {key,0,false,1},
<a name="2902"/> 2902:     true = ets:insert(T,Object),
<a name="2903"/> 2903: 
<a name="2904"/> 2904:     UpdateF = fun(Arg3) -&gt;
<a name="2905"/> 2905: 		      ArgHash = erlang:phash2({T,key,Arg3}),
<a name="2906"/> 2906: 		      {'EXIT',{badarg,_}} = (catch ets:update_counter(T,key,Arg3)),
<a name="2907"/> 2907: 		      ArgHash = erlang:phash2({T,key,Arg3}),
<a name="2908"/> 2908: 		      [Object] = ets:lookup(T,key)
<a name="2909"/> 2909: 	      end,
<a name="2910"/> 2910: 
<a name="2911"/> 2911:     %% List of invalid arg3-tuples
<a name="2912"/> 2912:     InvList = [false, {2}, {2,false}, {false,1},
<a name="2913"/> 2913: 	       {0,1}, {-1,1}, % BUG &lt; R12B-2
<a name="2914"/> 2914: 	       {1,1}, {3,1}, {5,1}, {2,1,100}, {2,1,100,0,false}, {2,1,false,0}, {2,1,0,false}],
<a name="2915"/> 2915: 
<a name="2916"/> 2916:     lists:foreach(UpdateF, InvList),
<a name="2917"/> 2917:     lists:foreach(fun(Inv) -&gt; UpdateF([{2,1},Inv]) end, InvList),
<a name="2918"/> 2918:     lists:foreach(fun(Inv) -&gt; UpdateF([Inv,{2,1}]) end, InvList),
<a name="2919"/> 2919:     lists:foreach(fun(Inv) -&gt; UpdateF([{2,1},{4,-100},Inv]) end, InvList),
<a name="2920"/> 2920:     lists:foreach(fun(Inv) -&gt; UpdateF([{4,100,50,0},{2,1},Inv]) end, InvList),
<a name="2921"/> 2921:     lists:foreach(fun(Inv) -&gt; UpdateF([{2,1},Inv,{4,100,50,0}]) end, InvList),
<a name="2922"/> 2922:     lists:foreach(fun(Inv) -&gt; UpdateF([Inv,{4,100,50,0},{2,1}]) end, InvList),
<a name="2923"/> 2923:     UpdateF([{2,1} | {4,1}]),
<a name="2924"/> 2924:     lists:foreach(fun(Inv) -&gt; UpdateF([{2,1} | Inv]) end, InvList),
<a name="2925"/> 2925: 
<a name="2926"/> 2926:     {'EXIT',{badarg,_}} = (catch ets:update_counter(T,false,1)),
<a name="2927"/> 2927:     ets:delete(T,key),
<a name="2928"/> 2928:     {'EXIT',{badarg,_}} = (catch ets:update_counter(T,key,1)),
<a name="update_counter_neg_for-last_expr"/><a name="2929"/> 2929:     ok.
<a name="2930"/> 2930: 
<a name="2931"/> 2931: 
<a name="evil_update_counter-1"/><a name="2932"/> 2932: <b>evil_update_counter</b>(Config) when is_list(Config) -&gt;
<a name="2933"/> 2933:     %% The code server uses ets table. Pre-load modules that might not be
<a name="2934"/> 2934:     %% already loaded.
<a name="2935"/> 2935:     gb_sets:module_info(),
<a name="2936"/> 2936:     math:module_info(),
<a name="2937"/> 2937:     ordsets:module_info(),
<a name="2938"/> 2938:     rand:module_info(),
<a name="2939"/> 2939: 
<a name="evil_update_counter-last_expr"/><a name="2940"/> 2940: <b>    repeat_for_opts</b>(fun evil_update_counter_do/1).
<a name="2941"/> 2941: 
<a name="evil_update_counter_do-1"/><a name="2942"/> 2942: <b>evil_update_counter_do</b>(Opts) -&gt;
<a name="2943"/> 2943:     EtsMem = etsmem(),
<a name="2944"/> 2944:     process_flag(trap_exit, true),
<a name="2945"/> 2945:     Pids = [my_spawn_link(fun() -&gt; evil_counter(I,Opts) end)  || I &lt;- lists:seq(1, 40)],
<a name="2946"/> 2946:     wait_for_all(gb_sets:from_list(Pids)),
<a name="2947"/> 2947:     verify_etsmem(EtsMem),
<a name="evil_update_counter_do-last_expr"/><a name="2948"/> 2948:     ok.
<a name="2949"/> 2949: 
<a name="wait_for_all-1"/><a name="2950"/> 2950: <b>wait_for_all</b>(Pids0) -&gt;
<a name="wait_for_all-last_expr"/><a name="2951"/> 2951: <b>    case gb_sets:is_empty</b>(Pids0) of
<a name="2952"/> 2952: 	true -&gt;
<a name="2953"/> 2953: 	    ok;
<a name="2954"/> 2954: 	false -&gt;
<a name="2955"/> 2955: 	    receive
<a name="2956"/> 2956: 		{'EXIT',Pid,normal} -&gt;
<a name="2957"/> 2957: 		    Pids = gb_sets:delete(Pid, Pids0),
<a name="2958"/> 2958: 		    wait_for_all(Pids);
<a name="2959"/> 2959: 		Other -&gt;
<a name="2960"/> 2960: 		    io:format(&quot;unexpected: ~p\n&quot;, [Other]),
<a name="2961"/> 2961: 		    ct:fail(failed)
<a name="2962"/> 2962: 	    end
<a name="2963"/> 2963:     end.
<a name="2964"/> 2964: 
<a name="evil_counter-2"/><a name="2965"/> 2965: <b>evil_counter</b>(I,Opts) -&gt;
<a name="2966"/> 2966:     T = ets_new(a, Opts),
<a name="2967"/> 2967:     Start0 = case I rem 3 of
<a name="2968"/> 2968: 		 0 -&gt; 16#12345678;
<a name="2969"/> 2969: 		 1 -&gt; 16#12345678FFFFFFFF;
<a name="2970"/> 2970: 		 2 -&gt; 16#7777777777FFFFFFFF863648726743
<a name="2971"/> 2971: 	     end,
<a name="2972"/> 2972:     Start = Start0 + rand:uniform(100000),
<a name="2973"/> 2973:     ets:insert(T, {dracula,Start}),
<a name="2974"/> 2974:     Iter = 40000 div syrup_factor(),
<a name="2975"/> 2975:     End = Start + Iter,
<a name="2976"/> 2976:     End = evil_counter_1(Iter, T),
<a name="evil_counter-last_expr"/><a name="2977"/> 2977: <b>    ets:delete</b>(T).
<a name="2978"/> 2978: 
<a name="evil_counter_1-2"/><a name="2979"/> 2979: <b>evil_counter_1</b>(0, T) -&gt;
<a name="2980"/> 2980:     [{dracula,Count}] = ets:lookup(T, dracula),
<a name="2981"/> 2981:     Count;
<a name="2982"/> 2982: <b>evil_counter_1</b>(Iter, T) -&gt;
<a name="2983"/> 2983:     ets:update_counter(T, dracula, 1),
<a name="evil_counter_1-last_expr"/><a name="2984"/> 2984: <b>    evil_counter_1</b>(Iter-1, T).
<a name="2985"/> 2985: 
<a name="update_counter_with_default-1"/><a name="2986"/> 2986: <b>update_counter_with_default</b>(Config) when is_list(Config) -&gt;
<a name="update_counter_with_default-last_expr"/><a name="2987"/> 2987: <b>    repeat_for_opts</b>(fun update_counter_with_default_do/1).
<a name="2988"/> 2988: 
<a name="update_counter_with_default_do-1"/><a name="2989"/> 2989: <b>update_counter_with_default_do</b>(Opts) -&gt;
<a name="2990"/> 2990:     T1 = ets_new(a, [set | Opts]),
<a name="2991"/> 2991:     %% Insert default object.
<a name="2992"/> 2992:     3 = ets:update_counter(T1, foo, 2, {beaufort,1}),
<a name="2993"/> 2993:     1 = ets:info(T1, size),
<a name="2994"/> 2994:     %% Increment.
<a name="2995"/> 2995:     5 = ets:update_counter(T1, foo, 2, {cabecou,1}),
<a name="2996"/> 2996:     1 = ets:info(T1, size),
<a name="2997"/> 2997:     %% Increment with list.
<a name="2998"/> 2998:     [9] = ets:update_counter(T1, foo, [{2,4}], {camembert,1}),
<a name="2999"/> 2999:     1 = ets:info(T1, size),
<a name="3000"/> 3000:     %% Same with non-immediate key.
<a name="3001"/> 3001:     3 = ets:update_counter(T1, {foo,bar}, 2, {{chaource,chevrotin},1}),
<a name="3002"/> 3002:     2 = ets:info(T1, size),
<a name="3003"/> 3003:     5 = ets:update_counter(T1, {foo,bar}, 2, {{cantal,comt},1}),
<a name="3004"/> 3004:     2 = ets:info(T1, size),
<a name="3005"/> 3005:     [9] = ets:update_counter(T1, {foo,bar}, [{2,4}], {{emmental,de,savoie},1}),
<a name="3006"/> 3006:     2 = ets:info(T1, size),
<a name="3007"/> 3007:     %% default counter is not an integer.
<a name="3008"/> 3008:     {'EXIT',{badarg,_}} = (catch ets:update_counter(T1, qux, 3, {saint,flicien})),
<a name="3009"/> 3009:     2 = ets:info(T1, size),
<a name="3010"/> 3010:     %% No third element in default value.
<a name="3011"/> 3011:     {'EXIT',{badarg,_}} = (catch ets:update_counter(T1, qux, [{3,1}], {roquefort,1})),
<a name="3012"/> 3012:     2 = ets:info(T1, size),
<a name="3013"/> 3013: 
<a name="3014"/> 3014:     %% Same with ordered set.
<a name="3015"/> 3015:     run_if_valid_opts(
<a name="3016"/> 3016:       [ordered_set | Opts],
<a name="3017"/> 3017:       fun (Opts2) -&gt;
<a name="3018"/> 3018:               T2 = ets_new(b, Opts2),
<a name="3019"/> 3019:               3 = ets:update_counter(T2, foo, 2, {maroilles,1}),
<a name="3020"/> 3020:               1 = ets:info(T2, size),
<a name="3021"/> 3021:               5 = ets:update_counter(T2, foo, 2, {mimolette,1}),
<a name="3022"/> 3022:               1 = ets:info(T2, size),
<a name="3023"/> 3023:               [9] = ets:update_counter(T2, foo, [{2,4}], {morbier,1}),
<a name="3024"/> 3024:               1 = ets:info(T2, size),
<a name="3025"/> 3025:               3 = ets:update_counter(T2, {foo,bar}, 2, {{laguiole},1}),
<a name="3026"/> 3026:               2 = ets:info(T2, size),
<a name="3027"/> 3027:               5 = ets:update_counter(T2, {foo,bar}, 2, {{saint,nectaire},1}),
<a name="3028"/> 3028:               2 = ets:info(T2, size),
<a name="3029"/> 3029:               [9] = ets:update_counter(T2, {foo,bar}, [{2,4}], {{rocamadour},1}),
<a name="3030"/> 3030:               2 = ets:info(T2, size),
<a name="3031"/> 3031:               %% Arithmetically-equal keys.
<a name="3032"/> 3032:               3 = ets:update_counter(T2, 1.0, 2, {1,1}),
<a name="3033"/> 3033:               3 = ets:info(T2, size),
<a name="3034"/> 3034:               5 = ets:update_counter(T2, 1, 2, {1,1}),
<a name="3035"/> 3035:               3 = ets:info(T2, size),
<a name="3036"/> 3036:               7 = ets:update_counter(T2, 1, 2, {1.0,1}),
<a name="3037"/> 3037:               3 = ets:info(T2, size),
<a name="3038"/> 3038:               %% Same with reversed type difference.
<a name="3039"/> 3039:               3 = ets:update_counter(T2, 2, 2, {2.0,1}),
<a name="3040"/> 3040:               4 = ets:info(T2, size),
<a name="3041"/> 3041:               5 = ets:update_counter(T2, 2.0, 2, {2.0,1}),
<a name="3042"/> 3042:               4 = ets:info(T2, size),
<a name="3043"/> 3043:               7 = ets:update_counter(T2, 2.0, 2, {2,1}),
<a name="3044"/> 3044:               4 = ets:info(T2, size),
<a name="3045"/> 3045:               %% default counter is not an integer.
<a name="3046"/> 3046:               {'EXIT',{badarg,_}} = (catch ets:update_counter(T2, qux, 3, {saint,flicien})),
<a name="3047"/> 3047:               4 = ets:info(T2, size),
<a name="3048"/> 3048:               %% No third element in default value.
<a name="3049"/> 3049:               {'EXIT',{badarg,_}} = (catch ets:update_counter(T2, qux, [{3,1}], {roquefort,1})),
<a name="3050"/> 3050:               4 = ets:info(T2, size)
<a name="3051"/> 3051:       end),
<a name="update_counter_with_default_do-last_expr"/><a name="3052"/> 3052:     ok.
<a name="3053"/> 3053: 
<a name="3054"/> 3054: <i>%% ERL-1125</i>
<a name="update_counter_with_default_bad_pos-1"/><a name="3055"/> 3055: <b>update_counter_with_default_bad_pos</b>(Config) when is_list(Config) -&gt;
<a name="update_counter_with_default_bad_pos-last_expr"/><a name="3056"/> 3056: <b>    repeat_for_all_ord_set_table_types</b>(fun update_counter_with_default_bad_pos_do/1).
<a name="3057"/> 3057: 
<a name="update_counter_with_default_bad_pos_do-1"/><a name="3058"/> 3058: <b>update_counter_with_default_bad_pos_do</b>(Opts) -&gt;
<a name="3059"/> 3059:     T = ets_new(a, Opts),
<a name="3060"/> 3060:     0 = ets:info(T, size),
<a name="3061"/> 3061:     ok = try ets:update_counter(T, 101065, {1, 1}, {101065, 0})
<a name="3062"/> 3062:          catch
<a name="3063"/> 3063:              error:badarg -&gt; ok;
<a name="3064"/> 3064:              Class:Reason -&gt; {Class, Reason}
<a name="3065"/> 3065:          end,
<a name="3066"/> 3066:     0 = ets:info(T, size),
<a name="update_counter_with_default_bad_pos_do-last_expr"/><a name="3067"/> 3067:     ok.
<a name="3068"/> 3068: 
<a name="update_counter_table_growth-1"/><a name="3069"/> 3069: <b>update_counter_table_growth</b>(_Config) -&gt;
<a name="update_counter_table_growth-last_expr"/><a name="3070"/> 3070: <b>    repeat_for_opts</b>(fun update_counter_table_growth_do/1).
<a name="3071"/> 3071: 
<a name="update_counter_table_growth_do-1"/><a name="3072"/> 3072: <b>update_counter_table_growth_do</b>(Opts) -&gt;
<a name="3073"/> 3073:     Set = ets_new(b, [set | Opts]),
<a name="3074"/> 3074:     [ets:update_counter(Set, N, {2, 1}, {N, 1}) || N &lt;- lists:seq(1,10000)],
<a name="3075"/> 3075: 
<a name="3076"/> 3076:     run_if_valid_opts(
<a name="3077"/> 3077:       [ordered_set | Opts],
<a name="3078"/> 3078:       fun(OptsOrdSet) -&gt;
<a name="3079"/> 3079:               OrdSet = ets_new(b, OptsOrdSet),
<a name="3080"/> 3080:               [ets:update_counter(OrdSet, N, {2, 1}, {N, 1})
<a name="3081"/> 3081:                || N &lt;- lists:seq(1,10000)]
<a name="3082"/> 3082:       end),
<a name="update_counter_table_growth_do-last_expr"/><a name="3083"/> 3083:     ok.
<a name="3084"/> 3084: 
<a name="3085"/> 3085: <i>%% Check that a first-next sequence always works on a fixed table.</i>
<a name="fixtable_next-1"/><a name="3086"/> 3086: <b>fixtable_next</b>(Config) when is_list(Config) -&gt;
<a name="fixtable_next-last_expr"/><a name="3087"/> 3087: <b>    repeat_for_opts</b>(fun fixtable_next_do/1,
<a name="3088"/> 3088:                     [write_concurrency,all_types]).
<a name="3089"/> 3089: 
<a name="fixtable_next_do-1"/><a name="3090"/> 3090: <b>fixtable_next_do</b>(Opts) -&gt;
<a name="3091"/> 3091:     EtsMem = etsmem(),
<a name="3092"/> 3092:     do_fixtable_next(ets_new(set,[public | Opts])),
<a name="fixtable_next_do-last_expr"/><a name="3093"/> 3093: <b>    verify_etsmem</b>(EtsMem).
<a name="3094"/> 3094: 
<a name="do_fixtable_next-1"/><a name="3095"/> 3095: <b>do_fixtable_next</b>(Tab) -&gt;
<a name="3096"/> 3096:     F = fun(X,T,FF) -&gt;
<a name="3097"/> 3097:                 case X of
<a name="3098"/> 3098:                     0 -&gt; true;
<a name="3099"/> 3099:                     _ -&gt;
<a name="3100"/> 3100:                         ets:insert(T, {X,
<a name="3101"/> 3101:                                        integer_to_list(X),
<a name="3102"/> 3102:                                        X rem 10}),
<a name="3103"/> 3103:                         FF(X-1,T,FF)
<a name="3104"/> 3104:                 end
<a name="3105"/> 3105:         end,
<a name="3106"/> 3106:     F(100,Tab,F),
<a name="3107"/> 3107:     ets:safe_fixtable(Tab,true),
<a name="3108"/> 3108:     First = ets:first(Tab),
<a name="3109"/> 3109:     ets:delete(Tab, First),
<a name="3110"/> 3110:     ets:next(Tab, First),
<a name="3111"/> 3111:     ets:match_delete(Tab,{'_','_','_'}),
<a name="3112"/> 3112:     '$end_of_table' = ets:next(Tab, First),
<a name="3113"/> 3113:     true = ets:info(Tab, fixed),
<a name="3114"/> 3114:     ets:safe_fixtable(Tab, false),
<a name="3115"/> 3115:     false = ets:info(Tab, fixed),
<a name="do_fixtable_next-last_expr"/><a name="3116"/> 3116: <b>    ets:delete</b>(Tab).
<a name="3117"/> 3117: 
<a name="3118"/> 3118: <i>%% Check that iteration of bags find all live objects and nothing else.</i>
<a name="fixtable_iter_bag-1"/><a name="3119"/> 3119: <b>fixtable_iter_bag</b>(Config) when is_list(Config) -&gt;
<a name="fixtable_iter_bag-last_expr"/><a name="3120"/> 3120: <b>    repeat_for_opts</b>(fun fixtable_iter_do/1,
<a name="3121"/> 3121:                     [write_concurrency,[bag,duplicate_bag]]).
<a name="3122"/> 3122: 
<a name="fixtable_iter_do-1"/><a name="3123"/> 3123: <b>fixtable_iter_do</b>(Opts) -&gt;
<a name="3124"/> 3124:     EtsMem = etsmem(),
<a name="3125"/> 3125:     do_fixtable_iter_bag(ets_new(fixtable_iter_bag,Opts)),
<a name="fixtable_iter_do-last_expr"/><a name="3126"/> 3126: <b>    verify_etsmem</b>(EtsMem).
<a name="3127"/> 3127: 
<a name="do_fixtable_iter_bag-1"/><a name="3128"/> 3128: <b>do_fixtable_iter_bag</b>(T) -&gt;
<a name="3129"/> 3129:     MaxValues = 4,
<a name="3130"/> 3130:     %% Create 1 to MaxValues objects for each key
<a name="3131"/> 3131:     %% and then delete every possible combination of those objects
<a name="3132"/> 3132:     %% in every possible order.
<a name="3133"/> 3133:     %% Then test iteration returns all live objects and nothing else.
<a name="3134"/> 3134: 
<a name="3135"/> 3135:     CrDelOps = [begin
<a name="3136"/> 3136:                     Values = lists:seq(1,N),
<a name="3137"/> 3137:                     %% All ways of deleting any number of the Values in any order
<a name="3138"/> 3138:                     Combos = combs(Values),
<a name="3139"/> 3139:                     DeleteOps = concat_lists([perms(C) || C &lt;- Combos]),
<a name="3140"/> 3140:                     {N, DeleteOps}
<a name="3141"/> 3141:                 end
<a name="3142"/> 3142:                 || N &lt;- lists:seq(1,MaxValues)],
<a name="3143"/> 3143: 
<a name="3144"/> 3144:     %%io:format(&quot;~p\n&quot;, [CrDelOps]),
<a name="3145"/> 3145: 
<a name="3146"/> 3146:     NKeys = lists:foldl(fun({_, DeleteOps}, Cnt) -&gt;
<a name="3147"/> 3147:                                Cnt + length(DeleteOps)
<a name="3148"/> 3148:                        end,
<a name="3149"/> 3149:                        0,
<a name="3150"/> 3150:                        CrDelOps),
<a name="3151"/> 3151: 
<a name="3152"/> 3152:     io:format(&quot;Create ~p keys\n&quot;, [NKeys]),
<a name="3153"/> 3153: 
<a name="3154"/> 3154:     %% Fixate even before inserts just to maintain small table size
<a name="3155"/> 3155:     %% and increase likelyhood of different keys in same bucket.
<a name="3156"/> 3156:     ets:safe_fixtable(T,true),
<a name="3157"/> 3157:     InsRes = [begin
<a name="3158"/> 3158:                   [begin
<a name="3159"/> 3159:                        Key = {NValues,ValueList},
<a name="3160"/> 3160:                        [begin
<a name="3161"/> 3161:                             Tpl = {Key, V},
<a name="3162"/> 3162:                             %%io:format(&quot;Insert object ~p&quot;, [Tpl]),
<a name="3163"/> 3163:                             ets:insert(T, Tpl),
<a name="3164"/> 3164:                             Tpl
<a name="3165"/> 3165:                         end
<a name="3166"/> 3166:                         || V &lt;- lists:seq(1,NValues)]
<a name="3167"/> 3167:                    end
<a name="3168"/> 3168:                    || ValueList &lt;- DeleteOps]
<a name="3169"/> 3169:               end
<a name="3170"/> 3170:               || {NValues, DeleteOps} &lt;- CrDelOps],
<a name="3171"/> 3171: 
<a name="3172"/> 3172:     Inserted = lists:flatten(InsRes),
<a name="3173"/> 3173:     InSorted = lists:sort(Inserted),
<a name="3174"/> 3174:     InSorted = lists:usort(Inserted),  %% No duplicates
<a name="3175"/> 3175:     NObjs = length(Inserted),
<a name="3176"/> 3176: 
<a name="3177"/> 3177:     DelRes = [begin
<a name="3178"/> 3178:                   [begin
<a name="3179"/> 3179:                        Key = {NValues,ValueList},
<a name="3180"/> 3180:                        [begin
<a name="3181"/> 3181:                             Tpl = {Key, V},
<a name="3182"/> 3182:                             %%io:format(&quot;Delete object ~p&quot;, [Tpl]),
<a name="3183"/> 3183:                             ets:delete_object(T, Tpl),
<a name="3184"/> 3184:                             Tpl
<a name="3185"/> 3185:                         end
<a name="3186"/> 3186:                         || V &lt;- ValueList]
<a name="3187"/> 3187:                    end
<a name="3188"/> 3188:                    || ValueList &lt;- DeleteOps]
<a name="3189"/> 3189:               end
<a name="3190"/> 3190:               || {NValues, DeleteOps} &lt;- CrDelOps],
<a name="3191"/> 3191: 
<a name="3192"/> 3192:     Deleted = lists:flatten(DelRes),
<a name="3193"/> 3193:     DelSorted = lists:sort(Deleted),
<a name="3194"/> 3194:     DelSorted = lists:usort(Deleted),  %% No duplicates
<a name="3195"/> 3195:     NDels = length(Deleted),
<a name="3196"/> 3196: 
<a name="3197"/> 3197:     %% Nr of keys where all values were deleted.
<a name="3198"/> 3198:     NDeletedKeys = lists:sum([factorial(N) || N &lt;- lists:seq(1,MaxValues)]),
<a name="3199"/> 3199: 
<a name="3200"/> 3200:     CountKeysFun = fun Me(K1, Cnt) -&gt;
<a name="3201"/> 3201:                            case ets:next(T, K1) of
<a name="3202"/> 3202:                                '$end_of_table' -&gt;
<a name="3203"/> 3203:                                    Cnt;
<a name="3204"/> 3204:                                K2 -&gt;
<a name="3205"/> 3205:                                    Objs = ets:lookup(T, K2),
<a name="3206"/> 3206:                                    [{{NValues, ValueList}, _V} | _] = Objs,
<a name="3207"/> 3207:                                    ExpectedLive = NValues - length(ValueList),
<a name="3208"/> 3208:                                    ExpectedLive = length(Objs),
<a name="3209"/> 3209:                                    Me(K2, Cnt+1)
<a name="3210"/> 3210:                            end
<a name="3211"/> 3211:                    end,
<a name="3212"/> 3212: 
<a name="3213"/> 3213:     ExpectedKeys = NKeys - NDeletedKeys,
<a name="3214"/> 3214:     io:format(&quot;Expected keys: ~p\n&quot;, [ExpectedKeys]),
<a name="3215"/> 3215:     FoundKeys = CountKeysFun(ets:first(T), 1),
<a name="3216"/> 3216:     io:format(&quot;Found keys: ~p\n&quot;, [FoundKeys]),
<a name="3217"/> 3217:     ExpectedKeys = FoundKeys,
<a name="3218"/> 3218: 
<a name="3219"/> 3219:     ExpectedObjs = NObjs - NDels,
<a name="3220"/> 3220:     io:format(&quot;Expected objects: ~p\n&quot;, [ExpectedObjs]),
<a name="3221"/> 3221:     FoundObjs = ets:select_count(T, [{{'_','_'}, [], [true]}]),
<a name="3222"/> 3222:     io:format(&quot;Found objects: ~p\n&quot;, [FoundObjs]),
<a name="3223"/> 3223:     ExpectedObjs = FoundObjs,
<a name="3224"/> 3224: 
<a name="do_fixtable_iter_bag-last_expr"/><a name="3225"/> 3225: <b>    ets:delete</b>(T).
<a name="3226"/> 3226: 
<a name="3227"/> 3227: <i>%% All permutations of list</i>
<a name="perms-1"/><a name="3228"/> 3228: <b>perms</b>([]) -&gt; [[]];
<a name="perms-last_expr"/><a name="3229"/> 3229: <b>perms</b>(L)  -&gt; [[H|T] || H &lt;- L, T &lt;- perms(L--[H])].
<a name="3230"/> 3230: 
<a name="3231"/> 3231: <i>%% All combinations of picking the element (or not) from list</i>
<a name="combs-1"/><a name="3232"/> 3232: <b>combs</b>([]) -&gt; [[]];
<a name="3233"/> 3233: <b>combs</b>([H|T]) -&gt;
<a name="3234"/> 3234:     Tcombs = combs(T),
<a name="combs-last_expr"/><a name="3235"/> 3235:     Tcombs ++ [[H | C] || C &lt;- Tcombs].
<a name="3236"/> 3236: 
<a name="factorial-1"/><a name="3237"/> 3237: <b>factorial</b>(0) -&gt; 1;
<a name="3238"/> 3238: <b>factorial</b>(N) when N &gt; 0 -&gt;
<a name="factorial-last_expr"/><a name="3239"/> 3239: <b>    N * factorial</b>(N - 1).
<a name="3240"/> 3240: 
<a name="concat_lists-1"/><a name="3241"/> 3241: <b>concat_lists</b>([]) -&gt;
<a name="3242"/> 3242:     [];
<a name="3243"/> 3243: <b>concat_lists</b>([H|T]) -&gt;
<a name="concat_lists-last_expr"/><a name="3244"/> 3244: <b>    H ++ concat_lists</b>(T).
<a name="3245"/> 3245: 
<a name="3246"/> 3246: 
<a name="3247"/> 3247: <i>%% Check inserts of deleted keys in fixed bags.</i>
<a name="fixtable_insert-1"/><a name="3248"/> 3248: <b>fixtable_insert</b>(Config) when is_list(Config) -&gt;
<a name="3249"/> 3249:     Combos = [[Type,{write_concurrency,WC}] || Type&lt;- [bag,duplicate_bag],
<a name="3250"/> 3250: 					       WC &lt;- [false,true]],
<a name="3251"/> 3251:     lists:foreach(fun(Opts) -&gt; fixtable_insert_do(Opts) end,
<a name="3252"/> 3252: 		  Combos),
<a name="fixtable_insert-last_expr"/><a name="3253"/> 3253:     ok.
<a name="3254"/> 3254: 
<a name="fixtable_insert_do-1"/><a name="3255"/> 3255: <b>fixtable_insert_do</b>(Opts) -&gt;
<a name="3256"/> 3256:     io:format(&quot;Opts = ~p\n&quot;,[Opts]),
<a name="3257"/> 3257:     Ets = make_table(ets, Opts, [{a,1}, {a,2}, {b,1}, {b,2}]),
<a name="3258"/> 3258:     ets:safe_fixtable(Ets,true),
<a name="3259"/> 3259:     ets:match_delete(Ets,{b,1}),
<a name="3260"/> 3260:     First = ets:first(Ets),
<a name="3261"/> 3261:     Next = case First of
<a name="3262"/> 3262: 	       a -&gt; b;
<a name="3263"/> 3263: 	       b -&gt; a
<a name="3264"/> 3264: 	   end,
<a name="3265"/> 3265:     Next = ets:next(Ets,First),
<a name="3266"/> 3266:     ets:delete(Ets,Next),
<a name="3267"/> 3267:     '$end_of_table' = ets:next(Ets,First),
<a name="3268"/> 3268:     ets:insert(Ets, {Next,1}),
<a name="3269"/> 3269:     false = ets:insert_new(Ets, {Next,1}),
<a name="3270"/> 3270:     Next = ets:next(Ets,First),
<a name="3271"/> 3271:     '$end_of_table' = ets:next(Ets,Next),
<a name="3272"/> 3272:     ets:delete(Ets,Next),
<a name="3273"/> 3273:     '$end_of_table' = ets:next(Ets,First),
<a name="3274"/> 3274:     ets:insert(Ets, {Next,2}),
<a name="3275"/> 3275:     false = ets:insert_new(Ets, {Next,1}),
<a name="3276"/> 3276:     Next = ets:next(Ets,First),
<a name="3277"/> 3277:     '$end_of_table' = ets:next(Ets,Next),
<a name="3278"/> 3278:     ets:delete(Ets,First),
<a name="3279"/> 3279:     Next = ets:first(Ets),
<a name="3280"/> 3280:     '$end_of_table' = ets:next(Ets,Next),
<a name="3281"/> 3281:     ets:delete(Ets,Next),
<a name="3282"/> 3282:     '$end_of_table' = ets:next(Ets,First),
<a name="3283"/> 3283:     true = ets:insert_new(Ets,{Next,1}),
<a name="3284"/> 3284:     false = ets:insert_new(Ets,{Next,2}),
<a name="3285"/> 3285:     Next = ets:next(Ets,First),
<a name="3286"/> 3286:     ets:delete_object(Ets,{Next,1}),
<a name="3287"/> 3287:     '$end_of_table' = ets:next(Ets,First),
<a name="3288"/> 3288:     true = ets:insert_new(Ets,{Next,2}),
<a name="3289"/> 3289:     false = ets:insert_new(Ets,{Next,1}),
<a name="3290"/> 3290:     Next = ets:next(Ets,First),
<a name="3291"/> 3291:     ets:delete(Ets,First),
<a name="3292"/> 3292:     ets:safe_fixtable(Ets,false),
<a name="3293"/> 3293:     {'EXIT',{badarg,_}} = (catch ets:next(Ets,First)),
<a name="fixtable_insert_do-last_expr"/><a name="3294"/> 3294:     ok.
<a name="3295"/> 3295: 
<a name="3296"/> 3296: <i>%% Test the 'write_concurrency' option.</i>
<a name="write_concurrency-1"/><a name="3297"/> 3297: <b>write_concurrency</b>(Config) when is_list(Config) -&gt;
<a name="3298"/> 3298:     EtsMem = etsmem(),
<a name="3299"/> 3299:     Yes1 = ets_new(foo,[public,{write_concurrency,true}]),
<a name="3300"/> 3300:     Yes2 = ets_new(foo,[protected,{write_concurrency,true}]),
<a name="3301"/> 3301:     No1 = ets_new(foo,[private,{write_concurrency,true}]),
<a name="3302"/> 3302: 
<a name="3303"/> 3303:     Yes3 = ets_new(foo,[bag,public,{write_concurrency,true}]),
<a name="3304"/> 3304:     Yes4 = ets_new(foo,[bag,protected,{write_concurrency,true}]),
<a name="3305"/> 3305:     No2 = ets_new(foo,[bag,private,{write_concurrency,true}]),
<a name="3306"/> 3306: 
<a name="3307"/> 3307:     Yes5 = ets_new(foo,[duplicate_bag,public,{write_concurrency,true}]),
<a name="3308"/> 3308:     Yes6 = ets_new(foo,[duplicate_bag,protected,{write_concurrency,true}]),
<a name="3309"/> 3309:     No3 = ets_new(foo,[duplicate_bag,private,{write_concurrency,true}]),
<a name="3310"/> 3310: 
<a name="3311"/> 3311:     NoCentCtrs = {decentralized_counters,false},
<a name="3312"/> 3312:     Yes7 = ets_new(foo,[ordered_set,public,{write_concurrency,true},NoCentCtrs]),
<a name="3313"/> 3313:     Yes8 = ets_new(foo,[ordered_set,protected,{write_concurrency,true},NoCentCtrs]),
<a name="3314"/> 3314:     Yes9 = ets_new(foo,[ordered_set,{write_concurrency,true},NoCentCtrs]),
<a name="3315"/> 3315:     Yes10 = ets_new(foo,[{write_concurrency,true},ordered_set,public,NoCentCtrs]),
<a name="3316"/> 3316:     Yes11 = ets_new(foo,[{write_concurrency,true},ordered_set,protected,NoCentCtrs]),
<a name="3317"/> 3317:     Yes12 = ets_new(foo,[set,{write_concurrency,false},
<a name="3318"/> 3318:                          {write_concurrency,true},ordered_set,public,NoCentCtrs]),
<a name="3319"/> 3319:     Yes13 = ets_new(foo,[private,public,set,{write_concurrency,false},
<a name="3320"/> 3320:                          {write_concurrency,true},ordered_set,NoCentCtrs]),
<a name="3321"/> 3321:     Yes14 = ets_new(foo,[ordered_set,public,{write_concurrency,true}]),
<a name="3322"/> 3322:     No4 = ets_new(foo,[ordered_set,private,{write_concurrency,true}]),
<a name="3323"/> 3323:     No5 = ets_new(foo,[ordered_set,public,{write_concurrency,false}]),
<a name="3324"/> 3324:     No6 = ets_new(foo,[ordered_set,protected,{write_concurrency,false}]),
<a name="3325"/> 3325:     No7 = ets_new(foo,[ordered_set,private,{write_concurrency,false}]),
<a name="3326"/> 3326: 
<a name="3327"/> 3327:     No8 = ets_new(foo,[public,{write_concurrency,false}]),
<a name="3328"/> 3328:     No9 = ets_new(foo,[protected,{write_concurrency,false}]),
<a name="3329"/> 3329: 
<a name="3330"/> 3330:     YesMem = ets:info(Yes1,memory),
<a name="3331"/> 3331:     NoHashMem = ets:info(No1,memory),
<a name="3332"/> 3332:     YesTreeMem = ets:info(Yes7,memory),
<a name="3333"/> 3333:     YesYesTreeMem = ets:info(Yes14,memory),
<a name="3334"/> 3334:     NoTreeMem = ets:info(No4,memory),
<a name="3335"/> 3335: 
<a name="3336"/> 3336:     io:format(&quot;YesMem=~p NoHashMem=~p NoTreeMem=~p YesTreeMem=~p YesYesTreeMem=~p\n&quot;,
<a name="3337"/> 3337:               [YesMem,NoHashMem,NoTreeMem,YesTreeMem,YesYesTreeMem]),
<a name="3338"/> 3338: 
<a name="3339"/> 3339:     YesMem = ets:info(Yes2,memory),
<a name="3340"/> 3340:     YesMem = ets:info(Yes3,memory),
<a name="3341"/> 3341:     YesMem = ets:info(Yes4,memory),
<a name="3342"/> 3342:     YesMem = ets:info(Yes5,memory),
<a name="3343"/> 3343:     YesMem = ets:info(Yes6,memory),
<a name="3344"/> 3344:     NoHashMem = ets:info(No2,memory),
<a name="3345"/> 3345:     NoHashMem = ets:info(No3,memory),
<a name="3346"/> 3346:     YesTreeMem = ets:info(Yes7,memory),
<a name="3347"/> 3347:     YesTreeMem = ets:info(Yes8,memory),
<a name="3348"/> 3348:     YesTreeMem = ets:info(Yes9,memory),
<a name="3349"/> 3349:     YesTreeMem = ets:info(Yes10,memory),
<a name="3350"/> 3350:     YesTreeMem = ets:info(Yes11,memory),
<a name="3351"/> 3351:     YesTreeMem = ets:info(Yes12,memory),
<a name="3352"/> 3352:     YesTreeMem = ets:info(Yes13,memory),
<a name="3353"/> 3353:     NoTreeMem = ets:info(No4,memory),
<a name="3354"/> 3354:     NoTreeMem = ets:info(No5,memory),
<a name="3355"/> 3355:     NoTreeMem = ets:info(No6,memory),
<a name="3356"/> 3356:     NoTreeMem = ets:info(No7,memory),
<a name="3357"/> 3357:     NoHashMem = ets:info(No8,memory),
<a name="3358"/> 3358:     NoHashMem = ets:info(No9,memory),
<a name="3359"/> 3359: 
<a name="3360"/> 3360:     true = YesMem &gt; YesTreeMem,
<a name="3361"/> 3361: 
<a name="3362"/> 3362:     case erlang:system_info(schedulers) of
<a name="3363"/> 3363:         1 -&gt;
<a name="3364"/> 3364:             YesMem = NoHashMem,
<a name="3365"/> 3365:             YesTreeMem = NoTreeMem,
<a name="3366"/> 3366:             YesYesTreeMem = YesTreeMem;
<a name="3367"/> 3367:         NoSchedulers -&gt;
<a name="3368"/> 3368:             true = YesMem &gt; NoHashMem,
<a name="3369"/> 3369:             true = YesMem &gt; NoTreeMem,
<a name="3370"/> 3370: 
<a name="3371"/> 3371:             %% The memory of ordered_set with write concurrency is
<a name="3372"/> 3372:             %% smaller than without write concurrency on 64-bit systems with
<a name="3373"/> 3373:             %% few schedulers.
<a name="3374"/> 3374:             Bits = 8*erlang:system_info(wordsize),
<a name="3375"/> 3375:             if Bits =:= 32;
<a name="3376"/> 3376:                NoSchedulers &gt; 6 -&gt;
<a name="3377"/> 3377:                     true = YesTreeMem &gt;= NoTreeMem;
<a name="3378"/> 3378:                true -&gt;
<a name="3379"/> 3379:                     true = YesTreeMem &lt; NoTreeMem
<a name="3380"/> 3380:             end,
<a name="3381"/> 3381:             true = YesYesTreeMem &gt; YesTreeMem
<a name="3382"/> 3382:     end,
<a name="3383"/> 3383: 
<a name="3384"/> 3384:     {'EXIT',{badarg,_}} = (catch ets_new(foo,[public,{write_concurrency,foo}])),
<a name="3385"/> 3385:     {'EXIT',{badarg,_}} = (catch ets_new(foo,[public,{write_concurrency}])),
<a name="3386"/> 3386:     {'EXIT',{badarg,_}} = (catch ets_new(foo,[public,{write_concurrency,true,foo}])),
<a name="3387"/> 3387:     {'EXIT',{badarg,_}} = (catch ets_new(foo,[public,write_concurrency])),
<a name="3388"/> 3388: 
<a name="3389"/> 3389:     lists:foreach(fun(T) -&gt; ets:delete(T) end,
<a name="3390"/> 3390:         	  [Yes1,Yes2,Yes3,Yes4,Yes5,Yes6,Yes7,Yes8,Yes9,Yes10,Yes11,Yes12,Yes13,Yes14,
<a name="3391"/> 3391:         	   No1,No2,No3,No4,No5,No6,No7,No8,No9]),
<a name="3392"/> 3392:     verify_etsmem(EtsMem),
<a name="write_concurrency-last_expr"/><a name="3393"/> 3393:     ok.
<a name="3394"/> 3394: 
<a name="3395"/> 3395: 
<a name="3396"/> 3396: <i>%% The 'heir' option.</i>
<a name="heir-1"/><a name="3397"/> 3397: <b>heir</b>(Config) when is_list(Config) -&gt;
<a name="heir-last_expr"/><a name="3398"/> 3398: <b>    repeat_for_opts</b>(fun heir_do/1).
<a name="3399"/> 3399: 
<a name="heir_do-1"/><a name="3400"/> 3400: <b>heir_do</b>(Opts) -&gt;
<a name="3401"/> 3401:     EtsMem = etsmem(),
<a name="3402"/> 3402:     Master = self(),
<a name="3403"/> 3403: 
<a name="3404"/> 3404:     %% Different types of heir data and link/monitor relations
<a name="3405"/> 3405:     TestFun = fun(Arg) -&gt; {EtsMem,Arg} end,
<a name="3406"/> 3406:     Combos = [{Data,Mode} || Data&lt;-[foo_data, &lt;&lt;&quot;binary&quot;&gt;&gt;,
<a name="3407"/> 3407: 				    lists:seq(1,10), {17,TestFun,self()},
<a name="3408"/> 3408: 				    &quot;The busy heir&quot;],
<a name="3409"/> 3409: 			     Mode&lt;-[none,link,monitor]],
<a name="3410"/> 3410:     lists:foreach(fun({Data,Mode})-&gt; heir_1(Data,Mode,Opts) end,
<a name="3411"/> 3411: 		  Combos),
<a name="3412"/> 3412: 
<a name="3413"/> 3413:     %% No heir
<a name="3414"/> 3414:     {Founder1,MrefF1} = my_spawn_monitor(fun()-&gt;heir_founder(Master,foo_data,Opts)end),
<a name="3415"/> 3415:     Founder1 ! {go, none},
<a name="3416"/> 3416:     {&quot;No heir&quot;,Founder1} = receive_any(),
<a name="3417"/> 3417:     {'DOWN', MrefF1, process, Founder1, normal} = receive_any(),
<a name="3418"/> 3418:     undefined = ets:info(foo),
<a name="3419"/> 3419: 
<a name="3420"/> 3420:     %% An already dead heir
<a name="3421"/> 3421:     {Heir2,MrefH2} = my_spawn_monitor(fun()-&gt;die end),
<a name="3422"/> 3422:     {'DOWN', MrefH2, process, Heir2, normal} = receive_any(),
<a name="3423"/> 3423:     {Founder2,MrefF2} = my_spawn_monitor(fun()-&gt;heir_founder(Master,foo_data,Opts)end),
<a name="3424"/> 3424:     Founder2 ! {go, Heir2},
<a name="3425"/> 3425:     {&quot;No heir&quot;,Founder2} = receive_any(),
<a name="3426"/> 3426:     {'DOWN', MrefF2, process, Founder2, normal} = receive_any(),
<a name="3427"/> 3427:     undefined = ets:info(foo),
<a name="3428"/> 3428: 
<a name="3429"/> 3429:     %% When heir dies before founder
<a name="3430"/> 3430:     {Founder3,MrefF3} = my_spawn_monitor(fun()-&gt;heir_founder(Master,&quot;The dying heir&quot;,Opts)end),
<a name="3431"/> 3431:     {Heir3,MrefH3} = my_spawn_monitor(fun()-&gt;heir_heir(Founder3)end),
<a name="3432"/> 3432:     Founder3 ! {go, Heir3},
<a name="3433"/> 3433:     {'DOWN', MrefH3, process, Heir3, normal} = receive_any(),
<a name="3434"/> 3434:     Founder3 ! die_please,
<a name="3435"/> 3435:     {'DOWN', MrefF3, process, Founder3, normal} = receive_any(),
<a name="3436"/> 3436:     undefined = ets:info(foo),
<a name="3437"/> 3437: 
<a name="3438"/> 3438:     %% When heir dies and pid reused before founder dies
<a name="3439"/> 3439:     repeat_while(fun() -&gt;
<a name="3440"/> 3440: 			 NextPidIx = erts_debug:get_internal_state(next_pid),
<a name="3441"/> 3441: 			 {Founder4,MrefF4} = my_spawn_monitor(fun()-&gt;heir_founder(Master,&quot;The dying heir&quot;,Opts)end),
<a name="3442"/> 3442: 			 {Heir4,MrefH4} = my_spawn_monitor(fun()-&gt;heir_heir(Founder4)end),
<a name="3443"/> 3443: 			 Founder4 ! {go, Heir4},
<a name="3444"/> 3444: 			 {'DOWN', MrefH4, process, Heir4, normal} = receive_any(),
<a name="3445"/> 3445: 			 erts_debug:set_internal_state(next_pid, NextPidIx),
<a name="3446"/> 3446: 			 DoppelGanger = spawn_monitor_with_pid(Heir4,
<a name="3447"/> 3447: 							       fun()-&gt; die_please = receive_any() end),
<a name="3448"/> 3448: 			 Founder4 ! die_please,
<a name="3449"/> 3449: 			 {'DOWN', MrefF4, process, Founder4, normal} = receive_any(),
<a name="3450"/> 3450: 			 case DoppelGanger of
<a name="3451"/> 3451: 			     {Heir4,MrefH4_B} -&gt;
<a name="3452"/> 3452: 				 Heir4 ! die_please,
<a name="3453"/> 3453: 				 {'DOWN', MrefH4_B, process, Heir4, normal} = receive_any(),
<a name="3454"/> 3454: 				 undefined = ets:info(foo),
<a name="3455"/> 3455: 				 false;
<a name="3456"/> 3456: 			     failed -&gt;
<a name="3457"/> 3457: 				 io:format(&quot;Failed to spawn process with pid ~p\n&quot;, [Heir4]),
<a name="3458"/> 3458: 				 true % try again
<a name="3459"/> 3459: 			 end
<a name="3460"/> 3460: 		 end),
<a name="3461"/> 3461: 
<a name="heir_do-last_expr"/><a name="3462"/> 3462: <b>    verify_etsmem</b>(EtsMem).
<a name="3463"/> 3463: 
<a name="heir_founder-3"/><a name="3464"/> 3464: <b>heir_founder</b>(Master, HeirData, Opts) -&gt;
<a name="3465"/> 3465:     {go,Heir} = receive_any(),
<a name="3466"/> 3466:     HeirTpl = case Heir of
<a name="3467"/> 3467: 		  none -&gt; {heir,none};
<a name="3468"/> 3468: 		  _ -&gt; {heir, Heir, HeirData}
<a name="3469"/> 3469: 	      end,
<a name="3470"/> 3470:     T = ets_new(foo,[named_table, private, HeirTpl | Opts]),
<a name="3471"/> 3471:     true = ets:insert(T,{key,1}),
<a name="3472"/> 3472:     [{key,1}] = ets:lookup(T,key),
<a name="3473"/> 3473:     Self = self(),
<a name="3474"/> 3474:     Self = ets:info(T,owner),
<a name="heir_founder-last_expr"/><a name="3475"/> 3475: <b>    case ets:info</b>(T,heir) of
<a name="3476"/> 3476: 	none -&gt;
<a name="3477"/> 3477: 	    true = (Heir =:= none) orelse (not is_process_alive(Heir)),
<a name="3478"/> 3478: 	    Master ! {&quot;No heir&quot;,self()};
<a name="3479"/> 3479: 
<a name="3480"/> 3480: 	Heir -&gt;
<a name="3481"/> 3481: 	    true = is_process_alive(Heir),
<a name="3482"/> 3482: 	    Heir ! {table,T,HeirData},
<a name="3483"/> 3483: 	    die_please = receive_any()
<a name="3484"/> 3484:     end.
<a name="3485"/> 3485: 
<a name="3486"/> 3486: 
<a name="heir_heir-1"/><a name="3487"/> 3487: <b>heir_heir</b>(Founder) -&gt;
<a name="heir_heir-last_expr"/><a name="3488"/> 3488: <b>    heir_heir</b>(Founder, none).
<a name="heir_heir-2"/><a name="3489"/> 3489: <b>heir_heir</b>(Founder, Mode) -&gt;
<a name="3490"/> 3490:     {table,T,HeirData} = receive_any(),
<a name="3491"/> 3491:     {'EXIT',{badarg,_}} = (catch ets:lookup(T,key)),
<a name="3492"/> 3492:     case HeirData of
<a name="3493"/> 3493: 	&quot;The dying heir&quot; -&gt; exit(normal);
<a name="3494"/> 3494: 	_ -&gt; ok
<a name="3495"/> 3495:     end,
<a name="3496"/> 3496: 
<a name="3497"/> 3497:     Mref = case Mode of
<a name="3498"/> 3498: 	       link -&gt; process_flag(trap_exit, true),
<a name="3499"/> 3499: 		       link(Founder);
<a name="3500"/> 3500: 	       monitor -&gt; erlang:monitor(process,Founder);
<a name="3501"/> 3501: 	       none -&gt; ok
<a name="3502"/> 3502: 	   end,
<a name="3503"/> 3503:     Founder ! die_please,
<a name="3504"/> 3504:     Msg = case HeirData of
<a name="3505"/> 3505: 	      &quot;The busy heir&quot; -&gt; receive_any_spinning();
<a name="3506"/> 3506: 	      _ -&gt; receive_any()
<a name="3507"/> 3507: 	  end,
<a name="3508"/> 3508:     {'ETS-TRANSFER', T, Founder, HeirData} = Msg,
<a name="3509"/> 3509:     foo = T,
<a name="3510"/> 3510:     Self = self(),
<a name="3511"/> 3511:     Self = ets:info(T,owner),
<a name="3512"/> 3512:     Self = ets:info(T,heir),
<a name="3513"/> 3513:     [{key,1}] = ets:lookup(T,key),
<a name="3514"/> 3514:     true = ets:insert(T,{key,2}),
<a name="3515"/> 3515:     [{key,2}] = ets:lookup(T,key),
<a name="heir_heir-last_expr"/><a name="3516"/> 3516:     case Mode of % Verify that EXIT or DOWN comes after ETS-TRANSFER
<a name="3517"/> 3517: 	link -&gt;
<a name="3518"/> 3518: 	    {'EXIT',Founder,normal} = receive_any(),
<a name="3519"/> 3519: 	    process_flag(trap_exit, false);
<a name="3520"/> 3520: 	monitor -&gt;
<a name="3521"/> 3521: 	    {'DOWN', Mref, process, Founder, normal} = receive_any();
<a name="3522"/> 3522: 	none -&gt; ok
<a name="3523"/> 3523:     end.
<a name="3524"/> 3524: 
<a name="3525"/> 3525: 
<a name="heir_1-3"/><a name="3526"/> 3526: <b>heir_1</b>(HeirData,Mode,Opts) -&gt;
<a name="3527"/> 3527:     io:format(&quot;test with heir_data = ~p\n&quot;, [HeirData]),
<a name="3528"/> 3528:     Master = self(),
<a name="3529"/> 3529:     Founder = my_spawn_link(fun() -&gt; heir_founder(Master,HeirData,Opts) end),
<a name="3530"/> 3530:     io:format(&quot;founder spawned = ~p\n&quot;, [Founder]),
<a name="3531"/> 3531:     {Heir,Mref} = my_spawn_monitor(fun() -&gt; heir_heir(Founder,Mode) end),
<a name="3532"/> 3532:     io:format(&quot;heir spawned = ~p\n&quot;, [{Heir,Mref}]),
<a name="3533"/> 3533:     Founder ! {go, Heir},
<a name="heir_1-last_expr"/><a name="3534"/> 3534: <b>    {'DOWN', Mref, process, Heir, normal} = receive_any</b>().
<a name="3535"/> 3535: 
<a name="3536"/> 3536: <i>%% Test ets:give_way/3.</i>
<a name="give_away-1"/><a name="3537"/> 3537: <b>give_away</b>(Config) when is_list(Config) -&gt;
<a name="give_away-last_expr"/><a name="3538"/> 3538: <b>    repeat_for_opts</b>(fun give_away_do/1).
<a name="3539"/> 3539: 
<a name="give_away_do-1"/><a name="3540"/> 3540: <b>give_away_do</b>(Opts) -&gt;
<a name="3541"/> 3541:     T = ets_new(foo,[named_table, private | Opts]),
<a name="3542"/> 3542:     true = ets:insert(T,{key,1}),
<a name="3543"/> 3543:     [{key,1}] = ets:lookup(T,key),
<a name="3544"/> 3544:     Parent = self(),
<a name="3545"/> 3545: 
<a name="3546"/> 3546:     %% Give and then give back
<a name="3547"/> 3547:     {Receiver,Mref} = my_spawn_monitor(fun()-&gt; give_away_receiver(T,Parent) end),
<a name="3548"/> 3548:     give_me = receive_any(),
<a name="3549"/> 3549:     true = ets:give_away(T,Receiver,here_you_are),
<a name="3550"/> 3550:     {'EXIT',{badarg,_}} = (catch ets:lookup(T,key)),
<a name="3551"/> 3551:     Receiver ! give_back,
<a name="3552"/> 3552:     {'ETS-TRANSFER',T,Receiver,&quot;Tillbakakaka&quot;} = receive_any(),
<a name="3553"/> 3553:     [{key,2}] = ets:lookup(T,key),
<a name="3554"/> 3554:     {'DOWN', Mref, process, Receiver, normal} = receive_any(),
<a name="3555"/> 3555: 
<a name="3556"/> 3556:     %% Give and then let receiver keep it
<a name="3557"/> 3557:     true = ets:insert(T,{key,1}),
<a name="3558"/> 3558:     {Receiver3,Mref3} = my_spawn_monitor(fun()-&gt; give_away_receiver(T,Parent) end),
<a name="3559"/> 3559:     give_me = receive_any(),
<a name="3560"/> 3560:     true = ets:give_away(T,Receiver3,here_you_are),
<a name="3561"/> 3561:     {'EXIT',{badarg,_}} = (catch ets:lookup(T,key)),
<a name="3562"/> 3562:     Receiver3 ! die_please,
<a name="3563"/> 3563:     {'DOWN', Mref3, process, Receiver3, normal} = receive_any(),
<a name="3564"/> 3564:     undefined = ets:info(T),
<a name="3565"/> 3565: 
<a name="3566"/> 3566:     %% Give and then kill receiver to get back
<a name="3567"/> 3567:     T2 = ets_new(foo,[private | Opts]),
<a name="3568"/> 3568:     true = ets:insert(T2,{key,1}),
<a name="3569"/> 3569:     ets:setopts(T2,{heir,self(),&quot;Som en gummiboll...&quot;}),
<a name="3570"/> 3570:     {Receiver2,Mref2} = my_spawn_monitor(fun()-&gt; give_away_receiver(T2,Parent) end),
<a name="3571"/> 3571:     give_me = receive_any(),
<a name="3572"/> 3572:     true = ets:give_away(T2,Receiver2,here_you_are),
<a name="3573"/> 3573:     {'EXIT',{badarg,_}} = (catch ets:lookup(T2,key)),
<a name="3574"/> 3574:     Receiver2 ! die_please,
<a name="3575"/> 3575:     {'ETS-TRANSFER',T2,Receiver2,&quot;Som en gummiboll...&quot;} = receive_any(),
<a name="3576"/> 3576:     [{key,2}] = ets:lookup(T2,key),
<a name="3577"/> 3577:     {'DOWN', Mref2, process, Receiver2, normal} = receive_any(),
<a name="3578"/> 3578: 
<a name="3579"/> 3579:     %% Some negative testing
<a name="3580"/> 3580:     {'EXIT',{badarg,_}} = (catch ets:give_away(T2,Receiver,&quot;To a dead one&quot;)),
<a name="3581"/> 3581:     {'EXIT',{badarg,_}} = (catch ets:give_away(T2,self(),&quot;To myself&quot;)),
<a name="3582"/> 3582:     {'EXIT',{badarg,_}} = (catch ets:give_away(T2,&quot;not a pid&quot;,&quot;To wrong type&quot;)),
<a name="3583"/> 3583: 
<a name="3584"/> 3584:     true = ets:delete(T2),
<a name="3585"/> 3585:     {ReceiverNeg,MrefNeg} = my_spawn_monitor(fun()-&gt; give_away_receiver(T2,Parent) end),
<a name="3586"/> 3586:     give_me = receive_any(),
<a name="3587"/> 3587:     {'EXIT',{badarg,_}} = (catch ets:give_away(T2,ReceiverNeg,&quot;A deleted table&quot;)),
<a name="3588"/> 3588: 
<a name="3589"/> 3589:     T3 = ets_new(foo,[public | Opts]),
<a name="3590"/> 3590:     my_spawn_link(fun()-&gt; {'EXIT',{badarg,_}} = (catch ets:give_away(T3,ReceiverNeg,&quot;From non owner&quot;)),
<a name="3591"/> 3591: 			  Parent ! done
<a name="3592"/> 3592: 		  end),
<a name="3593"/> 3593:     done = receive_any(),
<a name="3594"/> 3594:     ReceiverNeg ! no_soup_for_you,
<a name="3595"/> 3595:     {'DOWN', MrefNeg, process, ReceiverNeg, normal} = receive_any(),
<a name="give_away_do-last_expr"/><a name="3596"/> 3596:     ok.
<a name="3597"/> 3597: 
<a name="give_away_receiver-2"/><a name="3598"/> 3598: <b>give_away_receiver</b>(T, Giver) -&gt;
<a name="3599"/> 3599:     {'EXIT',{badarg,_}} = (catch ets:lookup(T,key)),
<a name="3600"/> 3600:     Giver ! give_me,
<a name="give_away_receiver-last_expr"/><a name="3601"/> 3601: <b>    case receive_any</b>() of
<a name="3602"/> 3602: 	{'ETS-TRANSFER',T,Giver,here_you_are} -&gt;
<a name="3603"/> 3603: 	    [{key,1}] = ets:lookup(T,key),
<a name="3604"/> 3604: 	    true = ets:insert(T,{key,2}),
<a name="3605"/> 3605: 	    case receive_any() of
<a name="3606"/> 3606: 		give_back -&gt;
<a name="3607"/> 3607: 		    true = ets:give_away(T,Giver,&quot;Tillbakakaka&quot;),
<a name="3608"/> 3608: 		    {'EXIT',{badarg,_}} = (catch ets:lookup(T,key));
<a name="3609"/> 3609: 		die_please -&gt;
<a name="3610"/> 3610: 		    ok
<a name="3611"/> 3611: 	    end;
<a name="3612"/> 3612: 	no_soup_for_you -&gt;
<a name="3613"/> 3613: 	    ok
<a name="3614"/> 3614:     end.
<a name="3615"/> 3615: 
<a name="3616"/> 3616: 
<a name="3617"/> 3617: <i>%% Test ets:setopts/2.</i>
<a name="setopts-1"/><a name="3618"/> 3618: <b>setopts</b>(Config) when is_list(Config) -&gt;
<a name="setopts-last_expr"/><a name="3619"/> 3619: <b>    repeat_for_opts</b>(fun setopts_do/1, [write_concurrency,all_types]).
<a name="3620"/> 3620: 
<a name="setopts_do-1"/><a name="3621"/> 3621: <b>setopts_do</b>(Opts) -&gt;
<a name="3622"/> 3622:     Self = self(),
<a name="3623"/> 3623:     T = ets_new(foo,[named_table, private | Opts]),
<a name="3624"/> 3624:     none = ets:info(T,heir),
<a name="3625"/> 3625:     Heir = my_spawn_link(fun()-&gt;heir_heir(Self) end),
<a name="3626"/> 3626:     ets:setopts(T,{heir,Heir,&quot;Data&quot;}),
<a name="3627"/> 3627:     Heir = ets:info(T,heir),
<a name="3628"/> 3628:     ets:setopts(T,{heir,self(),&quot;Data&quot;}),
<a name="3629"/> 3629:     Self = ets:info(T,heir),
<a name="3630"/> 3630:     ets:setopts(T,[{heir,Heir,&quot;Data&quot;}]),
<a name="3631"/> 3631:     Heir = ets:info(T,heir),
<a name="3632"/> 3632:     ets:setopts(T,[{heir,none}]),
<a name="3633"/> 3633:     none = ets:info(T,heir),
<a name="3634"/> 3634: 
<a name="3635"/> 3635:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,[{heir,self(),&quot;Data&quot;},false])),
<a name="3636"/> 3636:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,{heir,self()})),
<a name="3637"/> 3637:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,{heir,false})),
<a name="3638"/> 3638:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,heir)),
<a name="3639"/> 3639:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,{heir,false,&quot;Data&quot;})),
<a name="3640"/> 3640:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,{false,self(),&quot;Data&quot;})),
<a name="3641"/> 3641: 
<a name="3642"/> 3642:     ets:setopts(T,{protection,protected}),
<a name="3643"/> 3643:     ets:setopts(T,{protection,public}),
<a name="3644"/> 3644:     ets:setopts(T,{protection,private}),
<a name="3645"/> 3645:     ets:setopts(T,[{protection,protected}]),
<a name="3646"/> 3646:     ets:setopts(T,[{protection,public}]),
<a name="3647"/> 3647:     ets:setopts(T,[{protection,private}]),
<a name="3648"/> 3648: 
<a name="3649"/> 3649:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,{protection})),
<a name="3650"/> 3650:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,{protection,false})),
<a name="3651"/> 3651:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,{protection,private,false})),
<a name="3652"/> 3652:     {'EXIT',{badarg,_}} = (catch ets:setopts(T,protection)),
<a name="3653"/> 3653:     ets:delete(T),
<a name="3654"/> 3654:     unlink(Heir),
<a name="3655"/> 3655:     exit(Heir, bang),
<a name="setopts_do-last_expr"/><a name="3656"/> 3656:     ok.
<a name="3657"/> 3657: 
<a name="3658"/> 3658: <i>%% All kinds of operations with bad table argument.</i>
<a name="bad_table-1"/><a name="3659"/> 3659: <b>bad_table</b>(Config) when is_list(Config) -&gt;
<a name="3660"/> 3660: 
<a name="3661"/> 3661:     %% Open and close disk_log to stabilize etsmem.
<a name="3662"/> 3662:     Name = make_ref(),
<a name="3663"/> 3663:     File = filename:join([proplists:get_value(priv_dir, Config),&quot;bad_table.dummy&quot;]),
<a name="3664"/> 3664:     {ok, Name} = disk_log:open([{name, Name}, {file, File}]),
<a name="3665"/> 3665:     disk_log:close(Name),
<a name="3666"/> 3666:     file:delete(File),
<a name="3667"/> 3667: 
<a name="3668"/> 3668:     EtsMem = etsmem(),
<a name="3669"/> 3669: 
<a name="3670"/> 3670:     repeat_for_opts(fun(Opts) -&gt; bad_table_do(Opts,File) end,
<a name="3671"/> 3671: 		    [write_concurrency, all_types]),
<a name="3672"/> 3672:     verify_etsmem(EtsMem),
<a name="bad_table-last_expr"/><a name="3673"/> 3673:     ok.
<a name="3674"/> 3674: 
<a name="bad_table_do-2"/><a name="3675"/> 3675: <b>bad_table_do</b>(Opts, DummyFile) -&gt;
<a name="3676"/> 3676:     Parent = self(),
<a name="3677"/> 3677:     {Pid,Mref} = my_spawn_opt(fun()-&gt; ets_new(priv,[private,named_table | Opts]),
<a name="3678"/> 3678: 				      Priv = ets_new(priv,[private | Opts]),
<a name="3679"/> 3679: 				      ets_new(prot,[protected,named_table | Opts]),
<a name="3680"/> 3680: 				      Prot = ets_new(prot,[protected | Opts]),
<a name="3681"/> 3681: 				      Parent ! {self(),Priv,Prot},
<a name="3682"/> 3682: 				      die_please = receive_any()
<a name="3683"/> 3683: 			      end,
<a name="3684"/> 3684: 			      [link, monitor]),
<a name="3685"/> 3685:     {Pid,Priv,Prot} = receive_any(),
<a name="3686"/> 3686:     MatchSpec = {{key,'_'}, [], ['$$']},
<a name="3687"/> 3687:     Fun = fun(X,_) -&gt; X end,
<a name="3688"/> 3688:     OpList = [{delete,[key],update},
<a name="3689"/> 3689: 	      {delete_all_objects,[],update},
<a name="3690"/> 3690: 	      {delete_object,[{key,data}],update},
<a name="3691"/> 3691: 	      {first,[],read},
<a name="3692"/> 3692: 	      {foldl,[Fun, 0], read, tabarg_last},
<a name="3693"/> 3693: 	      {foldr,[Fun, 0], read, tabarg_last},
<a name="3694"/> 3694: 	      %%{from_dets,[DetsTab], update},
<a name="3695"/> 3695: 	      {give_away,[Pid, data], update},
<a name="3696"/> 3696: 	      %%{info, [], read},
<a name="3697"/> 3697: 	      %%{info, [safe_fixed], read},
<a name="3698"/> 3698: 	      %%{init_table,[Name, InitFun],update},
<a name="3699"/> 3699: 	      {insert, [{key,data}], update},
<a name="3700"/> 3700: 	      {insert_new, [{key,data}], update},
<a name="3701"/> 3701: 	      {insert_new, [[{key,data},{other,data}]], update},
<a name="3702"/> 3702: 	      {last, [], read},
<a name="3703"/> 3703: 	      {lookup, [key], read},
<a name="3704"/> 3704: 	      {lookup_element, [key, 2], read},
<a name="3705"/> 3705: 	      {match, [{}], read},
<a name="3706"/> 3706: 	      {match, [{},17], read},
<a name="3707"/> 3707: 	      {match_delete, [{}], update},
<a name="3708"/> 3708: 	      {match_object, [{}], read},
<a name="3709"/> 3709: 	      {match_object, [{},17], read},
<a name="3710"/> 3710: 	      {member,[key], read},
<a name="3711"/> 3711: 	      {next, [key], read},
<a name="3712"/> 3712: 	      {prev, [key], read},
<a name="3713"/> 3713: 	      {rename, [new_name], update},
<a name="3714"/> 3714: 	      {safe_fixtable, [true], read},
<a name="3715"/> 3715: 	      {select,[MatchSpec], read},
<a name="3716"/> 3716: 	      {select,[MatchSpec,17], read},
<a name="3717"/> 3717: 	      {select_count,[MatchSpec], read},
<a name="3718"/> 3718: 	      {select_delete,[MatchSpec], update},
<a name="3719"/> 3719: 	      {setopts, [{heir,none}], update},
<a name="3720"/> 3720: 	      {slot, [0], read},
<a name="3721"/> 3721: 	      {tab2file, [DummyFile], read, {return,{error,badtab}}},
<a name="3722"/> 3722: 	      {tab2file, [DummyFile,[]], read, {return,{error,badtab}}},
<a name="3723"/> 3723: 	      {tab2list, [], read},
<a name="3724"/> 3724: 	      %%{table,[], read},
<a name="3725"/> 3725: 	      %%{to_dets, [DetsTab], read},
<a name="3726"/> 3726: 	      {update_counter,[key,1], update},
<a name="3727"/> 3727: 	      {update_element,[key,{2,new_data}], update}
<a name="3728"/> 3728: 	     ],
<a name="3729"/> 3729:     Info = {Opts, Priv, Prot},
<a name="3730"/> 3730:     lists:foreach(fun(Op) -&gt; bad_table_op(Info, Op) end,
<a name="3731"/> 3731:                   OpList),
<a name="3732"/> 3732:     Pid ! die_please,
<a name="3733"/> 3733:     {'DOWN', Mref, process, Pid, normal} = receive_any(),
<a name="bad_table_do-last_expr"/><a name="3734"/> 3734:     ok.
<a name="3735"/> 3735: 
<a name="bad_table_op-2"/><a name="3736"/> 3736: <b>bad_table_op</b>({Opts,Priv,Prot}, Op) -&gt;
<a name="3737"/> 3737:     %%io:format(&quot;Doing Op=~p on ~p's\n&quot;,[Op,Type]),
<a name="3738"/> 3738:     T1 = ets_new(noname,Opts),
<a name="3739"/> 3739:     bad_table_call(noname,Op),
<a name="3740"/> 3740:     ets:delete(T1),
<a name="3741"/> 3741:     bad_table_call(T1,Op),
<a name="3742"/> 3742:     T2 = ets_new(named,[named_table | Opts]),
<a name="3743"/> 3743:     ets:delete(T2),
<a name="3744"/> 3744:     bad_table_call(named,Op),
<a name="3745"/> 3745:     bad_table_call(T2,Op),
<a name="3746"/> 3746:     bad_table_call(priv,Op),
<a name="3747"/> 3747:     bad_table_call(Priv,Op),
<a name="bad_table_op-last_expr"/><a name="3748"/> 3748: <b>    case element</b>(3,Op) of
<a name="3749"/> 3749: 	update -&gt;
<a name="3750"/> 3750: 	    bad_table_call(prot,Op),
<a name="3751"/> 3751: 	    bad_table_call(Prot,Op);
<a name="3752"/> 3752: 	read -&gt; ok
<a name="3753"/> 3753:     end.
<a name="3754"/> 3754: 
<a name="bad_table_call-2"/><a name="3755"/> 3755: <b>bad_table_call</b>(T,{F,Args,_}) -&gt;
<a name="3756"/> 3756:     {'EXIT',{badarg,_}} = (catch apply(ets, F, [T|Args]));
<a name="3757"/> 3757: <b>bad_table_call</b>(T,{F,Args,_,tabarg_last}) -&gt;
<a name="3758"/> 3758:     {'EXIT',{badarg,_}} = (catch apply(ets, F, Args++[T]));
<a name="3759"/> 3759: <b>bad_table_call</b>(T,{F,Args,_,{return,Return}}) -&gt;
<a name="bad_table_call-last_expr"/><a name="3760"/> 3760:     try
<a name="3761"/> 3761: 	Return = apply(ets, F, [T|Args])
<a name="3762"/> 3762:     catch
<a name="3763"/> 3763: 	error:badarg -&gt; ok
<a name="3764"/> 3764:     end.
<a name="3765"/> 3765: 
<a name="3766"/> 3766: 
<a name="3767"/> 3767: <i>%% Check rename of ets tables.</i>
<a name="rename-1"/><a name="3768"/> 3768: <b>rename</b>(Config) when is_list(Config) -&gt;
<a name="rename-last_expr"/><a name="3769"/> 3769: <b>    repeat_for_opts</b>(fun rename_do/1, [write_concurrency, all_types]).
<a name="3770"/> 3770: 
<a name="rename_do-1"/><a name="3771"/> 3771: <b>rename_do</b>(Opts) -&gt;
<a name="3772"/> 3772:     EtsMem = etsmem(),
<a name="3773"/> 3773:     ets_new(foobazz,[named_table, public | Opts]),
<a name="3774"/> 3774:     ets:insert(foobazz,{foo,bazz}),
<a name="3775"/> 3775:     ungermanbazz = ets:rename(foobazz,ungermanbazz),
<a name="3776"/> 3776:     {'EXIT',{badarg, _}} = (catch ets:lookup(foobazz,foo)),
<a name="3777"/> 3777:     [{foo,bazz}] = ets:lookup(ungermanbazz,foo),
<a name="3778"/> 3778:     {'EXIT',{badarg,_}} =  (catch ets:rename(ungermanbazz,&quot;no atom&quot;)),
<a name="3779"/> 3779:     ets:delete(ungermanbazz),
<a name="rename_do-last_expr"/><a name="3780"/> 3780: <b>    verify_etsmem</b>(EtsMem).
<a name="3781"/> 3781: 
<a name="3782"/> 3782: <i>%% Check rename of unnamed ets table.</i>
<a name="rename_unnamed-1"/><a name="3783"/> 3783: <b>rename_unnamed</b>(Config) when is_list(Config) -&gt;
<a name="rename_unnamed-last_expr"/><a name="3784"/> 3784: <b>    repeat_for_opts</b>(fun rename_unnamed_do/1,
<a name="3785"/> 3785:                     [write_concurrency,all_types]).
<a name="3786"/> 3786: 
<a name="rename_unnamed_do-1"/><a name="3787"/> 3787: <b>rename_unnamed_do</b>(Opts) -&gt;
<a name="3788"/> 3788:     EtsMem = etsmem(),
<a name="3789"/> 3789:     Tab = ets_new(bonkz,[public | Opts]),
<a name="3790"/> 3790:     {'EXIT',{badarg, _}} = (catch ets:insert(bonkz,{foo,bazz})),
<a name="3791"/> 3791:     bonkz = ets:info(Tab, name),
<a name="3792"/> 3792:     Tab = ets:rename(Tab, tjabonkz),
<a name="3793"/> 3793:     {'EXIT',{badarg, _}} = (catch ets:insert(tjabonkz,{foo,bazz})),
<a name="3794"/> 3794:     tjabonkz = ets:info(Tab, name),
<a name="3795"/> 3795:     ets:delete(Tab),
<a name="rename_unnamed_do-last_expr"/><a name="3796"/> 3796: <b>    verify_etsmem</b>(EtsMem).
<a name="3797"/> 3797: 
<a name="3798"/> 3798: <i>%% Rename a table with many fixations, and at the same time delete it.</i>
<a name="evil_rename-1"/><a name="3799"/> 3799: <b>evil_rename</b>(Config) when is_list(Config) -&gt;
<a name="3800"/> 3800:     EtsMem = etsmem(),
<a name="3801"/> 3801:     evil_rename_1(old_hash, new_hash, [public,named_table]),
<a name="3802"/> 3802:     evil_rename_1(old_tree, new_tree, [public,ordered_set,named_table]),
<a name="3803"/> 3803:     wait_for_test_procs(true),
<a name="evil_rename-last_expr"/><a name="3804"/> 3804: <b>    verify_etsmem</b>(EtsMem).
<a name="3805"/> 3805: 
<a name="evil_rename_1-3"/><a name="3806"/> 3806: <b>evil_rename_1</b>(Old, New, Flags) -&gt;
<a name="3807"/> 3807:     process_flag(trap_exit, true),
<a name="3808"/> 3808:     Old = ets_new(Old, Flags),
<a name="3809"/> 3809:     Fixer = fun() -&gt; ets:safe_fixtable(Old, true) end,
<a name="3810"/> 3810:     crazy_fixtable(15000, Fixer),
<a name="3811"/> 3811:     erlang:yield(),
<a name="3812"/> 3812:     New = ets:rename(Old, New),
<a name="3813"/> 3813:     erlang:yield(),
<a name="3814"/> 3814:     ets:delete(New),
<a name="evil_rename_1-last_expr"/><a name="3815"/> 3815:     ok.
<a name="3816"/> 3816: 
<a name="crazy_fixtable-2"/><a name="3817"/> 3817: <b>crazy_fixtable</b>(N, Fixer) -&gt;
<a name="3818"/> 3818:     Dracula = ets_new(count_dracula, [public]),
<a name="3819"/> 3819:     ets:insert(Dracula, {count,0}),
<a name="3820"/> 3820:     SpawnFun = fun() -&gt;
<a name="3821"/> 3821: 		       Fixer(),
<a name="3822"/> 3822: 		       case ets:update_counter(Dracula, count, 1) rem 15 of
<a name="3823"/> 3823: 			   0 -&gt; evil_creater_destroyer();
<a name="3824"/> 3824: 			   _ -&gt; erlang:hibernate(erlang, error, [dont_wake_me])
<a name="3825"/> 3825: 		       end
<a name="3826"/> 3826: 	       end,
<a name="3827"/> 3827:     crazy_fixtable_1(N, SpawnFun),
<a name="3828"/> 3828:     crazy_fixtable_wait(N, Dracula),
<a name="crazy_fixtable-last_expr"/><a name="3829"/> 3829:     Dracula.
<a name="3830"/> 3830: 
<a name="crazy_fixtable_wait-2"/><a name="3831"/> 3831: <b>crazy_fixtable_wait</b>(N, Dracula) -&gt;
<a name="crazy_fixtable_wait-last_expr"/><a name="3832"/> 3832: <b>    case ets:lookup</b>(Dracula, count) of
<a name="3833"/> 3833: 	[{count,N}] -&gt;
<a name="3834"/> 3834: 	    ets:delete(Dracula);
<a name="3835"/> 3835: 	Other -&gt;
<a name="3836"/> 3836: 	    io:format(&quot;~p\n&quot;, [Other]),
<a name="3837"/> 3837: 	    receive after 10 -&gt; ok end,
<a name="3838"/> 3838: 	    crazy_fixtable_wait(N, Dracula)
<a name="3839"/> 3839:     end.
<a name="3840"/> 3840: 
<a name="crazy_fixtable_1-2"/><a name="3841"/> 3841: <b>crazy_fixtable_1</b>(0, _) -&gt;
<a name="3842"/> 3842:     ok;
<a name="3843"/> 3843: <b>crazy_fixtable_1</b>(N, Fun) -&gt;
<a name="3844"/> 3844:     %%FIXME my_spawn_link(Fun),
<a name="3845"/> 3845:     my_spawn_link(Fun),
<a name="crazy_fixtable_1-last_expr"/><a name="3846"/> 3846: <b>    crazy_fixtable_1</b>(N-1, Fun).
<a name="3847"/> 3847: 
<a name="evil_creater_destroyer-0"/><a name="3848"/> 3848: <b>evil_creater_destroyer</b>() -&gt;
<a name="3849"/> 3849:     T1 = evil_create_fixed_tab(),
<a name="evil_creater_destroyer-last_expr"/><a name="3850"/> 3850: <b>    ets:delete</b>(T1).
<a name="3851"/> 3851: 
<a name="evil_create_fixed_tab-0"/><a name="3852"/> 3852: <b>evil_create_fixed_tab</b>() -&gt;
<a name="3853"/> 3853:     T = ets_new(arne, [public]),
<a name="3854"/> 3854:     ets:safe_fixtable(T, true),
<a name="evil_create_fixed_tab-last_expr"/><a name="3855"/> 3855:     T.
<a name="3856"/> 3856: 
<a name="3857"/> 3857: <i>%% Tests that the return values and errors are equal for set's and</i>
<a name="3858"/> 3858: <i>%% ordered_set's where applicable.</i>
<a name="interface_equality-1"/><a name="3859"/> 3859: <b>interface_equality</b>(Config) when is_list(Config) -&gt;
<a name="interface_equality-last_expr"/><a name="3860"/> 3860: <b>    repeat_for_opts</b>(fun interface_equality_do/1).
<a name="3861"/> 3861: 
<a name="interface_equality_do-1"/><a name="3862"/> 3862: <b>interface_equality_do</b>(Opts) -&gt;
<a name="3863"/> 3863:     EtsMem = etsmem(),
<a name="3864"/> 3864:     Set = ets_new(set,[set | Opts]),
<a name="3865"/> 3865:     OrderedSet = ets_new(ordered_set,
<a name="3866"/> 3866:                          replace_dbg_hash_fixed_nr_of_locks([ordered_set | Opts])),
<a name="3867"/> 3867:     F = fun(X,T,FF) -&gt; case X of
<a name="3868"/> 3868:                            0 -&gt; true;
<a name="3869"/> 3869:                            _ -&gt;
<a name="3870"/> 3870:                                ets:insert(T, {X,
<a name="3871"/> 3871:                                               integer_to_list(X),
<a name="3872"/> 3872:                                               X rem 10}),
<a name="3873"/> 3873:                                FF(X-1,T,FF)
<a name="3874"/> 3874:                        end
<a name="3875"/> 3875:         end,
<a name="3876"/> 3876:     F(100,Set,F),
<a name="3877"/> 3877:     F(100,OrderedSet,F),
<a name="3878"/> 3878:     equal_results(ets, insert, Set, OrderedSet, [{a,&quot;a&quot;}]),
<a name="3879"/> 3879:     equal_results(ets, insert, Set, OrderedSet, [{1,1,&quot;1&quot;}]),
<a name="3880"/> 3880:     equal_results(ets, lookup, Set, OrderedSet, [10]),
<a name="3881"/> 3881:     equal_results(ets, lookup, Set, OrderedSet, [1000]),
<a name="3882"/> 3882:     equal_results(ets, delete, Set, OrderedSet, [10]),
<a name="3883"/> 3883:     equal_results(ets, delete, Set, OrderedSet, [nott]),
<a name="3884"/> 3884:     equal_results(ets, lookup, Set, OrderedSet, [1000]),
<a name="3885"/> 3885:     equal_results(ets, insert, Set, OrderedSet, [10]),
<a name="3886"/> 3886:     equal_results(ets, next, Set, OrderedSet, ['$end_of_table']),
<a name="3887"/> 3887:     equal_results(ets, prev, Set, OrderedSet, ['$end_of_table']),
<a name="3888"/> 3888:     equal_results(ets, match, Set, OrderedSet, [{'_','_','_'}]),
<a name="3889"/> 3889:     equal_results(ets, match, Set, OrderedSet, [{'_','_','_','_'}]),
<a name="3890"/> 3890:     equal_results(ets, match, Set, OrderedSet, [{$3,$2,2}]),
<a name="3891"/> 3891:     equal_results(ets, match, Set, OrderedSet, ['_']),
<a name="3892"/> 3892:     equal_results(ets, match, Set, OrderedSet, ['$1']),
<a name="3893"/> 3893:     equal_results(ets, match, Set, OrderedSet, [{'_','$50',3}]),
<a name="3894"/> 3894:     equal_results(ets, match, Set, OrderedSet, [['_','$50',3]]),
<a name="3895"/> 3895:     equal_results(ets, match_delete, Set, OrderedSet, [{'_','_',4}]),
<a name="3896"/> 3896:     equal_results(ets, match_delete, Set, OrderedSet, [{'_','_',4}]),
<a name="3897"/> 3897:     equal_results(ets, match_object, Set, OrderedSet, [{'_','_',4}]),
<a name="3898"/> 3898:     equal_results(ets, match_object, Set, OrderedSet, [{'_','_',5}]),
<a name="3899"/> 3899:     equal_results(ets, match_object, Set, OrderedSet, [{'_','_',4}]),
<a name="3900"/> 3900:     equal_results(ets, match_object, Set, OrderedSet, ['_']),
<a name="3901"/> 3901:     equal_results(ets, match_object, Set, OrderedSet, ['$5011']),
<a name="3902"/> 3902:     equal_results(ets, match_delete, Set, OrderedSet, ['$20']),
<a name="3903"/> 3903:     equal_results(ets, lookup_element, Set, OrderedSet, [13,2]),
<a name="3904"/> 3904:     equal_results(ets, lookup_element, Set, OrderedSet, [13,4]),
<a name="3905"/> 3905:     equal_results(ets, lookup_element, Set, OrderedSet, [14,2]),
<a name="3906"/> 3906:     equal_results(ets, delete, Set, OrderedSet, []),
<a name="interface_equality_do-last_expr"/><a name="3907"/> 3907: <b>    verify_etsmem</b>(EtsMem).
<a name="3908"/> 3908: 
<a name="equal_results-5"/><a name="3909"/> 3909: <b>equal_results</b>(M, F, FirstArg1, FirstArg2 ,ACommon) -&gt;
<a name="3910"/> 3910:     Res = maybe_sort((catch apply(M,F, [FirstArg1 | ACommon]))),
<a name="equal_results-last_expr"/><a name="3911"/> 3911: <b>    Res = maybe_sort</b>((catch apply(M,F,[FirstArg2 | ACommon]))).
<a name="3912"/> 3912: 
<a name="maybe_sort-1"/><a name="3913"/> 3913: <b>maybe_sort</b>(L) when is_list(L) -&gt;
<a name="3914"/> 3914:     lists:sort(L);
<a name="3915"/> 3915: <b>maybe_sort</b>({'EXIT',{Reason, List}}) when is_list(List) -&gt;
<a name="3916"/> 3916:     {'EXIT',{Reason, lists:map(fun({Module, Function, _, _}) -&gt;
<a name="3917"/> 3917: 				       {Module, Function, '_'}
<a name="3918"/> 3918: 			       end,
<a name="3919"/> 3919: 			       List)}};
<a name="3920"/> 3920: <b>maybe_sort</b>(Any) -&gt;
<a name="maybe_sort-last_expr"/><a name="3921"/> 3921:     Any.
<a name="3922"/> 3922: 
<a name="3923"/> 3923: <i>%% Test match, match_object and match_delete in ordered set's.</i>
<a name="ordered_match-1"/><a name="3924"/> 3924: <b>ordered_match</b>(Config) when is_list(Config)-&gt;
<a name="ordered_match-last_expr"/><a name="3925"/> 3925: <b>    repeat_for_opts_extra_opt</b>(fun ordered_match_do/1, ordered_set).
<a name="3926"/> 3926: 
<a name="ordered_match_do-1"/><a name="3927"/> 3927: <b>ordered_match_do</b>(Opts) -&gt;
<a name="3928"/> 3928:     EtsMem = etsmem(),
<a name="3929"/> 3929:     F = fun(X,T,FF) -&gt; case X of
<a name="3930"/> 3930: 			   0 -&gt; true;
<a name="3931"/> 3931: 			   _ -&gt;
<a name="3932"/> 3932: 			       ets:insert(T, {X,
<a name="3933"/> 3933: 					      integer_to_list(X),
<a name="3934"/> 3934: 					      X rem 10,
<a name="3935"/> 3935: 					      X rem 100,
<a name="3936"/> 3936: 					      X rem 1000}),
<a name="3937"/> 3937: 			       FF(X-1,T,FF)
<a name="3938"/> 3938: 		       end
<a name="3939"/> 3939: 	end,
<a name="3940"/> 3940:     T1 = ets_new(xxx,[ordered_set| Opts]),
<a name="3941"/> 3941:     F(3000,T1,F),
<a name="3942"/> 3942:     [[3,3],[3,3],[3,3]] = ets:match(T1, {'_','_','$1','$2',3}),
<a name="3943"/> 3943:     F2 = fun(X,Rem,Res,FF) -&gt; case X of
<a name="3944"/> 3944: 				  0 -&gt; [];
<a name="3945"/> 3945: 				  _ -&gt;
<a name="3946"/> 3946: 				      case X rem Rem of
<a name="3947"/> 3947: 					  Res -&gt;
<a name="3948"/> 3948: 					      FF(X-1,Rem,Res,FF) ++
<a name="3949"/> 3949: 						  [{X,
<a name="3950"/> 3950: 						    integer_to_list(X),
<a name="3951"/> 3951: 						    X rem 10,
<a name="3952"/> 3952: 						    X rem 100,
<a name="3953"/> 3953: 						    X rem 1000}];
<a name="3954"/> 3954: 					  _ -&gt;
<a name="3955"/> 3955: 					      FF(X-1,Rem,Res,FF)
<a name="3956"/> 3956: 				      end
<a name="3957"/> 3957: 			      end
<a name="3958"/> 3958: 	 end,
<a name="3959"/> 3959:     OL1 = F2(3000,100,2,F2),
<a name="3960"/> 3960:     OL1 = ets:match_object(T1, {'_','_','_',2,'_'}),
<a name="3961"/> 3961:     true = ets:match_delete(T1,{'_','_','_',2,'_'}),
<a name="3962"/> 3962:     [] = ets:match_object(T1, {'_','_','_',2,'_'}),
<a name="3963"/> 3963:     OL2 = F2(3000,100,3,F2),
<a name="3964"/> 3964:     OL2 = ets:match_object(T1, {'_','_','_',3,'_'}),
<a name="3965"/> 3965:     ets:delete(T1),
<a name="ordered_match_do-last_expr"/><a name="3966"/> 3966: <b>    verify_etsmem</b>(EtsMem).
<a name="3967"/> 3967: 
<a name="3968"/> 3968: 
<a name="3969"/> 3969: <i>%% Test basic functionality in ordered_set's.</i>
<a name="ordered-1"/><a name="3970"/> 3970: <b>ordered</b>(Config) when is_list(Config) -&gt;
<a name="ordered-last_expr"/><a name="3971"/> 3971: <b>    repeat_for_opts_extra_opt</b>(fun ordered_do/1, ordered_set).
<a name="3972"/> 3972: 
<a name="ordered_do-1"/><a name="3973"/> 3973: <b>ordered_do</b>(Opts) -&gt;
<a name="3974"/> 3974:     EtsMem = etsmem(),
<a name="3975"/> 3975:     T = ets_new(oset, [ordered_set | Opts]),
<a name="3976"/> 3976:     InsList = [
<a name="3977"/> 3977: 	       25,26,27,28,
<a name="3978"/> 3978: 	       5,6,7,8,
<a name="3979"/> 3979: 	       21,22,23,24,
<a name="3980"/> 3980: 	       9,10,11,12,
<a name="3981"/> 3981: 	       1,2,3,4,
<a name="3982"/> 3982: 	       17,18,19,20,
<a name="3983"/> 3983: 	       13,14,15,16,
<a name="3984"/> 3984: 	       1 bsl 33
<a name="3985"/> 3985: 	      ],
<a name="3986"/> 3986:     lists:foreach(fun(X) -&gt;
<a name="3987"/> 3987: 			  ets:insert(T,{X,integer_to_list(X)})
<a name="3988"/> 3988: 		  end,
<a name="3989"/> 3989: 		  InsList),
<a name="3990"/> 3990:     IL2 = lists:map(fun(X) -&gt; {X,integer_to_list(X)} end, InsList),
<a name="3991"/> 3991:     L1 = pick_all_forward(T),
<a name="3992"/> 3992:     L2 = pick_all_backwards(T),
<a name="3993"/> 3993:     S1 = lists:sort(IL2),
<a name="3994"/> 3994:     S2 = lists:reverse(lists:sort(IL2)),
<a name="3995"/> 3995:     S1 = L1,
<a name="3996"/> 3996:     S2 = L2,
<a name="3997"/> 3997:     [{1,&quot;1&quot;}] = ets:slot(T,0),
<a name="3998"/> 3998:     [{28,&quot;28&quot;}] = ets:slot(T,27),
<a name="3999"/> 3999:     [{1 bsl 33,_}] = ets:slot(T,28),
<a name="4000"/> 4000:     27 = ets:prev(T,28),
<a name="4001"/> 4001:     [{7,&quot;7&quot;}] = ets:slot(T,6),
<a name="4002"/> 4002:     '$end_of_table' = ets:next(T,1 bsl 33),
<a name="4003"/> 4003:     [{12,&quot;12&quot;}] = ets:slot(T,11),
<a name="4004"/> 4004:     '$end_of_table' = ets:slot(T,29),
<a name="4005"/> 4005:     [{1,&quot;1&quot;}] = ets:slot(T,0),
<a name="4006"/> 4006:     28 = ets:prev(T,1 bsl 33),
<a name="4007"/> 4007:     1 = ets:next(T,0),
<a name="4008"/> 4008:     pick_all_forward(T),
<a name="4009"/> 4009:     [{7,&quot;7&quot;}] = ets:slot(T,6),
<a name="4010"/> 4010:     L2 = pick_all_backwards(T),
<a name="4011"/> 4011:     [{7,&quot;7&quot;}] = ets:slot(T,6),
<a name="4012"/> 4012:     ets:delete(T),
<a name="ordered_do-last_expr"/><a name="4013"/> 4013: <b>    verify_etsmem</b>(EtsMem).
<a name="4014"/> 4014: 
<a name="pick_all-3"/><a name="4015"/> 4015: <b>pick_all</b>(_T,'$end_of_table',_How) -&gt;
<a name="4016"/> 4016:     [];
<a name="4017"/> 4017: <b>pick_all</b>(T,Last,How) -&gt;
<a name="4018"/> 4018:     This = case How of
<a name="4019"/> 4019: 	       next -&gt;
<a name="4020"/> 4020: 		   ets:next(T,Last);
<a name="4021"/> 4021: 	       prev -&gt;
<a name="4022"/> 4022: 		   ets:prev(T,Last)
<a name="4023"/> 4023: 	   end,
<a name="4024"/> 4024:     [LastObj] = ets:lookup(T,Last),
<a name="pick_all-last_expr"/><a name="4025"/> 4025: <b>    [LastObj | pick_all</b>(T,This,How)].
<a name="4026"/> 4026: 
<a name="pick_all_forward-1"/><a name="4027"/> 4027: <b>pick_all_forward</b>(T) -&gt;
<a name="pick_all_forward-last_expr"/><a name="4028"/> 4028: <b>    pick_all</b>(T,ets:first(T),next).
<a name="pick_all_backwards-1"/><a name="4029"/> 4029: <b>pick_all_backwards</b>(T) -&gt;
<a name="pick_all_backwards-last_expr"/><a name="4030"/> 4030: <b>    pick_all</b>(T,ets:last(T),prev).
<a name="4031"/> 4031: 
<a name="4032"/> 4032: 
<a name="4033"/> 4033: 
<a name="4034"/> 4034: <i>%% Small test case for both set and bag type ets tables.</i>
<a name="setbag-1"/><a name="4035"/> 4035: <b>setbag</b>(Config) when is_list(Config) -&gt;
<a name="4036"/> 4036:     EtsMem = etsmem(),
<a name="4037"/> 4037:     lists:foreach(fun(SetType) -&gt;
<a name="4038"/> 4038:                           Set = ets_new(SetType,[SetType]),
<a name="4039"/> 4039:                           Bag = ets_new(bag,[bag]),
<a name="4040"/> 4040:                           Key = {foo,bar},
<a name="4041"/> 4041: 
<a name="4042"/> 4042:                           %% insert some value
<a name="4043"/> 4043:                           ets:insert(Set,{Key,val1}),
<a name="4044"/> 4044:                           ets:insert(Bag,{Key,val1}),
<a name="4045"/> 4045: 
<a name="4046"/> 4046:                           %% insert new value for same key again
<a name="4047"/> 4047:                           ets:insert(Set,{Key,val2}),
<a name="4048"/> 4048:                           ets:insert(Bag,{Key,val2}),
<a name="4049"/> 4049: 
<a name="4050"/> 4050:                           %% check
<a name="4051"/> 4051:                           [{Key,val2}] = ets:lookup(Set,Key),
<a name="4052"/> 4052:                           [{Key,val1},{Key,val2}] = ets:lookup(Bag,Key),
<a name="4053"/> 4053: 
<a name="4054"/> 4054:                           true = ets:delete(Set),
<a name="4055"/> 4055:                           true = ets:delete(Bag)
<a name="4056"/> 4056:                   end, [set, cat_ord_set,stim_cat_ord_set,ordered_set]),
<a name="setbag-last_expr"/><a name="4057"/> 4057: <b>    verify_etsmem</b>(EtsMem).
<a name="4058"/> 4058: 
<a name="4059"/> 4059: <i>%% Test case to check proper return values for illegal ets_new() calls.</i>
<a name="badnew-1"/><a name="4060"/> 4060: <b>badnew</b>(Config) when is_list(Config) -&gt;
<a name="4061"/> 4061:     EtsMem = etsmem(),
<a name="4062"/> 4062:     {'EXIT',{badarg,_}} = (catch ets:new(12,[])),
<a name="4063"/> 4063:     {'EXIT',{badarg,_}} = (catch ets:new({a,b},[])),
<a name="4064"/> 4064:     {'EXIT',{badarg,_}} = (catch ets:new(name,[foo])),
<a name="4065"/> 4065:     {'EXIT',{badarg,_}} = (catch ets:new(name,{bag})),
<a name="4066"/> 4066:     {'EXIT',{badarg,_}} = (catch ets:new(name,bag)),
<a name="badnew-last_expr"/><a name="4067"/> 4067: <b>    verify_etsmem</b>(EtsMem).
<a name="4068"/> 4068: 
<a name="4069"/> 4069: <i>%% OTP-2314. Test case to check that a non-proper list does not</i>
<a name="4070"/> 4070: <i>%% crash the emulator.</i>
<a name="verybadnew-1"/><a name="4071"/> 4071: <b>verybadnew</b>(Config) when is_list(Config) -&gt;
<a name="4072"/> 4072:     EtsMem = etsmem(),
<a name="4073"/> 4073:     {'EXIT',{badarg,_}} = (catch ets:new(verybad,[set|protected])),
<a name="verybadnew-last_expr"/><a name="4074"/> 4074: <b>    verify_etsmem</b>(EtsMem).
<a name="4075"/> 4075: 
<a name="4076"/> 4076: <i>%% Small check to see if named tables work.</i>
<a name="named-1"/><a name="4077"/> 4077: <b>named</b>(Config) when is_list(Config) -&gt;
<a name="4078"/> 4078:     EtsMem = etsmem(),
<a name="4079"/> 4079:     Tab = make_table(foo,
<a name="4080"/> 4080: 		     [named_table],
<a name="4081"/> 4081: 		     [{key,val}]),
<a name="4082"/> 4082:     [{key,val}] = ets:lookup(foo,key),
<a name="4083"/> 4083:     true = ets:delete(Tab),
<a name="named-last_expr"/><a name="4084"/> 4084: <b>    verify_etsmem</b>(EtsMem).
<a name="4085"/> 4085: 
<a name="4086"/> 4086: <i>%% Test case to check if specified keypos works.</i>
<a name="keypos2-1"/><a name="4087"/> 4087: <b>keypos2</b>(Config) when is_list(Config) -&gt;
<a name="4088"/> 4088:     EtsMem = etsmem(),
<a name="4089"/> 4089:     lists:foreach(fun(SetType) -&gt;
<a name="4090"/> 4090:                           Tab = make_table(foo,
<a name="4091"/> 4091:                                            [SetType,{keypos,2}],
<a name="4092"/> 4092:                                            [{val,key}, {val2,key}]),
<a name="4093"/> 4093:                           [{val2,key}] = ets:lookup(Tab,key),
<a name="4094"/> 4094:                           true = ets:delete(Tab)
<a name="4095"/> 4095:                   end, [set, cat_ord_set,stim_cat_ord_set,ordered_set]),
<a name="keypos2-last_expr"/><a name="4096"/> 4096: <b>    verify_etsmem</b>(EtsMem).
<a name="4097"/> 4097: 
<a name="4098"/> 4098: <i>%% Privacy check. Check that a named(public/private/protected) table</i>
<a name="4099"/> 4099: <i>%% cannot be read by the wrong process(es).</i>
<a name="privacy-1"/><a name="4100"/> 4100: <b>privacy</b>(Config) when is_list(Config) -&gt;
<a name="privacy-last_expr"/><a name="4101"/> 4101: <b>    repeat_for_opts</b>(fun privacy_do/1).
<a name="4102"/> 4102: 
<a name="privacy_do-1"/><a name="4103"/> 4103: <b>privacy_do</b>(Opts) -&gt;
<a name="4104"/> 4104:     EtsMem = etsmem(),
<a name="4105"/> 4105:     process_flag(trap_exit,true),
<a name="4106"/> 4106:     Parent = self(),
<a name="4107"/> 4107:     Owner = my_spawn_link(fun() -&gt; privacy_owner(Parent, Opts) end),
<a name="4108"/> 4108:     receive
<a name="4109"/> 4109: 	{'EXIT',Owner,Reason} -&gt;
<a name="4110"/> 4110: 	    exit({privacy_test,Reason});
<a name="4111"/> 4111: 	ok -&gt;
<a name="4112"/> 4112: 	    ok
<a name="4113"/> 4113:     end,
<a name="4114"/> 4114: 
<a name="4115"/> 4115:     privacy_check(pub,prot,priv),
<a name="4116"/> 4116: 
<a name="4117"/> 4117:     Owner ! {shift,1,{pub,prot,priv}},
<a name="4118"/> 4118:     receive
<a name="4119"/> 4119:         {Pub1,Prot1,Priv1} -&gt;
<a name="4120"/> 4120:             ok = privacy_check(Pub1,Prot1,Priv1),
<a name="4121"/> 4121:             Owner ! {shift,2,{Pub1,Prot1,Priv1}}
<a name="4122"/> 4122:     end,
<a name="4123"/> 4123: 
<a name="4124"/> 4124:     receive
<a name="4125"/> 4125:         {Pub2,Prot2,Priv2} -&gt;
<a name="4126"/> 4126:             ok = privacy_check(Pub2,Prot2,Priv2),
<a name="4127"/> 4127:             Owner ! {shift,0,{Pub2,Prot2,Priv2}}
<a name="4128"/> 4128:     end,
<a name="4129"/> 4129: 
<a name="4130"/> 4130:     receive
<a name="4131"/> 4131:         {Pub3,Prot3,Priv3} -&gt;
<a name="4132"/> 4132:             ok = privacy_check(Pub3,Prot3,Priv3)
<a name="4133"/> 4133:     end,
<a name="4134"/> 4134: 
<a name="4135"/> 4135:     Owner ! die,
<a name="4136"/> 4136:     receive {'EXIT',Owner,_} -&gt; ok end,
<a name="privacy_do-last_expr"/><a name="4137"/> 4137: <b>    verify_etsmem</b>(EtsMem).
<a name="4138"/> 4138: 
<a name="privacy_check-3"/><a name="4139"/> 4139: <b>privacy_check</b>(Pub,Prot,Priv) -&gt;
<a name="4140"/> 4140:     %% check read rights
<a name="4141"/> 4141:     [] = ets:lookup(Pub, foo),
<a name="4142"/> 4142:     [] = ets:lookup(Prot,foo),
<a name="4143"/> 4143:     {'EXIT',{badarg,_}} = (catch ets:lookup(Priv,foo)),
<a name="4144"/> 4144: 
<a name="4145"/> 4145:     %% check write rights
<a name="4146"/> 4146:     true = ets:insert(Pub, {1,foo}),
<a name="4147"/> 4147:     {'EXIT',{badarg,_}} = (catch ets:insert(Prot,{2,foo})),
<a name="4148"/> 4148:     {'EXIT',{badarg,_}} = (catch ets:insert(Priv,{3,foo})),
<a name="4149"/> 4149: 
<a name="4150"/> 4150:     %% check that it really wasn't written, either
<a name="4151"/> 4151:     [] = ets:lookup(Prot,foo),
<a name="privacy_check-last_expr"/><a name="4152"/> 4152:     ok.
<a name="4153"/> 4153: 
<a name="privacy_owner-2"/><a name="4154"/> 4154: <b>privacy_owner</b>(Boss, Opts) -&gt;
<a name="4155"/> 4155:     ets_new(pub, [public,named_table | Opts]),
<a name="4156"/> 4156:     ets_new(prot,[protected,named_table | Opts]),
<a name="4157"/> 4157:     ets_new(priv,[private,named_table | Opts]),
<a name="4158"/> 4158:     Boss ! ok,
<a name="privacy_owner-last_expr"/><a name="4159"/> 4159: <b>    privacy_owner_loop</b>(Boss).
<a name="4160"/> 4160: 
<a name="privacy_owner_loop-1"/><a name="4161"/> 4161: <b>privacy_owner_loop</b>(Boss) -&gt;
<a name="privacy_owner_loop-last_expr"/><a name="4162"/> 4162:     receive
<a name="4163"/> 4163: 	{shift,N,Pub_Prot_Priv} -&gt;
<a name="4164"/> 4164: 	    {Pub,Prot,Priv} = rotate_tuple(Pub_Prot_Priv, N),
<a name="4165"/> 4165: 
<a name="4166"/> 4166: 	    ets:setopts(Pub,{protection,public}),
<a name="4167"/> 4167: 	    ets:setopts(Prot,{protection,protected}),
<a name="4168"/> 4168: 	    ets:setopts(Priv,{protection,private}),
<a name="4169"/> 4169: 	    Boss ! {Pub,Prot,Priv},
<a name="4170"/> 4170: 	    privacy_owner_loop(Boss);
<a name="4171"/> 4171: 
<a name="4172"/> 4172: 	die -&gt; ok
<a name="4173"/> 4173:     end.
<a name="4174"/> 4174: 
<a name="rotate_tuple-2"/><a name="4175"/> 4175: <b>rotate_tuple</b>(Tuple, 0) -&gt;
<a name="4176"/> 4176:     Tuple;
<a name="4177"/> 4177: <b>rotate_tuple</b>(Tuple, N) -&gt;
<a name="4178"/> 4178:     [H|T] = tuple_to_list(Tuple),
<a name="rotate_tuple-last_expr"/><a name="4179"/> 4179: <b>    rotate_tuple</b>(list_to_tuple(T ++ [H]), N-1).
<a name="4180"/> 4180: 
<a name="4181"/> 4181: 
<a name="4182"/> 4182: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="4183"/> 4183: 
<a name="4184"/> 4184: 
<a name="4185"/> 4185: <i>%% Check lookup in an empty table and lookup of a non-existing key.</i>
<a name="empty-1"/><a name="4186"/> 4186: <b>empty</b>(Config) when is_list(Config) -&gt;
<a name="empty-last_expr"/><a name="4187"/> 4187: <b>    repeat_for_opts_all_table_types</b>(fun empty_do/1).
<a name="4188"/> 4188: 
<a name="empty_do-1"/><a name="4189"/> 4189: <b>empty_do</b>(Opts) -&gt;
<a name="4190"/> 4190:     EtsMem = etsmem(),
<a name="4191"/> 4191:     Tab = ets_new(foo,Opts),
<a name="4192"/> 4192:     [] = ets:lookup(Tab,key),
<a name="4193"/> 4193:     true = ets:insert(Tab,{key2,val}),
<a name="4194"/> 4194:     [] = ets:lookup(Tab,key),
<a name="4195"/> 4195:     true = ets:delete(Tab),
<a name="empty_do-last_expr"/><a name="4196"/> 4196: <b>    verify_etsmem</b>(EtsMem).
<a name="4197"/> 4197: 
<a name="4198"/> 4198: <i>%% Check proper return values for illegal insert operations.</i>
<a name="badinsert-1"/><a name="4199"/> 4199: <b>badinsert</b>(Config) when is_list(Config) -&gt;
<a name="badinsert-last_expr"/><a name="4200"/> 4200: <b>    repeat_for_opts_all_table_types</b>(fun badinsert_do/1).
<a name="4201"/> 4201: 
<a name="badinsert_do-1"/><a name="4202"/> 4202: <b>badinsert_do</b>(Opts) -&gt;
<a name="4203"/> 4203:     EtsMem = etsmem(),
<a name="4204"/> 4204:     {'EXIT',{badarg,_}} = (catch ets:insert(foo,{key,val})),
<a name="4205"/> 4205: 
<a name="4206"/> 4206:     Tab = ets_new(foo,Opts),
<a name="4207"/> 4207:     {'EXIT',{badarg,_}} = (catch ets:insert(Tab,{})),
<a name="4208"/> 4208: 
<a name="4209"/> 4209:     Tab3 = ets_new(foo,[{keypos,3}| Opts]),
<a name="4210"/> 4210:     {'EXIT',{badarg,_}} = (catch ets:insert(Tab3,{a,b})),
<a name="4211"/> 4211: 
<a name="4212"/> 4212:     {'EXIT',{badarg,_}} = (catch ets:insert(Tab,[key,val2])),
<a name="4213"/> 4213:     true = ets:delete(Tab),
<a name="4214"/> 4214:     true = ets:delete(Tab3),
<a name="badinsert_do-last_expr"/><a name="4215"/> 4215: <b>    verify_etsmem</b>(EtsMem).
<a name="4216"/> 4216: 
<a name="4217"/> 4217: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="4218"/> 4218: 
<a name="4219"/> 4219: 
<a name="4220"/> 4220: <i>%% Check proper return values from bad lookups in existing/non existing</i>
<a name="4221"/> 4221: <i>%% ets tables.</i>
<a name="badlookup-1"/><a name="4222"/> 4222: <b>badlookup</b>(Config) when is_list(Config) -&gt;
<a name="4223"/> 4223:     EtsMem = etsmem(),
<a name="4224"/> 4224:     {'EXIT',{badarg,_}} = (catch ets:lookup(foo,key)),
<a name="4225"/> 4225:     Tab = ets_new(foo,[]),
<a name="4226"/> 4226:     ets:delete(Tab),
<a name="4227"/> 4227:     {'EXIT',{badarg,_}} = (catch ets:lookup(Tab,key)),
<a name="badlookup-last_expr"/><a name="4228"/> 4228: <b>    verify_etsmem</b>(EtsMem).
<a name="4229"/> 4229: 
<a name="4230"/> 4230: <i>%% Test that lookup returns objects in order of insertion for bag and dbag.</i>
<a name="lookup_order-1"/><a name="4231"/> 4231: <b>lookup_order</b>(Config) when is_list(Config) -&gt;
<a name="4232"/> 4232:     EtsMem = etsmem(),
<a name="4233"/> 4233:     repeat_for_opts(fun lookup_order_do/1,
<a name="4234"/> 4234:                     [write_concurrency,[bag,duplicate_bag]]),
<a name="4235"/> 4235:     verify_etsmem(EtsMem),
<a name="lookup_order-last_expr"/><a name="4236"/> 4236:     ok.
<a name="4237"/> 4237: 
<a name="lookup_order_do-1"/><a name="4238"/> 4238: <b>lookup_order_do</b>(Opts) -&gt;
<a name="4239"/> 4239:     lookup_order_2(Opts, false),
<a name="lookup_order_do-last_expr"/><a name="4240"/> 4240: <b>    lookup_order_2</b>(Opts, true).
<a name="4241"/> 4241: 
<a name="lookup_order_2-2"/><a name="4242"/> 4242: <b>lookup_order_2</b>(Opts, Fixed) -&gt;
<a name="4243"/> 4243:     io:format(&quot;Opts=~p Fixed=~p\n&quot;,[Opts,Fixed]),
<a name="4244"/> 4244: 
<a name="4245"/> 4245:     A = 1, B = 2, C = 3,
<a name="4246"/> 4246:     ABC = [A,B,C],
<a name="4247"/> 4247:     Pair = [{A,B},{B,A},{A,C},{C,A},{B,C},{C,B}],
<a name="4248"/> 4248:     Combos = [{D1,D2,D3} || D1&lt;-ABC, D2&lt;-Pair, D3&lt;-Pair],
<a name="lookup_order_2-last_expr"/><a name="4249"/> 4249: <b>    lists:foreach</b>(fun({D1,{D2a,D2b},{D3a,D3b}}) -&gt;
<a name="4250"/> 4250: 			  T = ets_new(foo,Opts),
<a name="4251"/> 4251: 			  case Fixed of
<a name="4252"/> 4252: 			      true -&gt; ets:safe_fixtable(T,true);
<a name="4253"/> 4253: 			      false -&gt; ok
<a name="4254"/> 4254: 			  end,
<a name="4255"/> 4255: 			  S10 = {T,[],key},
<a name="4256"/> 4256: 			  S20 = check_insert(S10,A),
<a name="4257"/> 4257: 			  S30 = check_insert(S20,B),
<a name="4258"/> 4258: 			  S40 = check_insert(S30,C),
<a name="4259"/> 4259: 			  S50 = check_delete(S40,D1),
<a name="4260"/> 4260: 			  S55 = check_insert(S50,D1),
<a name="4261"/> 4261: 			  S60 = check_insert(S55,D1),
<a name="4262"/> 4262: 			  S70 = check_delete(S60,D2a),
<a name="4263"/> 4263: 			  S80 = check_delete(S70,D2b),
<a name="4264"/> 4264: 			  S90 = check_insert(S80,D2a),
<a name="4265"/> 4265: 			  SA0 = check_delete(S90,D3a),
<a name="4266"/> 4266: 			  SB0 = check_delete(SA0,D3b),
<a name="4267"/> 4267: 			  check_insert_new(SB0,D3b),
<a name="4268"/> 4268: 
<a name="4269"/> 4269: 			  true = ets:delete(T)
<a name="4270"/> 4270: 		  end,
<a name="4271"/> 4271: 		  Combos).
<a name="4272"/> 4272: 
<a name="4273"/> 4273: 
<a name="check_insert-2"/><a name="4274"/> 4274: <b>check_insert</b>({T,List0,Key},Val) -&gt;
<a name="4275"/> 4275:     %%io:format(&quot;insert ~p into ~p\n&quot;,[Val,List0]),
<a name="4276"/> 4276:     ets:insert(T,{Key,Val}),
<a name="4277"/> 4277:     List1 = case (ets:info(T,type) =:= bag andalso
<a name="4278"/> 4278: 		  lists:member({Key,Val},List0)) of
<a name="4279"/> 4279: 		true -&gt; List0;
<a name="4280"/> 4280: 		false -&gt; [{Key,Val} | List0]
<a name="4281"/> 4281: 	    end,
<a name="check_insert-last_expr"/><a name="4282"/> 4282: <b>    check_check</b>({T,List1,Key}).
<a name="4283"/> 4283: 
<a name="check_insert_new-2"/><a name="4284"/> 4284: <b>check_insert_new</b>({T,List0,Key},Val) -&gt;
<a name="4285"/> 4285:     %%io:format(&quot;insert_new ~p into ~p\n&quot;,[Val,List0]),
<a name="4286"/> 4286:     Ret = ets:insert_new(T,{Key,Val}),
<a name="4287"/> 4287:     Ret = (List0 =:= []),
<a name="4288"/> 4288:     List1 = case Ret of
<a name="4289"/> 4289: 		true -&gt; [{Key,Val}];
<a name="4290"/> 4290: 		false -&gt; List0
<a name="4291"/> 4291: 	    end,
<a name="check_insert_new-last_expr"/><a name="4292"/> 4292: <b>    check_check</b>({T,List1,Key}).
<a name="4293"/> 4293: 
<a name="4294"/> 4294: 
<a name="check_delete-2"/><a name="4295"/> 4295: <b>check_delete</b>({T,List0,Key},Val) -&gt;
<a name="4296"/> 4296:     %%io:format(&quot;delete ~p from ~p\n&quot;,[Val,List0]),
<a name="4297"/> 4297:     ets:delete_object(T,{Key,Val}),
<a name="4298"/> 4298:     List1 = lists:filter(fun(Obj) -&gt; Obj =/= {Key,Val} end,
<a name="4299"/> 4299: 			 List0),
<a name="check_delete-last_expr"/><a name="4300"/> 4300: <b>    check_check</b>({T,List1,Key}).
<a name="4301"/> 4301: 
<a name="check_check-1"/><a name="4302"/> 4302: <b>check_check</b>(S={T,List,Key}) -&gt;
<a name="4303"/> 4303:     case lists:reverse(ets:lookup(T,Key)) of
<a name="4304"/> 4304: 	List -&gt; ok;
<a name="4305"/> 4305:         ETS -&gt; io:format(&quot;check failed:\nETS: ~p\nCHK: ~p\n&quot;, [ETS,List]),
<a name="4306"/> 4306: 	       ct:fail(&quot;Invalid return value from ets:lookup&quot;)
<a name="4307"/> 4307:     end,
<a name="4308"/> 4308:     Items = ets:info(T,size),
<a name="4309"/> 4309:     Items = length(List),
<a name="check_check-last_expr"/><a name="4310"/> 4310:     S.
<a name="4311"/> 4311: 
<a name="fill_tab-2"/><a name="4312"/> 4312: <b>fill_tab</b>(Tab,Val) -&gt;
<a name="4313"/> 4313:     ets:insert(Tab,{key,Val}),
<a name="4314"/> 4314:     ets:insert(Tab,{{a,144},Val}),
<a name="4315"/> 4315:     ets:insert(Tab,{{a,key2},Val}),
<a name="4316"/> 4316:     ets:insert(Tab,{14,Val}),
<a name="fill_tab-last_expr"/><a name="4317"/> 4317:     ok.
<a name="4318"/> 4318: 
<a name="4319"/> 4319: 
<a name="4320"/> 4320: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="4321"/> 4321: 
<a name="lookup_element_default-1"/><a name="4322"/> 4322: <b>lookup_element_default</b>(Config) when is_list(Config) -&gt;
<a name="4323"/> 4323:     EtsMem = etsmem(),
<a name="4324"/> 4324: 
<a name="4325"/> 4325:     TabSet = ets_new(foo, [set]),
<a name="4326"/> 4326:     ets:insert(TabSet, {key, 42}),
<a name="4327"/> 4327:     42 = ets:lookup_element(TabSet, key, 2, 13),
<a name="4328"/> 4328:     13 = ets:lookup_element(TabSet, not_key, 2, 13),
<a name="4329"/> 4329:     {'EXIT',{badarg,_}} = catch ets:lookup_element(TabSet, key, 3, 13),
<a name="4330"/> 4330:     true = ets:delete(TabSet),
<a name="4331"/> 4331: 
<a name="4332"/> 4332:     TabOrderedSet = ets_new(foo, [ordered_set]),
<a name="4333"/> 4333:     ets:insert(TabOrderedSet, {key, 42}),
<a name="4334"/> 4334:     42 = ets:lookup_element(TabOrderedSet, key, 2, 13),
<a name="4335"/> 4335:     13 = ets:lookup_element(TabOrderedSet, not_key, 2, 13),
<a name="4336"/> 4336:     {'EXIT',{badarg,_}} = catch ets:lookup_element(TabOrderedSet, key, 3, 13),
<a name="4337"/> 4337:     true = ets:delete(TabOrderedSet),
<a name="4338"/> 4338: 
<a name="4339"/> 4339:     TabBag = ets_new(foo, [bag]),
<a name="4340"/> 4340:     ets:insert(TabBag, {key, 42}),
<a name="4341"/> 4341:     ets:insert(TabBag, {key, 43, 44}),
<a name="4342"/> 4342:     [42, 43] = ets:lookup_element(TabBag, key, 2, 13),
<a name="4343"/> 4343:     13 = ets:lookup_element(TabBag, not_key, 2, 13),
<a name="4344"/> 4344:     {'EXIT',{badarg,_}} = catch ets:lookup_element(TabBag, key, 3, 13),
<a name="4345"/> 4345:     true = ets:delete(TabBag),
<a name="4346"/> 4346: 
<a name="4347"/> 4347:     TabDuplicateBag = ets_new(foo, [duplicate_bag]),
<a name="4348"/> 4348:     ets:insert(TabDuplicateBag, {key, 42}),
<a name="4349"/> 4349:     ets:insert(TabDuplicateBag, {key, 42}),
<a name="4350"/> 4350:     ets:insert(TabDuplicateBag, {key, 43, 44}),
<a name="4351"/> 4351:     [42, 42, 43] = ets:lookup_element(TabDuplicateBag, key, 2, 13),
<a name="4352"/> 4352:     13 = ets:lookup_element(TabDuplicateBag, not_key, 2, 13),
<a name="4353"/> 4353:     {'EXIT',{badarg,_}} = catch ets:lookup_element(TabDuplicateBag, key, 3, 13),
<a name="4354"/> 4354:     true = ets:delete(TabDuplicateBag),
<a name="4355"/> 4355: 
<a name="lookup_element_default-last_expr"/><a name="4356"/> 4356: <b>    verify_etsmem</b>(EtsMem).
<a name="4357"/> 4357: 
<a name="4358"/> 4358: <i>%% OTP-2386. Multiple return elements.</i>
<a name="lookup_element_mult-1"/><a name="4359"/> 4359: <b>lookup_element_mult</b>(Config) when is_list(Config) -&gt;
<a name="lookup_element_mult-last_expr"/><a name="4360"/> 4360: <b>    repeat_for_opts</b>(fun lookup_element_mult_do/1).
<a name="4361"/> 4361: 
<a name="lookup_element_mult_do-1"/><a name="4362"/> 4362: <b>lookup_element_mult_do</b>(Opts) -&gt;
<a name="4363"/> 4363:     EtsMem = etsmem(),
<a name="4364"/> 4364:     T = ets_new(service, [bag, {keypos, 2} | Opts]),
<a name="4365"/> 4365:     D = lists:reverse(lem_data()),
<a name="4366"/> 4366:     lists:foreach(fun(X) -&gt; ets:insert(T, X) end, D),
<a name="4367"/> 4367:     ok = lem_crash_3(T),
<a name="4368"/> 4368:     ets:insert(T, {0, &quot;heap_key&quot;}),
<a name="4369"/> 4369:     ets:lookup_element(T, &quot;heap_key&quot;, 2),
<a name="4370"/> 4370:     true = ets:delete(T),
<a name="lookup_element_mult_do-last_expr"/><a name="4371"/> 4371: <b>    verify_etsmem</b>(EtsMem).
<a name="4372"/> 4372: 
<a name="lem_data-0"/><a name="4373"/> 4373: <b>lem_data</b>() -&gt;
<a name="lem_data-last_expr"/><a name="4374"/> 4374: <b>    [{service,'eddie2@boromir',{150,236,14,103},httpd88,self</b>()},
<a name="4375"/> 4375:      {service,'eddie2@boromir',{150,236,14,103},httpd80,self()},
<a name="4376"/> 4376:      {service,'eddie3@boromir',{150,236,14,107},httpd88,self()},
<a name="4377"/> 4377:      {service,'eddie3@boromir',{150,236,14,107},httpd80,self()},
<a name="4378"/> 4378:      {service,'eddie4@boromir',{150,236,14,108},httpd88,self()}].
<a name="4379"/> 4379: 
<a name="lem_crash-1"/><a name="4380"/> 4380: <b>lem_crash</b>(T) -&gt;
<a name="4381"/> 4381:     L = ets:lookup_element(T, 'eddie2@boromir', 3),
<a name="lem_crash-last_expr"/><a name="4382"/> 4382: <b>    {erlang:phash2</b>(L, 256), L}.
<a name="4383"/> 4383: 
<a name="lem_crash_3-1"/><a name="4384"/> 4384: <b>lem_crash_3</b>(T) -&gt;
<a name="4385"/> 4385:     lem_crash(T),
<a name="4386"/> 4386:     io:format(&quot;Survived once~n&quot;),
<a name="4387"/> 4387:     lem_crash(T),
<a name="4388"/> 4388:     io:format(&quot;Survived twice~n&quot;),
<a name="4389"/> 4389:     lem_crash(T),
<a name="4390"/> 4390:     io:format(&quot;Survived all!~n&quot;),
<a name="lem_crash_3-last_expr"/><a name="4391"/> 4391:     ok.
<a name="4392"/> 4392: 
<a name="4393"/> 4393: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="4394"/> 4394: 
<a name="4395"/> 4395: 
<a name="4396"/> 4396: <i>%% Check delete of an element inserted in a `filled' table.</i>
<a name="delete_elem-1"/><a name="4397"/> 4397: <b>delete_elem</b>(Config) when is_list(Config) -&gt;
<a name="delete_elem-last_expr"/><a name="4398"/> 4398: <b>    repeat_for_opts</b>(fun delete_elem_do/1,
<a name="4399"/> 4399:                     [write_concurrency, all_types]).
<a name="4400"/> 4400: 
<a name="delete_elem_do-1"/><a name="4401"/> 4401: <b>delete_elem_do</b>(Opts) -&gt;
<a name="4402"/> 4402:     EtsMem = etsmem(),
<a name="4403"/> 4403:     Tab = ets_new(foo,Opts),
<a name="4404"/> 4404:     fill_tab(Tab,foo),
<a name="4405"/> 4405:     ets:insert(Tab,{{b,key},foo}),
<a name="4406"/> 4406:     ets:insert(Tab,{{c,key},foo}),
<a name="4407"/> 4407:     true = ets:delete(Tab,{b,key}),
<a name="4408"/> 4408:     [] = ets:lookup(Tab,{b,key}),
<a name="4409"/> 4409:     [{{c,key},foo}] = ets:lookup(Tab,{c,key}),
<a name="4410"/> 4410:     true = ets:delete(Tab),
<a name="delete_elem_do-last_expr"/><a name="4411"/> 4411: <b>    verify_etsmem</b>(EtsMem).
<a name="4412"/> 4412: 
<a name="4413"/> 4413: <i>%% Check that ets:delete() works and releases the name of the</i>
<a name="4414"/> 4414: <i>%% deleted table.</i>
<a name="delete_tab-1"/><a name="4415"/> 4415: <b>delete_tab</b>(Config) when is_list(Config) -&gt;
<a name="delete_tab-last_expr"/><a name="4416"/> 4416: <b>    repeat_for_opts</b>(fun delete_tab_do/1,
<a name="4417"/> 4417:                     [write_concurrency,all_types]).
<a name="4418"/> 4418: 
<a name="delete_tab_do-1"/><a name="4419"/> 4419: <b>delete_tab_do</b>(Opts) -&gt;
<a name="4420"/> 4420:     Name = foo,
<a name="4421"/> 4421:     EtsMem = etsmem(),
<a name="4422"/> 4422:     Name = ets_new(Name, [named_table | Opts]),
<a name="4423"/> 4423:     true = ets:delete(foo),
<a name="4424"/> 4424:     %% The name should be available again.
<a name="4425"/> 4425:     Name = ets_new(Name, [named_table | Opts]),
<a name="4426"/> 4426:     true = ets:delete(Name),
<a name="delete_tab_do-last_expr"/><a name="4427"/> 4427: <b>    verify_etsmem</b>(EtsMem).
<a name="4428"/> 4428: 
<a name="4429"/> 4429: <i>%% Check that ets:delete/1 works and that other processes can run.</i>
<a name="delete_large_tab-1"/><a name="4430"/> 4430: <b>delete_large_tab</b>(Config) when is_list(Config) -&gt;
<a name="4431"/> 4431:     ct:timetrap({minutes,60}), %% valgrind needs a lot
<a name="4432"/> 4432:     KeyRange = 16#ffffff,
<a name="4433"/> 4433:     Data = [{erlang:phash2(I, KeyRange),I} || I &lt;- lists:seq(1, 200000)],
<a name="4434"/> 4434:     EtsMem = etsmem(),
<a name="4435"/> 4435:     repeat_for_opts(fun(Opts) -&gt; delete_large_tab_do(Config,
<a name="4436"/> 4436:                                                      key_range(Opts,KeyRange),
<a name="4437"/> 4437:                                                      Data)
<a name="4438"/> 4438:                     end),
<a name="delete_large_tab-last_expr"/><a name="4439"/> 4439: <b>    verify_etsmem</b>(EtsMem).
<a name="4440"/> 4440: 
<a name="delete_large_tab_do-3"/><a name="4441"/> 4441: <b>delete_large_tab_do</b>(Config, Opts,Data) -&gt;
<a name="4442"/> 4442:     delete_large_tab_1(Config, foo_hash, Opts, Data, false),
<a name="4443"/> 4443:     run_if_valid_opts(
<a name="4444"/> 4444:       [ordered_set | Opts],
<a name="4445"/> 4445:       fun(OptsOrdSet) -&gt;
<a name="4446"/> 4446:               delete_large_tab_1(Config, foo_tree, OptsOrdSet, Data, false)
<a name="4447"/> 4447:       end),
<a name="4448"/> 4448:     run_if_valid_opts(
<a name="4449"/> 4449:       [stim_cat_ord_set | Opts],
<a name="4450"/> 4450:       fun(OptsCat) -&gt;
<a name="4451"/> 4451:               delete_large_tab_1(Config, foo_tree, OptsCat, Data, false)
<a name="4452"/> 4452:       end),
<a name="delete_large_tab_do-last_expr"/><a name="4453"/> 4453: <b>    delete_large_tab_1</b>(Config, foo_hash_fix, Opts, Data, true).
<a name="4454"/> 4454: 
<a name="4455"/> 4455: 
<a name="delete_large_tab_1-5"/><a name="4456"/> 4456: <b>delete_large_tab_1</b>(Config, Name, Flags, Data, Fix) -&gt;
<a name="delete_large_tab_1-last_expr"/><a name="4457"/> 4457: <b>    case is_redundant_opts_combo</b>(Flags) of
<a name="4458"/> 4458:         true -&gt; skip;
<a name="4459"/> 4459:         false -&gt;
<a name="4460"/> 4460:             delete_large_tab_2(Config, Name, Flags, Data, Fix)
<a name="4461"/> 4461:     end.
<a name="4462"/> 4462: 
<a name="delete_large_tab_2-5"/><a name="4463"/> 4463: <b>delete_large_tab_2</b>(Config, Name, Flags, Data, Fix) -&gt;
<a name="4464"/> 4464:     Tab = ets_new(Name, Flags),
<a name="4465"/> 4465:     ets:insert(Tab, Data),
<a name="4466"/> 4466: 
<a name="4467"/> 4467:     case Fix of
<a name="4468"/> 4468: 	false -&gt; ok;
<a name="4469"/> 4469: 	true -&gt;
<a name="4470"/> 4470: 	    true = ets:safe_fixtable(Tab, true),
<a name="4471"/> 4471: 	    lists:foreach(fun({K,_}) -&gt; ets:delete(Tab, K) end, Data)
<a name="4472"/> 4472:     end,
<a name="4473"/> 4473: 
<a name="4474"/> 4474:     {priority, Prio} = process_info(self(), priority),
<a name="4475"/> 4475:     Deleter = self(),
<a name="4476"/> 4476:     ForceTrap = proplists:get_bool(ets_force_trap, Config),
<a name="4477"/> 4477:     [SchedTracer]
<a name="4478"/> 4478: 	= start_loopers(1,
<a name="4479"/> 4479: 			Prio,
<a name="4480"/> 4480: 			fun (SC) -&gt;
<a name="4481"/> 4481: 				receive
<a name="4482"/> 4482: 				    {trace, Deleter, out, _} -&gt;
<a name="4483"/> 4483:                                         case {ets:info(Tab), SC, ForceTrap} of
<a name="4484"/> 4484:                                             {undefined, _, _} -&gt; ok;
<a name="4485"/> 4485:                                             {_, 0, true} -&gt;
<a name="4486"/> 4486:                                                 %% Forced first trap of ets:delete,
<a name="4487"/> 4487:                                                 %% tab still reachable
<a name="4488"/> 4488:                                                 ok
<a name="4489"/> 4489:                                         end,
<a name="4490"/> 4490:                                         SC+1;
<a name="4491"/> 4491: 				    {trace,
<a name="4492"/> 4492: 				     Deleter,
<a name="4493"/> 4493: 				     register,
<a name="4494"/> 4494: 				     delete_large_tab_done_marker}-&gt;
<a name="4495"/> 4495: 					Deleter ! {schedule_count, SC},
<a name="4496"/> 4496: 					exit(normal);
<a name="4497"/> 4497: 				    _ -&gt;
<a name="4498"/> 4498: 					SC
<a name="4499"/> 4499: 				end
<a name="4500"/> 4500: 			end,
<a name="4501"/> 4501: 			0),
<a name="4502"/> 4502:     SchedTracerMon = monitor(process, SchedTracer),
<a name="4503"/> 4503:     Loopers = start_loopers(erlang:system_info(schedulers),
<a name="4504"/> 4504: 			    Prio,
<a name="4505"/> 4505: 			    fun (_) -&gt; erlang:yield() end,
<a name="4506"/> 4506: 			    ok),
<a name="4507"/> 4507:     erlang:yield(),
<a name="4508"/> 4508:     1 = erlang:trace(self(),true,[running,procs,{tracer,SchedTracer}]),
<a name="4509"/> 4509:     true = ets:delete(Tab),
<a name="4510"/> 4510:     %% The register stuff is just a trace marker
<a name="4511"/> 4511:     true = register(delete_large_tab_done_marker, self()),
<a name="4512"/> 4512:     true = unregister(delete_large_tab_done_marker),
<a name="4513"/> 4513:     undefined = ets:info(Tab),
<a name="4514"/> 4514:     ok = stop_loopers(Loopers),
<a name="4515"/> 4515:     receive
<a name="4516"/> 4516: 	{schedule_count, N} -&gt;
<a name="4517"/> 4517: 	    io:format(&quot;~s: context switches: ~p&quot;, [Name,N]),
<a name="4518"/> 4518: 	    if
<a name="4519"/> 4519: 		N &gt;= 5 -&gt; ok;
<a name="4520"/> 4520: 		true -&gt; ct:fail(failed)
<a name="4521"/> 4521: 	    end
<a name="4522"/> 4522:     end,
<a name="4523"/> 4523:     receive {'DOWN',SchedTracerMon,process,SchedTracer,_} -&gt; ok end,
<a name="delete_large_tab_2-last_expr"/><a name="4524"/> 4524:     ok.
<a name="4525"/> 4525: 
<a name="4526"/> 4526: <i>%% Delete a large name table and try to create a new table with</i>
<a name="4527"/> 4527: <i>%% the same name in another process.</i>
<a name="delete_large_named_table-1"/><a name="4528"/> 4528: <b>delete_large_named_table</b>(Config) when is_list(Config) -&gt;
<a name="4529"/> 4529:     KeyRange = 16#ffffff,
<a name="4530"/> 4530:     Data = [{erlang:phash2(I, KeyRange),I} || I &lt;- lists:seq(1, 200000)],
<a name="4531"/> 4531:     EtsMem = etsmem(),
<a name="4532"/> 4532:     repeat_for_opts(fun(Opts) -&gt;
<a name="4533"/> 4533:                             delete_large_named_table_do(key_range(Opts,KeyRange),
<a name="4534"/> 4534:                                                         Data)
<a name="4535"/> 4535:                     end),
<a name="4536"/> 4536:     verify_etsmem(EtsMem),
<a name="delete_large_named_table-last_expr"/><a name="4537"/> 4537:     ok.
<a name="4538"/> 4538: 
<a name="delete_large_named_table_do-2"/><a name="4539"/> 4539: <b>delete_large_named_table_do</b>(Opts,Data) -&gt;
<a name="4540"/> 4540:     delete_large_named_table_1(foo_hash, [named_table | Opts], Data, false),
<a name="4541"/> 4541:     run_if_valid_opts(
<a name="4542"/> 4542:       [ordered_set,named_table | Opts],
<a name="4543"/> 4543:       fun(OptsOrdSet) -&gt;
<a name="4544"/> 4544:               delete_large_named_table_1(foo_tree, OptsOrdSet, Data, false)
<a name="4545"/> 4545:       end),
<a name="4546"/> 4546:     run_if_valid_opts(
<a name="4547"/> 4547:       [stim_cat_ord_set,named_table | Opts],
<a name="4548"/> 4548:       fun(OptsStimCat) -&gt;
<a name="4549"/> 4549:               delete_large_named_table_1(foo_tree, OptsStimCat, Data, false)
<a name="4550"/> 4550:       end),
<a name="delete_large_named_table_do-last_expr"/><a name="4551"/> 4551: <b>    delete_large_named_table_1</b>(foo_hash, [named_table | Opts], Data, true).
<a name="4552"/> 4552: 
<a name="delete_large_named_table_1-4"/><a name="4553"/> 4553: <b>delete_large_named_table_1</b>(Name, Flags, Data, Fix) -&gt;
<a name="delete_large_named_table_1-last_expr"/><a name="4554"/> 4554: <b>    case is_redundant_opts_combo</b>(Flags) of
<a name="4555"/> 4555:         true -&gt; skip;
<a name="4556"/> 4556:         false -&gt;
<a name="4557"/> 4557:             delete_large_named_table_2(Name, Flags, Data, Fix)
<a name="4558"/> 4558:     end.
<a name="4559"/> 4559: 
<a name="delete_large_named_table_2-4"/><a name="4560"/> 4560: <b>delete_large_named_table_2</b>(Name, Flags, Data, Fix) -&gt;
<a name="4561"/> 4561:     Tab = ets_new(Name, Flags),
<a name="4562"/> 4562:     ets:insert(Tab, Data),
<a name="4563"/> 4563: 
<a name="4564"/> 4564:     case Fix of
<a name="4565"/> 4565: 	false -&gt; ok;
<a name="4566"/> 4566: 	true -&gt;
<a name="4567"/> 4567: 	    true = ets:safe_fixtable(Tab, true),
<a name="4568"/> 4568: 	    lists:foreach(fun({K,_}) -&gt; ets:delete(Tab, K) end, Data)
<a name="4569"/> 4569:     end,
<a name="4570"/> 4570:     {Pid, MRef} = my_spawn_opt(fun() -&gt;
<a name="4571"/> 4571: 				       receive
<a name="4572"/> 4572: 					   ets_new -&gt;
<a name="4573"/> 4573: 					       ets_new(Name, [named_table])
<a name="4574"/> 4574: 				       end
<a name="4575"/> 4575: 			       end,
<a name="4576"/> 4576: 			       [link, monitor]),
<a name="4577"/> 4577:     true = ets:delete(Tab),
<a name="4578"/> 4578:     Pid ! ets_new,
<a name="4579"/> 4579:     receive {'DOWN',MRef,process,Pid,_} -&gt; ok end,
<a name="delete_large_named_table_2-last_expr"/><a name="4580"/> 4580:     ok.
<a name="4581"/> 4581: 
<a name="4582"/> 4582: <i>%% Delete a large table, and kill the process during the delete.</i>
<a name="evil_delete-1"/><a name="4583"/> 4583: <b>evil_delete</b>(Config) when is_list(Config) -&gt;
<a name="4584"/> 4584:     KeyRange = 100000,
<a name="4585"/> 4585:     Data = [{I,I*I} || I &lt;- lists:seq(1, KeyRange)],
<a name="evil_delete-last_expr"/><a name="4586"/> 4586: <b>    repeat_for_opts</b>(fun(Opts) -&gt;
<a name="4587"/> 4587:                             evil_delete_do(key_range(Opts,KeyRange),
<a name="4588"/> 4588:                                            Data)
<a name="4589"/> 4589:                     end).
<a name="4590"/> 4590: 
<a name="evil_delete_do-2"/><a name="4591"/> 4591: <b>evil_delete_do</b>(Opts,Data) -&gt;
<a name="4592"/> 4592:     EtsMem = etsmem(),
<a name="4593"/> 4593:     evil_delete_owner(foo_hash, Opts, Data, false),
<a name="4594"/> 4594:     verify_etsmem(EtsMem),
<a name="4595"/> 4595:     evil_delete_owner(foo_hash, Opts, Data, true),
<a name="4596"/> 4596:     verify_etsmem(EtsMem),
<a name="4597"/> 4597:     evil_delete_owner(foo_tree, [ordered_set | Opts], Data, false),
<a name="4598"/> 4598:     verify_etsmem(EtsMem),
<a name="4599"/> 4599:     evil_delete_owner(foo_catree, [stim_cat_ord_set | Opts], Data, false),
<a name="4600"/> 4600:     verify_etsmem(EtsMem),
<a name="4601"/> 4601:     TabA = evil_delete_not_owner(foo_hash, Opts, Data, false),
<a name="4602"/> 4602:     verify_etsmem(EtsMem),
<a name="4603"/> 4603:     TabB = evil_delete_not_owner(foo_hash, Opts, Data, true),
<a name="4604"/> 4604:     verify_etsmem(EtsMem),
<a name="4605"/> 4605:     TabC = evil_delete_not_owner(foo_tree, [ordered_set | Opts], Data, false),
<a name="4606"/> 4606:     verify_etsmem(EtsMem),
<a name="4607"/> 4607:     TabD = evil_delete_not_owner(foo_catree, [stim_cat_ord_set | Opts], Data, false),
<a name="4608"/> 4608:     verify_etsmem(EtsMem),
<a name="evil_delete_do-last_expr"/><a name="4609"/> 4609: <b>    lists:foreach</b>(fun(T) -&gt; undefined = ets:info(T) end,
<a name="4610"/> 4610: 		  [TabA,TabB,TabC,TabD]).
<a name="4611"/> 4611: 
<a name="evil_delete_not_owner-4"/><a name="4612"/> 4612: <b>evil_delete_not_owner</b>(Name, Flags, Data, Fix) -&gt;
<a name="evil_delete_not_owner-last_expr"/><a name="4613"/> 4613: <b>    case is_redundant_opts_combo</b>(Flags) of
<a name="4614"/> 4614:         true -&gt; skip;
<a name="4615"/> 4615:         false -&gt;
<a name="4616"/> 4616:             evil_delete_not_owner_1(Name, Flags, Data, Fix)
<a name="4617"/> 4617:     end.
<a name="4618"/> 4618: 
<a name="evil_delete_not_owner_1-4"/><a name="4619"/> 4619: <b>evil_delete_not_owner_1</b>(Name, Flags, Data, Fix) -&gt;
<a name="4620"/> 4620:     io:format(&quot;Not owner: ~p, fix = ~p&quot;, [Name,Fix]),
<a name="4621"/> 4621:     Tab = ets_new(Name, [public|Flags]),
<a name="4622"/> 4622:     ets:insert(Tab, Data),
<a name="4623"/> 4623:     case Fix of
<a name="4624"/> 4624: 	false -&gt; ok;
<a name="4625"/> 4625: 	true -&gt;
<a name="4626"/> 4626: 	    true = ets:safe_fixtable(Tab, true),
<a name="4627"/> 4627: 	    lists:foreach(fun({K,_}) -&gt; ets:delete(Tab, K) end, Data)
<a name="4628"/> 4628:     end,
<a name="4629"/> 4629:     Pid = my_spawn(fun() -&gt;
<a name="4630"/> 4630: 			   P = my_spawn_link(
<a name="4631"/> 4631: 				 fun() -&gt;
<a name="4632"/> 4632: 					 receive kill -&gt; ok end,
<a name="4633"/> 4633: 					 erlang:yield(),
<a name="4634"/> 4634: 					 exit(kill_linked_processes_now)
<a name="4635"/> 4635: 				 end),
<a name="4636"/> 4636: 			   erlang:yield(),
<a name="4637"/> 4637: 			   P ! kill,
<a name="4638"/> 4638: 			   true = ets:delete(Tab)
<a name="4639"/> 4639: 		   end),
<a name="4640"/> 4640:     Ref = erlang:monitor(process, Pid),
<a name="4641"/> 4641:     receive {'DOWN',Ref,_,_,_} -&gt; ok end,
<a name="evil_delete_not_owner_1-last_expr"/><a name="4642"/> 4642:     Tab.
<a name="4643"/> 4643: 
<a name="evil_delete_owner-4"/><a name="4644"/> 4644: <b>evil_delete_owner</b>(Name, Flags, Data, Fix) -&gt;
<a name="evil_delete_owner-last_expr"/><a name="4645"/> 4645: <b>    case is_redundant_opts_combo</b>(Flags) of
<a name="4646"/> 4646:         true -&gt; skip;
<a name="4647"/> 4647:         false -&gt;
<a name="4648"/> 4648:             evil_delete_owner_1(Name, Flags, Data, Fix)
<a name="4649"/> 4649:     end.
<a name="4650"/> 4650: 
<a name="evil_delete_owner_1-4"/><a name="4651"/> 4651: <b>evil_delete_owner_1</b>(Name, Flags, Data, Fix) -&gt;
<a name="4652"/> 4652:     Fun = fun() -&gt;
<a name="4653"/> 4653: 		  Tab = ets_new(Name, [public|Flags]),
<a name="4654"/> 4654: 		  ets:insert(Tab, Data),
<a name="4655"/> 4655: 		  case Fix of
<a name="4656"/> 4656: 		      false -&gt; ok;
<a name="4657"/> 4657: 		      true -&gt;
<a name="4658"/> 4658: 			  true = ets:safe_fixtable(Tab, true),
<a name="4659"/> 4659: 			  lists:foreach(fun({K,_}) -&gt;
<a name="4660"/> 4660: 						ets:delete(Tab, K)
<a name="4661"/> 4661: 					end, Data)
<a name="4662"/> 4662: 		  end,
<a name="4663"/> 4663: 		  erlang:yield(),
<a name="4664"/> 4664: 		  my_spawn_link(fun() -&gt;
<a name="4665"/> 4665: 					erlang:yield(),
<a name="4666"/> 4666: 					exit(kill_linked_processes_now)
<a name="4667"/> 4667: 				end),
<a name="4668"/> 4668: 		  true = ets:delete(Tab)
<a name="4669"/> 4669: 	  end,
<a name="4670"/> 4670:     Pid = my_spawn(Fun),
<a name="4671"/> 4671:     Ref = erlang:monitor(process, Pid),
<a name="evil_delete_owner_1-last_expr"/><a name="4672"/> 4672:     receive {'DOWN',Ref,_,_,_} -&gt; ok end.
<a name="4673"/> 4673: 
<a name="4674"/> 4674: 
<a name="exit_large_table_owner-1"/><a name="4675"/> 4675: <b>exit_large_table_owner</b>(Config) when is_list(Config) -&gt;
<a name="4676"/> 4676:     %%Data = [{erlang:phash2(I, 16#ffffff),I} || I &lt;- lists:seq(1, 500000)],
<a name="4677"/> 4677:     Laps = 500000 div syrup_factor(),
<a name="4678"/> 4678:     FEData = fun(Do) -&gt; repeat_while(fun(I) when I =:= Laps -&gt; {false,ok};
<a name="4679"/> 4679: 					(I) -&gt; Do({erlang:phash2(I, 16#ffffff),I}),
<a name="4680"/> 4680: 					       {true, I+1}
<a name="4681"/> 4681: 				     end, 1)
<a name="4682"/> 4682: 	     end,
<a name="4683"/> 4683:     EtsMem = etsmem(),
<a name="4684"/> 4684:     repeat_for_opts(fun(Opts) -&gt;
<a name="4685"/> 4685:                             exit_large_table_owner_do(Opts,
<a name="4686"/> 4686:                                                       FEData,
<a name="4687"/> 4687:                                                       Config)
<a name="4688"/> 4688:                     end),
<a name="exit_large_table_owner-last_expr"/><a name="4689"/> 4689: <b>    verify_etsmem</b>(EtsMem).
<a name="4690"/> 4690: 
<a name="exit_large_table_owner_do-3"/><a name="4691"/> 4691: <b>exit_large_table_owner_do</b>(Opts, FEData, Config) -&gt;
<a name="4692"/> 4692:     verify_rescheduling_exit(Config, FEData, [named_table | Opts], true, 1, 1),
<a name="exit_large_table_owner_do-last_expr"/><a name="4693"/> 4693: <b>    verify_rescheduling_exit</b>(Config, FEData, Opts, false, 1, 1).
<a name="4694"/> 4694: 
<a name="exit_many_large_table_owner-1"/><a name="4695"/> 4695: <b>exit_many_large_table_owner</b>(Config) when is_list(Config) -&gt;
<a name="4696"/> 4696:     ct:timetrap({minutes,30}), %% valgrind needs a lot
<a name="4697"/> 4697:     %%Data = [{erlang:phash2(I, 16#ffffff),I} || I &lt;- lists:seq(1, 500000)],
<a name="4698"/> 4698:     Laps = 500000 div syrup_factor(),
<a name="4699"/> 4699:     FEData = fun(Do) -&gt; repeat_while(fun(I) when I =:= Laps -&gt; {false,ok};
<a name="4700"/> 4700: 					(I) -&gt; Do({erlang:phash2(I, 16#ffffff),I}),
<a name="4701"/> 4701: 					       {true, I+1}
<a name="4702"/> 4702: 				     end, 1)
<a name="4703"/> 4703: 	     end,
<a name="4704"/> 4704:     EtsMem = etsmem(),
<a name="4705"/> 4705:     repeat_for_opts(fun(Opts) -&gt; exit_many_large_table_owner_do(Opts,FEData,Config) end),
<a name="exit_many_large_table_owner-last_expr"/><a name="4706"/> 4706: <b>    verify_etsmem</b>(EtsMem).
<a name="4707"/> 4707: 
<a name="exit_many_large_table_owner_do-3"/><a name="4708"/> 4708: <b>exit_many_large_table_owner_do</b>(Opts,FEData,Config) -&gt;
<a name="4709"/> 4709:     verify_rescheduling_exit(Config, FEData, Opts, true, 1, 4),
<a name="exit_many_large_table_owner_do-last_expr"/><a name="4710"/> 4710: <b>    verify_rescheduling_exit</b>(Config, FEData, [named_table | Opts], false, 1, 4).
<a name="4711"/> 4711: 
<a name="exit_many_tables_owner-1"/><a name="4712"/> 4712: <b>exit_many_tables_owner</b>(Config) when is_list(Config) -&gt;
<a name="4713"/> 4713:     NoData = fun(_Do) -&gt; ok end,
<a name="4714"/> 4714:     EtsMem = etsmem(),
<a name="4715"/> 4715:     verify_rescheduling_exit(Config, NoData, [named_table], false, 1000, 1),
<a name="4716"/> 4716:     verify_rescheduling_exit(Config, NoData, [named_table,{write_concurrency,true}], false, 1000, 1),
<a name="exit_many_tables_owner-last_expr"/><a name="4717"/> 4717: <b>    verify_etsmem</b>(EtsMem).
<a name="4718"/> 4718: 
<a name="exit_many_many_tables_owner-1"/><a name="4719"/> 4719: <b>exit_many_many_tables_owner</b>(Config) when is_list(Config) -&gt;
<a name="4720"/> 4720:     Data = [{erlang:phash2(I, 16#ffffff),I} || I &lt;- lists:seq(1, 50)],
<a name="4721"/> 4721:     FEData = fun(Do) -&gt; lists:foreach(Do, Data) end,
<a name="exit_many_many_tables_owner-last_expr"/><a name="4722"/> 4722: <b>    repeat_for_opts</b>(fun(Opts) -&gt; exit_many_many_tables_owner_do1(Opts,FEData,Config) end).
<a name="4723"/> 4723: 
<a name="exit_many_many_tables_owner_do1-3"/><a name="4724"/> 4724: <b>exit_many_many_tables_owner_do1</b>(Opts,FEData,Config) -&gt;
<a name="exit_many_many_tables_owner_do1-last_expr"/><a name="4725"/> 4725: <b>    case has_fixed_number_of_locks</b>(Opts) of
<a name="4726"/> 4726:         true -&gt;
<a name="4727"/> 4727:             %% Few memory hogging tables =&gt; not enough yielding for the test
<a name="4728"/> 4728:             io:format(&quot;Skip option combo ~p\n&quot;, [Opts]);
<a name="4729"/> 4729:         false -&gt;
<a name="4730"/> 4730:             exit_many_many_tables_owner_do2(Opts,FEData,Config)
<a name="4731"/> 4731:     end.
<a name="4732"/> 4732: 
<a name="exit_many_many_tables_owner_do2-3"/><a name="4733"/> 4733: <b>exit_many_many_tables_owner_do2</b>(Opts,FEData,Config) -&gt;
<a name="4734"/> 4734:     E = ets_new(tmp,Opts),
<a name="4735"/> 4735:     FEData(fun(Data) -&gt; ets:insert(E, Data) end),
<a name="4736"/> 4736:     Mem = ets:info(E,memory) * erlang:system_info(wordsize),
<a name="4737"/> 4737:     ets:delete(E),
<a name="4738"/> 4738: 
<a name="4739"/> 4739:     ct:log(&quot;Memory per table: ~p bytes&quot;,[Mem]),
<a name="4740"/> 4740: 
<a name="4741"/> 4741:     Tables =
<a name="4742"/> 4742:         case erlang:system_info(wordsize) of
<a name="4743"/> 4743:             8 -&gt;
<a name="4744"/> 4744:                 200;
<a name="4745"/> 4745:             4 -&gt;
<a name="4746"/> 4746:                 lists:min([200,2_000_000_000 div (Mem * 5)])
<a name="4747"/> 4747:         end,
<a name="4748"/> 4748: 
<a name="4749"/> 4749:     verify_rescheduling_exit(Config, FEData, [named_table | Opts], true, Tables, 5),
<a name="4750"/> 4750:     verify_rescheduling_exit(Config, FEData, Opts, false, Tables, 5),
<a name="4751"/> 4751:     wait_for_test_procs(),
<a name="4752"/> 4752:     EtsMem = etsmem(),
<a name="4753"/> 4753:     verify_rescheduling_exit(Config, FEData, Opts, true, Tables, 5),
<a name="4754"/> 4754:     verify_rescheduling_exit(Config, FEData, [named_table | Opts], false, Tables, 5),
<a name="exit_many_many_tables_owner_do2-last_expr"/><a name="4755"/> 4755: <b>    verify_etsmem</b>(EtsMem).
<a name="4756"/> 4756: 
<a name="4757"/> 4757: 
<a name="count_exit_sched-1"/><a name="4758"/> 4758: <b>count_exit_sched</b>(TP) -&gt;
<a name="count_exit_sched-last_expr"/><a name="4759"/> 4759:     receive
<a name="4760"/> 4760: 	{trace, TP, in_exiting, 0} -&gt;
<a name="4761"/> 4761: 	    count_exit_sched_out(TP, 1);
<a name="4762"/> 4762: 	{trace, TP, out_exiting, 0} -&gt;
<a name="4763"/> 4763: 	    count_exit_sched_in(TP, 1);
<a name="4764"/> 4764: 	{trace, TP, out_exited, 0} -&gt;
<a name="4765"/> 4765: 	    0
<a name="4766"/> 4766:     end.
<a name="4767"/> 4767: 
<a name="count_exit_sched_in-2"/><a name="4768"/> 4768: <b>count_exit_sched_in</b>(TP, N) -&gt;
<a name="count_exit_sched_in-last_expr"/><a name="4769"/> 4769:     receive
<a name="4770"/> 4770: 	{trace, TP, in_exiting, 0} -&gt;
<a name="4771"/> 4771: 	    count_exit_sched_out(TP, N);
<a name="4772"/> 4772: 	{trace, TP, _, _} = Msg -&gt;
<a name="4773"/> 4773: 	    exit({unexpected_trace_msg, Msg})
<a name="4774"/> 4774:     end.
<a name="4775"/> 4775: 
<a name="count_exit_sched_out-2"/><a name="4776"/> 4776: <b>count_exit_sched_out</b>(TP, N) -&gt;
<a name="count_exit_sched_out-last_expr"/><a name="4777"/> 4777:     receive
<a name="4778"/> 4778: 	{trace, TP, out_exiting, 0} -&gt;
<a name="4779"/> 4779: 	    count_exit_sched_in(TP, N+1);
<a name="4780"/> 4780: 	{trace, TP, out_exited, 0} -&gt;
<a name="4781"/> 4781: 	    N;
<a name="4782"/> 4782: 	{trace, TP, _, _} = Msg -&gt;
<a name="4783"/> 4783: 	    exit({unexpected_trace_msg, Msg})
<a name="4784"/> 4784:     end.
<a name="4785"/> 4785: 
<a name="vre_fix_tables-1"/><a name="4786"/> 4786: <b>vre_fix_tables</b>(Tab) -&gt;
<a name="4787"/> 4787:     Parent = self(),
<a name="4788"/> 4788:     Go = make_ref(),
<a name="4789"/> 4789:     my_spawn_link(fun () -&gt;
<a name="4790"/> 4790: 			  true = ets:safe_fixtable(Tab, true),
<a name="4791"/> 4791: 			  Parent ! Go,
<a name="4792"/> 4792: 			  receive infinity -&gt; ok end
<a name="4793"/> 4793: 		  end),
<a name="4794"/> 4794:     receive Go -&gt; ok end,
<a name="vre_fix_tables-last_expr"/><a name="4795"/> 4795:     ok.
<a name="4796"/> 4796: 
<a name="verify_rescheduling_exit-6"/><a name="4797"/> 4797: <b>verify_rescheduling_exit</b>(Config, ForEachData, Flags, Fix, NOTabs, NOProcs) -&gt;
<a name="4798"/> 4798:     NoFix = 5,
<a name="4799"/> 4799:     TestCase = atom_to_list(proplists:get_value(test_case, Config)),
<a name="4800"/> 4800:     Parent = self(),
<a name="4801"/> 4801:     KillMe = make_ref(),
<a name="4802"/> 4802:     PFun =
<a name="4803"/> 4803: 	fun () -&gt;
<a name="4804"/> 4804: 		repeat(
<a name="4805"/> 4805: 		  fun () -&gt;
<a name="4806"/> 4806: 			  Uniq = erlang:unique_integer([positive]),
<a name="4807"/> 4807: 			  Name = list_to_atom(TestCase ++ &quot;-&quot; ++
<a name="4808"/> 4808: 						  integer_to_list(Uniq)),
<a name="4809"/> 4809: 			  Tab = ets_new(Name, Flags),
<a name="4810"/> 4810:                           ForEachData(fun(Data) -&gt; ets:insert(Tab, Data) end),
<a name="4811"/> 4811: 			  case Fix of
<a name="4812"/> 4812: 			      false -&gt; ok;
<a name="4813"/> 4813: 			      true -&gt;
<a name="4814"/> 4814: 				  lists:foreach(fun (_) -&gt;
<a name="4815"/> 4815: 							vre_fix_tables(Tab)
<a name="4816"/> 4816: 						end,
<a name="4817"/> 4817: 						lists:seq(1,NoFix)),
<a name="4818"/> 4818:                                   KeyPos = ets:info(Tab,keypos),
<a name="4819"/> 4819:                                   ForEachData(fun(Data) -&gt;
<a name="4820"/> 4820: 						      ets:delete(Tab, element(KeyPos,Data))
<a name="4821"/> 4821:                                               end)
<a name="4822"/> 4822: 			  end
<a name="4823"/> 4823: 		  end,
<a name="4824"/> 4824: 		  NOTabs),
<a name="4825"/> 4825: 		Parent ! {KillMe, self()},
<a name="4826"/> 4826: 		receive after infinity -&gt; ok end
<a name="4827"/> 4827: 	end,
<a name="4828"/> 4828:     TPs = lists:map(fun (_) -&gt;
<a name="4829"/> 4829: 			    TP = my_spawn_link(PFun),
<a name="4830"/> 4830: 			    1 = erlang:trace(TP, true, [exiting]),
<a name="4831"/> 4831: 			    TP
<a name="4832"/> 4832: 		    end,
<a name="4833"/> 4833: 		    lists:seq(1, NOProcs)),
<a name="4834"/> 4834:     lists:foreach(fun (TP) -&gt;
<a name="4835"/> 4835: 			  receive {KillMe, TP} -&gt; ok end
<a name="4836"/> 4836: 		  end,
<a name="4837"/> 4837: 		  TPs),
<a name="4838"/> 4838:     LPs = start_loopers(erlang:system_info(schedulers),
<a name="4839"/> 4839: 			normal,
<a name="4840"/> 4840: 			fun (_) -&gt;
<a name="4841"/> 4841: 				erlang:yield()
<a name="4842"/> 4842: 			end,
<a name="4843"/> 4843: 			ok),
<a name="4844"/> 4844:     lists:foreach(fun (TP) -&gt;
<a name="4845"/> 4845: 			  unlink(TP),
<a name="4846"/> 4846: 			  exit(TP, bang)
<a name="4847"/> 4847: 		  end,
<a name="4848"/> 4848: 		  TPs),
<a name="4849"/> 4849:     lists:foreach(fun (TP) -&gt;
<a name="4850"/> 4850: 			  XScheds = count_exit_sched(TP),
<a name="4851"/> 4851: 			  io:format(&quot;~p XScheds=~p~n&quot;,
<a name="4852"/> 4852: 				    [TP, XScheds]),
<a name="4853"/> 4853: 			  true = XScheds &gt;= 3
<a name="4854"/> 4854: 		  end,
<a name="4855"/> 4855: 		  TPs),
<a name="4856"/> 4856:     stop_loopers(LPs),
<a name="verify_rescheduling_exit-last_expr"/><a name="4857"/> 4857:     ok.
<a name="4858"/> 4858: 
<a name="4859"/> 4859: 
<a name="4860"/> 4860: 
<a name="4861"/> 4861: <i>%% Make sure that slots for ets tables are cleared properly.</i>
<a name="table_leak-1"/><a name="4862"/> 4862: <b>table_leak</b>(Config) when is_list(Config) -&gt;
<a name="table_leak-last_expr"/><a name="4863"/> 4863: <b>    repeat_for_opts_all_non_stim_table_types</b>(fun(Opts) -&gt; table_leak_1(Opts,20000) end).
<a name="4864"/> 4864: 
<a name="table_leak_1-2"/><a name="4865"/> 4865: <b>table_leak_1</b>(_,0) -&gt; ok;
<a name="4866"/> 4866: <b>table_leak_1</b>(Opts,N) -&gt;
<a name="4867"/> 4867:     T = ets_new(fooflarf, Opts),
<a name="4868"/> 4868:     true = ets:delete(T),
<a name="table_leak_1-last_expr"/><a name="4869"/> 4869: <b>    table_leak_1</b>(Opts,N-1).
<a name="4870"/> 4870: 
<a name="4871"/> 4871: <i>%% Check proper return values for illegal delete operations.</i>
<a name="baddelete-1"/><a name="4872"/> 4872: <b>baddelete</b>(Config) when is_list(Config) -&gt;
<a name="4873"/> 4873:     EtsMem = etsmem(),
<a name="4874"/> 4874:     {'EXIT',{badarg,_}} = (catch ets:delete(foo)),
<a name="4875"/> 4875:     Tab = ets_new(foo,[]),
<a name="4876"/> 4876:     true = ets:delete(Tab),
<a name="4877"/> 4877:     {'EXIT',{badarg,_}} = (catch ets:delete(Tab)),
<a name="baddelete-last_expr"/><a name="4878"/> 4878: <b>    verify_etsmem</b>(EtsMem).
<a name="4879"/> 4879: 
<a name="4880"/> 4880: <i>%% Check that match_delete works. Also tests tab2list function.</i>
<a name="match_delete-1"/><a name="4881"/> 4881: <b>match_delete</b>(Config) when is_list(Config) -&gt;
<a name="4882"/> 4882:     EtsMem = etsmem(),
<a name="4883"/> 4883:     repeat_for_opts(fun match_delete_do/1,
<a name="4884"/> 4884:                     [write_concurrency,all_types]),
<a name="match_delete-last_expr"/><a name="4885"/> 4885: <b>    verify_etsmem</b>(EtsMem).
<a name="4886"/> 4886: 
<a name="match_delete_do-1"/><a name="4887"/> 4887: <b>match_delete_do</b>(Opts) -&gt;
<a name="4888"/> 4888:     EtsMem = etsmem(),
<a name="4889"/> 4889:     Tab = ets_new(kad,Opts),
<a name="4890"/> 4890:     fill_tab(Tab,foo),
<a name="4891"/> 4891:     ets:insert(Tab,{{c,key},bar}),
<a name="4892"/> 4892:     _ = ets:match_delete(Tab,{'_',foo}),
<a name="4893"/> 4893:     [{{c,key},bar}] = ets:tab2list(Tab),
<a name="4894"/> 4894:     _ = ets:match_delete(Tab,'_'),
<a name="4895"/> 4895:     [] = ets:tab2list(Tab),
<a name="4896"/> 4896:     true = ets:delete(Tab),
<a name="match_delete_do-last_expr"/><a name="4897"/> 4897: <b>    verify_etsmem</b>(EtsMem).
<a name="4898"/> 4898: 
<a name="4899"/> 4899: <i>%% OTP-3005: check match_delete with constant argument.</i>
<a name="match_delete3-1"/><a name="4900"/> 4900: <b>match_delete3</b>(Config) when is_list(Config) -&gt;
<a name="match_delete3-last_expr"/><a name="4901"/> 4901: <b>    repeat_for_opts</b>(fun match_delete3_do/1).
<a name="4902"/> 4902: 
<a name="match_delete3_do-1"/><a name="4903"/> 4903: <b>match_delete3_do</b>(Opts) -&gt;
<a name="4904"/> 4904:     EtsMem = etsmem(),
<a name="4905"/> 4905:     T = make_table(test,
<a name="4906"/> 4906: 		   [duplicate_bag | Opts],
<a name="4907"/> 4907: 		   [{aa,17},
<a name="4908"/> 4908: 		    {cA,1000},
<a name="4909"/> 4909: 		    {cA,17},
<a name="4910"/> 4910: 		    {cA,1000},
<a name="4911"/> 4911: 		    {aa,17}]),
<a name="4912"/> 4912:     %% 'aa' and 'cA' have the same hash value in the current
<a name="4913"/> 4913:     %% implementation. This causes the aa's to precede the cA's, to make
<a name="4914"/> 4914:     %% the test more interesting.
<a name="4915"/> 4915:     [{cA,1000},{cA,1000}] = ets:match_object(T, {'_', 1000}),
<a name="4916"/> 4916:     ets:match_delete(T, {cA,1000}),
<a name="4917"/> 4917:     [] = ets:match_object(T, {'_', 1000}),
<a name="4918"/> 4918:     ets:delete(T),
<a name="match_delete3_do-last_expr"/><a name="4919"/> 4919: <b>    verify_etsmem</b>(EtsMem).
<a name="4920"/> 4920: 
<a name="4921"/> 4921: 
<a name="4922"/> 4922: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="4923"/> 4923: 
<a name="4924"/> 4924: <i>%% Test ets:first/1 &amp; ets:next/2.</i>
<a name="4925"/> 4925: 
<a name="ets_first_using_first_lookup-1"/><a name="4926"/> 4926: <b>ets_first_using_first_lookup</b>(Tab) -&gt;
<a name="ets_first_using_first_lookup-last_expr"/><a name="4927"/> 4927: <b>    case ets:first_lookup</b>(Tab) of
<a name="4928"/> 4928:         '$end_of_table' -&gt;
<a name="4929"/> 4929:             '$end_of_table';
<a name="4930"/> 4930:         {Key, _} -&gt;
<a name="4931"/> 4931:             Key
<a name="4932"/> 4932:     end.
<a name="4933"/> 4933: 
<a name="ets_next_using_next_lookup-2"/><a name="4934"/> 4934: <b>ets_next_using_next_lookup</b>(Tab, Key) -&gt;
<a name="ets_next_using_next_lookup-last_expr"/><a name="4935"/> 4935: <b>    case ets:next_lookup</b>(Tab, Key) of
<a name="4936"/> 4936:         '$end_of_table' -&gt;
<a name="4937"/> 4937:             '$end_of_table';
<a name="4938"/> 4938:         {Key2, _} -&gt;
<a name="4939"/> 4939:             Key2
<a name="4940"/> 4940:     end.
<a name="4941"/> 4941: 
<a name="firstnext-1"/><a name="4942"/> 4942: <b>firstnext</b>(Config) when is_list(Config) -&gt;
<a name="firstnext-last_expr"/><a name="4943"/> 4943: <b>    repeat_for_opts_all_set_table_types</b>(
<a name="4944"/> 4944:         fun(Opts) -&gt; firstnext_do(Opts, fun ets:first/1, fun ets:next/2) end).
<a name="4945"/> 4945: 
<a name="firstnext_lookup-1"/><a name="4946"/> 4946: <b>firstnext_lookup</b>(Config) when is_list(Config) -&gt;
<a name="firstnext_lookup-last_expr"/><a name="4947"/> 4947: <b>    repeat_for_opts_all_set_table_types</b>(
<a name="4948"/> 4948:         fun(Opts) -&gt; firstnext_do(Opts, fun ets_first_using_first_lookup/1, fun ets_next_using_next_lookup/2) end).
<a name="4949"/> 4949: 
<a name="firstnext_do-3"/><a name="4950"/> 4950: <b>firstnext_do</b>(Opts, FirstKeyFun, NextKeyFun) -&gt;
<a name="4951"/> 4951:     EtsMem = etsmem(),
<a name="4952"/> 4952:     Tab = ets_new(foo,Opts),
<a name="4953"/> 4953:     [] = firstnext_collect(Tab,FirstKeyFun(Tab),[], NextKeyFun),
<a name="4954"/> 4954:     fill_tab(Tab,foo),
<a name="4955"/> 4955:     Len = length(ets:tab2list(Tab)),
<a name="4956"/> 4956:     Len = length(firstnext_collect(Tab,FirstKeyFun(Tab),[], NextKeyFun)),
<a name="4957"/> 4957:     true = ets:delete(Tab),
<a name="firstnext_do-last_expr"/><a name="4958"/> 4958: <b>    verify_etsmem</b>(EtsMem).
<a name="4959"/> 4959: 
<a name="firstnext_collect-4"/><a name="4960"/> 4960: <b>firstnext_collect</b>(_Tab,'$end_of_table',List, _NextKeyFun) -&gt;
<a name="4961"/> 4961:     List;
<a name="4962"/> 4962: <b>firstnext_collect</b>(Tab,Key,List, NextKeyFun) -&gt;
<a name="firstnext_collect-last_expr"/><a name="4963"/> 4963: <b>    firstnext_collect</b>(Tab,NextKeyFun(Tab,Key),[Key|List], NextKeyFun).
<a name="4964"/> 4964: 
<a name="firstnext_concurrent-1"/><a name="4965"/> 4965: <b>firstnext_concurrent</b>(Config) when is_list(Config) -&gt;
<a name="firstnext_concurrent-last_expr"/><a name="4966"/> 4966: <b>    firstnext_concurrent_do</b>(Config, fun ets:first/1, fun ets:next/2).
<a name="4967"/> 4967: 
<a name="firstnext_lookup_concurrent-1"/><a name="4968"/> 4968: <b>firstnext_lookup_concurrent</b>(Config) when is_list(Config) -&gt;
<a name="firstnext_lookup_concurrent-last_expr"/><a name="4969"/> 4969: <b>    firstnext_concurrent_do</b>(Config, fun ets_first_using_first_lookup/1, fun ets_next_using_next_lookup/2).
<a name="4970"/> 4970: 
<a name="firstnext_concurrent_do-3"/><a name="4971"/> 4971: <b>firstnext_concurrent_do</b>(Config, FirstKeyFun, NextKeyFun) when is_list(Config) -&gt;
<a name="firstnext_concurrent_do-last_expr"/><a name="4972"/> 4972: <b>    lists:foreach</b>(
<a name="4973"/> 4973:       fun(TableType) -&gt;
<a name="4974"/> 4974:               register(master, self()),
<a name="4975"/> 4975:               TableName = list_to_atom(atom_to_list(?MODULE) ++ atom_to_list(TableType)),
<a name="4976"/> 4976:               ets_init(TableName, 20, TableType),
<a name="4977"/> 4977:               [dynamic_go(TableName, FirstKeyFun, NextKeyFun) || _ &lt;- lists:seq(1, 2)],
<a name="4978"/> 4978:               receive
<a name="4979"/> 4979:               after 5000 -&gt; ok
<a name="4980"/> 4980:               end,
<a name="4981"/> 4981:               unregister(master)
<a name="4982"/> 4982:       end, repeat_for_opts_atom2list(ord_set_types)).
<a name="4983"/> 4983: 
<a name="ets_init-3"/><a name="4984"/> 4984: <b>ets_init</b>(Tab, N, TableType) -&gt;
<a name="4985"/> 4985:     ets_new(Tab, [named_table,public,TableType]),
<a name="ets_init-last_expr"/><a name="4986"/> 4986: <b>    cycle</b>(Tab, lists:seq(1,N+1)).
<a name="4987"/> 4987: 
<a name="cycle-2"/><a name="4988"/> 4988: <b>cycle</b>(_Tab, [H|T]) when H &gt; length(T)-&gt; ok;
<a name="4989"/> 4989: <b>cycle</b>(Tab, L) -&gt;
<a name="4990"/> 4990:     ets:insert(Tab,list_to_tuple(L)),
<a name="cycle-last_expr"/><a name="4991"/> 4991: <b>    cycle</b>(Tab, tl(L)++[hd(L)]).
<a name="4992"/> 4992: 
<a name="dynamic_go-3"/><a name="dynamic_go-last_expr"/><a name="4993"/> 4993: <b>dynamic_go</b>(TableName, FirstKeyFun, NextKeyFun) -&gt; my_spawn_link(fun() -&gt; dynamic_init(TableName, FirstKeyFun, NextKeyFun) end).
<a name="4994"/> 4994: 
<a name="dynamic_init-3"/><a name="dynamic_init-last_expr"/><a name="4995"/> 4995: <b>dynamic_init</b>(TableName, FirstKeyFun, NextKeyFun) -&gt; [dyn_lookup(TableName, FirstKeyFun, NextKeyFun) || _ &lt;- lists:seq(1, 10)].
<a name="4996"/> 4996: 
<a name="dyn_lookup-3"/><a name="dyn_lookup-last_expr"/><a name="4997"/> 4997: <b>dyn_lookup</b>(T, FirstKeyFun, NextKeyFun) -&gt; dyn_lookup_next(T, FirstKeyFun(T), NextKeyFun).
<a name="4998"/> 4998: 
<a name="dyn_lookup_next-3"/><a name="4999"/> 4999: <b>dyn_lookup_next</b>(_T, '$end_of_table', _NextKeyFun) -&gt; [];
<a name="5000"/> 5000: <b>dyn_lookup_next</b>(T, K, NextKeyFun) -&gt;
<a name="5001"/> 5001:     NextKey = NextKeyFun(T,K),
<a name="dyn_lookup_next-last_expr"/><a name="5002"/> 5002: <b>    case NextKeyFun</b>(T,K) of
<a name="5003"/> 5003: 	NextKey -&gt;
<a name="5004"/> 5004: 	    dyn_lookup_next(T, NextKey, NextKeyFun);
<a name="5005"/> 5005: 	NK -&gt;
<a name="5006"/> 5006: 	    io:fwrite(&quot;hmmm... ~p =/= ~p~n&quot;, [NextKey,NK]),
<a name="5007"/> 5007: 	    exit(failed)
<a name="5008"/> 5008:     end.
<a name="5009"/> 5009: 
<a name="5010"/> 5010: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="5011"/> 5011: 
<a name="slot-1"/><a name="5012"/> 5012: <b>slot</b>(Config) when is_list(Config) -&gt;
<a name="slot-last_expr"/><a name="5013"/> 5013: <b>    repeat_for_opts_all_set_table_types</b>(fun slot_do/1).
<a name="5014"/> 5014: 
<a name="slot_do-1"/><a name="5015"/> 5015: <b>slot_do</b>(Opts) -&gt;
<a name="5016"/> 5016:     EtsMem = etsmem(),
<a name="5017"/> 5017:     Tab = ets_new(foo,Opts),
<a name="5018"/> 5018:     fill_tab(Tab,foo),
<a name="5019"/> 5019:     Elts = ets:info(Tab,size),
<a name="5020"/> 5020:     Elts = slot_loop(Tab,0,0),
<a name="5021"/> 5021:     case ets:info(Tab, type) of
<a name="5022"/> 5022:         ordered_set -&gt;
<a name="5023"/> 5023:             '$end_of_table' = ets:slot(Tab,Elts);
<a name="5024"/> 5024:         _ -&gt; ok
<a name="5025"/> 5025:     end,
<a name="5026"/> 5026:     true = ets:delete(Tab),
<a name="slot_do-last_expr"/><a name="5027"/> 5027: <b>    verify_etsmem</b>(EtsMem).
<a name="5028"/> 5028: 
<a name="slot_loop-3"/><a name="5029"/> 5029: <b>slot_loop</b>(Tab,SlotNo,EltsSoFar) -&gt;
<a name="slot_loop-last_expr"/><a name="5030"/> 5030: <b>    case ets:slot</b>(Tab,SlotNo) of
<a name="5031"/> 5031: 	'$end_of_table' -&gt;
<a name="5032"/> 5032: 	    {'EXIT',{badarg,_}} =
<a name="5033"/> 5033: 		(catch ets:slot(Tab,SlotNo+1)),
<a name="5034"/> 5034: 	    EltsSoFar;
<a name="5035"/> 5035: 	Elts -&gt;
<a name="5036"/> 5036: 	    slot_loop(Tab,SlotNo+1,EltsSoFar+length(Elts))
<a name="5037"/> 5037:     end.
<a name="5038"/> 5038: 
<a name="5039"/> 5039: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="5040"/> 5040: 
<a name="hash_clash-1"/><a name="5041"/> 5041: <b>hash_clash</b>(Config) when is_list(Config) -&gt;
<a name="5042"/> 5042:     %% ensure that erlang:phash2 and ets:slot use different hash seed
<a name="5043"/> 5043:     Tab = ets:new(tab, [set]),
<a name="5044"/> 5044:     Buckets = erlang:element(1, ets:info(Tab, stats)),
<a name="5045"/> 5045:     Phash = erlang:phash2(&lt;&lt;&quot;123&quot;&gt;&gt;, Buckets),
<a name="5046"/> 5046:     true = ets:insert(Tab, {&lt;&lt;&quot;123&quot;&gt;&gt;, &quot;extra&quot;}),
<a name="hash_clash-last_expr"/><a name="5047"/> 5047: <b>    [] = ets:slot</b>(Tab, Phash).
<a name="5048"/> 5048: 
<a name="5049"/> 5049: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="5050"/> 5050: 
<a name="5051"/> 5051: 
<a name="match1-1"/><a name="5052"/> 5052: <b>match1</b>(Config) when is_list(Config) -&gt;
<a name="match1-last_expr"/><a name="5053"/> 5053: <b>    repeat_for_opts_all_set_table_types</b>(fun match1_do/1).
<a name="5054"/> 5054: 
<a name="match1_do-1"/><a name="5055"/> 5055: <b>match1_do</b>(Opts) -&gt;
<a name="5056"/> 5056:     EtsMem = etsmem(),
<a name="5057"/> 5057:     Tab = ets_new(foo,Opts),
<a name="5058"/> 5058:     fill_tab(Tab,foo),
<a name="5059"/> 5059:     [] = ets:match(Tab,{}),
<a name="5060"/> 5060:     ets:insert(Tab,{{one,4},4}),
<a name="5061"/> 5061:     ets:insert(Tab,{{one,5},5}),
<a name="5062"/> 5062:     ets:insert(Tab,{{two,4},4}),
<a name="5063"/> 5063:     ets:insert(Tab,{{two,5},6}),
<a name="5064"/> 5064:     case ets:match(Tab,{{one,'_'},'$0'}) of
<a name="5065"/> 5065: 	[[4],[5]] -&gt; ok;
<a name="5066"/> 5066: 	[[5],[4]] -&gt; ok
<a name="5067"/> 5067:     end,
<a name="5068"/> 5068:     case ets:match(Tab,{{two,'$1'},'$0'}) of
<a name="5069"/> 5069: 	[[4,4],[6,5]] -&gt; ok;
<a name="5070"/> 5070: 	[[6,5],[4,4]] -&gt; ok
<a name="5071"/> 5071:     end,
<a name="5072"/> 5072:     case ets:match(Tab,{{two,'$9'},'$4'}) of
<a name="5073"/> 5073: 	[[4,4],[6,5]] -&gt; ok;
<a name="5074"/> 5074: 	[[6,5],[4,4]] -&gt; ok
<a name="5075"/> 5075:     end,
<a name="5076"/> 5076:     case ets:match(Tab,{{two,'$9'},'$22'}) of
<a name="5077"/> 5077: 	[[4,4],[5,6]] -&gt; ok;
<a name="5078"/> 5078: 	[[5,6],[4,4]] -&gt; ok
<a name="5079"/> 5079:     end,
<a name="5080"/> 5080:     [[4]] = ets:match(Tab,{{two,'$0'},'$0'}),
<a name="5081"/> 5081:     Len = length(ets:match(Tab,'$0')),
<a name="5082"/> 5082:     Len = length(ets:match(Tab,'_')),
<a name="5083"/> 5083:     if Len &gt; 4 -&gt; ok end,
<a name="5084"/> 5084:     true = ets:delete(Tab),
<a name="match1_do-last_expr"/><a name="5085"/> 5085: <b>    verify_etsmem</b>(EtsMem).
<a name="5086"/> 5086: 
<a name="5087"/> 5087: <i>%% Test match with specified keypos bag table.</i>
<a name="match2-1"/><a name="5088"/> 5088: <b>match2</b>(Config) when is_list(Config) -&gt;
<a name="match2-last_expr"/><a name="5089"/> 5089: <b>    repeat_for_opts</b>(fun match2_do/1).
<a name="5090"/> 5090: 
<a name="match2_do-1"/><a name="5091"/> 5091: <b>match2_do</b>(Opts) -&gt;
<a name="5092"/> 5092:     EtsMem = etsmem(),
<a name="5093"/> 5093:     Tab = make_table(foobar,
<a name="5094"/> 5094: 		     [bag, named_table, {keypos, 2} | Opts],
<a name="5095"/> 5095: 		     [{value1, key1},
<a name="5096"/> 5096: 		      {value2_1, key2},
<a name="5097"/> 5097: 		      {value2_2, key2},
<a name="5098"/> 5098: 		      {value3_1, key3},
<a name="5099"/> 5099: 		      {value3_2, key3},
<a name="5100"/> 5100: 		      {value2_1, key2_wannabe}]),
<a name="5101"/> 5101:     case length(ets:match(Tab, '$1')) of
<a name="5102"/> 5102: 	6 -&gt; ok;
<a name="5103"/> 5103: 	_ -&gt; ct:fail(&quot;Length of matched list is wrong.&quot;)
<a name="5104"/> 5104:     end,
<a name="5105"/> 5105:     [[value3_1],[value3_2]] = ets:match(Tab, {'$1', key3}),
<a name="5106"/> 5106:     [[key1]] = ets:match(Tab, {value1, '$1'}),
<a name="5107"/> 5107:     [[key2_wannabe],[key2]] = ets:match(Tab, {value2_1, '$2'}),
<a name="5108"/> 5108:     [] = ets:match(Tab,{'$1',nosuchkey}),
<a name="5109"/> 5109:     [] = ets:match(Tab,{'$1',kgY2}), % same hash as key2
<a name="5110"/> 5110:     [] = ets:match(Tab,{nosuchvalue,'$1'}),
<a name="5111"/> 5111:     true = ets:delete(Tab),
<a name="match2_do-last_expr"/><a name="5112"/> 5112: <b>    verify_etsmem</b>(EtsMem).
<a name="5113"/> 5113: 
<a name="5114"/> 5114: <i>%% Some ets:match_object tests.</i>
<a name="match_object-1"/><a name="5115"/> 5115: <b>match_object</b>(Config) when is_list(Config) -&gt;
<a name="match_object-last_expr"/><a name="5116"/> 5116: <b>    repeat_for_opts_all_set_table_types</b>(fun match_object_do/1).
<a name="5117"/> 5117: 
<a name="match_object_do-1"/><a name="5118"/> 5118: <b>match_object_do</b>(Opts) -&gt;
<a name="5119"/> 5119:     EtsMem = etsmem(),
<a name="5120"/> 5120:     Tab = ets_new(foobar, Opts),
<a name="5121"/> 5121:     fill_tab(Tab, foo),
<a name="5122"/> 5122:     ets:insert(Tab,{{one,4},4}),
<a name="5123"/> 5123:     ets:insert(Tab,{{one,5},5}),
<a name="5124"/> 5124:     ets:insert(Tab,{{two,4},4}),
<a name="5125"/> 5125:     ets:insert(Tab,{{two,5},6}),
<a name="5126"/> 5126:     ets:insert(Tab, {#{camembert=&gt;cabcou},7}),
<a name="5127"/> 5127:     ets:insert(Tab, {#{&quot;hi&quot;=&gt;&quot;hello&quot;,&quot;wazzup&quot;=&gt;&quot;awesome&quot;,&quot;1337&quot;=&gt;&quot;42&quot;},8}),
<a name="5128"/> 5128:     ets:insert(Tab, {#{&quot;hi&quot;=&gt;&quot;hello&quot;,#{&quot;wazzup&quot;=&gt;3}=&gt;&quot;awesome&quot;,&quot;1337&quot;=&gt;&quot;42&quot;},9}),
<a name="5129"/> 5129:     ets:insert(Tab, {#{&quot;hi&quot;=&gt;&quot;hello&quot;,&quot;wazzup&quot;=&gt;#{&quot;awesome&quot;=&gt;3},&quot;1337&quot;=&gt;&quot;42&quot;},10}),
<a name="5130"/> 5130:     Is = lists:seq(1,100),
<a name="5131"/> 5131:     M1 = maps:from_list([{I,I}||I &lt;- Is]),
<a name="5132"/> 5132:     M2 = maps:from_list([{I,&quot;hi&quot;}||I &lt;- Is]),
<a name="5133"/> 5133:     ets:insert(Tab, {M1,11}),
<a name="5134"/> 5134:     ets:insert(Tab, {M2,12}),
<a name="5135"/> 5135: 
<a name="5136"/> 5136:     case ets:match_object(Tab, {{one, '_'}, '$0'}) of
<a name="5137"/> 5137: 	[{{one,5},5},{{one,4},4}] -&gt; ok;
<a name="5138"/> 5138: 	[{{one,4},4},{{one,5},5}] -&gt; ok;
<a name="5139"/> 5139: 	_ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5140"/> 5140:     end,
<a name="5141"/> 5141:     case ets:match_object(Tab, {{two, '$1'}, '$0'}) of
<a name="5142"/> 5142: 	[{{two,5},6},{{two,4},4}] -&gt; ok;
<a name="5143"/> 5143: 	[{{two,4},4},{{two,5},6}] -&gt; ok;
<a name="5144"/> 5144: 	_ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5145"/> 5145:     end,
<a name="5146"/> 5146:     case ets:match_object(Tab, {{two, '$9'}, '$4'}) of
<a name="5147"/> 5147: 	[{{two,5},6},{{two,4},4}] -&gt; ok;
<a name="5148"/> 5148: 	[{{two,4},4},{{two,5},6}] -&gt; ok;
<a name="5149"/> 5149: 	_ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5150"/> 5150:     end,
<a name="5151"/> 5151:     case ets:match_object(Tab, {{two, '$9'}, '$22'}) of
<a name="5152"/> 5152: 	[{{two,5},6},{{two,4},4}] -&gt; ok;
<a name="5153"/> 5153: 	[{{two,4},4},{{two,5},6}] -&gt; ok;
<a name="5154"/> 5154: 	_ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5155"/> 5155:     end,
<a name="5156"/> 5156: 
<a name="5157"/> 5157:     %% Check that maps are inspected for variables.
<a name="5158"/> 5158:     [{#{camembert:=cabcou},7}] = ets:match_object(Tab, {#{camembert=&gt;'_'},7}),
<a name="5159"/> 5159: 
<a name="5160"/> 5160:     [{#{&quot;hi&quot;:=&quot;hello&quot;,#{&quot;wazzup&quot;=&gt;3}:=&quot;awesome&quot;,&quot;1337&quot;:=&quot;42&quot;},9}] =
<a name="5161"/> 5161:         ets:match_object(Tab, {#{#{&quot;wazzup&quot;=&gt;3}=&gt;&quot;awesome&quot;,&quot;hi&quot;=&gt;&quot;hello&quot;,&quot;1337&quot;=&gt;&quot;42&quot;},9}),
<a name="5162"/> 5162:     [{#{&quot;hi&quot;:=&quot;hello&quot;,#{&quot;wazzup&quot;=&gt;3}:=&quot;awesome&quot;,&quot;1337&quot;:=&quot;42&quot;},9}] =
<a name="5163"/> 5163:         ets:match_object(Tab, {#{#{&quot;wazzup&quot;=&gt;3}=&gt;&quot;awesome&quot;,&quot;hi&quot;=&gt;&quot;hello&quot;,&quot;1337&quot;=&gt;'_'},'_'}),
<a name="5164"/> 5164:     [{#{&quot;hi&quot;:=&quot;hello&quot;,&quot;wazzup&quot;:=#{&quot;awesome&quot;:=3},&quot;1337&quot;:=&quot;42&quot;},10}] =
<a name="5165"/> 5165:         ets:match_object(Tab, {#{&quot;wazzup&quot;=&gt;'_',&quot;hi&quot;=&gt;'_',&quot;1337&quot;=&gt;'_'},10}),
<a name="5166"/> 5166: 
<a name="5167"/> 5167:     %% multiple patterns
<a name="5168"/> 5168:     Pat = {{#{#{&quot;wazzup&quot;=&gt;3}=&gt;&quot;awesome&quot;,&quot;hi&quot;=&gt;&quot;hello&quot;,&quot;1337&quot;=&gt;'_'},'$1'},[{is_integer,'$1'}],['$_']},
<a name="5169"/> 5169:     [{#{&quot;hi&quot;:=&quot;hello&quot;,#{&quot;wazzup&quot;=&gt;3}:=&quot;awesome&quot;,&quot;1337&quot;:=&quot;42&quot;},9}] =
<a name="5170"/> 5170:         ets:select(Tab, [Pat,Pat,Pat,Pat]),
<a name="5171"/> 5171:     case ets:match_object(Tab, {#{&quot;hi&quot;=&gt;&quot;hello&quot;,&quot;wazzup&quot;=&gt;'_',&quot;1337&quot;=&gt;&quot;42&quot;},'_'}) of
<a name="5172"/> 5172:         [{#{&quot;1337&quot; := &quot;42&quot;,&quot;hi&quot; := &quot;hello&quot;,&quot;wazzup&quot; := &quot;awesome&quot;},8},
<a name="5173"/> 5173:          {#{&quot;1337&quot; := &quot;42&quot;,&quot;hi&quot; := &quot;hello&quot;,&quot;wazzup&quot; := #{&quot;awesome&quot; := 3}},10}] -&gt; ok;
<a name="5174"/> 5174:         [{#{&quot;1337&quot; := &quot;42&quot;,&quot;hi&quot; := &quot;hello&quot;,&quot;wazzup&quot; := #{&quot;awesome&quot; := 3}},10},
<a name="5175"/> 5175:          {#{&quot;1337&quot; := &quot;42&quot;,&quot;hi&quot; := &quot;hello&quot;,&quot;wazzup&quot; := &quot;awesome&quot;},8}] -&gt; ok;
<a name="5176"/> 5176:         _ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5177"/> 5177:     end,
<a name="5178"/> 5178:     case ets:match_object(Tab, {#{&quot;hi&quot;=&gt;'_'},'_'}) of
<a name="5179"/> 5179:         [{#{&quot;1337&quot;:=&quot;42&quot;, &quot;hi&quot;:=&quot;hello&quot;},_},
<a name="5180"/> 5180:          {#{&quot;1337&quot;:=&quot;42&quot;, &quot;hi&quot;:=&quot;hello&quot;},_},
<a name="5181"/> 5181:          {#{&quot;1337&quot;:=&quot;42&quot;, &quot;hi&quot;:=&quot;hello&quot;},_}] -&gt; ok;
<a name="5182"/> 5182:         _ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5183"/> 5183:     end,
<a name="5184"/> 5184: 
<a name="5185"/> 5185:     %% match large maps
<a name="5186"/> 5186:     [{#{1:=1,2:=2,99:=99,100:=100},11}] = ets:match_object(Tab, {M1,11}),
<a name="5187"/> 5187:     [{#{1:=&quot;hi&quot;,2:=&quot;hi&quot;,99:=&quot;hi&quot;,100:=&quot;hi&quot;},12}] = ets:match_object(Tab, {M2,12}),
<a name="5188"/> 5188:     case ets:match_object(Tab, {#{1=&gt;'_',2=&gt;'_'},'_'}) of
<a name="5189"/> 5189:         %% only match a part of the map
<a name="5190"/> 5190:         [{#{1:=1,5:=5,99:=99,100:=100},11},{#{1:=&quot;hi&quot;,6:=&quot;hi&quot;,99:=&quot;hi&quot;},12}] -&gt; ok;
<a name="5191"/> 5191:         [{#{1:=&quot;hi&quot;,2:=&quot;hi&quot;,59:=&quot;hi&quot;},12},{#{1:=1,2:=2,39:=39,100:=100},11}] -&gt; ok;
<a name="5192"/> 5192:         _ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5193"/> 5193:     end,
<a name="5194"/> 5194:     case ets:match_object(Tab, {maps:from_list([{I,'_'}||I&lt;-Is]),'_'}) of
<a name="5195"/> 5195:         %% only match a part of the map
<a name="5196"/> 5196:         [{#{1:=1,5:=5,99:=99,100:=100},11},{#{1:=&quot;hi&quot;,6:=&quot;hi&quot;,99:=&quot;hi&quot;},12}] -&gt; ok;
<a name="5197"/> 5197:         [{#{1:=&quot;hi&quot;,2:=&quot;hi&quot;,59:=&quot;hi&quot;},12},{#{1:=1,2:=2,39:=39,100:=100},11}] -&gt; ok;
<a name="5198"/> 5198:         _ -&gt; ct:fail(&quot;ets:match_object() returned something funny.&quot;)
<a name="5199"/> 5199:     end,
<a name="5200"/> 5200:     {'EXIT',{badarg,_}} = (catch ets:match_object(Tab, {#{'$1'=&gt;'_'},7})),
<a name="5201"/> 5201:     Mve = maps:from_list([{list_to_atom([$$|integer_to_list(I)]),'_'}||I&lt;-Is]),
<a name="5202"/> 5202:     {'EXIT',{badarg,_}} = (catch ets:match_object(Tab, {Mve,11})),
<a name="5203"/> 5203: 
<a name="5204"/> 5204:     %% Check that unsuccessful match returns an empty list.
<a name="5205"/> 5205:     [] = ets:match_object(Tab, {{three,'$0'}, '$92'}),
<a name="5206"/> 5206:     %% Check that '$0' equals '_'.
<a name="5207"/> 5207:     Len = length(ets:match_object(Tab, '$0')),
<a name="5208"/> 5208:     Len = length(ets:match_object(Tab, '_')),
<a name="5209"/> 5209:     if Len &gt; 4 -&gt; ok end,
<a name="5210"/> 5210:     true = ets:delete(Tab),
<a name="match_object_do-last_expr"/><a name="5211"/> 5211: <b>    verify_etsmem</b>(EtsMem).
<a name="5212"/> 5212: 
<a name="5213"/> 5213: <i>%% Tests that db_match_object does not generate a `badarg' when</i>
<a name="5214"/> 5214: <i>%% resuming a search with no previous matches.</i>
<a name="match_object2-1"/><a name="5215"/> 5215: <b>match_object2</b>(Config) when is_list(Config) -&gt;
<a name="match_object2-last_expr"/><a name="5216"/> 5216: <b>    repeat_for_opts_all_table_types</b>(fun match_object2_do/1).
<a name="5217"/> 5217: 
<a name="match_object2_do-1"/><a name="5218"/> 5218: <b>match_object2_do</b>(Opts) -&gt;
<a name="5219"/> 5219:     EtsMem = etsmem(),
<a name="5220"/> 5220:     KeyRange = 13005,
<a name="5221"/> 5221:     Tab = ets_new(foo, [{keypos, 2} | Opts], KeyRange),
<a name="5222"/> 5222:     fill_tab2(Tab, 0, KeyRange),     % match_db_object does 1000
<a name="5223"/> 5223: 						% elements per pass, might
<a name="5224"/> 5224: 						% change in the future.
<a name="5225"/> 5225:     [] = ets:match_object(Tab, {hej, '$1'}),
<a name="5226"/> 5226:     ets:delete(Tab),
<a name="match_object2_do-last_expr"/><a name="5227"/> 5227: <b>    verify_etsmem</b>(EtsMem).
<a name="5228"/> 5228: 
<a name="5229"/> 5229: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="5230"/> 5230: 
<a name="5231"/> 5231: 
<a name="5232"/> 5232: <i>%% OTP-3319. Test tab2list.</i>
<a name="tab2list-1"/><a name="5233"/> 5233: <b>tab2list</b>(Config) when is_list(Config) -&gt;
<a name="tab2list-last_expr"/><a name="5234"/> 5234: <b>    repeat_for_all_ord_set_table_types</b>(
<a name="5235"/> 5235:       fun(Opts) -&gt;
<a name="5236"/> 5236:               EtsMem = etsmem(),
<a name="5237"/> 5237:               Tab = make_table(foo,
<a name="5238"/> 5238:                                Opts,
<a name="5239"/> 5239:                                [{a,b}, {c,b}, {b,b}, {a,c}]),
<a name="5240"/> 5240:               [{a,c},{b,b},{c,b}] = ets:tab2list(Tab),
<a name="5241"/> 5241:               true = ets:delete(Tab),
<a name="5242"/> 5242:               verify_etsmem(EtsMem)
<a name="5243"/> 5243:       end).
<a name="5244"/> 5244: 
<a name="5245"/> 5245: <i>%% Simple general small test.  If this fails, ets is in really bad</i>
<a name="5246"/> 5246: <i>%% shape.</i>
<a name="misc1-1"/><a name="5247"/> 5247: <b>misc1</b>(Config) when is_list(Config) -&gt;
<a name="misc1-last_expr"/><a name="5248"/> 5248: <b>    repeat_for_opts_all_table_types</b>(fun misc1_do/1).
<a name="5249"/> 5249: 
<a name="misc1_do-1"/><a name="5250"/> 5250: <b>misc1_do</b>(Opts) -&gt;
<a name="5251"/> 5251:     EtsMem = etsmem(),
<a name="5252"/> 5252:     Tab = ets_new(foo,Opts),
<a name="5253"/> 5253:     true = lists:member(Tab,ets:all()),
<a name="5254"/> 5254:     ets:delete(Tab),
<a name="5255"/> 5255:     false = lists:member(Tab,ets:all()),
<a name="5256"/> 5256:     case catch ets:delete(Tab) of
<a name="5257"/> 5257: 	{'EXIT',_Reason} -&gt;
<a name="5258"/> 5258: 	    verify_etsmem(EtsMem);
<a name="5259"/> 5259: 	true -&gt;
<a name="5260"/> 5260: 	    ct:fail(&quot;Delete of nonexisting table returned `true'.&quot;)
<a name="5261"/> 5261:     end,
<a name="misc1_do-last_expr"/><a name="5262"/> 5262:     ok.
<a name="5263"/> 5263: 
<a name="5264"/> 5264: <i>%% Check the safe_fixtable function.</i>
<a name="safe_fixtable-1"/><a name="5265"/> 5265: <b>safe_fixtable</b>(Config) when is_list(Config) -&gt;
<a name="safe_fixtable-last_expr"/><a name="5266"/> 5266: <b>    repeat_for_opts_all_table_types</b>(fun safe_fixtable_do/1).
<a name="5267"/> 5267: 
<a name="safe_fixtable_do-1"/><a name="5268"/> 5268: <b>safe_fixtable_do</b>(Opts) -&gt;
<a name="5269"/> 5269:     EtsMem = etsmem(),
<a name="5270"/> 5270:     Tab = ets_new(foo, Opts),
<a name="5271"/> 5271:     fill_tab(Tab, foobar),
<a name="5272"/> 5272:     true = ets:safe_fixtable(Tab, true),
<a name="5273"/> 5273:     receive after 1 -&gt; ok end,
<a name="5274"/> 5274:     true = ets:safe_fixtable(Tab, false),
<a name="5275"/> 5275:     false = ets:info(Tab,safe_fixed_monotonic_time),
<a name="5276"/> 5276:     false = ets:info(Tab,safe_fixed),
<a name="5277"/> 5277:     SysBefore = erlang:timestamp(),
<a name="5278"/> 5278:     MonBefore = erlang:monotonic_time(),
<a name="5279"/> 5279:     true = ets:safe_fixtable(Tab, true),
<a name="5280"/> 5280:     MonAfter = erlang:monotonic_time(),
<a name="5281"/> 5281:     SysAfter = erlang:timestamp(),
<a name="5282"/> 5282:     Self = self(),
<a name="5283"/> 5283:     {FixMonTime,[{Self,1}]} = ets:info(Tab,safe_fixed_monotonic_time),
<a name="5284"/> 5284:     {FixSysTime,[{Self,1}]} = ets:info(Tab,safe_fixed),
<a name="5285"/> 5285:     true = is_integer(FixMonTime),
<a name="5286"/> 5286:     true = MonBefore =&lt; FixMonTime,
<a name="5287"/> 5287:     true = FixMonTime =&lt; MonAfter,
<a name="5288"/> 5288:     {FstMs,FstS,FstUs} = FixSysTime,
<a name="5289"/> 5289:     true = is_integer(FstMs),
<a name="5290"/> 5290:     true = is_integer(FstS),
<a name="5291"/> 5291:     true = is_integer(FstUs),
<a name="5292"/> 5292:     case erlang:system_info(time_warp_mode) of
<a name="5293"/> 5293: 	no_time_warp -&gt;
<a name="5294"/> 5294: 	    true = timer:now_diff(FixSysTime, SysBefore) &gt;= 0,
<a name="5295"/> 5295: 	    true = timer:now_diff(SysAfter, FixSysTime) &gt;= 0;
<a name="5296"/> 5296: 	_ -&gt;
<a name="5297"/> 5297: 	    %% ets:info(Tab,safe_fixed) not timewarp safe...
<a name="5298"/> 5298: 	    ignore
<a name="5299"/> 5299:     end,
<a name="5300"/> 5300:     %% Test that an unjustified 'unfix' is a no-op.
<a name="5301"/> 5301:     {Pid,MRef} = my_spawn_monitor(fun() -&gt; true = ets:safe_fixtable(Tab,false) end),
<a name="5302"/> 5302:     {'DOWN', MRef, process, Pid, normal} = receive M -&gt; M end,
<a name="5303"/> 5303:     true = ets:info(Tab,fixed),
<a name="5304"/> 5304:     {FixMonTime,[{Self,1}]} = ets:info(Tab,safe_fixed_monotonic_time),
<a name="5305"/> 5305:     {FixSysTime,[{Self,1}]} = ets:info(Tab,safe_fixed),
<a name="5306"/> 5306:     %% badarg's
<a name="5307"/> 5307:     {'EXIT', {badarg, _}} = (catch ets:safe_fixtable(Tab, foobar)),
<a name="5308"/> 5308:     true = ets:info(Tab,fixed),
<a name="5309"/> 5309:     true = ets:safe_fixtable(Tab, false),
<a name="5310"/> 5310:     false = ets:info(Tab,fixed),
<a name="5311"/> 5311:     {'EXIT', {badarg, _}} = (catch ets:safe_fixtable(Tab, foobar)),
<a name="5312"/> 5312:     false = ets:info(Tab,fixed),
<a name="5313"/> 5313:     ets:delete(Tab),
<a name="5314"/> 5314:     case catch ets:safe_fixtable(Tab, true) of
<a name="5315"/> 5315: 	{'EXIT', _Reason} -&gt;
<a name="5316"/> 5316: 	    verify_etsmem(EtsMem);
<a name="5317"/> 5317: 	_ -&gt;
<a name="5318"/> 5318: 	    ct:fail(&quot;Fixtable on nonexisting table returned `true'&quot;)
<a name="5319"/> 5319:     end,
<a name="safe_fixtable_do-last_expr"/><a name="5320"/> 5320:     ok.
<a name="5321"/> 5321: 
<a name="5322"/> 5322: <b>-define</b>(ets_info(Tab,Item,SlavePid), ets_info(Tab, Item, SlavePid, ?LINE)).
<a name="5323"/> 5323: 
<a name="5324"/> 5324: <i>%% Tests ets:info result for required tuples.</i>
<a name="info-1"/><a name="5325"/> 5325: <b>info</b>(Config) when is_list(Config) -&gt;
<a name="5326"/> 5326:     repeat_for_opts(fun info_do/1,
<a name="5327"/> 5327:                     [[void, set, bag, duplicate_bag, ordered_set],
<a name="5328"/> 5328:                      [void, private, protected, public],
<a name="5329"/> 5329:                      write_concurrency, read_concurrency, compressed]),
<a name="5330"/> 5330: 
<a name="5331"/> 5331:     undefined = ets:info(non_existing_table_xxyy),
<a name="5332"/> 5332:     undefined = ets:info(non_existing_table_xxyy,type),
<a name="5333"/> 5333:     undefined = ets:info(non_existing_table_xxyy,node),
<a name="5334"/> 5334:     undefined = ets:info(non_existing_table_xxyy,named_table),
<a name="5335"/> 5335:     undefined = ets:info(non_existing_table_xxyy,safe_fixed_monotonic_time),
<a name="5336"/> 5336:     undefined = ets:info(non_existing_table_xxyy,safe_fixed),
<a name="5337"/> 5337: 
<a name="5338"/> 5338:     {'EXIT',{badarg,_}} = (catch ets:info(42)),
<a name="5339"/> 5339:     {'EXIT',{badarg,_}} = (catch ets:info(42, type)),
<a name="5340"/> 5340:     {'EXIT',{badarg,_}} = (catch ets:info(make_ref())),
<a name="5341"/> 5341:     {'EXIT',{badarg,_}} = (catch ets:info(make_ref(), type)),
<a name="5342"/> 5342: 
<a name="5343"/> 5343:     case erlang:system_info(schedulers) of
<a name="5344"/> 5344:         1 -&gt; %% Fine grained locking is not activated when there is only one scheduler
<a name="5345"/> 5345:             lists:foreach(
<a name="5346"/> 5346:               fun(Type) -&gt;
<a name="5347"/> 5347:                       T1 = ets:new(t1, [public, Type, {write_concurrency, auto}]),
<a name="5348"/> 5348:                       false = ets:info(T1, write_concurrency),
<a name="5349"/> 5349:                       T2 = ets:new(t2, [public, Type, {write_concurrency, true}]),
<a name="5350"/> 5350:                       false = ets:info(T2, write_concurrency)
<a name="5351"/> 5351:               end,
<a name="5352"/> 5352:               [set, bag, duplicate_bag, ordered_set]),
<a name="5353"/> 5353:             T2 = ets:new(t2, [public, {write_concurrency, {debug_hash_fixed_number_of_locks, 2049}}]),
<a name="5354"/> 5354:             false = ets:info(T2, write_concurrency);
<a name="5355"/> 5355:         _ -&gt;
<a name="5356"/> 5356:             %% Test that one can set the synchronization granularity level for
<a name="5357"/> 5357:             %% tables of type set
<a name="5358"/> 5358:             T1 = ets:new(t1, [public, {write_concurrency, {debug_hash_fixed_number_of_locks, 1024}}]),
<a name="5359"/> 5359:             {debug_hash_fixed_number_of_locks, 1024} = ets:info(T1, write_concurrency),
<a name="5360"/> 5360:             T2 = ets:new(t2, [public, {write_concurrency, {debug_hash_fixed_number_of_locks, 2048}}]),
<a name="5361"/> 5361:             {debug_hash_fixed_number_of_locks, 2048} = ets:info(T2, write_concurrency),
<a name="5362"/> 5362:             T3 = ets:new(t3, [public, {write_concurrency, {debug_hash_fixed_number_of_locks, 1024}}, {write_concurrency, true}]),
<a name="5363"/> 5363:             true = ets:info(T3, write_concurrency),
<a name="5364"/> 5364:             T4 = ets:new(t4, [private, {write_concurrency, {debug_hash_fixed_number_of_locks, 1024}}]),
<a name="5365"/> 5365:             false = ets:info(T4, write_concurrency),
<a name="5366"/> 5366:             %% Test the auto option
<a name="5367"/> 5367:             lists:foreach(
<a name="5368"/> 5368:               fun(Type) -&gt;
<a name="5369"/> 5369:                       T5 = ets:new(t5, [public, Type, {write_concurrency, auto}]),
<a name="5370"/> 5370:                       auto = ets:info(T5, write_concurrency)
<a name="5371"/> 5371:               end,
<a name="5372"/> 5372:               [set, bag, duplicate_bag, ordered_set]),
<a name="5373"/> 5373:             T6 = ets:new(t6, [private, {write_concurrency, true}]),
<a name="5374"/> 5374:             false = ets:info(T6, write_concurrency),
<a name="5375"/> 5375:             T7 = ets:new(t7, [private, {write_concurrency, auto}]),
<a name="5376"/> 5376:             false = ets:info(T7, write_concurrency),
<a name="5377"/> 5377:             %% Test that the number of locks is rounded down to the nearest power of two
<a name="5378"/> 5378:             T8 = ets:new(t8, [public, {write_concurrency, {debug_hash_fixed_number_of_locks, 2049}}]),
<a name="5379"/> 5379:             {debug_hash_fixed_number_of_locks, 2048} = ets:info(T8, write_concurrency)
<a name="5380"/> 5380:     end,
<a name="info-last_expr"/><a name="5381"/> 5381:     ok.
<a name="5382"/> 5382: 
<a name="info_do-1"/><a name="5383"/> 5383: <b>info_do</b>(Opts) -&gt;
<a name="5384"/> 5384:     EtsMem = etsmem(),
<a name="5385"/> 5385:     TableType = lists:foldl(
<a name="5386"/> 5386:                   fun(Item, Curr) -&gt;
<a name="5387"/> 5387:                           case Item of
<a name="5388"/> 5388:                               set -&gt; set;
<a name="5389"/> 5389:                               ordered_set -&gt; ordered_set;
<a name="5390"/> 5390:                               cat_ord_set -&gt; ordered_set;
<a name="5391"/> 5391:                               stim_cat_ord_set -&gt; ordered_set;
<a name="5392"/> 5392:                               bag -&gt; bag;
<a name="5393"/> 5393:                               duplicate_bag -&gt; duplicate_bag;
<a name="5394"/> 5394:                               _ -&gt; Curr
<a name="5395"/> 5395:                           end
<a name="5396"/> 5396:                   end, set, Opts),
<a name="5397"/> 5397:     PublicOrCurr =
<a name="5398"/> 5398:         fun(Curr) -&gt;
<a name="5399"/> 5399:                 case lists:member({write_concurrency, false}, Opts) or
<a name="5400"/> 5400:                     lists:member(private, Opts) or
<a name="5401"/> 5401:                     lists:member(protected, Opts) of
<a name="5402"/> 5402:                     true -&gt; Curr;
<a name="5403"/> 5403:                     false -&gt; public
<a name="5404"/> 5404:                 end
<a name="5405"/> 5405:         end,
<a name="5406"/> 5406:     Protection = lists:foldl(
<a name="5407"/> 5407:                    fun(Item, Curr) -&gt;
<a name="5408"/> 5408:                            case Item of
<a name="5409"/> 5409:                                public -&gt; public;
<a name="5410"/> 5410:                                protected -&gt; protected;
<a name="5411"/> 5411:                                private -&gt; private;
<a name="5412"/> 5412:                                cat_ord_set -&gt; PublicOrCurr(Curr); %% Special items
<a name="5413"/> 5413:                                stim_cat_ord_set -&gt; PublicOrCurr(Curr);
<a name="5414"/> 5414:                                _ -&gt; Curr
<a name="5415"/> 5415:                            end
<a name="5416"/> 5416:                    end, protected, Opts),
<a name="5417"/> 5417:     MeMyselfI=self(),
<a name="5418"/> 5418:     ThisNode=node(),
<a name="5419"/> 5419:     Tab = ets_new(foobar, [{keypos, 2} | Opts]),
<a name="5420"/> 5420: 
<a name="5421"/> 5421:     %% Start slave to also do ets:info from a process not owning the table.
<a name="5422"/> 5422:     SlavePid = spawn_link(fun Slave() -&gt;
<a name="5423"/> 5423:                                   receive
<a name="5424"/> 5424:                                       {Master, Item} -&gt;
<a name="5425"/> 5425:                                           Master ! {self(), Item, ets:info(Tab, Item)}
<a name="5426"/> 5426:                                   end,
<a name="5427"/> 5427:                                   Slave()
<a name="5428"/> 5428:                           end),
<a name="5429"/> 5429: 
<a name="5430"/> 5430:     %% Note: ets:info/1 used to return a tuple, but from R11B onwards it
<a name="5431"/> 5431:     %% returns a list.
<a name="5432"/> 5432:     Res = ets:info(Tab),
<a name="5433"/> 5433:     {value, {memory, _Mem}} = lists:keysearch(memory, 1, Res),
<a name="5434"/> 5434:     {value, {owner, MeMyselfI}} = lists:keysearch(owner, 1, Res),
<a name="5435"/> 5435:     {value, {name, foobar}} = lists:keysearch(name, 1, Res),
<a name="5436"/> 5436:     {value, {size, 0}} = lists:keysearch(size, 1, Res),
<a name="5437"/> 5437:     {value, {node, ThisNode}} = lists:keysearch(node, 1, Res),
<a name="5438"/> 5438:     {value, {named_table, false}} = lists:keysearch(named_table, 1, Res),
<a name="5439"/> 5439:     {value, {type, TableType}} = lists:keysearch(type, 1, Res),
<a name="5440"/> 5440:     {value, {keypos, 2}} = lists:keysearch(keypos, 1, Res),
<a name="5441"/> 5441:     {value, {protection, Protection}} =
<a name="5442"/> 5442: 	lists:keysearch(protection, 1, Res),
<a name="5443"/> 5443:     {value, {id, Tab}} = lists:keysearch(id, 1, Res),
<a name="5444"/> 5444:     {value, {decentralized_counters, _DecentralizedCtrs}} =
<a name="5445"/> 5445:         lists:keysearch(decentralized_counters, 1, Res),
<a name="5446"/> 5446:     %% Test 'binary'
<a name="5447"/> 5447:     [] = ?ets_info(Tab, binary, SlavePid),
<a name="5448"/> 5448:     BinSz = 100,
<a name="5449"/> 5449:     RefcBin = list_to_binary(lists:seq(1,BinSz)),
<a name="5450"/> 5450:     ets:insert(Tab, {RefcBin,key}),
<a name="5451"/> 5451:     [{BinPtr,BinSz,2}] = ?ets_info(Tab,binary, SlavePid),
<a name="5452"/> 5452:     ets:insert(Tab, {RefcBin,key2}),
<a name="5453"/> 5453:     [{BinPtr,BinSz,3}, {BinPtr,BinSz,3}] = ?ets_info(Tab,binary,SlavePid),
<a name="5454"/> 5454:     ets:delete(Tab, key),
<a name="5455"/> 5455:     [{BinPtr,BinSz,2}] = ?ets_info(Tab,binary, SlavePid),
<a name="5456"/> 5456:     case TableType of
<a name="5457"/> 5457:         ordered_set -&gt;
<a name="5458"/> 5458:             ets:delete(Tab, key2);
<a name="5459"/> 5459:         _ -&gt;
<a name="5460"/> 5460:             ets:safe_fixtable(Tab, true),
<a name="5461"/> 5461:             ets:delete(Tab, key2),
<a name="5462"/> 5462:             [{BinPtr,BinSz,2}] = ?ets_info(Tab,binary, SlavePid),
<a name="5463"/> 5463:             ets:safe_fixtable(Tab, false)
<a name="5464"/> 5464:     end,
<a name="5465"/> 5465:     [] = ?ets_info(Tab,binary, SlavePid),
<a name="5466"/> 5466:     RefcBin = id(RefcBin), % keep alive
<a name="5467"/> 5467: 
<a name="5468"/> 5468:     unlink(SlavePid),
<a name="5469"/> 5469:     exit(SlavePid,kill),
<a name="5470"/> 5470:     true = ets:delete(Tab),
<a name="info_do-last_expr"/><a name="5471"/> 5471: <b>    verify_etsmem</b>(EtsMem).
<a name="5472"/> 5472: 
<a name="ets_info-4"/><a name="5473"/> 5473: <b>ets_info</b>(Tab, Item, SlavePid, _Line) -&gt;
<a name="5474"/> 5474:     R = ets:info(Tab, Item),
<a name="5475"/> 5475:     %%io:format(&quot;~p: ets:info(~p) -&gt; ~p\n&quot;, [_Line, Item, R]),
<a name="5476"/> 5476:     SlavePid ! {self(), Item},
<a name="5477"/> 5477:     {SlavePid, Item, R} = receive M -&gt; M end,
<a name="ets_info-last_expr"/><a name="5478"/> 5478:     R.
<a name="5479"/> 5479: 
<a name="5480"/> 5480: 
<a name="5481"/> 5481: 
<a name="info_binary_stress-1"/><a name="5482"/> 5482: <b>info_binary_stress</b>(_Config) -&gt;
<a name="info_binary_stress-last_expr"/><a name="5483"/> 5483: <b>    repeat_for_opts</b>(fun info_binary_stress_do/1,
<a name="5484"/> 5484:                     [[set,bag,duplicate_bag,ordered_set],
<a name="5485"/> 5485:                      compressed]).
<a name="5486"/> 5486: 
<a name="info_binary_stress_do-1"/><a name="5487"/> 5487: <b>info_binary_stress_do</b>(Opts) -&gt;
<a name="5488"/> 5488:     Tab = ets_new(info_binary_stress, [public, {write_concurrency,true} | Opts]),
<a name="5489"/> 5489: 
<a name="5490"/> 5490:     KeyRange = 1000,
<a name="5491"/> 5491:     ValueRange = 3,
<a name="5492"/> 5492:     RefcBin = list_to_binary(lists:seq(1,100)),
<a name="5493"/> 5493:     InitF = fun (_) -&gt; #{insert =&gt; 0, delete =&gt; 0, delete_object =&gt; 0}
<a name="5494"/> 5494:             end,
<a name="5495"/> 5495:     ExecF = fun (Counters) -&gt;
<a name="5496"/> 5496:                     Key = rand:uniform(KeyRange),
<a name="5497"/> 5497:                     Value = rand:uniform(ValueRange),
<a name="5498"/> 5498:                     Op = element(rand:uniform(4),{insert,insert,delete,delete_object}),
<a name="5499"/> 5499:                     case Op of
<a name="5500"/> 5500:                         insert -&gt;
<a name="5501"/> 5501:                             ets:insert(Tab, {Key,Value,RefcBin});
<a name="5502"/> 5502:                         delete -&gt;
<a name="5503"/> 5503:                             ets:delete(Tab, Key);
<a name="5504"/> 5504:                         delete_object -&gt;
<a name="5505"/> 5505:                             ets:delete_object(Tab, {Key,Value,RefcBin})
<a name="5506"/> 5506:                     end,
<a name="5507"/> 5507:                     Acc = incr_counter(Op, Counters),
<a name="5508"/> 5508: 
<a name="5509"/> 5509:                     receive stop -&gt;
<a name="5510"/> 5510:                                 [end_of_work | Acc]
<a name="5511"/> 5511:                     after 0 -&gt;
<a name="5512"/> 5512:                             Acc
<a name="5513"/> 5513:                     end
<a name="5514"/> 5514:             end,
<a name="5515"/> 5515:     FiniF = fun (Acc) -&gt; Acc end,
<a name="5516"/> 5516:     Pids = run_sched_workers(InitF, ExecF, FiniF, infinite),
<a name="5517"/> 5517:     timer:send_after(500, stop),
<a name="5518"/> 5518: 
<a name="5519"/> 5519:     Rounds = fun Loop(N, Fix) -&gt;
<a name="5520"/> 5520:                      ets:info(Tab, binary),
<a name="5521"/> 5521:                      ets:safe_fixtable(Tab, Fix),
<a name="5522"/> 5522:                      receive
<a name="5523"/> 5523:                          stop -&gt;
<a name="5524"/> 5524:                              ets:safe_fixtable(Tab, false),
<a name="5525"/> 5525:                              false = ets:info(Tab, fixed),
<a name="5526"/> 5526:                              N
<a name="5527"/> 5527:                      after 0 -&gt;
<a name="5528"/> 5528:                              Loop(N+1, not Fix)
<a name="5529"/> 5529:                      end
<a name="5530"/> 5530:              end (1, true),
<a name="5531"/> 5531:     [P ! stop || P &lt;- Pids],
<a name="5532"/> 5532:     Results = wait_pids(Pids),
<a name="5533"/> 5533:     Size = ets:info(Tab,size),
<a name="5534"/> 5534:     io:format(&quot;Ops = ~p\n&quot;, [maps_sum(Results)]),
<a name="5535"/> 5535:     io:format(&quot;Size = ~p\n&quot;, [Size]),
<a name="5536"/> 5536:     io:format(&quot;Stats = ~p\n&quot;, [ets:info(Tab,stats)]),
<a name="5537"/> 5537:     io:format(&quot;Rounds = ~p\n&quot;, [Rounds]),
<a name="5538"/> 5538:     Size = length(ets:info(Tab, binary)),
<a name="5539"/> 5539: 
<a name="5540"/> 5540:     ets:delete_all_objects(Tab),
<a name="5541"/> 5541:     [] = ets:info(Tab, binary),
<a name="5542"/> 5542:     true = ets:delete(Tab),
<a name="info_binary_stress_do-last_expr"/><a name="5543"/> 5543:     ok.
<a name="5544"/> 5544: 
<a name="5545"/> 5545: 
<a name="size_loop-4"/><a name="5546"/> 5546: <b>size_loop</b>(_T, 0, _, _) -&gt;
<a name="5547"/> 5547:     ok;
<a name="5548"/> 5548: <b>size_loop</b>(T, I, PrevSize, WhatToTest) -&gt;
<a name="5549"/> 5549:     Size = ets:info(T, WhatToTest),
<a name="5550"/> 5550:     case Size &lt; PrevSize of
<a name="5551"/> 5551:         true -&gt;
<a name="5552"/> 5552:             io:format(&quot;Bad ets:info/2 (got ~p expected &gt;=~p)&quot;,
<a name="5553"/> 5553:                       [Size, PrevSize]),
<a name="5554"/> 5554:             ct:fail(&quot;Bad ets:info/2)&quot;);
<a name="5555"/> 5555:         _ -&gt; ok
<a name="5556"/> 5556:     end,
<a name="size_loop-last_expr"/><a name="5557"/> 5557: <b>    size_loop</b>(T, I -1, Size, WhatToTest).
<a name="5558"/> 5558: 
<a name="add_loop-2"/><a name="5559"/> 5559: <b>add_loop</b>(_T, 0) -&gt;
<a name="5560"/> 5560:     ok;
<a name="5561"/> 5561: <b>add_loop</b>(T, I) -&gt;
<a name="5562"/> 5562:     ets:insert(T, {I}),
<a name="add_loop-last_expr"/><a name="5563"/> 5563: <b>    add_loop</b>(T, I -1).
<a name="5564"/> 5564: 
<a name="5565"/> 5565: 
<a name="test_table_counter_concurrency-2"/><a name="5566"/> 5566: <b>test_table_counter_concurrency</b>(WhatToTest, TableOptions) -&gt;
<a name="5567"/> 5567:     IntStatePrevOn =
<a name="5568"/> 5568:         erts_debug:set_internal_state(available_internal_state, true),
<a name="5569"/> 5569:     ItemsToAdd = 1000000,
<a name="5570"/> 5570:     SizeLoopSize = 1000,
<a name="5571"/> 5571:     T = ets:new(k, TableOptions),
<a name="5572"/> 5572:     case lists:member(ordered_set, TableOptions) of
<a name="5573"/> 5573:         true -&gt;
<a name="5574"/> 5574:             erts_debug:set_internal_state(ets_debug_random_split_join, {T, false});
<a name="5575"/> 5575:         false -&gt; ok
<a name="5576"/> 5576:     end,
<a name="5577"/> 5577:     0 = ets:info(T, size),
<a name="5578"/> 5578:     P = self(),
<a name="5579"/> 5579:     SpawnedSizeProcs =
<a name="5580"/> 5580:         [spawn_link(fun() -&gt;
<a name="5581"/> 5581:                             size_loop(T, SizeLoopSize, 0, WhatToTest),
<a name="5582"/> 5582:                             P ! done
<a name="5583"/> 5583:                     end)
<a name="5584"/> 5584:          || _ &lt;- lists:seq(1, 6)],
<a name="5585"/> 5585:     spawn_link(fun() -&gt;
<a name="5586"/> 5586:                        add_loop(T, ItemsToAdd),
<a name="5587"/> 5587:                        P ! done_add
<a name="5588"/> 5588:                end),
<a name="5589"/> 5589:     [receive
<a name="5590"/> 5590:          done -&gt; ok;
<a name="5591"/> 5591:          done_add -&gt; ok
<a name="5592"/> 5592:      end
<a name="5593"/> 5593:      || _ &lt;- [ok|SpawnedSizeProcs]],
<a name="5594"/> 5594:     case WhatToTest =:= size of
<a name="5595"/> 5595:         true -&gt;
<a name="5596"/> 5596:             ItemsToAdd = ets:info(T, size);
<a name="5597"/> 5597:         _ -&gt;
<a name="5598"/> 5598:             ok
<a name="5599"/> 5599:     end,
<a name="5600"/> 5600:     erts_debug:set_internal_state(available_internal_state, IntStatePrevOn),
<a name="test_table_counter_concurrency-last_expr"/><a name="5601"/> 5601:     ok.
<a name="5602"/> 5602: 
<a name="5603"/> 5603: <i>%% ERIERL-855: Calling info or whereis on a table being busy trapping (insert)</i>
<a name="5604"/> 5604: <i>%% could return 'undefined'.</i>
<a name="info_whereis_busy-1"/><a name="5605"/> 5605: <b>info_whereis_busy</b>(Config) when is_list(Config) -&gt;
<a name="5606"/> 5606:     TName = info_whereis_busy,
<a name="5607"/> 5607:     TName = ets:new(TName, [named_table, public]),
<a name="5608"/> 5608:     T = ets:whereis(TName),
<a name="5609"/> 5609:     NKeys = 100_000,
<a name="5610"/> 5610:     Tuples = [{K} || K &lt;- lists:seq(1,NKeys)],
<a name="5611"/> 5611:     _Inserter = spawn_link(fun() -&gt;
<a name="5612"/> 5612:                                    ets:insert(TName, Tuples)
<a name="5613"/> 5613:                            end),
<a name="5614"/> 5614:     repeat_while(fun() -&gt;
<a name="5615"/> 5615:                          Info = ets:info(TName),
<a name="5616"/> 5616:                          false = (Info =:= undefined),
<a name="5617"/> 5617:                          T = ets:whereis(TName),
<a name="5618"/> 5618:                          case lists:keyfind(size, 1, Info) of
<a name="5619"/> 5619:                              {size, NKeys} -&gt;
<a name="5620"/> 5620:                                  false;
<a name="5621"/> 5621:                              {size, _} -&gt;
<a name="5622"/> 5622:                                  true
<a name="5623"/> 5623:                          end
<a name="5624"/> 5624:                  end),
<a name="5625"/> 5625:     ets:delete(T),
<a name="info_whereis_busy-last_expr"/><a name="5626"/> 5626:     ok.
<a name="5627"/> 5627: 
<a name="5628"/> 5628: <i>%% Delete table during trapping ets:insert</i>
<a name="insert_trap_delete-1"/><a name="5629"/> 5629: <b>insert_trap_delete</b>(Config) when is_list(Config) -&gt;
<a name="5630"/> 5630:     repeat_for_opts(fun(Opts) -&gt;
<a name="5631"/> 5631:                             [insert_trap_delete_run1({Opts,InsertFunc,Mode})
<a name="5632"/> 5632:                              || InsertFunc &lt;- [insert,insert_new],
<a name="5633"/> 5633:                                 Mode &lt;- [exit, delete]]
<a name="5634"/> 5634:                     end,
<a name="5635"/> 5635:                     [all_non_stim_types, write_concurrency, compressed]),
<a name="insert_trap_delete-last_expr"/><a name="5636"/> 5636:     ok.
<a name="5637"/> 5637: 
<a name="insert_trap_delete_run1-1"/><a name="5638"/> 5638: <b>insert_trap_delete_run1</b>(Params) -&gt;
<a name="5639"/> 5639:     NKeys = 50_000 + rand:uniform(50_000),
<a name="5640"/> 5640:     %% First measure how many traps the insert op will do
<a name="5641"/> 5641:     Traps0 = insert_trap_delete_run3(unlimited, Params, NKeys),
<a name="5642"/> 5642:     %% Then do again and delete table at different moments
<a name="5643"/> 5643:     Decr = (Traps0 div 5) + 1,
<a name="insert_trap_delete_run1-last_expr"/><a name="5644"/> 5644: <b>    insert_trap_delete_run2</b>(Traps0-1, Decr, Params, NKeys).
<a name="5645"/> 5645: 
<a name="insert_trap_delete_run2-4"/><a name="5646"/> 5646: <b>insert_trap_delete_run2</b>(Traps, _Decr, Params, NKeys) when Traps =&lt; 1 -&gt;
<a name="5647"/> 5647:     insert_trap_delete_run3(1, Params, NKeys),
<a name="5648"/> 5648:     ok;
<a name="5649"/> 5649: <b>insert_trap_delete_run2</b>(Traps, Decr, Params, NKeys) -&gt;
<a name="5650"/> 5650:     insert_trap_delete_run3(Traps, Params, NKeys),
<a name="insert_trap_delete_run2-last_expr"/><a name="5651"/> 5651: <b>    insert_trap_delete_run2</b>(Traps - Decr, Decr, Params, NKeys).
<a name="5652"/> 5652: 
<a name="insert_trap_delete_run3-3"/><a name="5653"/> 5653: <b>insert_trap_delete_run3</b>(Traps, {Opts, InsertFunc, Mode}, NKeys) -&gt;
<a name="5654"/> 5654:     io:format(&quot;insert_trap_delete_run(~p, ~p, ~p) NKeys=~p\n&quot;,
<a name="5655"/> 5655:               [Traps, InsertFunc, Mode, NKeys]),
<a name="5656"/> 5656:     TabName = insert_trap_delete,
<a name="5657"/> 5657:     Tester = self(),
<a name="5658"/> 5658:     Tuples = [{K} || K &lt;- lists:seq(1,NKeys)],
<a name="5659"/> 5659: 
<a name="5660"/> 5660:     OwnerFun =
<a name="5661"/> 5661:         fun() -&gt;
<a name="5662"/> 5662:                 erlang:trace(Tester, true, [running]),
<a name="5663"/> 5663:                 ets_new(TabName, [named_table, public | Opts]),
<a name="5664"/> 5664:                 Tester ! {ets_new, ets:whereis(TabName)},
<a name="5665"/> 5665:                 io:format(&quot;Wait for ets:~p/2 to yield...\n&quot;, [InsertFunc]),
<a name="5666"/> 5666:                 GotTraps = repeat_while(
<a name="5667"/> 5667:                   fun(N) -&gt;
<a name="5668"/> 5668:                           case receive_any() of
<a name="5669"/> 5669:                               {trace, Tester, out, {ets,InsertFunc,2}} -&gt;
<a name="5670"/> 5670:                                   case N of
<a name="5671"/> 5671:                                       Traps -&gt; {false, Traps};
<a name="5672"/> 5672:                                       _ -&gt; {true, N+1}
<a name="5673"/> 5673:                                   end;
<a name="5674"/> 5674:                               &quot;Insert done&quot; -&gt;
<a name="5675"/> 5675:                                   io:format(&quot;Too late! Got ~p traps\n&quot;, [N]),
<a name="5676"/> 5676:                                   {false, N};
<a name="5677"/> 5677:                               _M -&gt;
<a name="5678"/> 5678:                                   %%io:format(&quot;[~p] Ignored msg: ~p\n&quot;, [N,_M]),
<a name="5679"/> 5679:                                   {true, N}
<a name="5680"/> 5680:                           end
<a name="5681"/> 5681:                   end,
<a name="5682"/> 5682:                   0),
<a name="5683"/> 5683:                 case Mode of
<a name="5684"/> 5684:                     delete -&gt;
<a name="5685"/> 5685:                         io:format(&quot;Delete table and then exit...\n&quot;,[]),
<a name="5686"/> 5686:                         ets:delete(TabName);
<a name="5687"/> 5687:                     exit -&gt;
<a name="5688"/> 5688:                         io:format(&quot;Exit and let table die...\n&quot;,[])
<a name="5689"/> 5689:                 end,
<a name="5690"/> 5690:                 Tester ! {traps, GotTraps}
<a name="5691"/> 5691:         end,
<a name="5692"/> 5692:     {Owner, Mon} = spawn_opt(OwnerFun, [link, monitor]),
<a name="5693"/> 5693: 
<a name="5694"/> 5694:     {ets_new, Tid} = receive_any(),
<a name="5695"/> 5695:     try ets:InsertFunc(TabName, Tuples) of
<a name="5696"/> 5696:         true -&gt;
<a name="5697"/> 5697:             try ets:lookup(Tid, NKeys) of
<a name="5698"/> 5698:                 [{NKeys}] -&gt; ok
<a name="5699"/> 5699:             catch
<a name="5700"/> 5700:                 error:badarg -&gt;
<a name="5701"/> 5701:                     %% Table must been deleted just after insert finished
<a name="5702"/> 5702:                     undefined = ets:info(Tid, id),
<a name="5703"/> 5703:                     undefined = ets:whereis(TabName)
<a name="5704"/> 5704:             end,
<a name="5705"/> 5705:             Owner ! &quot;Insert done&quot;
<a name="5706"/> 5706:     catch
<a name="5707"/> 5707:         error:badarg -&gt;
<a name="5708"/> 5708:             %% Insert failed, table must have been deleted
<a name="5709"/> 5709:             undefined = ets:info(Tid, id),
<a name="5710"/> 5710:             undefined = ets:whereis(TabName)
<a name="5711"/> 5711:     end,
<a name="5712"/> 5712:     {traps, GotTraps} = receive_any(),
<a name="5713"/> 5713:     {'DOWN', Mon, process, Owner, _} = receive_any(),
<a name="5714"/> 5714:     undefined = ets:whereis(TabName),
<a name="5715"/> 5715:     undefined = ets:info(Tid, id),
<a name="insert_trap_delete_run3-last_expr"/><a name="5716"/> 5716:     GotTraps.
<a name="5717"/> 5717: 
<a name="5718"/> 5718: <i>%% Rename table during trapping ets:insert</i>
<a name="insert_trap_rename-1"/><a name="5719"/> 5719: <b>insert_trap_rename</b>(Config) when is_list(Config) -&gt;
<a name="5720"/> 5720:     repeat_for_opts(fun(Opts) -&gt;
<a name="5721"/> 5721:                             [insert_trap_rename_run1(Opts, InsertFunc)
<a name="5722"/> 5722:                              || InsertFunc &lt;- [insert, insert_new]]
<a name="5723"/> 5723:                     end,
<a name="5724"/> 5724:                     [all_non_stim_types, write_concurrency, compressed]),
<a name="insert_trap_rename-last_expr"/><a name="5725"/> 5725:     ok.
<a name="5726"/> 5726: 
<a name="insert_trap_rename_run1-2"/><a name="5727"/> 5727: <b>insert_trap_rename_run1</b>(Opts, InsertFunc) -&gt;
<a name="5728"/> 5728:     NKeys = 50_000 + rand:uniform(50_000),
<a name="5729"/> 5729:     %% First measure how many traps the insert op will do
<a name="5730"/> 5730:     Traps0 = insert_trap_rename_run3(Opts, unlimited, InsertFunc, NKeys),
<a name="5731"/> 5731:     %% Then do again and rename table at different moments
<a name="5732"/> 5732:     Decr = (Traps0 div 5) + 1,
<a name="5733"/> 5733:     insert_trap_rename_run2(Opts, Traps0-1, Decr, InsertFunc, NKeys),
<a name="insert_trap_rename_run1-last_expr"/><a name="5734"/> 5734:     ok.
<a name="5735"/> 5735: 
<a name="insert_trap_rename_run2-5"/><a name="5736"/> 5736: <b>insert_trap_rename_run2</b>(Opts, Traps, _Decr, InsertFunc, NKeys) when Traps =&lt; 1 -&gt;
<a name="5737"/> 5737:     insert_trap_rename_run3(Opts, 1, InsertFunc, NKeys),
<a name="5738"/> 5738:     ok;
<a name="5739"/> 5739: <b>insert_trap_rename_run2</b>(Opts, Traps, Decr, InsertFunc, NKeys) -&gt;
<a name="5740"/> 5740:     insert_trap_rename_run3(Opts, Traps, InsertFunc, NKeys),
<a name="insert_trap_rename_run2-last_expr"/><a name="5741"/> 5741: <b>    insert_trap_rename_run2</b>(Opts, Traps - Decr, Decr, InsertFunc, NKeys).
<a name="5742"/> 5742: 
<a name="5743"/> 5743: 
<a name="insert_trap_rename_run3-4"/><a name="5744"/> 5744: <b>insert_trap_rename_run3</b>(Opts, Traps, InsertFunc, NKeys) -&gt;
<a name="5745"/> 5745:     io:format(&quot;insert_trap_rename_run(~p, ~p)\n&quot;, [Traps, InsertFunc]),
<a name="5746"/> 5746:     TabName = insert_trap_rename,
<a name="5747"/> 5747:     TabRenamed = insert_trap_rename_X,
<a name="5748"/> 5748:     Tester = self(),
<a name="5749"/> 5749:     Tuples = [{K} || K &lt;- lists:seq(1,NKeys)],
<a name="5750"/> 5750: 
<a name="5751"/> 5751:     OwnerFun =
<a name="5752"/> 5752:         fun() -&gt;
<a name="5753"/> 5753:                 erlang:trace(Tester, true, [running]),
<a name="5754"/> 5754:                 ets_new(TabName, [named_table, public | Opts]),
<a name="5755"/> 5755:                 Tester ! {ets_new, ets:whereis(TabName)},
<a name="5756"/> 5756:                 io:format(&quot;Wait for ets:~p/2 to yield...\n&quot;, [InsertFunc]),
<a name="5757"/> 5757:                 GotTraps = repeat_while(
<a name="5758"/> 5758:                   fun(N) -&gt;
<a name="5759"/> 5759:                           case receive_any() of
<a name="5760"/> 5760:                               {trace, Tester, out, {ets,InsertFunc,2}} -&gt;
<a name="5761"/> 5761:                                   case N of
<a name="5762"/> 5762:                                       Traps -&gt; {false, ok};
<a name="5763"/> 5763:                                       _ -&gt; {true, N+1}
<a name="5764"/> 5764:                                   end;
<a name="5765"/> 5765:                               &quot;Insert done&quot; -&gt;
<a name="5766"/> 5766:                                   io:format(&quot;Too late! Got ~p traps\n&quot;, [N]),
<a name="5767"/> 5767:                                   {false, N};
<a name="5768"/> 5768:                               _M -&gt;
<a name="5769"/> 5769:                                   %%io:format(&quot;[~p] Ignored msg: ~p\n&quot;, [N,_M]),
<a name="5770"/> 5770:                                   {true, N}
<a name="5771"/> 5771:                           end
<a name="5772"/> 5772:                   end,
<a name="5773"/> 5773:                   0),
<a name="5774"/> 5774:                 io:format(&quot;Rename table and wait...\n&quot;,[]),
<a name="5775"/> 5775:                 ets:rename(TabName, TabRenamed),
<a name="5776"/> 5776:                 ets:delete(TabRenamed, 42),
<a name="5777"/> 5777:                 Tester ! {renamed, GotTraps},
<a name="5778"/> 5778:                 receive die -&gt; ok end
<a name="5779"/> 5779:         end,
<a name="5780"/> 5780:     {Owner, Mon} = spawn_opt(OwnerFun, [link,monitor]),
<a name="5781"/> 5781: 
<a name="5782"/> 5782:     {ets_new, Tid} = receive_any(),
<a name="5783"/> 5783:     try ets:InsertFunc(TabName, Tuples) of
<a name="5784"/> 5784:         true -&gt;
<a name="5785"/> 5785:             io:format(&quot;ets:~p succeeded\n&quot;, [InsertFunc]),
<a name="5786"/> 5786:             true = ets:member(Tid, 1),
<a name="5787"/> 5787:             true = ets:member(Tid, NKeys)
<a name="5788"/> 5788:     catch
<a name="5789"/> 5789:         error:badarg -&gt;
<a name="5790"/> 5790:             io:format(&quot;ets:~p failed\n&quot;, [InsertFunc]),
<a name="5791"/> 5791:             false = ets:member(Tid, 1),
<a name="5792"/> 5792:             false = ets:member(Tid, NKeys)
<a name="5793"/> 5793:     end,
<a name="5794"/> 5794:     Owner ! &quot;Insert done&quot;,
<a name="5795"/> 5795:     {renamed, GotTraps} = receive_any(),
<a name="5796"/> 5796:     [] = ets:lookup(Tid, 42),
<a name="5797"/> 5797:     undefined = ets:whereis(TabName),
<a name="5798"/> 5798:     Tid = ets:whereis(TabRenamed),
<a name="5799"/> 5799:     Owner ! die,
<a name="5800"/> 5800:     {'DOWN', Mon, process, Owner, _} = receive_any(),
<a name="5801"/> 5801:     undefined = ets:whereis(TabName),
<a name="5802"/> 5802:     undefined = ets:whereis(TabRenamed),
<a name="insert_trap_rename_run3-last_expr"/><a name="5803"/> 5803:     GotTraps.
<a name="5804"/> 5804: 
<a name="5805"/> 5805: 
<a name="test_table_size_concurrency-1"/><a name="5806"/> 5806: <b>test_table_size_concurrency</b>(Config) when is_list(Config) -&gt;
<a name="test_table_size_concurrency-last_expr"/><a name="5807"/> 5807: <b>    case erlang:system_info</b>(schedulers) of
<a name="5808"/> 5808:         1 -&gt; {skip,&quot;Only valid on smp &gt; 1 systems&quot;};
<a name="5809"/> 5809:         _ -&gt;
<a name="5810"/> 5810:             lists:foreach(
<a name="5811"/> 5811:               fun(WriteConcurrencyOpt) -&gt;
<a name="5812"/> 5812:                       BaseOptions = [public, {write_concurrency, WriteConcurrencyOpt}],
<a name="5813"/> 5813:                       test_table_counter_concurrency(size, [set | BaseOptions]),
<a name="5814"/> 5814:                       test_table_counter_concurrency(size, [ordered_set | BaseOptions])
<a name="5815"/> 5815:               end,
<a name="5816"/> 5816:               [true, auto])
<a name="5817"/> 5817:     end.
<a name="5818"/> 5818: 
<a name="test_table_memory_concurrency-1"/><a name="5819"/> 5819: <b>test_table_memory_concurrency</b>(Config) when is_list(Config) -&gt;
<a name="test_table_memory_concurrency-last_expr"/><a name="5820"/> 5820: <b>    case erlang:system_info</b>(schedulers) of
<a name="5821"/> 5821:         1 -&gt; {skip,&quot;Only valid on smp &gt; 1 systems&quot;};
<a name="5822"/> 5822:         _ -&gt;
<a name="5823"/> 5823:             lists:foreach(
<a name="5824"/> 5824:               fun(WriteConcurrencyOpt) -&gt;
<a name="5825"/> 5825:                       BaseOptions = [public, {write_concurrency, WriteConcurrencyOpt}],
<a name="5826"/> 5826:                       test_table_counter_concurrency(memory, [set | BaseOptions]),
<a name="5827"/> 5827:                       test_table_counter_concurrency(memory, [ordered_set | BaseOptions])
<a name="5828"/> 5828:               end,
<a name="5829"/> 5829:               [true, auto])
<a name="5830"/> 5830:     end.
<a name="5831"/> 5831: 
<a name="5832"/> 5832: <i>%% Tests that calling the ets:delete operation on a table T with</i>
<a name="5833"/> 5833: <i>%% decentralized counters works while ets:info(T, size) operations are</i>
<a name="5834"/> 5834: <i>%% active</i>
<a name="test_delete_table_while_size_snapshot-1"/><a name="5835"/> 5835: <b>test_delete_table_while_size_snapshot</b>(Config) when is_list(Config) -&gt;
<a name="5836"/> 5836:     %% Run test case in a slave node as other test suites in stdlib
<a name="5837"/> 5837:     %% depend on that pids are ordered in creation order which is no
<a name="5838"/> 5838:     %% longer the case when many processes have been started before
<a name="5839"/> 5839:     {ok, Peer, Node} = ?CT_PEER(),
<a name="5840"/> 5840:     [ok = rpc:call(Node,
<a name="5841"/> 5841:                    ?MODULE,
<a name="5842"/> 5842:                    test_delete_table_while_size_snapshot_helper,
<a name="5843"/> 5843:                    [TableType])
<a name="5844"/> 5844:      || TableType &lt;- [set, ordered_set]],
<a name="5845"/> 5845:     peer:stop(Peer),
<a name="test_delete_table_while_size_snapshot-last_expr"/><a name="5846"/> 5846:     ok.
<a name="5847"/> 5847: 
<a name="test_delete_table_while_size_snapshot_helper-1"/><a name="5848"/> 5848: <b>test_delete_table_while_size_snapshot_helper</b>(TableType) -&gt;
<a name="5849"/> 5849:     TopParent = self(),
<a name="5850"/> 5850:     repeat_par(
<a name="5851"/> 5851:       fun() -&gt;
<a name="5852"/> 5852:               Table = ets:new(t, [public, TableType,
<a name="5853"/> 5853:                                   {decentralized_counters, true},
<a name="5854"/> 5854:                                   {write_concurrency, true}]),
<a name="5855"/> 5855:               Parent = self(),
<a name="5856"/> 5856:               NrOfSizeProcs = 100,
<a name="5857"/> 5857:               Pids = [ spawn(fun()-&gt; size_process(Table, Parent) end)
<a name="5858"/> 5858:                        || _ &lt;- lists:seq(1, NrOfSizeProcs)],
<a name="5859"/> 5859:               timer:sleep(1),
<a name="5860"/> 5860:               ets:delete(Table),
<a name="5861"/> 5861:               [receive
<a name="5862"/> 5862:                    table_gone -&gt;  ok;
<a name="5863"/> 5863:                    Problem -&gt; TopParent ! Problem
<a name="5864"/> 5864:                end || _ &lt;- Pids]
<a name="5865"/> 5865:       end,
<a name="5866"/> 5866:       100*erlang:system_info(schedulers_online)),
<a name="test_delete_table_while_size_snapshot_helper-last_expr"/><a name="5867"/> 5867:     receive
<a name="5868"/> 5868:         Problem -&gt; throw(Problem)
<a name="5869"/> 5869:     after 0 -&gt; ok
<a name="5870"/> 5870:     end.
<a name="5871"/> 5871: 
<a name="size_process-2"/><a name="5872"/> 5872: <b>size_process</b>(Table, Parent) -&gt;
<a name="size_process-last_expr"/><a name="5873"/> 5873: <b>    try ets:info</b>(Table, size) of
<a name="5874"/> 5874:         N when is_integer(N) -&gt;
<a name="5875"/> 5875:             size_process(Table, Parent);
<a name="5876"/> 5876:         undefined -&gt; Parent ! table_gone;
<a name="5877"/> 5877:         E -&gt; Parent ! {got_unexpected, E}
<a name="5878"/> 5878:     catch
<a name="5879"/> 5879:         E -&gt; Parent ! {got_unexpected_exception, E}
<a name="5880"/> 5880:     end.
<a name="5881"/> 5881: 
<a name="repeat_par-2"/><a name="5882"/> 5882: <b>repeat_par</b>(FunToRepeat, NrOfTimes) -&gt;
<a name="repeat_par-last_expr"/><a name="5883"/> 5883: <b>    repeat_par_help</b>(FunToRepeat, NrOfTimes, NrOfTimes).
<a name="5884"/> 5884: 
<a name="repeat_par_help-3"/><a name="5885"/> 5885: <b>repeat_par_help</b>(_FunToRepeat, 0, OrgNrOfTimes) -&gt;
<a name="5886"/> 5886:     repeat(fun()-&gt; receive done -&gt; ok end end, OrgNrOfTimes);
<a name="5887"/> 5887: <b>repeat_par_help</b>(FunToRepeat, NrOfTimes, OrgNrOfTimes) -&gt;
<a name="5888"/> 5888:     Parent = self(),
<a name="5889"/> 5889:     case NrOfTimes rem 5 of
<a name="5890"/> 5890:         0 -&gt; timer:sleep(1);
<a name="5891"/> 5891:         _ -&gt; ok
<a name="5892"/> 5892:     end,
<a name="5893"/> 5893:     spawn(fun()-&gt;
<a name="5894"/> 5894:                   FunToRepeat(),
<a name="5895"/> 5895:                   Parent ! done
<a name="5896"/> 5896:           end),
<a name="repeat_par_help-last_expr"/><a name="5897"/> 5897: <b>    repeat_par_help</b>(FunToRepeat, NrOfTimes-1, OrgNrOfTimes).
<a name="5898"/> 5898: 
<a name="test_decentralized_counters_setting-1"/><a name="5899"/> 5899: <b>test_decentralized_counters_setting</b>(Config) when is_list(Config) -&gt;
<a name="test_decentralized_counters_setting-last_expr"/><a name="5900"/> 5900: <b>    case erlang:system_info</b>(schedulers) of
<a name="5901"/> 5901:         1 -&gt; {skip,&quot;Only relevant when the number of shedulers &gt; 1&quot;};
<a name="5902"/> 5902:         _ -&gt; EtsMem = etsmem(),
<a name="5903"/> 5903:              do_test_decentralized_counters_setting(set),
<a name="5904"/> 5904:              do_test_decentralized_counters_setting(ordered_set),
<a name="5905"/> 5905:              do_test_decentralized_counters_default_setting(),
<a name="5906"/> 5906:              verify_etsmem(EtsMem)
<a name="5907"/> 5907:     end.
<a name="5908"/> 5908: 
<a name="do_test_decentralized_counters_setting-1"/><a name="5909"/> 5909: <b>do_test_decentralized_counters_setting</b>(TableType) -&gt;
<a name="5910"/> 5910:     wait_for_memory_deallocations(),
<a name="5911"/> 5911:     FlxCtrMemUsage = erts_debug:get_internal_state(flxctr_memory_usage),
<a name="5912"/> 5912:     FixOptsList =
<a name="5913"/> 5913:         fun(Opts) -&gt;
<a name="5914"/> 5914:                 case TableType of
<a name="5915"/> 5915:                     ordered_set -&gt;
<a name="5916"/> 5916:                         replace_dbg_hash_fixed_nr_of_locks(Opts);
<a name="5917"/> 5917:                     set -&gt;
<a name="5918"/> 5918:                         Opts
<a name="5919"/> 5919:                 end
<a name="5920"/> 5920:         end,
<a name="5921"/> 5921:     lists:foreach(
<a name="5922"/> 5922:       fun(OptList) -&gt;
<a name="5923"/> 5923:               T1 = ets:new(t1, FixOptsList([public, TableType] ++ OptList ++ [TableType])),
<a name="5924"/> 5924:               check_decentralized_counters(T1, false, FlxCtrMemUsage),
<a name="5925"/> 5925:               ets:delete(T1)
<a name="5926"/> 5926:       end,
<a name="5927"/> 5927:       [[{write_concurrency, false}]] ++
<a name="5928"/> 5928:           case TableType of
<a name="5929"/> 5929:               set -&gt;
<a name="5930"/> 5930:                   [[{write_concurrency, true}, {decentralized_counters, false}],
<a name="5931"/> 5931:                    [{write_concurrency, {debug_hash_fixed_number_of_locks, 1024}}, {write_concurrency, true}]];
<a name="5932"/> 5932:               ordered_set -&gt; []
<a name="5933"/> 5933:           end),
<a name="5934"/> 5934:     lists:foreach(
<a name="5935"/> 5935:       fun(OptList) -&gt;
<a name="5936"/> 5936:               T1 = ets:new(t1,
<a name="5937"/> 5937:                            FixOptsList([public,
<a name="5938"/> 5938:                                         TableType,
<a name="5939"/> 5939:                                         {write_concurrency, true}] ++ OptList ++ [TableType])),
<a name="5940"/> 5940:               check_decentralized_counters(T1, true, FlxCtrMemUsage),
<a name="5941"/> 5941:               ets:delete(T1),
<a name="5942"/> 5942:               wait_for_memory_deallocations(),
<a name="5943"/> 5943:               FlxCtrMemUsage = erts_debug:get_internal_state(flxctr_memory_usage)
<a name="5944"/> 5944:       end,
<a name="5945"/> 5945:       [[{decentralized_counters, true}],
<a name="5946"/> 5946:        [{write_concurrency, {debug_hash_fixed_number_of_locks, 1024}}],
<a name="5947"/> 5947:        [{write_concurrency, auto}]]),
<a name="do_test_decentralized_counters_setting-last_expr"/><a name="5948"/> 5948:     ok.
<a name="5949"/> 5949: 
<a name="do_test_decentralized_counters_default_setting-0"/><a name="5950"/> 5950: <b>do_test_decentralized_counters_default_setting</b>() -&gt;
<a name="5951"/> 5951:     wait_for_memory_deallocations(),
<a name="5952"/> 5952:     FlxCtrMemUsage = erts_debug:get_internal_state(flxctr_memory_usage),
<a name="5953"/> 5953:     Set = ets:new(t1, [public, {write_concurrency, true}]),
<a name="5954"/> 5954:     check_decentralized_counters(Set, false, FlxCtrMemUsage),
<a name="5955"/> 5955:     ets:delete(Set),
<a name="5956"/> 5956:     Set2 = ets:new(t1, [public, set, {write_concurrency, true}]),
<a name="5957"/> 5957:     check_decentralized_counters(Set2, false, FlxCtrMemUsage),
<a name="5958"/> 5958:     ets:delete(Set2),
<a name="5959"/> 5959:     OrdSet = ets:new(t1, [public, ordered_set, {write_concurrency, true}]),
<a name="5960"/> 5960:     check_decentralized_counters(OrdSet, true, FlxCtrMemUsage),
<a name="5961"/> 5961:     ets:delete(OrdSet),
<a name="do_test_decentralized_counters_default_setting-last_expr"/><a name="5962"/> 5962:     ok.
<a name="5963"/> 5963: 
<a name="check_decentralized_counters-3"/><a name="5964"/> 5964: <b>check_decentralized_counters</b>(T, ExpectedState, InitMemUsage) -&gt;
<a name="5965"/> 5965:     case {ExpectedState, erts_debug:get_internal_state(flxctr_memory_usage)} of
<a name="5966"/> 5966:         {false, notsup} -&gt; ok;
<a name="5967"/> 5967:         {false, X} -&gt; InitMemUsage = X;
<a name="5968"/> 5968:         {true, notsup} -&gt; ok;
<a name="5969"/> 5969:         {true, X} when X &gt; InitMemUsage -&gt; ok;
<a name="5970"/> 5970:         {true, _} -&gt; ct:fail(&quot;Decentralized counter not used.&quot;)
<a name="5971"/> 5971:     end,
<a name="check_decentralized_counters-last_expr"/><a name="5972"/> 5972: <b>    ExpectedState = ets:info</b>(T, decentralized_counters).
<a name="5973"/> 5973: 
<a name="5974"/> 5974: <i>%% Test various duplicate_bags stuff.</i>
<a name="dups-1"/><a name="5975"/> 5975: <b>dups</b>(Config) when is_list(Config) -&gt;
<a name="dups-last_expr"/><a name="5976"/> 5976: <b>    repeat_for_opts</b>(fun dups_do/1).
<a name="5977"/> 5977: 
<a name="dups_do-1"/><a name="5978"/> 5978: <b>dups_do</b>(Opts) -&gt;
<a name="5979"/> 5979:     EtsMem = etsmem(),
<a name="5980"/> 5980:     T = make_table(funky,
<a name="5981"/> 5981: 		   [duplicate_bag | Opts],
<a name="5982"/> 5982: 		   [{1, 2}, {1, 2}]),
<a name="5983"/> 5983:     2 = length(ets:tab2list(T)),
<a name="5984"/> 5984:     ets:delete(T, 1),
<a name="5985"/> 5985:     [] = ets:lookup(T, 1),
<a name="5986"/> 5986: 
<a name="5987"/> 5987:     ets:insert(T, {1, 2, 2}),
<a name="5988"/> 5988:     ets:insert(T, {1, 2, 4}),
<a name="5989"/> 5989:     ets:insert(T, {1, 2, 2}),
<a name="5990"/> 5990:     ets:insert(T, {1, 2, 2}),
<a name="5991"/> 5991:     ets:insert(T, {1, 2, 4}),
<a name="5992"/> 5992: 
<a name="5993"/> 5993:     5 = length(ets:tab2list(T)),
<a name="5994"/> 5994: 
<a name="5995"/> 5995:     5 = length(ets:match(T, {'$1', 2, '$2'})),
<a name="5996"/> 5996:     3 = length(ets:match(T, {'_', '$1', '$1'})),
<a name="5997"/> 5997:     ets:match_delete(T, {'_', '$1', '$1'}),
<a name="5998"/> 5998:     0 = length(ets:match(T, {'_', '$1', '$1'})),
<a name="5999"/> 5999:     ets:delete(T),
<a name="dups_do-last_expr"/><a name="6000"/> 6000: <b>    verify_etsmem</b>(EtsMem).
<a name="6001"/> 6001: 
<a name="6002"/> 6002: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="6003"/> 6003: 
<a name="6004"/> 6004: <i>%% Test the ets:tab2file function on an empty ets table.</i>
<a name="tab2file-1"/><a name="6005"/> 6005: <b>tab2file</b>(Config) when is_list(Config) -&gt;
<a name="6006"/> 6006:     FName = filename:join([proplists:get_value(priv_dir, Config),&quot;tab2file_case&quot;]),
<a name="6007"/> 6007:     tab2file_do(FName, [], set),
<a name="6008"/> 6008:     tab2file_do(FName, [], ordered_set),
<a name="6009"/> 6009:     tab2file_do(FName, [], cat_ord_set),
<a name="6010"/> 6010:     tab2file_do(FName, [], stim_cat_ord_set),
<a name="6011"/> 6011:     tab2file_do(FName, [{sync,true}], set),
<a name="6012"/> 6012:     tab2file_do(FName, [{sync,false}], set),
<a name="6013"/> 6013:     {'EXIT',{{badmatch,{error,_}},_}} = (catch tab2file_do(FName, [{sync,yes}], set)),
<a name="6014"/> 6014:     {'EXIT',{{badmatch,{error,_}},_}} = (catch tab2file_do(FName, [sync], set)),
<a name="tab2file-last_expr"/><a name="6015"/> 6015:     ok.
<a name="6016"/> 6016: 
<a name="tab2file_do-3"/><a name="6017"/> 6017: <b>tab2file_do</b>(FName, Opts, TableType) -&gt;
<a name="6018"/> 6018:     %% Write an empty ets table to a file, read back and check properties.
<a name="6019"/> 6019:     Tab = ets_new(ets_SUITE_foo_tab, [named_table, TableType, public,
<a name="6020"/> 6020: 				      {keypos, 2},
<a name="6021"/> 6021: 				      compressed,
<a name="6022"/> 6022: 				      {write_concurrency,true},
<a name="6023"/> 6023: 				      {read_concurrency,true}]),
<a name="6024"/> 6024:     ActualTableType =
<a name="6025"/> 6025:         case TableType of
<a name="6026"/> 6026:             cat_ord_set -&gt; ordered_set;
<a name="6027"/> 6027:             stim_cat_ord_set -&gt; ordered_set;
<a name="6028"/> 6028:             _ -&gt; TableType
<a name="6029"/> 6029:         end,
<a name="6030"/> 6030:     catch file:delete(FName),
<a name="6031"/> 6031:     Res = ets:tab2file(Tab, FName, Opts),
<a name="6032"/> 6032:     true = ets:delete(Tab),
<a name="6033"/> 6033:     ok = Res,
<a name="6034"/> 6034:     %%
<a name="6035"/> 6035:     EtsMem = etsmem(),
<a name="6036"/> 6036:     {ok, Tab2} = ets:file2tab(FName),
<a name="6037"/> 6037:     public = ets:info(Tab2, protection),
<a name="6038"/> 6038:     true = ets:info(Tab2, named_table),
<a name="6039"/> 6039:     2 = ets:info(Tab2, keypos),
<a name="6040"/> 6040:     ActualTableType = ets:info(Tab2, type),
<a name="6041"/> 6041:     true = ets:info(Tab2, compressed),
<a name="6042"/> 6042:     Smp = erlang:system_info(smp_support),
<a name="6043"/> 6043:     Smp = ets:info(Tab2, read_concurrency),
<a name="6044"/> 6044:     Smp = ets:info(Tab2, write_concurrency) orelse erlang:system_info(schedulers) == 1,
<a name="6045"/> 6045:     true = ets:delete(Tab2),
<a name="tab2file_do-last_expr"/><a name="6046"/> 6046: <b>    verify_etsmem</b>(EtsMem).
<a name="6047"/> 6047: 
<a name="6048"/> 6048: 
<a name="6049"/> 6049: <i>%% Check the ets:tab2file function on a filled set/bag type ets table.</i>
<a name="tab2file2-1"/><a name="6050"/> 6050: <b>tab2file2</b>(Config) when is_list(Config) -&gt;
<a name="tab2file2-last_expr"/><a name="6051"/> 6051: <b>    repeat_for_opts</b>(fun(Opts) -&gt;
<a name="6052"/> 6052:                             tab2file2_do(Opts, Config)
<a name="6053"/> 6053:                     end, [[stim_cat_ord_set,cat_ord_set,set,bag],compressed]).
<a name="6054"/> 6054: 
<a name="tab2file2_do-2"/><a name="6055"/> 6055: <b>tab2file2_do</b>(Opts, Config) -&gt;
<a name="6056"/> 6056:     EtsMem = etsmem(),
<a name="6057"/> 6057:     KeyRange = 10000,
<a name="6058"/> 6058:     Tab = ets_new(ets_SUITE_foo_tab, [named_table, private, {keypos, 2} | Opts],
<a name="6059"/> 6059:                   KeyRange),
<a name="6060"/> 6060:     FName = filename:join([proplists:get_value(priv_dir, Config),&quot;tab2file2_case&quot;]),
<a name="6061"/> 6061:     ok = fill_tab2(Tab, 0, KeyRange),   % Fill up the table (grucho mucho!)
<a name="6062"/> 6062:     Len = length(ets:tab2list(Tab)),
<a name="6063"/> 6063:     Mem = ets:info(Tab, memory),
<a name="6064"/> 6064:     Type = ets:info(Tab, type),
<a name="6065"/> 6065:     %%io:format(&quot;org tab: ~p\n&quot;,[ets:info(Tab)]),
<a name="6066"/> 6066:     ok = ets:tab2file(Tab, FName),
<a name="6067"/> 6067:     true = ets:delete(Tab),
<a name="6068"/> 6068: 
<a name="6069"/> 6069:     EtsMem4 = etsmem(),
<a name="6070"/> 6070: 
<a name="6071"/> 6071:     {ok, Tab2} = ets:file2tab(FName),
<a name="6072"/> 6072:     %%io:format(&quot;loaded tab: ~p\n&quot;,[ets:info(Tab2)]),
<a name="6073"/> 6073:     private = ets:info(Tab2, protection),
<a name="6074"/> 6074:     true = ets:info(Tab2, named_table),
<a name="6075"/> 6075:     2 = ets:info(Tab2, keypos),
<a name="6076"/> 6076:     Type = ets:info(Tab2, type),
<a name="6077"/> 6077:     Len = length(ets:tab2list(Tab2)),
<a name="6078"/> 6078:     Mem = ets:info(Tab2, memory),
<a name="6079"/> 6079:     true = ets:delete(Tab2),
<a name="6080"/> 6080:     io:format(&quot;Between = ~p\n&quot;, [EtsMem4]),
<a name="tab2file2_do-last_expr"/><a name="6081"/> 6081: <b>    verify_etsmem</b>(EtsMem).
<a name="6082"/> 6082: 
<a name="6083"/> 6083: <b>-define</b>(test_list, [8,5,4,1,58,125,255, 250, 245, 240, 235,
<a name="6084"/> 6084: 		    230, Num rem 255, 255, 125, 130, 135, 140, 145,
<a name="6085"/> 6085: 		    150, 134, 12, 54, Val rem 255, 12, 3, 6, 9, 126]).
<a name="6086"/> 6086: <b>-define</b>(big_test_list, [Num rem 256|lists:seq(1, 66)]).
<a name="6087"/> 6087: <b>-define</b>(test_integer, 2846287468+Num).
<a name="6088"/> 6088: <b>-define</b>(test_float, 187263.18236-Val).
<a name="6089"/> 6089: <b>-define</b>(test_atom, some_crazy_atom).
<a name="6090"/> 6090: <b>-define</b>(test_tuple, {just, 'Some', 'Tuple', 1, [list, item], Val+Num}).
<a name="6091"/> 6091: 
<a name="6092"/> 6092: <i>%% Insert different datatypes into a ets table.</i>
<a name="fill_tab2-3"/><a name="6093"/> 6093: <b>fill_tab2</b>(_Tab, _Val, 0) -&gt;
<a name="6094"/> 6094:     ok;
<a name="6095"/> 6095: <b>fill_tab2</b>(Tab, Val, Num) -&gt;
<a name="6096"/> 6096:     Item =
<a name="6097"/> 6097: 	case Num rem 10 of
<a name="6098"/> 6098: 	    0 -&gt; &quot;String&quot;;
<a name="6099"/> 6099: 	    1 -&gt; ?test_atom;
<a name="6100"/> 6100: 	    2 -&gt; ?test_tuple;
<a name="6101"/> 6101: 	    3 -&gt; ?test_integer;
<a name="6102"/> 6102: 	    4 -&gt; ?test_float;
<a name="6103"/> 6103: 	    5 -&gt; list_to_binary(?test_list); %Heap binary
<a name="6104"/> 6104: 	    6 -&gt; list_to_binary(?big_test_list); %Refc binary
<a name="6105"/> 6105: 	    7 -&gt; make_sub_binary(?test_list, Num); %Sub binary
<a name="6106"/> 6106: 	    8 -&gt; ?test_list;
<a name="6107"/> 6107: 	    9 -&gt; fun(X) -&gt; {Tab,Val,X*Num} end
<a name="6108"/> 6108: 	end,
<a name="6109"/> 6109:     true=ets:insert(Tab, {Item, Val}),
<a name="6110"/> 6110:     fill_tab2(Tab, Val+1, Num-1),
<a name="fill_tab2-last_expr"/><a name="6111"/> 6111:     ok.
<a name="6112"/> 6112: 
<a name="6113"/> 6113: <i>%% Test verification of tables with object count extended_info.</i>
<a name="tabfile_ext1-1"/><a name="6114"/> 6114: <b>tabfile_ext1</b>(Config) when is_list(Config) -&gt;
<a name="tabfile_ext1-last_expr"/><a name="6115"/> 6115: <b>    repeat_for_opts_all_set_table_types</b>(fun(Opts) -&gt; tabfile_ext1_do(Opts, Config) end).
<a name="6116"/> 6116: 
<a name="tabfile_ext1_do-2"/><a name="6117"/> 6117: <b>tabfile_ext1_do</b>(Opts,Config) -&gt;
<a name="6118"/> 6118:     FName = filename:join([proplists:get_value(priv_dir, Config),&quot;nisse.dat&quot;]),
<a name="6119"/> 6119:     FName2 = filename:join([proplists:get_value(priv_dir, Config),&quot;countflip.dat&quot;]),
<a name="6120"/> 6120:     KeyRange = 10,
<a name="6121"/> 6121:     L = lists:seq(1,KeyRange),
<a name="6122"/> 6122:     T = ets_new(x,Opts,KeyRange),
<a name="6123"/> 6123:     Name = make_ref(),
<a name="6124"/> 6124:     [ets:insert(T,{X,integer_to_list(X)}) || X &lt;- L],
<a name="6125"/> 6125:     ok = ets:tab2file(T,FName,[{extended_info,[object_count]}]),
<a name="6126"/> 6126:     true = lists:sort(ets:tab2list(T)) =:=
<a name="6127"/> 6127: 	lists:sort(ets:tab2list(element(2,ets:file2tab(FName)))),
<a name="6128"/> 6128:     true = lists:sort(ets:tab2list(T)) =:=
<a name="6129"/> 6129: 	lists:sort(ets:tab2list(
<a name="6130"/> 6130: 		     element(2,ets:file2tab(FName,[{verify,true}])))),
<a name="6131"/> 6131:     {ok,Name} = disk_log:open([{name,Name},{file,FName}]),
<a name="6132"/> 6132:     {_,[H0|T0]} = disk_log:chunk(Name,start),
<a name="6133"/> 6133:     disk_log:close(Name),
<a name="6134"/> 6134:     LH0=tuple_to_list(H0),
<a name="6135"/> 6135:     {value,{size,N}}=lists:keysearch(size,1,LH0),
<a name="6136"/> 6136:     NewLH0 = lists:keyreplace(size,1,LH0,{size,N-1}),
<a name="6137"/> 6137:     NewH0 = list_to_tuple(NewLH0),
<a name="6138"/> 6138:     NewT0=lists:keydelete(8,1,T0),
<a name="6139"/> 6139:     file:delete(FName2),
<a name="6140"/> 6140:     disk_log:open([{name,Name},{file,FName2},{mode,read_write}]),
<a name="6141"/> 6141:     disk_log:log_terms(Name,[NewH0|NewT0]),
<a name="6142"/> 6142:     disk_log:close(Name),
<a name="6143"/> 6143:     9 = length(ets:tab2list(element(2,ets:file2tab(FName2)))),
<a name="6144"/> 6144:     {error,invalid_object_count} = ets:file2tab(FName2,[{verify,true}]),
<a name="6145"/> 6145:     {ok, _} = ets:tabfile_info(FName2),
<a name="6146"/> 6146:     {ok, _} = ets:tabfile_info(FName),
<a name="6147"/> 6147:     file:delete(FName),
<a name="6148"/> 6148:     file:delete(FName2),
<a name="tabfile_ext1_do-last_expr"/><a name="6149"/> 6149:     ok.
<a name="6150"/> 6150: 
<a name="6151"/> 6151: 
<a name="6152"/> 6152: <i>%% Test verification of tables with md5sum extended_info.</i>
<a name="tabfile_ext2-1"/><a name="6153"/> 6153: <b>tabfile_ext2</b>(Config) when is_list(Config) -&gt;
<a name="tabfile_ext2-last_expr"/><a name="6154"/> 6154: <b>    repeat_for_opts_all_set_table_types</b>(fun(Opts) -&gt; tabfile_ext2_do(Opts,Config) end).
<a name="6155"/> 6155: 
<a name="tabfile_ext2_do-2"/><a name="6156"/> 6156: <b>tabfile_ext2_do</b>(Opts,Config) -&gt;
<a name="6157"/> 6157:     FName = filename:join([proplists:get_value(priv_dir, Config),&quot;olle.dat&quot;]),
<a name="6158"/> 6158:     FName2 = filename:join([proplists:get_value(priv_dir, Config),&quot;bitflip.dat&quot;]),
<a name="6159"/> 6159:     KeyRange = 10,
<a name="6160"/> 6160:     L = lists:seq(1, KeyRange),
<a name="6161"/> 6161:     T = ets_new(x, Opts, KeyRange),
<a name="6162"/> 6162:     Name = make_ref(),
<a name="6163"/> 6163:     [ets:insert(T,{X,integer_to_list(X)}) || X &lt;- L],
<a name="6164"/> 6164:     ok = ets:tab2file(T,FName,[{extended_info,[md5sum]}]),
<a name="6165"/> 6165:     true = lists:sort(ets:tab2list(T)) =:=
<a name="6166"/> 6166: 	lists:sort(ets:tab2list(element(2,ets:file2tab(FName)))),
<a name="6167"/> 6167:     true = lists:sort(ets:tab2list(T)) =:=
<a name="6168"/> 6168: 	lists:sort(ets:tab2list(
<a name="6169"/> 6169: 		     element(2,ets:file2tab(FName,[{verify,true}])))),
<a name="6170"/> 6170:     {ok, Name} = disk_log:open([{name,Name},{file,FName}]),
<a name="6171"/> 6171:     {_,[H1|T1]} = disk_log:chunk(Name,start),
<a name="6172"/> 6172:     disk_log:close(Name),
<a name="6173"/> 6173:     NewT1=lists:keyreplace(8,1,T1,{8,&quot;9&quot;}),
<a name="6174"/> 6174:     file:delete(FName2),
<a name="6175"/> 6175:     disk_log:open([{name,Name},{file,FName2},{mode,read_write}]),
<a name="6176"/> 6176:     disk_log:log_terms(Name,[H1|NewT1]),
<a name="6177"/> 6177:     disk_log:close(Name),
<a name="6178"/> 6178:     {value,{8,&quot;9&quot;}} = lists:keysearch(8,1,
<a name="6179"/> 6179: 				      ets:tab2list(
<a name="6180"/> 6180: 					element(2,ets:file2tab(FName2)))),
<a name="6181"/> 6181:     {error,checksum_error} = ets:file2tab(FName2,[{verify,true}]),
<a name="6182"/> 6182:     {value,{extended_info,[md5sum]}} =
<a name="6183"/> 6183: 	lists:keysearch(extended_info,1,element(2,ets:tabfile_info(FName2))),
<a name="6184"/> 6184:     {value,{extended_info,[md5sum]}} =
<a name="6185"/> 6185: 	lists:keysearch(extended_info,1,element(2,ets:tabfile_info(FName))),
<a name="6186"/> 6186:     file:delete(FName),
<a name="6187"/> 6187:     file:delete(FName2),
<a name="tabfile_ext2_do-last_expr"/><a name="6188"/> 6188:     ok.
<a name="6189"/> 6189: 
<a name="6190"/> 6190: <i>%% Test verification of (named) tables without extended info.</i>
<a name="tabfile_ext3-1"/><a name="6191"/> 6191: <b>tabfile_ext3</b>(Config) when is_list(Config) -&gt;
<a name="6192"/> 6192:     repeat_for_all_set_table_types(
<a name="6193"/> 6193:       fun(Opts) -&gt;
<a name="6194"/> 6194:               FName = filename:join([proplists:get_value(priv_dir, Config),&quot;namn.dat&quot;]),
<a name="6195"/> 6195:               FName2 = filename:join([proplists:get_value(priv_dir, Config),&quot;ncountflip.dat&quot;]),
<a name="6196"/> 6196:               L = lists:seq(1,10),
<a name="6197"/> 6197:               Name = make_ref(),
<a name="6198"/> 6198:               ?MODULE = ets_new(?MODULE,[named_table|Opts]),
<a name="6199"/> 6199:               [ets:insert(?MODULE,{X,integer_to_list(X)}) || X &lt;- L],
<a name="6200"/> 6200:               ets:tab2file(?MODULE,FName),
<a name="6201"/> 6201:               {error,cannot_create_table} = ets:file2tab(FName),
<a name="6202"/> 6202:               true = ets:delete(?MODULE),
<a name="6203"/> 6203:               {ok,?MODULE} = ets:file2tab(FName),
<a name="6204"/> 6204:               true = ets:delete(?MODULE),
<a name="6205"/> 6205:               disk_log:open([{name,Name},{file,FName}]),
<a name="6206"/> 6206:               {_,[H2|T2]} = disk_log:chunk(Name,start),
<a name="6207"/> 6207:               disk_log:close(Name),
<a name="6208"/> 6208:               NewT2=lists:keydelete(8,1,T2),
<a name="6209"/> 6209:               file:delete(FName2),
<a name="6210"/> 6210:               disk_log:open([{name,Name},{file,FName2},{mode,read_write}]),
<a name="6211"/> 6211:               disk_log:log_terms(Name,[H2|NewT2]),
<a name="6212"/> 6212:               disk_log:close(Name),
<a name="6213"/> 6213:               9 = length(ets:tab2list(element(2,ets:file2tab(FName2)))),
<a name="6214"/> 6214:               true = ets:delete(?MODULE),
<a name="6215"/> 6215:               {error,invalid_object_count} = ets:file2tab(FName2,[{verify,true}]),
<a name="6216"/> 6216:               {'EXIT',_} = (catch ets:delete(?MODULE)),
<a name="6217"/> 6217:               {ok,_} = ets:tabfile_info(FName2),
<a name="6218"/> 6218:               {ok,_} = ets:tabfile_info(FName),
<a name="6219"/> 6219:               file:delete(FName),
<a name="6220"/> 6220:               file:delete(FName2)
<a name="6221"/> 6221:       end),
<a name="tabfile_ext3-last_expr"/><a name="6222"/> 6222:     ok.
<a name="6223"/> 6223: 
<a name="6224"/> 6224: <i>%% Tests verification of large table with md5 sum.</i>
<a name="tabfile_ext4-1"/><a name="6225"/> 6225: <b>tabfile_ext4</b>(Config) when is_list(Config) -&gt;
<a name="6226"/> 6226:     repeat_for_all_set_table_types(
<a name="6227"/> 6227:       fun(Opts) -&gt;
<a name="6228"/> 6228:               FName = filename:join([proplists:get_value(priv_dir, Config),&quot;bauta.dat&quot;]),
<a name="6229"/> 6229:               LL = lists:seq(1,10000),
<a name="6230"/> 6230:               TL = ets_new(x,Opts),
<a name="6231"/> 6231:               Name2 = make_ref(),
<a name="6232"/> 6232:               [ets:insert(TL,{X,integer_to_list(X)}) || X &lt;- LL],
<a name="6233"/> 6233:               ok = ets:tab2file(TL,FName,[{extended_info,[md5sum]}]),
<a name="6234"/> 6234:               {ok, Name2} = disk_log:open([{name, Name2}, {file, FName},
<a name="6235"/> 6235:                                            {mode, read_only}]),
<a name="6236"/> 6236:               {C,[_|_]} = disk_log:chunk(Name2,start),
<a name="6237"/> 6237:               {_,[_|_]} = disk_log:chunk(Name2,C),
<a name="6238"/> 6238:               disk_log:close(Name2),
<a name="6239"/> 6239:               true = lists:sort(ets:tab2list(TL)) =:=
<a name="6240"/> 6240:                   lists:sort(ets:tab2list(element(2,ets:file2tab(FName)))),
<a name="6241"/> 6241:               Res = [begin
<a name="6242"/> 6242:                          {ok,FD} = file:open(FName,[binary,read,write]),
<a name="6243"/> 6243:                          {ok, Bin} = file:pread(FD,0,1000),
<a name="6244"/> 6244:                          &lt;&lt;B1:N/binary,Ch:8,B2/binary&gt;&gt; = Bin,
<a name="6245"/> 6245:                          Ch2 = (Ch + 1) rem 255,
<a name="6246"/> 6246:                          Bin2 = &lt;&lt;B1/binary,Ch2:8,B2/binary&gt;&gt;,
<a name="6247"/> 6247:                          ok = file:pwrite(FD,0,Bin2),
<a name="6248"/> 6248:                          ok = file:close(FD),
<a name="6249"/> 6249:                          X = case ets:file2tab(FName) of
<a name="6250"/> 6250:                                  {ok,TL2} -&gt;
<a name="6251"/> 6251:                                      true = lists:sort(ets:tab2list(TL)) =/=
<a name="6252"/> 6252:                                          lists:sort(ets:tab2list(TL2));
<a name="6253"/> 6253:                                  _ -&gt;
<a name="6254"/> 6254:                                      totally_broken
<a name="6255"/> 6255:                              end,
<a name="6256"/> 6256:                          {error,Y} = ets:file2tab(FName,[{verify,true}]),
<a name="6257"/> 6257:                          ets:tab2file(TL,FName,[{extended_info,[md5sum]}]),
<a name="6258"/> 6258:                          {X,Y}
<a name="6259"/> 6259:                      end || N &lt;- lists:seq(700,800)],
<a name="6260"/> 6260:               io:format(&quot;~p~n&quot;,[Res]),
<a name="6261"/> 6261:               file:delete(FName)
<a name="6262"/> 6262:       end),
<a name="tabfile_ext4-last_expr"/><a name="6263"/> 6263:     ok.
<a name="6264"/> 6264: 
<a name="6265"/> 6265: <i>%% Test that no disk_log is left open when file has been corrupted.</i>
<a name="badfile-1"/><a name="6266"/> 6266: <b>badfile</b>(Config) when is_list(Config) -&gt;
<a name="6267"/> 6267:     PrivDir = proplists:get_value(priv_dir,Config),
<a name="6268"/> 6268:     File = filename:join(PrivDir, &quot;badfile&quot;),
<a name="6269"/> 6269:     _ = file:delete(File),
<a name="6270"/> 6270:     T = ets:new(table, []),
<a name="6271"/> 6271:     true = ets:insert(T, [{a,1},{b,2}]),
<a name="6272"/> 6272:     ok = ets:tab2file(T, File, []),
<a name="6273"/> 6273:     true = ets:delete(T),
<a name="6274"/> 6274:     [H0 | Ts ] = get_all_terms(l, File),
<a name="6275"/> 6275:     H1 = tuple_to_list(H0),
<a name="6276"/> 6276:     H2 = [{K,V} || {K,V} &lt;- H1, K =/= protection],
<a name="6277"/> 6277:     H = list_to_tuple(H2),
<a name="6278"/> 6278:     ok = file:delete(File),
<a name="6279"/> 6279:     write_terms(l, File, [H | Ts]),
<a name="6280"/> 6280:     %% All mandatory keys are no longer members of the header
<a name="6281"/> 6281:     {error, badfile} = ets:file2tab(File),
<a name="6282"/> 6282:     {error, badfile} = ets:tabfile_info(File),
<a name="6283"/> 6283:     file:delete(File),
<a name="6284"/> 6284:     [] = disk_log:all(),
<a name="badfile-last_expr"/><a name="6285"/> 6285:     ok.
<a name="6286"/> 6286: 
<a name="get_all_terms-2"/><a name="6287"/> 6287: <b>get_all_terms</b>(Log, File) -&gt;
<a name="6288"/> 6288:     {ok, Log} = disk_log:open([{name,Log},
<a name="6289"/> 6289:                                {file, File},
<a name="6290"/> 6290:                                {mode, read_only}]),
<a name="6291"/> 6291:     Ts = get_all_terms(Log),
<a name="6292"/> 6292:     ok = disk_log:close(Log),
<a name="get_all_terms-last_expr"/><a name="6293"/> 6293:     Ts.
<a name="6294"/> 6294: 
<a name="get_all_terms-1"/><a name="6295"/> 6295: <b>get_all_terms</b>(Log) -&gt;
<a name="get_all_terms-last_expr"/><a name="6296"/> 6296: <b>    get_all_terms1</b>(Log, start, []).
<a name="6297"/> 6297: 
<a name="get_all_terms1-3"/><a name="6298"/> 6298: <b>get_all_terms1</b>(Log, Cont, Res) -&gt;
<a name="get_all_terms1-last_expr"/><a name="6299"/> 6299: <b>    case disk_log:chunk</b>(Log, Cont) of
<a name="6300"/> 6300: 	{error, _R} -&gt;
<a name="6301"/> 6301:             throw(fel);
<a name="6302"/> 6302: 	{Cont2, Terms} -&gt;
<a name="6303"/> 6303: 	    get_all_terms1(Log, Cont2, Res ++ Terms);
<a name="6304"/> 6304: 	eof -&gt;
<a name="6305"/> 6305: 	    Res
<a name="6306"/> 6306:     end.
<a name="6307"/> 6307: 
<a name="write_terms-3"/><a name="6308"/> 6308: <b>write_terms</b>(Log, File, Terms) -&gt;
<a name="6309"/> 6309:     {ok, Log} = disk_log:open([{name,Log},{file, File},{mode,read_write}]),
<a name="6310"/> 6310:     ok = disk_log:log(Log, Terms),
<a name="write_terms-last_expr"/><a name="6311"/> 6311: <b>    ok = disk_log:close</b>(Log).
<a name="6312"/> 6312: 
<a name="6313"/> 6313: <i>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</i>
<a name="6314"/> 6314: 
<a name="make_sub_binary-2"/><a name="6315"/> 6315: <b>make_sub_binary</b>(List, Num) when is_list(List) -&gt;
<a name="6316"/> 6316:     N = Num rem 23,
<a name="6317"/> 6317:     Bin = list_to_binary([lists:seq(0, N)|List]),
<a name="6318"/> 6318:     {_,B} = split_binary(Bin, N+1),
<a name="make_sub_binary-last_expr"/><a name="6319"/> 6319:     B.
<a name="6320"/> 6320: 
<a name="6321"/> 6321: 
<a name="6322"/> 6322: <i>%% Lookup stuff like crazy...</i>
<a name="6323"/> 6323: 
<a name="6324"/> 6324: <i>%% Perform multiple lookups for every key in a large table.</i>
<a name="heavy_lookup-1"/><a name="6325"/> 6325: <b>heavy_lookup</b>(Config) when is_list(Config) -&gt;
<a name="heavy_lookup-last_expr"/><a name="6326"/> 6326: <b>    repeat_for_opts_all_set_table_types</b>(fun heavy_lookup_do/1).
<a name="6327"/> 6327: 
<a name="heavy_lookup_do-1"/><a name="6328"/> 6328: <b>heavy_lookup_do</b>(Opts) -&gt;
<a name="6329"/> 6329:     EtsMem = etsmem(),
<a name="6330"/> 6330:     KeyRange = 7000,
<a name="6331"/> 6331:     Tab = ets_new(foobar_table, [{keypos, 2} | Opts], KeyRange),
<a name="6332"/> 6332:     ok = fill_tab2(Tab, 0, KeyRange),
<a name="6333"/> 6333:     _ = [do_lookup(Tab, KeyRange-1) || _ &lt;- lists:seq(1, 50)],
<a name="6334"/> 6334:     true = ets:delete(Tab),
<a name="heavy_lookup_do-last_expr"/><a name="6335"/> 6335: <b>    verify_etsmem</b>(EtsMem).
<a name="6336"/> 6336: 
<a name="do_lookup-2"/><a name="6337"/> 6337: <b>do_lookup</b>(_Tab, 0) -&gt; ok;
<a name="6338"/> 6338: <b>do_lookup</b>(Tab, N) -&gt;
<a name="do_lookup-last_expr"/><a name="6339"/> 6339: <b>    case ets:lookup</b>(Tab, N) of
<a name="6340"/> 6340: 	[] -&gt;
<a name="6341"/> 6341: 	    io:format(&quot;Set #~p was reported as empty. Not valid.&quot;,
<a name="6342"/> 6342: 		      [N]),
<a name="6343"/> 6343: 	    exit('Invalid lookup');
<a name="6344"/> 6344: 	_ -&gt;
<a name="6345"/> 6345: 	    do_lookup(Tab, N-1)
<a name="6346"/> 6346:     end.
<a name="6347"/> 6347: 
<a name="6348"/> 6348: <i>%% Perform multiple lookups for every element in a large table.</i>
<a name="heavy_lookup_element-1"/><a name="6349"/> 6349: <b>heavy_lookup_element</b>(Config) when is_list(Config) -&gt;
<a name="heavy_lookup_element-last_expr"/><a name="6350"/> 6350: <b>    repeat_for_opts_all_set_table_types</b>(fun heavy_lookup_element_do/1).
<a name="6351"/> 6351: 
<a name="heavy_lookup_element_do-1"/><a name="6352"/> 6352: <b>heavy_lookup_element_do</b>(Opts) -&gt;
<a name="6353"/> 6353:     EtsMem = etsmem(),
<a name="6354"/> 6354:     KeyRange = 7000,
<a name="6355"/> 6355:     Tab = ets_new(foobar_table, [{keypos, 2} | Opts], KeyRange),
<a name="6356"/> 6356:     ok = fill_tab2(Tab, 0, KeyRange),
<a name="6357"/> 6357:     %% lookup ALL elements 50 times
<a name="6358"/> 6358:     Laps = 50 div syrup_factor(),
<a name="6359"/> 6359:     _ = [do_lookup_element(Tab, KeyRange-1, 1) || _ &lt;- lists:seq(1, Laps)],
<a name="6360"/> 6360:     true = ets:delete(Tab),
<a name="heavy_lookup_element_do-last_expr"/><a name="6361"/> 6361: <b>    verify_etsmem</b>(EtsMem).
<a name="6362"/> 6362: 
<a name="do_lookup_element-3"/><a name="6363"/> 6363: <b>do_lookup_element</b>(_Tab, 0, _) -&gt; ok;
<a name="6364"/> 6364: <b>do_lookup_element</b>(Tab, N, M) -&gt;
<a name="do_lookup_element-last_expr"/><a name="6365"/> 6365: <b>    case catch ets:lookup_element</b>(Tab, N, M) of
<a name="6366"/> 6366: 	{'EXIT', {badarg, _}} -&gt;
<a name="6367"/> 6367: 	    case M of
<a name="6368"/> 6368: 		1 -&gt; ct:fail(&quot;Set #~p reported as empty. Not valid.&quot;,
<a name="6369"/> 6369: 			     [N]),
<a name="6370"/> 6370: 		     exit('Invalid lookup_element');
<a name="6371"/> 6371: 		_ -&gt; do_lookup_element(Tab, N-1, 1)
<a name="6372"/> 6372: 	    end;
<a name="6373"/> 6373: 	_ -&gt; do_lookup_element(Tab, N, M+1)
<a name="6374"/> 6374:     end.
<a name="6375"/> 6375: 
<a name="6376"/> 6376: 
<a name="heavy_concurrent-1"/><a name="6377"/> 6377: <b>heavy_concurrent</b>(Config) when is_list(Config) -&gt;
<a name="6378"/> 6378:     ct:timetrap({minutes,120}), %% valgrind needs a lot of time
<a name="heavy_concurrent-last_expr"/><a name="6379"/> 6379: <b>    repeat_for_opts_all_set_table_types</b>(fun do_heavy_concurrent/1).
<a name="6380"/> 6380: 
<a name="do_heavy_concurrent-1"/><a name="6381"/> 6381: <b>do_heavy_concurrent</b>(Opts) -&gt;
<a name="6382"/> 6382:     KeyRange = 10000,
<a name="6383"/> 6383:     Laps = 10000 div syrup_factor(),
<a name="6384"/> 6384:     EtsMem = etsmem(),
<a name="6385"/> 6385:     Tab = ets_new(blupp, [public, {keypos, 2} | Opts], KeyRange),
<a name="6386"/> 6386:     ok = fill_tab2(Tab, 0, KeyRange),
<a name="6387"/> 6387:     Procs = lists:map(
<a name="6388"/> 6388: 	      fun (N) -&gt;
<a name="6389"/> 6389: 		      my_spawn_link(
<a name="6390"/> 6390: 			fun () -&gt;
<a name="6391"/> 6391: 				do_heavy_concurrent_proc(Tab, Laps, N)
<a name="6392"/> 6392: 			end)
<a name="6393"/> 6393: 	      end,
<a name="6394"/> 6394: 	      lists:seq(1, 500)),
<a name="6395"/> 6395:     lists:foreach(fun (P) -&gt;
<a name="6396"/> 6396: 			  M = erlang:monitor(process, P),
<a name="6397"/> 6397: 			  receive
<a name="6398"/> 6398: 			      {'DOWN', M, process, P, _} -&gt;
<a name="6399"/> 6399: 				  ok
<a name="6400"/> 6400: 			  end
<a name="6401"/> 6401: 		  end,
<a name="6402"/> 6402: 		  Procs),
<a name="6403"/> 6403:     true = ets:delete(Tab),
<a name="do_heavy_concurrent-last_expr"/><a name="6404"/> 6404: <b>    verify_etsmem</b>(EtsMem).
<a name="6405"/> 6405: 
<a name="do_heavy_concurrent_proc-3"/><a name="6406"/> 6406: <b>do_heavy_concurrent_proc</b>(_Tab, 0, _Offs) -&gt;
<a name="6407"/> 6407:     done;
<a name="6408"/> 6408: <b>do_heavy_concurrent_proc</b>(Tab, N, Offs) when (N+Offs) rem 100 == 0 -&gt;
<a name="6409"/> 6409:     Data = {&quot;here&quot;, are, &quot;S O M E &quot;, data, &quot;toooooooooooooooooo&quot;, insert,
<a name="6410"/> 6410: 	    make_ref(), make_ref(), make_ref()},
<a name="6411"/> 6411:     true=ets:insert(Tab, {{self(),Data}, N}),
<a name="6412"/> 6412:     do_heavy_concurrent_proc(Tab, N-1, Offs);
<a name="6413"/> 6413: <b>do_heavy_concurrent_proc</b>(Tab, N, Offs) -&gt;
<a name="6414"/> 6414:     _ = ets:lookup(Tab, N),
<a name="do_heavy_concurrent_proc-last_expr"/><a name="6415"/> 6415: <b>    do_heavy_concurrent_proc</b>(Tab, N-1, Offs).
<a name="6416"/> 6416: 
<a name="6417"/> 6417: 
<a name="fold_empty-1"/><a name="6418"/> 6418: <b>fold_empty</b>(Config) when is_list(Config) -&gt;
<a name="6419"/> 6419:     repeat_for_opts_all_set_table_types(
<a name="6420"/> 6420:       fun(Opts) -&gt;
<a name="6421"/> 6421:               EtsMem = etsmem(),
<a name="6422"/> 6422:               Tab = make_table(a, Opts, []),
<a name="6423"/> 6423:               [] = ets:foldl(fun(_X) -&gt; exit(hej) end, [], Tab),
<a name="6424"/> 6424:               [] = ets:foldr(fun(_X) -&gt; exit(hej) end, [], Tab),
<a name="6425"/> 6425:               true = ets:delete(Tab),
<a name="6426"/> 6426:               verify_etsmem(EtsMem)
<a name="6427"/> 6427:       end),
<a name="fold_empty-last_expr"/><a name="6428"/> 6428:     ok.
<a name="6429"/> 6429: 
<a name="foldl-1"/><a name="6430"/> 6430: <b>foldl</b>(Config) when is_list(Config) -&gt;
<a name="6431"/> 6431:     repeat_for_opts_all_table_types(
<a name="6432"/> 6432:       fun(Opts) -&gt;
<a name="6433"/> 6433:               EtsMem = etsmem(),
<a name="6434"/> 6434:               L = [{a,1}, {c,3}, {b,2}],
<a name="6435"/> 6435:               LS = lists:sort(L),
<a name="6436"/> 6436:               Tab = make_table(a, Opts, L),
<a name="6437"/> 6437:               LS = lists:sort(ets:foldl(fun(E,A) -&gt; [E|A] end, [], Tab)),
<a name="6438"/> 6438:               true = ets:delete(Tab),
<a name="6439"/> 6439:               verify_etsmem(EtsMem)
<a name="6440"/> 6440:       end),
<a name="foldl-last_expr"/><a name="6441"/> 6441:     ok.
<a name="6442"/> 6442: 
<a name="foldr-1"/><a name="6443"/> 6443: <b>foldr</b>(Config) when is_list(Config) -&gt;
<a name="6444"/> 6444:     repeat_for_opts_all_table_types(
<a name="6445"/> 6445:       fun(Opts) -&gt;
<a name="6446"/> 6446:               EtsMem = etsmem(),
<a name="6447"/> 6447:               L = [{a,1}, {c,3}, {b,2}],
<a name="6448"/> 6448:               LS = lists:sort(L),
<a name="6449"/> 6449:               Tab = make_table(a, Opts, L),
<a name="6450"/> 6450:               LS = lists:sort(ets:foldr(fun(E,A) -&gt; [E|A] end, [], Tab)),
<a name="6451"/> 6451:               true = ets:delete(Tab),
<a name="6452"/> 6452:               verify_etsmem(EtsMem)
<a name="6453"/> 6453:       end),
<a name="foldr-last_expr"/><a name="6454"/> 6454:     ok.
<a name="6455"/> 6455: 
<a name="foldl_ordered-1"/><a name="6456"/> 6456: <b>foldl_ordered</b>(Config) when is_list(Config) -&gt;
<a name="6457"/> 6457:     repeat_for_opts_all_ord_set_table_types(
<a name="6458"/> 6458:       fun(Opts) -&gt;
<a name="6459"/> 6459:               EtsMem = etsmem(),
<a name="6460"/> 6460:               L = [{a,1}, {c,3}, {b,2}],
<a name="6461"/> 6461:               LS = lists:sort(L),
<a name="6462"/> 6462:               Tab = make_table(a, Opts, L),
<a name="6463"/> 6463:               LS = lists:reverse(ets:foldl(fun(E,A) -&gt; [E|A] end, [], Tab)),
<a name="6464"/> 6464:               true = ets:delete(Tab),
<a name="6465"/> 6465:               verify_etsmem(EtsMem)
<a name="6466"/> 6466:       end),
<a name="foldl_ordered-last_expr"/><a name="6467"/> 6467:     ok.
<a name="6468"/> 6468: 
<a name="foldr_ordered-1"/><a name="6469"/> 6469: <b>foldr_ordered</b>(Config) when is_list(Config) -&gt;
<a name="6470"/> 6470:     repeat_for_opts_all_ord_set_table_types(
<a name="6471"/> 6471:       fun(Opts) -&gt;
<a name="6472"/> 6472:               EtsMem = etsmem(),
<a name="6473"/> 6473:               L = [{a,1}, {c,3}, {b,2}],
<a name="6474"/> 6474:               LS = lists:sort(L),
<a name="6475"/> 6475:               Tab = make_table(a, Opts, L),
<a name="6476"/> 6476:               LS = ets:foldr(fun(E,A) -&gt; [E|A] end, [], Tab),
<a name="6477"/> 6477:               true = ets:delete(Tab),
<a name="6478"/> 6478:               verify_etsmem(EtsMem)
<a name="6479"/> 6479:       end),
<a name="foldr_ordered-last_expr"/><a name="6480"/> 6480:     ok.
<a name="6481"/> 6481: 
<a name="6482"/> 6482: <i>%% Test ets:member BIF.</i>
<a name="member-1"/><a name="6483"/> 6483: <b>member</b>(Config) when is_list(Config) -&gt;
<a name="member-last_expr"/><a name="6484"/> 6484: <b>    repeat_for_opts</b>(fun member_do/1, [write_concurrency, all_types]).
<a name="6485"/> 6485: 
<a name="member_do-1"/><a name="6486"/> 6486: <b>member_do</b>(Opts) -&gt;
<a name="6487"/> 6487:     EtsMem = etsmem(),
<a name="6488"/> 6488:     T = ets_new(xxx, Opts),
<a name="6489"/> 6489:     false = ets:member(T,hej),
<a name="6490"/> 6490:     E = fun(0,_F)-&gt;ok;
<a name="6491"/> 6491: 	   (N,F) -&gt;
<a name="6492"/> 6492: 		ets:insert(T,{N,N rem 10}),
<a name="6493"/> 6493: 		F(N-1,F)
<a name="6494"/> 6494: 	end,
<a name="6495"/> 6495:     E(10000,E),
<a name="6496"/> 6496:     false = ets:member(T,hej),
<a name="6497"/> 6497:     true = ets:member(T,1),
<a name="6498"/> 6498:     false = ets:member(T,20000),
<a name="6499"/> 6499:     ets:delete(T,5),
<a name="6500"/> 6500:     false = ets:member(T,5),
<a name="6501"/> 6501:     ets:safe_fixtable(T,true),
<a name="6502"/> 6502:     ets:delete(T,6),
<a name="6503"/> 6503:     false = ets:member(T,6),
<a name="6504"/> 6504:     ets:safe_fixtable(T,false),
<a name="6505"/> 6505:     false = ets:member(T,6),
<a name="6506"/> 6506:     ets:delete(T),
<a name="6507"/> 6507:     {'EXIT',{badarg,_}} = (catch ets:member(finnsinte, 23)),
<a name="6508"/> 6508:     {'EXIT',{badarg,_}} = (catch ets:member(T, 23)),
<a name="member_do-last_expr"/><a name="6509"/> 6509: <b>    verify_etsmem</b>(EtsMem).
<a name="6510"/> 6510: 
<a name="6511"/> 6511: 
<a name="build_table-3"/><a name="6512"/> 6512: <b>build_table</b>(L1,L2,Num) -&gt;
<a name="6513"/> 6513:     T = ets_new(xxx, [ordered_set]),
<a name="6514"/> 6514:     lists:foreach(
<a name="6515"/> 6515:       fun(X1) -&gt;
<a name="6516"/> 6516: 	      lists:foreach(
<a name="6517"/> 6517: 		fun(X2) -&gt;
<a name="6518"/> 6518: 			F = fun(FF,N) -&gt;
<a name="6519"/> 6519: 				    ets:insert(T,{{X1,X2,N}, X1, X2, N}),
<a name="6520"/> 6520: 				    case N of
<a name="6521"/> 6521: 					0 -&gt;
<a name="6522"/> 6522: 					    ok;
<a name="6523"/> 6523: 					_ -&gt;
<a name="6524"/> 6524: 					    FF(FF,N-1)
<a name="6525"/> 6525: 				    end
<a name="6526"/> 6526: 			    end,
<a name="6527"/> 6527: 			F(F,Num)
<a name="6528"/> 6528: 		end, L2)
<a name="6529"/> 6529:       end, L1),
<a name="build_table-last_expr"/><a name="6530"/> 6530:     T.
<a name="6531"/> 6531: 
<a name="build_table2-3"/><a name="6532"/> 6532: <b>build_table2</b>(L1,L2,Num) -&gt;
<a name="6533"/> 6533:     T = ets_new(xxx, [ordered_set]),
<a name="6534"/> 6534:     lists:foreach(
<a name="6535"/> 6535:       fun(X1) -&gt;
<a name="6536"/> 6536: 	      lists:foreach(
<a name="6537"/> 6537: 		fun(X2) -&gt;
<a name="6538"/> 6538: 			F = fun(FF,N) -&gt;
<a name="6539"/> 6539: 				    ets:insert(T,{{N,X1,X2}, N, X1, X2}),
<a name="6540"/> 6540: 				    case N of
<a name="6541"/> 6541: 					0 -&gt;
<a name="6542"/> 6542: 					    ok;
<a name="6543"/> 6543: 					_ -&gt;
<a name="6544"/> 6544: 					    FF(FF,N-1)
<a name="6545"/> 6545: 				    end
<a name="6546"/> 6546: 			    end,
<a name="6547"/> 6547: 			F(F,Num)
<a name="6548"/> 6548: 		end, L2)
<a name="6549"/> 6549:       end, L1),
<a name="build_table2-last_expr"/><a name="6550"/> 6550:     T.
<a name="6551"/> 6551: 
<a name="time_match_object-3"/><a name="6552"/> 6552: <b>time_match_object</b>(Tab,Match, Res) -&gt;
<a name="6553"/> 6553:     T1 = erlang:monotonic_time(microsecond),
<a name="6554"/> 6554:     Res = ets:match_object(Tab,Match),
<a name="6555"/> 6555:     T2 = erlang:monotonic_time(microsecond),
<a name="time_match_object-last_expr"/><a name="6556"/> 6556:     T2 - T1.
<a name="6557"/> 6557: 
<a name="time_match-2"/><a name="6558"/> 6558: <b>time_match</b>(Tab,Match) -&gt;
<a name="6559"/> 6559:     T1 = erlang:monotonic_time(microsecond),
<a name="6560"/> 6560:     ets:match(Tab,Match),
<a name="6561"/> 6561:     T2 = erlang:monotonic_time(microsecond),
<a name="time_match-last_expr"/><a name="6562"/> 6562:     T2 - T1.
<a name="6563"/> 6563: 
<a name="seventyfive_percent_success-4"/><a name="6564"/> 6564: <b>seventyfive_percent_success</b>(_,S,Fa,0) -&gt;
<a name="6565"/> 6565:     true = (S &gt; ((S + Fa) * 0.75));
<a name="6566"/> 6566: 
<a name="6567"/> 6567: <b>seventyfive_percent_success</b>(F, S, Fa, N) when is_function(F, 0) -&gt;
<a name="seventyfive_percent_success-last_expr"/><a name="6568"/> 6568: <b>    try F</b>() of
<a name="6569"/> 6569:         _ -&gt;
<a name="6570"/> 6570: 	    seventyfive_percent_success(F, S+1, Fa, N-1)
<a name="6571"/> 6571:     catch error:_ -&gt;
<a name="6572"/> 6572: 	    seventyfive_percent_success(F, S, Fa+1, N-1)
<a name="6573"/> 6573:     end.
<a name="6574"/> 6574: 
<a name="fifty_percent_success-4"/><a name="6575"/> 6575: <b>fifty_percent_success</b>(_,S,Fa,0) -&gt;
<a name="6576"/> 6576:     true = (S &gt; ((S + Fa) * 0.5));
<a name="6577"/> 6577: 
<a name="6578"/> 6578: <b>fifty_percent_success</b>(F, S, Fa, N) when is_function(F, 0) -&gt;
<a name="fifty_percent_success-last_expr"/><a name="6579"/> 6579: <b>    try F</b>() of
<a name="6580"/> 6580:         _ -&gt;
<a name="6581"/> 6581: 	    fifty_percent_success(F, S+1, Fa, N-1)
<a name="6582"/> 6582:     catch
<a name="6583"/> 6583:         error:_ -&gt;
<a name="6584"/> 6584: 	    fifty_percent_success(F, S, Fa+1, N-1)
<a name="6585"/> 6585:     end.
<a name="6586"/> 6586: 
<a name="create_random_string-1"/><a name="6587"/> 6587: <b>create_random_string</b>(0) -&gt;
<a name="6588"/> 6588:     [];
<a name="6589"/> 6589: 
<a name="6590"/> 6590: <b>create_random_string</b>(OfLength) -&gt;
<a name="6591"/> 6591:     C = case rand:uniform(2) of
<a name="6592"/> 6592: 	    1 -&gt;
<a name="6593"/> 6593: 		(rand:uniform($Z - $A + 1) - 1) + $A;
<a name="6594"/> 6594: 	    _ -&gt;
<a name="6595"/> 6595: 		(rand:uniform($z - $a + 1) - 1) + $a
<a name="6596"/> 6596: 	end,
<a name="create_random_string-last_expr"/><a name="6597"/> 6597: <b>    [C | create_random_string</b>(OfLength - 1)].
<a name="6598"/> 6598: 
<a name="6599"/> 6599: 
<a name="create_random_tuple-1"/><a name="6600"/> 6600: <b>create_random_tuple</b>(OfLength) -&gt;
<a name="create_random_tuple-last_expr"/><a name="6601"/> 6601: <b>    list_to_tuple</b>(lists:map(fun(X) -&gt;
<a name="6602"/> 6602: 				    list_to_atom([X])
<a name="6603"/> 6603: 			    end,create_random_string(OfLength))).
<a name="6604"/> 6604: 
<a name="create_partly_bound_tuple-1"/><a name="6605"/> 6605: <b>create_partly_bound_tuple</b>(OfLength) -&gt;
<a name="create_partly_bound_tuple-last_expr"/><a name="6606"/> 6606: <b>    case rand:uniform</b>(2) of
<a name="6607"/> 6607: 	1 -&gt;
<a name="6608"/> 6608: 	    create_partly_bound_tuple1(OfLength);
<a name="6609"/> 6609: 	_ -&gt;
<a name="6610"/> 6610: 	    create_partly_bound_tuple3(OfLength)
<a name="6611"/> 6611:     end.
<a name="6612"/> 6612: 
<a name="create_partly_bound_tuple1-1"/><a name="6613"/> 6613: <b>create_partly_bound_tuple1</b>(OfLength) -&gt;
<a name="6614"/> 6614:     T0 = create_random_tuple(OfLength),
<a name="6615"/> 6615:     I = rand:uniform(OfLength),
<a name="create_partly_bound_tuple1-last_expr"/><a name="6616"/> 6616: <b>    setelement</b>(I,T0,'$1').
<a name="6617"/> 6617: 
<a name="6618"/> 6618: 
<a name="set_n_random_elements-4"/><a name="6619"/> 6619: <b>set_n_random_elements</b>(T0,0,_,_) -&gt;
<a name="6620"/> 6620:     T0;
<a name="6621"/> 6621: <b>set_n_random_elements</b>(T0,N,OfLength,GenFun) -&gt;
<a name="6622"/> 6622:     I = rand:uniform(OfLength),
<a name="6623"/> 6623:     What = GenFun(I),
<a name="set_n_random_elements-last_expr"/><a name="6624"/> 6624: <b>    case element</b>(I,T0) of
<a name="6625"/> 6625: 	What -&gt;
<a name="6626"/> 6626: 	    set_n_random_elements(T0,N,OfLength,GenFun);
<a name="6627"/> 6627: 	_Else -&gt;
<a name="6628"/> 6628: 	    set_n_random_elements(setelement(I,T0,What),
<a name="6629"/> 6629: 				  N-1,OfLength,GenFun)
<a name="6630"/> 6630:     end.
<a name="6631"/> 6631: 
<a name="make_dollar_atom-1"/><a name="6632"/> 6632: <b>make_dollar_atom</b>(I) -&gt;
<a name="make_dollar_atom-last_expr"/><a name="6633"/> 6633: <b>    list_to_atom</b>([$$] ++ integer_to_list(I)).
<a name="create_partly_bound_tuple2-1"/><a name="6634"/> 6634: <b>create_partly_bound_tuple2</b>(OfLength) -&gt;
<a name="6635"/> 6635:     T0 = create_random_tuple(OfLength),
<a name="6636"/> 6636:     I = rand:uniform(OfLength - 1),
<a name="create_partly_bound_tuple2-last_expr"/><a name="6637"/> 6637: <b>    set_n_random_elements</b>(T0,I,OfLength,fun make_dollar_atom/1).
<a name="6638"/> 6638: 
<a name="create_partly_bound_tuple3-1"/><a name="6639"/> 6639: <b>create_partly_bound_tuple3</b>(OfLength) -&gt;
<a name="6640"/> 6640:     T0 = create_random_tuple(OfLength),
<a name="6641"/> 6641:     I = rand:uniform(OfLength - 1),
<a name="create_partly_bound_tuple3-last_expr"/><a name="6642"/> 6642: <b>    set_n_random_elements</b>(T0,I,OfLength,fun(_) -&gt; '_' end).
<a name="6643"/> 6643: 
<a name="do_n_times-2"/><a name="6644"/> 6644: <b>do_n_times</b>(_,0) -&gt;
<a name="6645"/> 6645:     ok;
<a name="6646"/> 6646: <b>do_n_times</b>(Fun,N) -&gt;
<a name="6647"/> 6647:     Fun(),
<a name="6648"/> 6648:     case N rem 1000 of
<a name="6649"/> 6649: 	0 -&gt;
<a name="6650"/> 6650: 	    io:format(&quot;.&quot;);
<a name="6651"/> 6651: 	_ -&gt;
<a name="6652"/> 6652: 	    ok
<a name="6653"/> 6653:     end,
<a name="do_n_times-last_expr"/><a name="6654"/> 6654: <b>    do_n_times</b>(Fun,N-1).
<a name="6655"/> 6655: 
<a name="make_table-3"/><a name="6656"/> 6656: <b>make_table</b>(Name, Options, Elements) -&gt;
<a name="6657"/> 6657:     T = ets_new(Name, Options),
<a name="6658"/> 6658:     lists:foreach(fun(E) -&gt; ets:insert(T, E) end, Elements),
<a name="make_table-last_expr"/><a name="6659"/> 6659:     T.
<a name="6660"/> 6660: 
<a name="filltabint-2"/><a name="6661"/> 6661: <b>filltabint</b>(Tab,0) -&gt;
<a name="6662"/> 6662:     Tab;
<a name="6663"/> 6663: <b>filltabint</b>(Tab,N) -&gt;
<a name="6664"/> 6664:     ets:insert(Tab,{N,integer_to_list(N)}),
<a name="filltabint-last_expr"/><a name="6665"/> 6665: <b>    filltabint</b>(Tab,N-1).
<a name="6666"/> 6666: 
<a name="filltabint2-2"/><a name="6667"/> 6667: <b>filltabint2</b>(Tab,0) -&gt;
<a name="6668"/> 6668:     Tab;
<a name="6669"/> 6669: <b>filltabint2</b>(Tab,N) -&gt;
<a name="6670"/> 6670:     ets:insert(Tab,{N + N rem 2,integer_to_list(N)}),
<a name="filltabint2-last_expr"/><a name="6671"/> 6671: <b>    filltabint2</b>(Tab,N-1).
<a name="filltabint3-2"/><a name="6672"/> 6672: <b>filltabint3</b>(Tab,0) -&gt;
<a name="6673"/> 6673:     Tab;
<a name="6674"/> 6674: <b>filltabint3</b>(Tab,N) -&gt;
<a name="6675"/> 6675:     ets:insert(Tab,{N + N rem 2,integer_to_list(N + N rem 2)}),
<a name="filltabint3-last_expr"/><a name="6676"/> 6676: <b>    filltabint3</b>(Tab,N-1).
<a name="xfilltabint-2"/><a name="6677"/> 6677: <b>xfilltabint</b>(Tab,N) -&gt;
<a name="xfilltabint-last_expr"/><a name="6678"/> 6678: <b>    case ets:info</b>(Tab,type) of
<a name="6679"/> 6679: 	bag -&gt;
<a name="6680"/> 6680: 	    filltabint2(Tab,N);
<a name="6681"/> 6681: 	duplicate_bag -&gt;
<a name="6682"/> 6682: 	    ets:select_delete(Tab,[{'_',[],[true]}]),
<a name="6683"/> 6683: 	    filltabint3(Tab,N);
<a name="6684"/> 6684: 	_ -&gt;
<a name="6685"/> 6685: 	    filltabint(Tab,N)
<a name="6686"/> 6686:     end.
<a name="6687"/> 6687: 
<a name="filltabintup-2"/><a name="6688"/> 6688: <b>filltabintup</b>(Tab,0) -&gt;
<a name="6689"/> 6689:     Tab;
<a name="6690"/> 6690: <b>filltabintup</b>(Tab,N) -&gt;
<a name="6691"/> 6691:     ets:insert(Tab,{{N,integer_to_list(N)},integer_to_list(N)}),
<a name="filltabintup-last_expr"/><a name="6692"/> 6692: <b>    filltabintup</b>(Tab,N-1).
<a name="6693"/> 6693: 
<a name="filltabintup2-2"/><a name="6694"/> 6694: <b>filltabintup2</b>(Tab,0) -&gt;
<a name="6695"/> 6695:     Tab;
<a name="6696"/> 6696: <b>filltabintup2</b>(Tab,N) -&gt;
<a name="6697"/> 6697:     ets:insert(Tab,{{N + N rem 2,integer_to_list(N)},integer_to_list(N)}),
<a name="filltabintup2-last_expr"/><a name="6698"/> 6698: <b>    filltabintup2</b>(Tab,N-1).
<a name="filltabintup3-2"/><a name="6699"/> 6699: <b>filltabintup3</b>(Tab,0) -&gt;
<a name="6700"/> 6700:     Tab;
<a name="6701"/> 6701: <b>filltabintup3</b>(Tab,N) -&gt;
<a name="6702"/> 6702:     ets:insert(Tab,{{N + N rem 2,integer_to_list(N + N rem 2)},integer_to_list(N + N rem 2)}),
<a name="filltabintup3-last_expr"/><a name="6703"/> 6703: <b>    filltabintup3</b>(Tab,N-1).
<a name="6704"/> 6704: 
<a name="filltabstr-2"/><a name="6705"/> 6705: <b>filltabstr</b>(Tab,N) -&gt;
<a name="filltabstr-last_expr"/><a name="6706"/> 6706: <b>    filltabstr</b>(Tab,0,N).
<a name="filltabstr-3"/><a name="6707"/> 6707: <b>filltabstr</b>(Tab,N,N) -&gt;
<a name="6708"/> 6708:     Tab;
<a name="6709"/> 6709: <b>filltabstr</b>(Tab,Floor,N) when N &gt; Floor -&gt;
<a name="6710"/> 6710:     ets:insert(Tab,{integer_to_list(N),N}),
<a name="filltabstr-last_expr"/><a name="6711"/> 6711: <b>    filltabstr</b>(Tab,Floor,N-1).
<a name="6712"/> 6712: 
<a name="filltabstr2-2"/><a name="6713"/> 6713: <b>filltabstr2</b>(Tab,0) -&gt;
<a name="6714"/> 6714:     Tab;
<a name="6715"/> 6715: <b>filltabstr2</b>(Tab,N) -&gt;
<a name="6716"/> 6716:     ets:insert(Tab,{integer_to_list(N),N}),
<a name="6717"/> 6717:     ets:insert(Tab,{integer_to_list(N),N+1}),
<a name="filltabstr2-last_expr"/><a name="6718"/> 6718: <b>    filltabstr2</b>(Tab,N-1).
<a name="filltabstr3-2"/><a name="6719"/> 6719: <b>filltabstr3</b>(Tab,0) -&gt;
<a name="6720"/> 6720:     Tab;
<a name="6721"/> 6721: <b>filltabstr3</b>(Tab,N) -&gt;
<a name="6722"/> 6722:     ets:insert(Tab,{integer_to_list(N),N}),
<a name="6723"/> 6723:     ets:insert(Tab,{integer_to_list(N),N}),
<a name="filltabstr3-last_expr"/><a name="6724"/> 6724: <b>    filltabstr3</b>(Tab,N-1).
<a name="xfilltabstr-2"/><a name="6725"/> 6725: <b>xfilltabstr</b>(Tab,N) -&gt;
<a name="xfilltabstr-last_expr"/><a name="6726"/> 6726: <b>    case ets:info</b>(Tab,type) of
<a name="6727"/> 6727: 	bag -&gt;
<a name="6728"/> 6728: 	    filltabstr2(Tab,N);
<a name="6729"/> 6729: 	duplicate_bag -&gt;
<a name="6730"/> 6730: 	    ets:select_delete(Tab,[{'_',[],[true]}]),
<a name="6731"/> 6731: 	    filltabstr3(Tab,N);
<a name="6732"/> 6732: 	_ -&gt;
<a name="6733"/> 6733: 	    filltabstr(Tab,N)
<a name="6734"/> 6734:     end.
<a name="6735"/> 6735: 
<a name="fill_sets_int-1"/><a name="6736"/> 6736: <b>fill_sets_int</b>(N) -&gt;
<a name="fill_sets_int-last_expr"/><a name="6737"/> 6737: <b>    fill_sets_int</b>(N,[]).
<a name="fill_sets_int-2"/><a name="6738"/> 6738: <b>fill_sets_int</b>(N,Opts) -&gt;
<a name="6739"/> 6739:     Tab1 = ets_new(xxx,
<a name="6740"/> 6740:                    replace_dbg_hash_fixed_nr_of_locks([ordered_set|Opts])),
<a name="6741"/> 6741:     filltabint(Tab1,N),
<a name="6742"/> 6742:     Tab2 = ets_new(xxx, [set|Opts]),
<a name="6743"/> 6743:     filltabint(Tab2,N),
<a name="6744"/> 6744:     Tab3 = ets_new(xxx, [bag|Opts]),
<a name="6745"/> 6745:     filltabint2(Tab3,N),
<a name="6746"/> 6746:     Tab4 = ets_new(xxx, [duplicate_bag|Opts]),
<a name="6747"/> 6747:     filltabint3(Tab4,N),
<a name="fill_sets_int-last_expr"/><a name="6748"/> 6748:     [Tab1,Tab2,Tab3,Tab4].
<a name="6749"/> 6749: 
<a name="fill_sets_intup-2"/><a name="6750"/> 6750: <b>fill_sets_intup</b>(N,Opts) -&gt;
<a name="6751"/> 6751:     Tab1 = ets_new(xxx,
<a name="6752"/> 6752:                    replace_dbg_hash_fixed_nr_of_locks([ordered_set|Opts])),
<a name="6753"/> 6753:     filltabintup(Tab1,N),
<a name="6754"/> 6754:     Tab2 = ets_new(xxx, [set|Opts]),
<a name="6755"/> 6755:     filltabintup(Tab2,N),
<a name="6756"/> 6756:     Tab3 = ets_new(xxx, [bag|Opts]),
<a name="6757"/> 6757:     filltabintup2(Tab3,N),
<a name="6758"/> 6758:     Tab4 = ets_new(xxx, [duplicate_bag|Opts]),
<a name="6759"/> 6759:     filltabintup3(Tab4,N),
<a name="fill_sets_intup-last_expr"/><a name="6760"/> 6760:     [Tab1,Tab2,Tab3,Tab4].
<a name="6761"/> 6761: 
<a name="check_fun-3"/><a name="6762"/> 6762: <b>check_fun</b>(_Tab,_Fun,'$end_of_table') -&gt;
<a name="6763"/> 6763:     ok;
<a name="6764"/> 6764: <b>check_fun</b>(Tab,Fun,Item) -&gt;
<a name="6765"/> 6765:     lists:foreach(fun(Obj) -&gt;
<a name="6766"/> 6766: 			  true = Fun(Obj)
<a name="6767"/> 6767: 		  end,
<a name="6768"/> 6768: 		  ets:lookup(Tab,Item)),
<a name="check_fun-last_expr"/><a name="6769"/> 6769: <b>    check_fun</b>(Tab,Fun,ets:next(Tab,Item)).
<a name="6770"/> 6770: 
<a name="check-3"/><a name="6771"/> 6771: <b>check</b>(Tab,Fun,N) -&gt;
<a name="6772"/> 6772:     N = ets:info(Tab, size),
<a name="check-last_expr"/><a name="6773"/> 6773: <b>    check_fun</b>(Tab,Fun,ets:first(Tab)).
<a name="6774"/> 6774: 
<a name="6775"/> 6775: 
<a name="6776"/> 6776: 
<a name="del_one_by_one_set-3"/><a name="6777"/> 6777: <b>del_one_by_one_set</b>(T,N,N) -&gt;
<a name="6778"/> 6778:     0 = ets:info(T,size),
<a name="6779"/> 6779:     ok;
<a name="6780"/> 6780: <b>del_one_by_one_set</b>(T,From,To) -&gt;
<a name="6781"/> 6781:     N = ets:info(T,size),
<a name="6782"/> 6782:     ets:delete_object(T,{From, integer_to_list(From)}),
<a name="6783"/> 6783:     N = (ets:info(T,size) + 1),
<a name="6784"/> 6784:     Next = if
<a name="6785"/> 6785: 	       From &lt; To -&gt;
<a name="6786"/> 6786: 		   From + 1;
<a name="6787"/> 6787: 	       true -&gt;
<a name="6788"/> 6788: 		   From - 1
<a name="6789"/> 6789: 	   end,
<a name="del_one_by_one_set-last_expr"/><a name="6790"/> 6790: <b>    del_one_by_one_set</b>(T,Next,To).
<a name="6791"/> 6791: 
<a name="del_one_by_one_bag-3"/><a name="6792"/> 6792: <b>del_one_by_one_bag</b>(T,N,N) -&gt;
<a name="6793"/> 6793:     0 = ets:info(T,size),
<a name="6794"/> 6794:     ok;
<a name="6795"/> 6795: <b>del_one_by_one_bag</b>(T,From,To) -&gt;
<a name="6796"/> 6796:     N = ets:info(T,size),
<a name="6797"/> 6797:     ets:delete_object(T,{From + From rem 2, integer_to_list(From)}),
<a name="6798"/> 6798:     N = (ets:info(T,size) + 1),
<a name="6799"/> 6799:     Next = if
<a name="6800"/> 6800: 	       From &lt; To -&gt;
<a name="6801"/> 6801: 		   From + 1;
<a name="6802"/> 6802: 	       true -&gt;
<a name="6803"/> 6803: 		   From - 1
<a name="6804"/> 6804: 	   end,
<a name="del_one_by_one_bag-last_expr"/><a name="6805"/> 6805: <b>    del_one_by_one_bag</b>(T,Next,To).
<a name="6806"/> 6806: 
<a name="6807"/> 6807: 
<a name="del_one_by_one_dbag_1-3"/><a name="6808"/> 6808: <b>del_one_by_one_dbag_1</b>(T,N,N) -&gt;
<a name="6809"/> 6809:     0 = ets:info(T,size),
<a name="6810"/> 6810:     ok;
<a name="6811"/> 6811: <b>del_one_by_one_dbag_1</b>(T,From,To) -&gt;
<a name="6812"/> 6812:     N = ets:info(T,size),
<a name="6813"/> 6813:     ets:delete_object(T,{From, integer_to_list(From)}),
<a name="6814"/> 6814:     case From rem 2 of
<a name="6815"/> 6815: 	0 -&gt;
<a name="6816"/> 6816: 	    N = (ets:info(T,size) + 2);
<a name="6817"/> 6817: 	1 -&gt;
<a name="6818"/> 6818: 	    N = ets:info(T,size)
<a name="6819"/> 6819:     end,
<a name="6820"/> 6820:     Next = if
<a name="6821"/> 6821: 	       From &lt; To -&gt;
<a name="6822"/> 6822: 		   From + 1;
<a name="6823"/> 6823: 	       true -&gt;
<a name="6824"/> 6824: 		   From - 1
<a name="6825"/> 6825: 	   end,
<a name="del_one_by_one_dbag_1-last_expr"/><a name="6826"/> 6826: <b>    del_one_by_one_dbag_1</b>(T,Next,To).
<a name="6827"/> 6827: 
<a name="del_one_by_one_dbag_2-3"/><a name="6828"/> 6828: <b>del_one_by_one_dbag_2</b>(T,N,N) -&gt;
<a name="6829"/> 6829:     0 = ets:info(T,size),
<a name="6830"/> 6830:     ok;
<a name="6831"/> 6831: <b>del_one_by_one_dbag_2</b>(T,From,To) -&gt;
<a name="6832"/> 6832:     N = ets:info(T,size),
<a name="6833"/> 6833:     ets:delete_object(T,{From, integer_to_list(From)}),
<a name="6834"/> 6834:     case From rem 2 of
<a name="6835"/> 6835: 	0 -&gt;
<a name="6836"/> 6836: 	    N = (ets:info(T,size) + 3);
<a name="6837"/> 6837: 	1 -&gt;
<a name="6838"/> 6838: 	    N = (ets:info(T,size) + 1)
<a name="6839"/> 6839:     end,
<a name="6840"/> 6840:     Next = if
<a name="6841"/> 6841: 	       From &lt; To -&gt;
<a name="6842"/> 6842: 		   From + 1;
<a name="6843"/> 6843: 	       true -&gt;
<a name="6844"/> 6844: 		   From - 1
<a name="6845"/> 6845: 	   end,
<a name="del_one_by_one_dbag_2-last_expr"/><a name="6846"/> 6846: <b>    del_one_by_one_dbag_2</b>(T,Next,To).
<a name="6847"/> 6847: 
<a name="del_one_by_one_dbag_3-3"/><a name="6848"/> 6848: <b>del_one_by_one_dbag_3</b>(T,N,N) -&gt;
<a name="6849"/> 6849:     0 = ets:info(T,size),
<a name="6850"/> 6850:     ok;
<a name="6851"/> 6851: <b>del_one_by_one_dbag_3</b>(T,From,To) -&gt;
<a name="6852"/> 6852:     N = ets:info(T,size),
<a name="6853"/> 6853:     Obj = {From + From rem 2, integer_to_list(From)},
<a name="6854"/> 6854:     ets:delete_object(T,Obj),
<a name="6855"/> 6855:     case From rem 2 of
<a name="6856"/> 6856: 	0 -&gt;
<a name="6857"/> 6857: 	    N = (ets:info(T,size) + 2);
<a name="6858"/> 6858: 	1 -&gt;
<a name="6859"/> 6859: 	    N = (ets:info(T,size) + 1),
<a name="6860"/> 6860: 	    Obj2 = {From, integer_to_list(From)},
<a name="6861"/> 6861: 	    ets:delete_object(T,Obj2),
<a name="6862"/> 6862: 	    N = (ets:info(T,size) + 2)
<a name="6863"/> 6863:     end,
<a name="6864"/> 6864:     Next = if
<a name="6865"/> 6865: 	       From &lt; To -&gt;
<a name="6866"/> 6866: 		   From + 1;
<a name="6867"/> 6867: 	       true -&gt;
<a name="6868"/> 6868: 		   From - 1
<a name="6869"/> 6869: 	   end,
<a name="del_one_by_one_dbag_3-last_expr"/><a name="6870"/> 6870: <b>    del_one_by_one_dbag_3</b>(T,Next,To).
<a name="6871"/> 6871: 
<a name="6872"/> 6872: 
<a name="successive_delete-4"/><a name="6873"/> 6873: <b>successive_delete</b>(Table,From,To,Type) -&gt;
<a name="successive_delete-last_expr"/><a name="6874"/> 6874: <b>    successive_delete</b>(Table,From,To,Type,ets:info(Table,type)).
<a name="6875"/> 6875: 
<a name="successive_delete-5"/><a name="6876"/> 6876: <b>successive_delete</b>(_Table,N,N,_,_) -&gt;
<a name="6877"/> 6877:     ok;
<a name="6878"/> 6878: <b>successive_delete</b>(Table,From,To,Type,TType) -&gt;
<a name="6879"/> 6879:     MS = case Type of
<a name="6880"/> 6880: 	     bound -&gt;
<a name="6881"/> 6881: 		 [{{From,'_'},[],[true]}];
<a name="6882"/> 6882: 	     unbound -&gt;
<a name="6883"/> 6883: 		 [{{'$1','_'},[],[{'==', '$1', From}]}]
<a name="6884"/> 6884: 	 end,
<a name="6885"/> 6885:     case TType of
<a name="6886"/> 6886: 	X when X == bag; X == duplicate_bag -&gt;
<a name="6887"/> 6887: 	    %%erlang:display(From),
<a name="6888"/> 6888: 	    case From rem 2 of
<a name="6889"/> 6889: 		0 -&gt;
<a name="6890"/> 6890: 		    2 = ets:select_delete(Table,MS);
<a name="6891"/> 6891: 		_ -&gt;
<a name="6892"/> 6892: 		    0 = ets:select_delete(Table,MS)
<a name="6893"/> 6893: 	    end;
<a name="6894"/> 6894: 	_ -&gt;
<a name="6895"/> 6895: 	    1 = ets:select_delete(Table,MS)
<a name="6896"/> 6896:     end,
<a name="6897"/> 6897:     Next = if
<a name="6898"/> 6898: 	       From &lt; To -&gt;
<a name="6899"/> 6899: 		   From + 1;
<a name="6900"/> 6900: 	       true -&gt;
<a name="6901"/> 6901: 		   From - 1
<a name="6902"/> 6902: 	   end,
<a name="successive_delete-last_expr"/><a name="6903"/> 6903: <b>    successive_delete</b>(Table, Next, To, Type,TType).
<a name="6904"/> 6904: 
<a name="gen_dets_filename-2"/><a name="6905"/> 6905: <b>gen_dets_filename</b>(Config,N) -&gt;
<a name="gen_dets_filename-last_expr"/><a name="6906"/> 6906: <b>    filename:join</b>(proplists:get_value(priv_dir,Config),
<a name="6907"/> 6907: 		  &quot;testdets_&quot; ++ integer_to_list(N) ++ &quot;.dets&quot;).
<a name="6908"/> 6908: 
<a name="otp_6842_select_1000-1"/><a name="6909"/> 6909: <b>otp_6842_select_1000</b>(Config) when is_list(Config) -&gt;
<a name="6910"/> 6910:     repeat_for_opts_all_ord_set_table_types(
<a name="6911"/> 6911:       fun(Opts) -&gt;
<a name="6912"/> 6912:               KeyRange = 10000,
<a name="6913"/> 6913:               Tab = ets_new(xxx, Opts, KeyRange),
<a name="6914"/> 6914:               [ets:insert(Tab,{X,X}) || X &lt;- lists:seq(1,KeyRange)],
<a name="6915"/> 6915:               AllTrue = lists:duplicate(10,true),
<a name="6916"/> 6916:               AllTrue =
<a name="6917"/> 6917:                   [ length(
<a name="6918"/> 6918:                       element(1,
<a name="6919"/> 6919:                               ets:select(Tab,[{'_',[],['$_']}],X*1000))) =:=
<a name="6920"/> 6920:                         X*1000 || X &lt;- lists:seq(1,10) ],
<a name="6921"/> 6921:               Sequences = [[1000,1000,1000,1000,1000,1000,1000,1000,1000,1000],
<a name="6922"/> 6922:                            [2000,2000,2000,2000,2000],
<a name="6923"/> 6923:                            [3000,3000,3000,1000],
<a name="6924"/> 6924:                            [4000,4000,2000],
<a name="6925"/> 6925:                            [5000,5000],
<a name="6926"/> 6926:                            [6000,4000],
<a name="6927"/> 6927:                            [7000,3000],
<a name="6928"/> 6928:                            [8000,2000],
<a name="6929"/> 6929:                            [9000,1000],
<a name="6930"/> 6930:                            [10000]],
<a name="6931"/> 6931:               AllTrue = [ check_seq(Tab, ets:select(Tab,[{'_',[],['$_']}],hd(L)),L) ||
<a name="6932"/> 6932:                             L &lt;- Sequences ],
<a name="6933"/> 6933:               ets:delete(Tab)
<a name="6934"/> 6934:       end),
<a name="otp_6842_select_1000-last_expr"/><a name="6935"/> 6935:     ok.
<a name="6936"/> 6936: 
<a name="check_seq-3"/><a name="6937"/> 6937: <b>check_seq</b>(_,'$end_of_table',[]) -&gt;
<a name="6938"/> 6938:     true;
<a name="6939"/> 6939: <b>check_seq</b>(Tab,{L,C},[H|T]) when length(L) =:= H -&gt;
<a name="6940"/> 6940:     check_seq(Tab, ets:select(C),T);
<a name="6941"/> 6941: <b>check_seq</b>(A,B,C) -&gt;
<a name="6942"/> 6942:     erlang:display({A,B,C}),
<a name="check_seq-last_expr"/><a name="6943"/> 6943:     false.
<a name="6944"/> 6944: 
<a name="otp_6338-1"/><a name="6945"/> 6945: <b>otp_6338</b>(Config) when is_list(Config) -&gt;
<a name="6946"/> 6946:     repeat_for_opts_all_ord_set_table_types(
<a name="6947"/> 6947:       fun(Opts) -&gt;
<a name="6948"/> 6948:               L = binary_to_term(&lt;&lt;131,108,0,0,0,2,104,2,108,0,0,0,2,103,100,0,19,112,112,
<a name="6949"/> 6949:                                    98,49,95,98,115,49,50,64,98,108,97,100,101,95,48,95,53,
<a name="6950"/> 6950:                                    0,0,33,50,0,0,0,4,1,98,0,0,23,226,106,100,0,4,101,120,
<a name="6951"/> 6951:                                    105,116,104,2,108,0,0,0,2,104,2,100,0,3,115,98,109,100,
<a name="6952"/> 6952:                                    0,19,112,112,98,50,95,98,115,49,50,64,98,108,97,100,
<a name="6953"/> 6953:                                    101,95,48,95,56,98,0,0,18,231,106,100,0,4,114,101,99,
<a name="6954"/> 6954:                                    118,106&gt;&gt;),
<a name="6955"/> 6955:               T = ets_new(xxx,Opts),
<a name="6956"/> 6956:               lists:foreach(fun(X) -&gt; ets:insert(T,X) end,L),
<a name="6957"/> 6957:               [[4839,recv]] = ets:match(T,{[{sbm,ppb2_bs12@blade_0_8},'$1'],'$2'}),
<a name="6958"/> 6958:               ets:delete(T)
<a name="6959"/> 6959:       end),
<a name="otp_6338-last_expr"/><a name="6960"/> 6960:     ok.
<a name="6961"/> 6961: 
<a name="6962"/> 6962: <i>%% OTP-15660: Verify select not doing excessive trapping</i>
<a name="6963"/> 6963: <i>%%            when process have mbuf heap fragments.</i>
<a name="select_mbuf_trapping-1"/><a name="6964"/> 6964: <b>select_mbuf_trapping</b>(Config) when is_list(Config) -&gt;
<a name="6965"/> 6965:     select_mbuf_trapping_do(set),
<a name="select_mbuf_trapping-last_expr"/><a name="6966"/> 6966: <b>    select_mbuf_trapping_do</b>(ordered_set).
<a name="6967"/> 6967: 
<a name="select_mbuf_trapping_do-1"/><a name="6968"/> 6968: <b>select_mbuf_trapping_do</b>(Type) -&gt;
<a name="6969"/> 6969:     T = ets:new(xxx, [Type]),
<a name="6970"/> 6970:     NKeys = 50,
<a name="6971"/> 6971:     [ets:insert(T, {K, value}) || K &lt;- lists:seq(1,NKeys)],
<a name="6972"/> 6972: 
<a name="6973"/> 6973:     {priority, Prio} = process_info(self(), priority),
<a name="6974"/> 6974:     Tracee = self(),
<a name="6975"/> 6975:     [SchedTracer]
<a name="6976"/> 6976: 	= start_loopers(1, Prio,
<a name="6977"/> 6977: 			fun (SC) -&gt;
<a name="6978"/> 6978: 				receive
<a name="6979"/> 6979: 				    {trace, Tracee, out, _} -&gt;
<a name="6980"/> 6980: 					SC+1;
<a name="6981"/> 6981: 				    done -&gt;
<a name="6982"/> 6982: 					Tracee ! {schedule_count, SC},
<a name="6983"/> 6983:                                         exit(normal)
<a name="6984"/> 6984: 				end
<a name="6985"/> 6985: 			end,
<a name="6986"/> 6986: 			0),
<a name="6987"/> 6987: 
<a name="6988"/> 6988:     erlang:garbage_collect(),
<a name="6989"/> 6989:     1 = erlang:trace(self(), true, [running,{tracer,SchedTracer}]),
<a name="6990"/> 6990: 
<a name="6991"/> 6991:     %% Artificially create an mbuf heap fragment
<a name="6992"/> 6992:     MbufTerm = &quot;Frag me up&quot;,
<a name="6993"/> 6993:     MbufTerm = erts_debug:set_internal_state(mbuf, MbufTerm),
<a name="6994"/> 6994: 
<a name="6995"/> 6995:     Keys = ets:select(T, [{{'$1', value}, [], ['$1']}]),
<a name="6996"/> 6996:     NKeys = length(Keys),
<a name="6997"/> 6997: 
<a name="6998"/> 6998:     1 = erlang:trace(self(), false, [running]),
<a name="6999"/> 6999:     Ref = erlang:trace_delivered(Tracee),
<a name="7000"/> 7000:     receive
<a name="7001"/> 7001:         {trace_delivered, Tracee, Ref} -&gt;
<a name="7002"/> 7002:             SchedTracer ! done
<a name="7003"/> 7003:     end,
<a name="7004"/> 7004:     receive
<a name="7005"/> 7005: 	{schedule_count, N} -&gt;
<a name="7006"/> 7006: 	    io:format(&quot;~p context switches: ~p&quot;, [Type,N]),
<a name="7007"/> 7007: 	    if
<a name="7008"/> 7008: 		N &lt; 3 -&gt; ok;
<a name="7009"/> 7009: 		true -&gt; ct:fail(failed)
<a name="7010"/> 7010: 	    end
<a name="7011"/> 7011:     end,
<a name="7012"/> 7012:     true = ets:delete(T),
<a name="select_mbuf_trapping_do-last_expr"/><a name="7013"/> 7013:     ok.
<a name="7014"/> 7014: 
<a name="7015"/> 7015: 
<a name="7016"/> 7016: 
<a name="7017"/> 7017: <i>%% Elements could come in the wrong order in a bag if a rehash occurred.</i>
<a name="otp_5340-1"/><a name="7018"/> 7018: <b>otp_5340</b>(Config) when is_list(Config) -&gt;
<a name="otp_5340-last_expr"/><a name="7019"/> 7019: <b>    repeat_for_opts</b>(fun otp_5340_do/1).
<a name="7020"/> 7020: 
<a name="otp_5340_do-1"/><a name="7021"/> 7021: <b>otp_5340_do</b>(Opts) -&gt;
<a name="7022"/> 7022:     N = 3000,
<a name="7023"/> 7023:     T = ets_new(otp_5340, [bag,public | Opts]),
<a name="7024"/> 7024:     Ids = [1,2,3,4,5],
<a name="7025"/> 7025:     [w(T, N, Id) || Id &lt;- Ids],
<a name="7026"/> 7026:     verify(T, Ids),
<a name="otp_5340_do-last_expr"/><a name="7027"/> 7027: <b>    ets:delete</b>(T).
<a name="7028"/> 7028: 
<a name="w-3"/><a name="7029"/> 7029: <b>w</b>(_,0, _) -&gt; ok;
<a name="7030"/> 7030: <b>w</b>(T,N, Id) -&gt;
<a name="7031"/> 7031:     ets:insert(T, {N, Id}),
<a name="w-last_expr"/><a name="7032"/> 7032: <b>    w</b>(T,N-1,Id).
<a name="7033"/> 7033: 
<a name="verify-2"/><a name="7034"/> 7034: <b>verify</b>(T, Ids) -&gt;
<a name="7035"/> 7035:     List = my_tab_to_list(T),
<a name="7036"/> 7036:     Errors = lists:filter(fun(Bucket) -&gt;
<a name="7037"/> 7037: 				  verify2(Bucket, Ids)
<a name="7038"/> 7038: 			  end, List),
<a name="verify-last_expr"/><a name="7039"/> 7039:     case Errors of
<a name="7040"/> 7040: 	[] -&gt;
<a name="7041"/> 7041: 	    ok;
<a name="7042"/> 7042: 	_ -&gt;
<a name="7043"/> 7043: 	    io:format(&quot;Failed:\n~p\n&quot;, [Errors]),
<a name="7044"/> 7044: 	    ct:fail(failed)
<a name="7045"/> 7045:     end.
<a name="7046"/> 7046: 
<a name="verify2-2"/><a name="7047"/> 7047: <b>verify2</b>([{_N,Id}|RL], [Id|R]) -&gt;
<a name="7048"/> 7048:     verify2(RL,R);
<a name="7049"/> 7049: <b>verify2</b>([],[]) -&gt; false;
<a name="7050"/> 7050: <b>verify2</b>(_Err, _) -&gt;
<a name="verify2-last_expr"/><a name="7051"/> 7051:     true.
<a name="7052"/> 7052: 
<a name="7053"/> 7053: <i>%% delete_object followed by delete on fixed bag failed to delete objects.</i>
<a name="otp_7665-1"/><a name="7054"/> 7054: <b>otp_7665</b>(Config) when is_list(Config) -&gt;
<a name="otp_7665-last_expr"/><a name="7055"/> 7055: <b>    repeat_for_opts</b>(fun otp_7665_do/1).
<a name="7056"/> 7056: 
<a name="otp_7665_do-1"/><a name="7057"/> 7057: <b>otp_7665_do</b>(Opts) -&gt;
<a name="7058"/> 7058:     Tab = ets_new(otp_7665,[bag | Opts]),
<a name="7059"/> 7059:     Min = 0,
<a name="7060"/> 7060:     Max = 10,
<a name="7061"/> 7061:     lists:foreach(fun(N)-&gt; otp_7665_act(Tab,Min,Max,N) end,
<a name="7062"/> 7062: 		  lists:seq(Min,Max)),
<a name="otp_7665_do-last_expr"/><a name="7063"/> 7063: <b>    true = ets:delete</b>(Tab).
<a name="7064"/> 7064: 
<a name="otp_7665_act-4"/><a name="7065"/> 7065: <b>otp_7665_act</b>(Tab,Min,Max,DelNr) -&gt;
<a name="7066"/> 7066:     List1 = [{key,N} || N &lt;- lists:seq(Min,Max)],
<a name="7067"/> 7067:     true = ets:insert(Tab, List1),
<a name="7068"/> 7068:     true = ets:safe_fixtable(Tab, true),
<a name="7069"/> 7069:     true = ets:delete_object(Tab, {key,DelNr}),
<a name="7070"/> 7070:     List2 = lists:sort(lists:delete({key,DelNr}, List1)),
<a name="7071"/> 7071: 
<a name="7072"/> 7072:     %% Now verify that we find all remaining objects
<a name="7073"/> 7073:     List2 = lists:sort(ets:lookup(Tab,key)),
<a name="7074"/> 7074:     EList2 = lists:sort(lists:map(fun({key,N})-&gt; N end,
<a name="7075"/> 7075:                                   List2)),
<a name="7076"/> 7076:     EList2 = lists:sort(ets:lookup_element(Tab,key,2)),
<a name="7077"/> 7077:     true = ets:delete(Tab, key),
<a name="7078"/> 7078:     [] = ets:lookup(Tab, key),
<a name="7079"/> 7079:     true = ets:safe_fixtable(Tab, false),
<a name="otp_7665_act-last_expr"/><a name="7080"/> 7080:     ok.
<a name="7081"/> 7081: 
<a name="7082"/> 7082: <i>%% Whitebox testing of meta name table hashing.</i>
<a name="meta_wb-1"/><a name="7083"/> 7083: <b>meta_wb</b>(Config) when is_list(Config) -&gt;
<a name="7084"/> 7084:     EtsMem = etsmem(),
<a name="7085"/> 7085:     repeat_for_opts_all_non_stim_table_types(fun meta_wb_do/1),
<a name="meta_wb-last_expr"/><a name="7086"/> 7086: <b>    verify_etsmem</b>(EtsMem).
<a name="7087"/> 7087: 
<a name="7088"/> 7088: 
<a name="meta_wb_do-1"/><a name="7089"/> 7089: <b>meta_wb_do</b>(Opts) -&gt;
<a name="7090"/> 7090:     %% Do random new/delete/rename of colliding named tables
<a name="7091"/> 7091:     Names0 = [pioneer | colliding_names(pioneer)],
<a name="7092"/> 7092: 
<a name="7093"/> 7093:     %% Remove any names that happen to exist as tables already
<a name="7094"/> 7094:     Names = lists:filter(fun(Name) -&gt; ets:info(Name) == undefined end,
<a name="7095"/> 7095:                          Names0),
<a name="7096"/> 7096:     Len = length(Names),
<a name="7097"/> 7097:     OpFuns = {fun meta_wb_new/4, fun meta_wb_delete/4, fun meta_wb_rename/4},
<a name="7098"/> 7098: 
<a name="7099"/> 7099:     true = (Len &gt;= 3),
<a name="7100"/> 7100: 
<a name="7101"/> 7101:     io:format(&quot;Colliding names = ~p\n&quot;,[Names]),
<a name="7102"/> 7102:     F = fun(0,_,_) -&gt; ok;
<a name="7103"/> 7103: 	   (N,Tabs,Me) -&gt;
<a name="7104"/> 7104: 		Name1 = lists:nth(rand:uniform(Len), Names),
<a name="7105"/> 7105: 		Name2 = lists:nth(rand:uniform(Len), Names),
<a name="7106"/> 7106: 		Op = element(rand:uniform(3),OpFuns),
<a name="7107"/> 7107: 		NTabs = Op(Name1, Name2, Tabs, Opts),
<a name="7108"/> 7108: 		Me(N-1, NTabs, Me)
<a name="7109"/> 7109: 	end,
<a name="7110"/> 7110:     F(Len*100, [], F),
<a name="7111"/> 7111: 
<a name="7112"/> 7112:     %% cleanup
<a name="meta_wb_do-last_expr"/><a name="7113"/> 7113: <b>    lists:foreach</b>(fun(Name)-&gt;catch ets:delete(Name) end,
<a name="7114"/> 7114: 		  Names).
<a name="7115"/> 7115: 
<a name="meta_wb_new-4"/><a name="7116"/> 7116: <b>meta_wb_new</b>(Name, _, Tabs, Opts) -&gt;
<a name="meta_wb_new-last_expr"/><a name="7117"/> 7117: <b>    case </b>(catch ets_new(Name,[named_table|Opts])) of
<a name="7118"/> 7118: 	Name -&gt;
<a name="7119"/> 7119: 	    false = lists:member(Name, Tabs),
<a name="7120"/> 7120: 	    [Name | Tabs];
<a name="7121"/> 7121: 	{'EXIT',{badarg,_}} -&gt;
<a name="7122"/> 7122: 	    true = lists:member(Name, Tabs),
<a name="7123"/> 7123: 	    Tabs
<a name="7124"/> 7124:     end.
<a name="meta_wb_delete-4"/><a name="7125"/> 7125: <b>meta_wb_delete</b>(Name, _, Tabs, _) -&gt;
<a name="meta_wb_delete-last_expr"/><a name="7126"/> 7126: <b>    case </b>(catch ets:delete(Name)) of
<a name="7127"/> 7127: 	true -&gt;
<a name="7128"/> 7128: 	    true = lists:member(Name, Tabs),
<a name="7129"/> 7129: 	    lists:delete(Name, Tabs);
<a name="7130"/> 7130: 	{'EXIT',{badarg,_}} -&gt;
<a name="7131"/> 7131: 	    false = lists:member(Name, Tabs),
<a name="7132"/> 7132: 	    Tabs
<a name="7133"/> 7133:     end.
<a name="meta_wb_rename-4"/><a name="7134"/> 7134: <b>meta_wb_rename</b>(Old, New, Tabs, _) -&gt;
<a name="meta_wb_rename-last_expr"/><a name="7135"/> 7135: <b>    case </b>(catch ets:rename(Old,New)) of
<a name="7136"/> 7136: 	New -&gt;
<a name="7137"/> 7137: 	    true = lists:member(Old, Tabs)
<a name="7138"/> 7138: 		andalso not lists:member(New, Tabs),
<a name="7139"/> 7139: 	    [New | lists:delete(Old, Tabs)];
<a name="7140"/> 7140: 	{'EXIT',{badarg,_}} -&gt;
<a name="7141"/> 7141: 	    true = not lists:member(Old, Tabs)
<a name="7142"/> 7142: 		orelse lists:member(New,Tabs),
<a name="7143"/> 7143: 	    Tabs
<a name="7144"/> 7144:     end.
<a name="7145"/> 7145: 
<a name="7146"/> 7146: 
<a name="colliding_names-1"/><a name="7147"/> 7147: <b>colliding_names</b>(Name) -&gt;
<a name="colliding_names-last_expr"/><a name="7148"/> 7148: <b>    erts_debug:set_internal_state</b>(colliding_names, {Name,5}).
<a name="7149"/> 7149: 
<a name="7150"/> 7150: 
<a name="7151"/> 7151: <i>%% OTP_6913: Grow and shrink.</i>
<a name="7152"/> 7152: 
<a name="grow_shrink-1"/><a name="7153"/> 7153: <b>grow_shrink</b>(Config) when is_list(Config) -&gt;
<a name="grow_shrink-last_expr"/><a name="7154"/> 7154: <b>    repeat_for_all_set_table_types</b>(
<a name="7155"/> 7155:       fun(Opts) -&gt;
<a name="7156"/> 7156:               EtsMem = etsmem(),
<a name="7157"/> 7157: 
<a name="7158"/> 7158:               Set = ets_new(a, Opts, 5000),
<a name="7159"/> 7159:               grow_shrink_0(0, 3071, 3000, 5000, Set),
<a name="7160"/> 7160:               ets:delete(Set),
<a name="7161"/> 7161: 
<a name="7162"/> 7162:               verify_etsmem(EtsMem)
<a name="7163"/> 7163:       end).
<a name="7164"/> 7164: 
<a name="grow_shrink_0-5"/><a name="7165"/> 7165: <b>grow_shrink_0</b>(N, _, _, Max, _) when N &gt;= Max -&gt;
<a name="7166"/> 7166:     ok;
<a name="7167"/> 7167: <b>grow_shrink_0</b>(N0, GrowN, ShrinkN, Max, T) -&gt;
<a name="7168"/> 7168:     N1 = grow_shrink_1(N0, GrowN, ShrinkN, T),
<a name="grow_shrink_0-last_expr"/><a name="7169"/> 7169: <b>    grow_shrink_0</b>(N1, GrowN, ShrinkN, Max, T).
<a name="7170"/> 7170: 
<a name="grow_shrink_1-4"/><a name="7171"/> 7171: <b>grow_shrink_1</b>(N0, GrowN, ShrinkN, T) -&gt;
<a name="7172"/> 7172:     N1 = grow_shrink_2(N0+1, N0 + GrowN, T),
<a name="grow_shrink_1-last_expr"/><a name="7173"/> 7173: <b>    grow_shrink_3</b>(N1, N1 - ShrinkN, T).
<a name="7174"/> 7174: 
<a name="grow_shrink_2-3"/><a name="7175"/> 7175: <b>grow_shrink_2</b>(N, GrowTo, _) when N &gt; GrowTo -&gt;
<a name="7176"/> 7176:     GrowTo;
<a name="7177"/> 7177: <b>grow_shrink_2</b>(N, GrowTo, T) -&gt;
<a name="7178"/> 7178:     true = ets:insert(T, {N,a}),
<a name="grow_shrink_2-last_expr"/><a name="7179"/> 7179: <b>    grow_shrink_2</b>(N+1, GrowTo, T).
<a name="7180"/> 7180: 
<a name="grow_shrink_3-3"/><a name="7181"/> 7181: <b>grow_shrink_3</b>(N, ShrinkTo, _) when N =&lt; ShrinkTo -&gt;
<a name="7182"/> 7182:     ShrinkTo;
<a name="7183"/> 7183: <b>grow_shrink_3</b>(N, ShrinkTo, T) -&gt;
<a name="7184"/> 7184:     true = ets:delete(T, N),
<a name="grow_shrink_3-last_expr"/><a name="7185"/> 7185: <b>    grow_shrink_3</b>(N-1, ShrinkTo, T).
<a name="7186"/> 7186: 
<a name="7187"/> 7187: <i>%% Grow a hash table that still contains pseudo-deleted objects.</i>
<a name="grow_pseudo_deleted-1"/><a name="7188"/> 7188: <b>grow_pseudo_deleted</b>(Config) when is_list(Config) -&gt;
<a name="grow_pseudo_deleted-last_expr"/><a name="7189"/> 7189: <b>    only_if_smp</b>(fun() -&gt; grow_pseudo_deleted_do() end).
<a name="7190"/> 7190: 
<a name="grow_pseudo_deleted_do-0"/><a name="7191"/> 7191: <b>grow_pseudo_deleted_do</b>() -&gt;
<a name="grow_pseudo_deleted_do-last_expr"/><a name="7192"/> 7192: <b>    lists:foreach</b>(fun(Type) -&gt; grow_pseudo_deleted_do(Type) end,
<a name="7193"/> 7193: 		  [set,bag,duplicate_bag]).
<a name="7194"/> 7194: 
<a name="grow_pseudo_deleted_do-1"/><a name="7195"/> 7195: <b>grow_pseudo_deleted_do</b>(Type) -&gt;
<a name="7196"/> 7196:     process_flag(scheduler,1),
<a name="7197"/> 7197:     Self = self(),
<a name="7198"/> 7198:     T = ets_new(kalle,[Type,public,{write_concurrency,true}]),
<a name="7199"/> 7199:     Mod = 7, Mult = 10000,
<a name="7200"/> 7200:     filltabint(T,Mod*Mult),
<a name="7201"/> 7201:     true = ets:safe_fixtable(T,true),
<a name="7202"/> 7202:     Mult = ets:select_delete(T,
<a name="7203"/> 7203: 			     [{{'$1', '_'},
<a name="7204"/> 7204: 			       [{'=:=', {'rem', '$1', Mod}, 0}],
<a name="7205"/> 7205: 			       [true]}]),
<a name="7206"/> 7206:     Left = Mult*(Mod-1),
<a name="7207"/> 7207:     Left = ets:info(T,size),
<a name="7208"/> 7208:     Mult = get_kept_objects(T),
<a name="7209"/> 7209:     filltabstr(T,Mult),
<a name="7210"/> 7210:     my_spawn_opt(
<a name="7211"/> 7211:       fun() -&gt;
<a name="7212"/> 7212: 	      true = ets:info(T,fixed),
<a name="7213"/> 7213: 	      Self ! start,
<a name="7214"/> 7214: 	      io:put_chars(&quot;Starting to filltabstr...\n&quot;),
<a name="7215"/> 7215: 	      do_tc(fun() -&gt;
<a name="7216"/> 7216: 			    filltabstr(T, Mult, Mult+10000)
<a name="7217"/> 7217: 		    end,
<a name="7218"/> 7218: 		    fun(Elapsed) -&gt;
<a name="7219"/> 7219: 			    io:format(&quot;Done with filltabstr in ~p ms\n&quot;,
<a name="7220"/> 7220: 				      [Elapsed])
<a name="7221"/> 7221: 		    end),
<a name="7222"/> 7222: 	      Self ! done
<a name="7223"/> 7223:       end, [link, {scheduler,2}]),
<a name="7224"/> 7224:     start = receive_any(),
<a name="7225"/> 7225:     io:format(&quot;Unfixing table... nitems=~p\n&quot;, [ets:info(T, size)]),
<a name="7226"/> 7226:     do_tc(fun() -&gt;
<a name="7227"/> 7227: 		  true = ets:safe_fixtable(T, false)
<a name="7228"/> 7228: 	  end,
<a name="7229"/> 7229: 	  fun(Elapsed) -&gt;
<a name="7230"/> 7230: 		  io:format(&quot;Unfix table done in ~p ms. nitems=~p\n&quot;,
<a name="7231"/> 7231: 			    [Elapsed,ets:info(T, size)])
<a name="7232"/> 7232: 	  end),
<a name="7233"/> 7233:     false = ets:info(T,fixed),
<a name="7234"/> 7234:     0 = get_kept_objects(T),
<a name="7235"/> 7235:     done = receive_any(),
<a name="7236"/> 7236:     %%verify_table_load(T), % may fail if concurrency is poor (genny)
<a name="7237"/> 7237:     ets:delete(T),
<a name="grow_pseudo_deleted_do-last_expr"/><a name="7238"/> 7238: <b>    process_flag</b>(scheduler,0).
<a name="7239"/> 7239: 
<a name="7240"/> 7240: <i>%% Shrink a hash table that still contains pseudo-deleted objects.</i>
<a name="shrink_pseudo_deleted-1"/><a name="7241"/> 7241: <b>shrink_pseudo_deleted</b>(Config) when is_list(Config) -&gt;
<a name="shrink_pseudo_deleted-last_expr"/><a name="7242"/> 7242: <b>    only_if_smp</b>(fun()-&gt;shrink_pseudo_deleted_do() end).
<a name="7243"/> 7243: 
<a name="shrink_pseudo_deleted_do-0"/><a name="7244"/> 7244: <b>shrink_pseudo_deleted_do</b>() -&gt;
<a name="shrink_pseudo_deleted_do-last_expr"/><a name="7245"/> 7245: <b>    lists:foreach</b>(fun(Type) -&gt; shrink_pseudo_deleted_do(Type) end,
<a name="7246"/> 7246: 		  [set,bag,duplicate_bag]).
<a name="7247"/> 7247: 
<a name="shrink_pseudo_deleted_do-1"/><a name="7248"/> 7248: <b>shrink_pseudo_deleted_do</b>(Type) -&gt;
<a name="7249"/> 7249:     process_flag(scheduler,1),
<a name="7250"/> 7250:     Self = self(),
<a name="7251"/> 7251:     T = ets_new(kalle,[Type,public,{write_concurrency,true}]),
<a name="7252"/> 7252:     Half = 10000,
<a name="7253"/> 7253:     filltabint(T,Half*2),
<a name="7254"/> 7254:     true = ets:safe_fixtable(T,true),
<a name="7255"/> 7255:     Half = ets:select_delete(T,
<a name="7256"/> 7256: 			     [{{'$1', '_'},
<a name="7257"/> 7257: 			       [{'&gt;', '$1', Half}],
<a name="7258"/> 7258: 			       [true]}]),
<a name="7259"/> 7259:     Half = ets:info(T,size),
<a name="7260"/> 7260:     Half = get_kept_objects(T),
<a name="7261"/> 7261:     my_spawn_opt(
<a name="7262"/> 7262:       fun()-&gt; true = ets:info(T,fixed),
<a name="7263"/> 7263: 	      Self ! start,
<a name="7264"/> 7264: 	      io:put_chars(&quot;Starting to delete... ~p\n&quot;),
<a name="7265"/> 7265: 	      do_tc(fun() -&gt;
<a name="7266"/> 7266: 			    del_one_by_one_set(T, 1, Half+1)
<a name="7267"/> 7267: 		    end,
<a name="7268"/> 7268: 		    fun(Elapsed) -&gt;
<a name="7269"/> 7269: 			    io:format(&quot;Done with delete in ~p ms.\n&quot;,
<a name="7270"/> 7270: 				      [Elapsed])
<a name="7271"/> 7271: 		    end),
<a name="7272"/> 7272: 	      Self ! done
<a name="7273"/> 7273:       end, [link, {scheduler,2}]),
<a name="7274"/> 7274:     start = receive_any(),
<a name="7275"/> 7275:     io:format(&quot;Unfixing table... nitems=~p\n&quot;, [ets:info(T, size)]),
<a name="7276"/> 7276:     do_tc(fun() -&gt;
<a name="7277"/> 7277: 		  true = ets:safe_fixtable(T, false)
<a name="7278"/> 7278: 	  end,
<a name="7279"/> 7279: 	  fun(Elapsed) -&gt;
<a name="7280"/> 7280: 		  io:format(&quot;Unfix table done in ~p ms. nitems=~p\n&quot;,
<a name="7281"/> 7281: 			    [Elapsed,ets:info(T, size)])
<a name="7282"/> 7282: 	  end),
<a name="7283"/> 7283:     false = ets:info(T,fixed),
<a name="7284"/> 7284:     0 = get_kept_objects(T),
<a name="7285"/> 7285:     done = receive_any(),
<a name="7286"/> 7286:     %%verify_table_load(T), % may fail if concurrency is poor (genny)
<a name="7287"/> 7287:     ets:delete(T),
<a name="shrink_pseudo_deleted_do-last_expr"/><a name="7288"/> 7288: <b>    process_flag</b>(scheduler,0).
<a name="7289"/> 7289: 
<a name="7290"/> 7290: 
<a name="7291"/> 7291: 
<a name="meta_lookup_unnamed_read-1"/><a name="7292"/> 7292: <b>meta_lookup_unnamed_read</b>(Config) when is_list(Config) -&gt;
<a name="7293"/> 7293:     InitF = fun(_) -&gt; Tab = ets_new(unnamed,[]),
<a name="7294"/> 7294: 		      true = ets:insert(Tab,{key,data}),
<a name="7295"/> 7295: 		      Tab
<a name="7296"/> 7296: 	    end,
<a name="7297"/> 7297:     ExecF = fun(Tab) -&gt; [{key,data}] = ets:lookup(Tab,key),
<a name="7298"/> 7298: 			Tab
<a name="7299"/> 7299: 	    end,
<a name="7300"/> 7300:     FiniF = fun(Tab) -&gt; true = ets:delete(Tab)
<a name="7301"/> 7301: 	    end,
<a name="meta_lookup_unnamed_read-last_expr"/><a name="7302"/> 7302: <b>    run_smp_workers</b>(InitF,ExecF,FiniF,10000).
<a name="7303"/> 7303: 
<a name="meta_lookup_unnamed_write-1"/><a name="7304"/> 7304: <b>meta_lookup_unnamed_write</b>(Config) when is_list(Config) -&gt;
<a name="7305"/> 7305:     InitF = fun(_) -&gt; Tab = ets_new(unnamed,[]),
<a name="7306"/> 7306: 		      {Tab,0}
<a name="7307"/> 7307: 	    end,
<a name="7308"/> 7308:     ExecF = fun({Tab,N}) -&gt; true = ets:insert(Tab,{key,N}),
<a name="7309"/> 7309: 			    {Tab,N+1}
<a name="7310"/> 7310: 	    end,
<a name="7311"/> 7311:     FiniF = fun({Tab,_}) -&gt; true = ets:delete(Tab)
<a name="7312"/> 7312: 	    end,
<a name="meta_lookup_unnamed_write-last_expr"/><a name="7313"/> 7313: <b>    run_smp_workers</b>(InitF,ExecF,FiniF,10000).
<a name="7314"/> 7314: 
<a name="meta_lookup_named_read-1"/><a name="7315"/> 7315: <b>meta_lookup_named_read</b>(Config) when is_list(Config) -&gt;
<a name="7316"/> 7316:     InitF = fun([ProcN|_]) -&gt; Name = list_to_atom(integer_to_list(ProcN)),
<a name="7317"/> 7317: 			      Tab = ets_new(Name,[named_table]),
<a name="7318"/> 7318: 			      true = ets:insert(Tab,{key,data}),
<a name="7319"/> 7319: 			      Tab
<a name="7320"/> 7320: 	    end,
<a name="7321"/> 7321:     ExecF = fun(Tab) -&gt; [{key,data}] = ets:lookup(Tab,key),
<a name="7322"/> 7322: 			Tab
<a name="7323"/> 7323: 	    end,
<a name="7324"/> 7324:     FiniF = fun(Tab) -&gt; true = ets:delete(Tab)
<a name="7325"/> 7325: 	    end,
<a name="meta_lookup_named_read-last_expr"/><a name="7326"/> 7326: <b>    run_smp_workers</b>(InitF,ExecF,FiniF,10000).
<a name="7327"/> 7327: 
<a name="meta_lookup_named_write-1"/><a name="7328"/> 7328: <b>meta_lookup_named_write</b>(Config) when is_list(Config) -&gt;
<a name="7329"/> 7329:     InitF = fun([ProcN|_]) -&gt; Name = list_to_atom(integer_to_list(ProcN)),
<a name="7330"/> 7330: 			      Tab = ets_new(Name,[named_table]),
<a name="7331"/> 7331: 			      {Tab,0}
<a name="7332"/> 7332: 	    end,
<a name="7333"/> 7333:     ExecF = fun({Tab,N}) -&gt; true = ets:insert(Tab,{key,N}),
<a name="7334"/> 7334: 			    {Tab,N+1}
<a name="7335"/> 7335: 	    end,
<a name="7336"/> 7336:     FiniF = fun({Tab,_}) -&gt; true = ets:delete(Tab)
<a name="7337"/> 7337: 	    end,
<a name="meta_lookup_named_write-last_expr"/><a name="7338"/> 7338: <b>    run_smp_workers</b>(InitF,ExecF,FiniF,10000).
<a name="7339"/> 7339: 
<a name="meta_newdel_unnamed-1"/><a name="7340"/> 7340: <b>meta_newdel_unnamed</b>(Config) when is_list(Config) -&gt;
<a name="7341"/> 7341:     InitF = fun(_) -&gt; ok end,
<a name="7342"/> 7342:     ExecF = fun(_) -&gt; Tab = ets_new(unnamed,[]),
<a name="7343"/> 7343: 		      true = ets:delete(Tab)
<a name="7344"/> 7344: 	    end,
<a name="7345"/> 7345:     FiniF = fun(_) -&gt; ok end,
<a name="meta_newdel_unnamed-last_expr"/><a name="7346"/> 7346: <b>    run_smp_workers</b>(InitF,ExecF,FiniF,10000).
<a name="7347"/> 7347: 
<a name="meta_newdel_named-1"/><a name="7348"/> 7348: <b>meta_newdel_named</b>(Config) when is_list(Config) -&gt;
<a name="7349"/> 7349:     InitF = fun([ProcN|_]) -&gt; list_to_atom(integer_to_list(ProcN))
<a name="7350"/> 7350: 	    end,
<a name="7351"/> 7351:     ExecF = fun(Name) -&gt; Name = ets_new(Name,[named_table]),
<a name="7352"/> 7352: 			 true = ets:delete(Name),
<a name="7353"/> 7353: 			 Name
<a name="7354"/> 7354: 	    end,
<a name="7355"/> 7355:     FiniF = fun(_) -&gt; ok end,
<a name="meta_newdel_named-last_expr"/><a name="7356"/> 7356: <b>    run_smp_workers</b>(InitF,ExecF,FiniF,10000).
<a name="7357"/> 7357: 
<a name="7358"/> 7358: <i>%% Concurrent insert's on same table.</i>
<a name="smp_insert-1"/><a name="7359"/> 7359: <b>smp_insert</b>(Config) when is_list(Config) -&gt;
<a name="smp_insert-last_expr"/><a name="7360"/> 7360: <b>    repeat_for_opts</b>(fun smp_insert_do/1,
<a name="7361"/> 7361:                     [[set,ordered_set,stim_cat_ord_set]]).
<a name="7362"/> 7362: 
<a name="smp_insert_do-1"/><a name="7363"/> 7363: <b>smp_insert_do</b>(Opts) -&gt;
<a name="7364"/> 7364:     KeyRange = 10000,
<a name="7365"/> 7365:     ets_new(smp_insert,[named_table,public,{write_concurrency,true}|Opts],
<a name="7366"/> 7366:             KeyRange),
<a name="7367"/> 7367:     InitF = fun(_) -&gt; ok end,
<a name="7368"/> 7368:     ExecF = fun(_) -&gt; true = ets:insert(smp_insert,{rand:uniform(KeyRange)})
<a name="7369"/> 7369:             end,
<a name="7370"/> 7370:     FiniF = fun(_) -&gt; ok end,
<a name="7371"/> 7371:     run_smp_workers(InitF,ExecF,FiniF,100000),
<a name="7372"/> 7372:     verify_table_load(smp_insert),
<a name="smp_insert_do-last_expr"/><a name="7373"/> 7373: <b>    ets:delete</b>(smp_insert).
<a name="7374"/> 7374: 
<a name="7375"/> 7375: <i>%% Concurrent deletes on same fixated table.</i>
<a name="smp_fixed_delete-1"/><a name="7376"/> 7376: <b>smp_fixed_delete</b>(Config) when is_list(Config) -&gt;
<a name="smp_fixed_delete-last_expr"/><a name="7377"/> 7377: <b>    only_if_smp</b>(fun() -&gt; smp_fixed_delete_do() end).
<a name="7378"/> 7378: 
<a name="smp_fixed_delete_do-0"/><a name="7379"/> 7379: <b>smp_fixed_delete_do</b>() -&gt;
<a name="7380"/> 7380:     T = ets_new(foo,[public,{write_concurrency,true}]),
<a name="7381"/> 7381:     %%Mem = ets:info(T,memory),
<a name="7382"/> 7382:     NumOfObjs = 100000,
<a name="7383"/> 7383:     filltabint(T,NumOfObjs),
<a name="7384"/> 7384:     ets:safe_fixtable(T,true),
<a name="7385"/> 7385:     Buckets = num_of_buckets(T),
<a name="7386"/> 7386:     InitF = fun([ProcN,NumOfProcs|_]) -&gt; {ProcN,NumOfProcs} end,
<a name="7387"/> 7387:     ExecF = fun({Key,_}) when Key &gt; NumOfObjs -&gt;
<a name="7388"/> 7388:                     [end_of_work];
<a name="7389"/> 7389:                ({Key,Increment}) -&gt;
<a name="7390"/> 7390:                     true = ets:delete(T,Key),
<a name="7391"/> 7391:                     {Key+Increment,Increment}
<a name="7392"/> 7392:             end,
<a name="7393"/> 7393:     FiniF = fun(_) -&gt; ok end,
<a name="7394"/> 7394:     run_sched_workers(InitF,ExecF,FiniF,NumOfObjs),
<a name="7395"/> 7395:     0 = ets:info(T,size),
<a name="7396"/> 7396:     true = ets:info(T,fixed),
<a name="7397"/> 7397:     Buckets = num_of_buckets(T),
<a name="7398"/> 7398:     case ets:info(T,type) of
<a name="7399"/> 7399:         set -&gt; NumOfObjs = get_kept_objects(T);
<a name="7400"/> 7400:         _ -&gt; ok
<a name="7401"/> 7401:     end,
<a name="7402"/> 7402:     ets:safe_fixtable(T,false),
<a name="7403"/> 7403:     %% Will fail as unfix does not shrink the table:
<a name="7404"/> 7404:     %%Mem = ets:info(T,memory),
<a name="7405"/> 7405:     %%verify_table_load(T),
<a name="smp_fixed_delete_do-last_expr"/><a name="7406"/> 7406: <b>    ets:delete</b>(T).
<a name="7407"/> 7407: 
<a name="7408"/> 7408: <i>%% ERL-720</i>
<a name="7409"/> 7409: <i>%% Provoke race between ets:delete and table unfix (by select_count)</i>
<a name="7410"/> 7410: <i>%% that caused ets_misc memory counter to indicate false leak.</i>
<a name="delete_unfix_race-1"/><a name="7411"/> 7411: <b>delete_unfix_race</b>(Config) when is_list(Config) -&gt;
<a name="7412"/> 7412:     EtsMem = etsmem(),
<a name="7413"/> 7413:     Table = ets:new(t,[set,public,{write_concurrency,true}]),
<a name="7414"/> 7414:     InsertOp =
<a name="7415"/> 7415:         fun() -&gt;
<a name="7416"/> 7416:                 receive stop -&gt;
<a name="7417"/> 7417:                         false
<a name="7418"/> 7418:                 after 0 -&gt;
<a name="7419"/> 7419:                         ets:insert(Table, {rand:uniform(10)}),
<a name="7420"/> 7420:                         true
<a name="7421"/> 7421:                 end
<a name="7422"/> 7422:         end,
<a name="7423"/> 7423:     DeleteOp =
<a name="7424"/> 7424:         fun() -&gt;
<a name="7425"/> 7425:                 receive stop -&gt;
<a name="7426"/> 7426:                         false
<a name="7427"/> 7427:                 after 0 -&gt;
<a name="7428"/> 7428:                         ets:delete(Table, rand:uniform(10)),
<a name="7429"/> 7429:                         true
<a name="7430"/> 7430:                 end
<a name="7431"/> 7431:         end,
<a name="7432"/> 7432:     SelectOp =
<a name="7433"/> 7433:         fun() -&gt;
<a name="7434"/> 7434:                 ets:select_count(Table, ets:fun2ms(fun(X) -&gt; true end))
<a name="7435"/> 7435:         end,
<a name="7436"/> 7436:     Main = self(),
<a name="7437"/> 7437:     Ins = spawn(fun()-&gt; repeat_while(InsertOp), Main ! self() end),
<a name="7438"/> 7438:     Del = spawn(fun()-&gt; repeat_while(DeleteOp), Main ! self() end),
<a name="7439"/> 7439:     spawn(fun()-&gt;
<a name="7440"/> 7440:                   repeat(SelectOp, 10000),
<a name="7441"/> 7441:                   Del ! stop,
<a name="7442"/> 7442:                   Ins ! stop
<a name="7443"/> 7443:           end),
<a name="7444"/> 7444:     [receive Pid -&gt; ok end || Pid &lt;- [Ins,Del]],
<a name="7445"/> 7445:     ets:delete(Table),
<a name="delete_unfix_race-last_expr"/><a name="7446"/> 7446: <b>    verify_etsmem</b>(EtsMem).
<a name="7447"/> 7447: 
<a name="num_of_buckets-1"/><a name="7448"/> 7448: <b>num_of_buckets</b>(T) -&gt;
<a name="num_of_buckets-last_expr"/><a name="7449"/> 7449: <b>    case ets:info</b>(T,type) of
<a name="7450"/> 7450:         set -&gt; element(1,ets:info(T,stats));
<a name="7451"/> 7451:         bag -&gt; element(1,ets:info(T,stats));
<a name="7452"/> 7452:         duplicate_bag -&gt; element(1,ets:info(T,stats));
<a name="7453"/> 7453:         _ -&gt; ok
<a name="7454"/> 7454:     end.
<a name="7455"/> 7455: 
<a name="7456"/> 7456: <i>%% Fixate hash table while other process is busy doing unfix.</i>
<a name="smp_unfix_fix-1"/><a name="7457"/> 7457: <b>smp_unfix_fix</b>(Config) when is_list(Config) -&gt;
<a name="smp_unfix_fix-last_expr"/><a name="7458"/> 7458: <b>    only_if_smp</b>(fun()-&gt; smp_unfix_fix_do() end).
<a name="7459"/> 7459: 
<a name="smp_unfix_fix_do-0"/><a name="7460"/> 7460: <b>smp_unfix_fix_do</b>() -&gt;
<a name="7461"/> 7461:     process_flag(scheduler,1),
<a name="7462"/> 7462:     Parent = self(),
<a name="7463"/> 7463:     T = ets_new(foo,[public,{write_concurrency,true}]),
<a name="7464"/> 7464:     %%Mem = ets:info(T,memory),
<a name="7465"/> 7465:     NumOfObjs = 100000,
<a name="7466"/> 7466:     Deleted = 50000,
<a name="7467"/> 7467:     filltabint(T,NumOfObjs),
<a name="7468"/> 7468:     ets:safe_fixtable(T,true),
<a name="7469"/> 7469:     Buckets = num_of_buckets(T),
<a name="7470"/> 7470:     Deleted = ets:select_delete(T,[{{'$1', '_'},
<a name="7471"/> 7471: 				    [{'=&lt;','$1', Deleted}],
<a name="7472"/> 7472: 				    [true]}]),
<a name="7473"/> 7473:     Buckets = num_of_buckets(T),
<a name="7474"/> 7474:     Left = NumOfObjs - Deleted,
<a name="7475"/> 7475:     Left = ets:info(T,size),
<a name="7476"/> 7476:     true = ets:info(T,fixed),
<a name="7477"/> 7477:     Deleted = get_kept_objects(T),
<a name="7478"/> 7478: 
<a name="7479"/> 7479:     {Child, Mref} =
<a name="7480"/> 7480: 	my_spawn_opt(
<a name="7481"/> 7481: 	  fun()-&gt;
<a name="7482"/> 7482: 		  true = ets:info(T,fixed),
<a name="7483"/> 7483: 		  Parent ! start,
<a name="7484"/> 7484: 		  io:format(&quot;Child waiting for table to be unfixed... mem=~p\n&quot;,
<a name="7485"/> 7485: 			    [ets:info(T, memory)]),
<a name="7486"/> 7486: 		  do_tc(fun() -&gt;
<a name="7487"/> 7487: 				repeat_while(fun()-&gt; ets:info(T, fixed) end)
<a name="7488"/> 7488: 			end,
<a name="7489"/> 7489: 			fun(Elapsed) -&gt;
<a name="7490"/> 7490: 				io:format(&quot;Table unfixed in ~p ms.&quot;
<a name="7491"/> 7491: 					  &quot; Child Fixating! mem=~p\n&quot;,
<a name="7492"/> 7492: 					  [Elapsed,ets:info(T,memory)])
<a name="7493"/> 7493: 			end),
<a name="7494"/> 7494: 		  true = ets:safe_fixtable(T,true),
<a name="7495"/> 7495: 		  repeat_while(fun(Key) when Key =&lt; NumOfObjs -&gt;
<a name="7496"/> 7496: 				       ets:delete(T,Key), {true,Key+1};
<a name="7497"/> 7497: 				  (Key) -&gt; {false,Key}
<a name="7498"/> 7498: 			       end,
<a name="7499"/> 7499: 			       Deleted),
<a name="7500"/> 7500: 		  0 = ets:info(T,size),
<a name="7501"/> 7501: 		  true = get_kept_objects(T) &gt;= Left,
<a name="7502"/> 7502: 		  done = receive_any()
<a name="7503"/> 7503: 	  end,
<a name="7504"/> 7504: 	  [link, monitor, {scheduler,2}]),
<a name="7505"/> 7505: 
<a name="7506"/> 7506:     start = receive_any(),
<a name="7507"/> 7507:     true = ets:info(T,fixed),
<a name="7508"/> 7508:     io:put_chars(&quot;Parent starting to unfix... ~p\n&quot;),
<a name="7509"/> 7509:     do_tc(fun() -&gt;
<a name="7510"/> 7510: 		  ets:safe_fixtable(T, false)
<a name="7511"/> 7511: 	  end,
<a name="7512"/> 7512: 	  fun(Elapsed) -&gt;
<a name="7513"/> 7513: 		  io:format(&quot;Parent done with unfix in ~p ms.\n&quot;,
<a name="7514"/> 7514: 			    [Elapsed])
<a name="7515"/> 7515: 	  end),
<a name="7516"/> 7516:     Child ! done,
<a name="7517"/> 7517:     {'DOWN', Mref, process, Child, normal} = receive_any(),
<a name="7518"/> 7518:     false = ets:info(T,fixed),
<a name="7519"/> 7519:     0 = get_kept_objects(T),
<a name="7520"/> 7520:     %%verify_table_load(T),
<a name="7521"/> 7521:     ets:delete(T),
<a name="smp_unfix_fix_do-last_expr"/><a name="7522"/> 7522: <b>    process_flag</b>(scheduler,0).
<a name="7523"/> 7523: 
<a name="7524"/> 7524: <i>%% Unsafe unfix was done by trapping select/match.</i>
<a name="otp_8166-1"/><a name="7525"/> 7525: <b>otp_8166</b>(Config) when is_list(Config) -&gt;
<a name="otp_8166-last_expr"/><a name="7526"/> 7526: <b>    only_if_smp</b>(3, fun()-&gt; otp_8166_do(false),
<a name="7527"/> 7527: 			   otp_8166_do(true)
<a name="7528"/> 7528: 		   end).
<a name="7529"/> 7529: 
<a name="otp_8166_do-1"/><a name="7530"/> 7530: <b>otp_8166_do</b>(WC) -&gt;
<a name="7531"/> 7531:     %% Bug scenario: One process segv while reading the table because another
<a name="7532"/> 7532:     %% process is doing unfix without write-lock at the end of a trapping match_object.
<a name="7533"/> 7533:     process_flag(scheduler,1),
<a name="7534"/> 7534:     T = ets_new(foo,[public, {write_concurrency,WC}]),
<a name="7535"/> 7535:     NumOfObjs = 3000,  %% Need more than 1000 live objects for match_object to trap one time
<a name="7536"/> 7536:     Deleted = NumOfObjs div 2,
<a name="7537"/> 7537:     filltabint(T,NumOfObjs),
<a name="7538"/> 7538:     {ReaderPid, ReaderMref} = my_spawn_opt(fun()-&gt; otp_8166_reader(T,NumOfObjs) end,
<a name="7539"/> 7539:                                            [link, monitor, {scheduler,2}]),
<a name="7540"/> 7540:     {ZombieCrPid, ZombieCrMref} = my_spawn_opt(fun()-&gt; otp_8166_zombie_creator(T,Deleted) end,
<a name="7541"/> 7541:                                                [link, monitor, {scheduler,3}]),
<a name="7542"/> 7542: 
<a name="7543"/> 7543:     repeat(fun() -&gt; ZombieCrPid ! {loop, self()},
<a name="7544"/> 7544: 		    zombies_created = receive_any(),
<a name="7545"/> 7545: 		    otp_8166_trapper(T, 10, ZombieCrPid)
<a name="7546"/> 7546: 	   end, 100),
<a name="7547"/> 7547: 
<a name="7548"/> 7548:     ReaderPid ! quit,
<a name="7549"/> 7549:     {'DOWN', ReaderMref, process, ReaderPid, normal} = receive_any(),
<a name="7550"/> 7550:     ZombieCrPid ! quit,
<a name="7551"/> 7551:     {'DOWN', ZombieCrMref, process, ZombieCrPid, normal} = receive_any(),
<a name="7552"/> 7552:     false = ets:info(T,fixed),
<a name="7553"/> 7553:     0 = get_kept_objects(T),
<a name="7554"/> 7554:     %%verify_table_load(T),
<a name="7555"/> 7555:     ets:delete(T),
<a name="otp_8166_do-last_expr"/><a name="7556"/> 7556: <b>    process_flag</b>(scheduler,0).
<a name="7557"/> 7557: 
<a name="7558"/> 7558: <i>%% Keep reading the table</i>
<a name="otp_8166_reader-2"/><a name="7559"/> 7559: <b>otp_8166_reader</b>(T, NumOfObjs) -&gt;
<a name="otp_8166_reader-last_expr"/><a name="7560"/> 7560: <b>    repeat_while</b>(fun(0) -&gt;
<a name="7561"/> 7561: 			 receive quit -&gt; {false,done}
<a name="7562"/> 7562: 			 after 0 -&gt; {true,NumOfObjs}
<a name="7563"/> 7563: 			 end;
<a name="7564"/> 7564: 		    (Key) -&gt;
<a name="7565"/> 7565: 			 ets:lookup(T,Key),
<a name="7566"/> 7566: 			 {true, Key-1}
<a name="7567"/> 7567: 		 end,
<a name="7568"/> 7568: 		 NumOfObjs).
<a name="7569"/> 7569: 
<a name="7570"/> 7570: <i>%% Do a match_object that will trap and thereby fixate and then unfixate the table</i>
<a name="otp_8166_trapper-3"/><a name="7571"/> 7571: <b>otp_8166_trapper</b>(T, Try, ZombieCrPid) -&gt;
<a name="7572"/> 7572:     [] = ets:match_object(T,{'_',&quot;Pink Unicorn&quot;}),
<a name="otp_8166_trapper-last_expr"/><a name="7573"/> 7573: <b>    case {ets:info</b>(T,fixed),Try} of
<a name="7574"/> 7574: 	{true,1} -&gt;
<a name="7575"/> 7575: 	    io:format(&quot;failed to provoke unsafe unfix, give up...\n&quot;,[]),
<a name="7576"/> 7576: 	    ZombieCrPid ! unfix;
<a name="7577"/> 7577: 	{true,_} -&gt;
<a name="7578"/> 7578: 	    io:format(&quot;trapper too fast, trying again...\n&quot;,[]),
<a name="7579"/> 7579: 	    otp_8166_trapper(T, Try-1, ZombieCrPid);
<a name="7580"/> 7580: 	{false,_} -&gt; done
<a name="7581"/> 7581:     end.
<a name="7582"/> 7582: 
<a name="7583"/> 7583: 
<a name="7584"/> 7584: <i>%% Fixate table and create some pseudo-deleted objects (zombies)</i>
<a name="7585"/> 7585: <i>%% Then wait for trapper to fixate before unfixing, as we want the trappers'</i>
<a name="7586"/> 7586: <i>%% unfix to be the one that purges the zombies.</i>
<a name="otp_8166_zombie_creator-2"/><a name="7587"/> 7587: <b>otp_8166_zombie_creator</b>(T,Deleted) -&gt;
<a name="otp_8166_zombie_creator-last_expr"/><a name="7588"/> 7588: <b>    case receive_any</b>() of
<a name="7589"/> 7589: 	quit -&gt; done;
<a name="7590"/> 7590: 
<a name="7591"/> 7591: 	{loop,Pid} -&gt;
<a name="7592"/> 7592: 	    filltabint(T,Deleted),
<a name="7593"/> 7593: 	    ets:safe_fixtable(T,true),
<a name="7594"/> 7594: 	    Deleted = ets:select_delete(T,[{{'$1', '_'},
<a name="7595"/> 7595: 					    [{'=&lt;','$1', Deleted}],
<a name="7596"/> 7596: 					    [true]}]),
<a name="7597"/> 7597: 	    Pid ! zombies_created,
<a name="7598"/> 7598: 	    repeat_while(fun() -&gt; case ets:info(T,safe_fixed_monotonic_time) of
<a name="7599"/> 7599: 				      {_,[_P1,_P2]} -&gt;
<a name="7600"/> 7600: 					  false;
<a name="7601"/> 7601: 				      _ -&gt;
<a name="7602"/> 7602: 					  receive unfix -&gt; false
<a name="7603"/> 7603: 					  after 0 -&gt; true
<a name="7604"/> 7604: 					  end
<a name="7605"/> 7605: 				  end
<a name="7606"/> 7606: 			 end),
<a name="7607"/> 7607: 	    ets:safe_fixtable(T,false),
<a name="7608"/> 7608: 	    otp_8166_zombie_creator(T,Deleted);
<a name="7609"/> 7609: 
<a name="7610"/> 7610: 	unfix -&gt;
<a name="7611"/> 7611: 	    io:format(&quot;ignore unfix in outer loop?\n&quot;,[]),
<a name="7612"/> 7612: 	    otp_8166_zombie_creator(T,Deleted)
<a name="7613"/> 7613:     end.
<a name="7614"/> 7614: 
<a name="7615"/> 7615: 
<a name="7616"/> 7616: 
<a name="7617"/> 7617: 
<a name="verify_table_load-1"/><a name="7618"/> 7618: <b>verify_table_load</b>(T) -&gt;
<a name="verify_table_load-last_expr"/><a name="7619"/> 7619: <b>    case ets:info</b>(T,type) of
<a name="7620"/> 7620:         ordered_set -&gt; ok;
<a name="7621"/> 7621:         _ -&gt;
<a name="7622"/> 7622:             Stats = ets:info(T,stats),
<a name="7623"/> 7623:             {Buckets,AvgLen,StdDev,ExpSD,_MinLen,_MaxLen,_,_} = Stats,
<a name="7624"/> 7624:             ok = if
<a name="7625"/> 7625:                      AvgLen &gt; 1.2 -&gt;
<a name="7626"/> 7626:                          io:format(&quot;Table overloaded: Stats=~p\n~p\n&quot;,
<a name="7627"/> 7627:                                    [Stats, ets:info(T)]),
<a name="7628"/> 7628:                          false;
<a name="7629"/> 7629: 
<a name="7630"/> 7630:                      Buckets&gt;256, AvgLen &lt; 0.47 -&gt;
<a name="7631"/> 7631:                          io:format(&quot;Table underloaded: Stats=~p\n~p\n&quot;,
<a name="7632"/> 7632:                                    [Stats, ets:info(T)]),
<a name="7633"/> 7633:                          false;
<a name="7634"/> 7634: 
<a name="7635"/> 7635:                      StdDev &gt; ExpSD*2 -&gt;
<a name="7636"/> 7636:                          io:format(&quot;Too large standard deviation (poor hashing?),&quot;
<a name="7637"/> 7637:                                    &quot; stats=~p\n~p\n&quot;,[Stats, ets:info(T)]),
<a name="7638"/> 7638:                          false;
<a name="7639"/> 7639: 
<a name="7640"/> 7640:                      true -&gt;
<a name="7641"/> 7641:                          io:format(&quot;Stats = ~p\n~p\n&quot;,[Stats, ets:info(T)]),
<a name="7642"/> 7642:                          ok
<a name="7643"/> 7643:                  end
<a name="7644"/> 7644:     end.
<a name="7645"/> 7645: 
<a name="7646"/> 7646: 
<a name="7647"/> 7647: <i>%% ets:select on a tree with NIL key object.</i>
<a name="otp_8732-1"/><a name="7648"/> 7648: <b>otp_8732</b>(Config) when is_list(Config) -&gt;
<a name="7649"/> 7649:     repeat_for_all_ord_set_table_types(
<a name="7650"/> 7650:       fun(Opts) -&gt;
<a name="7651"/> 7651:               KeyRange = 999,
<a name="7652"/> 7652:               KeyFun = fun(K) -&gt; integer_to_list(K) end,
<a name="7653"/> 7653:               Tab = ets_new(noname,Opts, KeyRange, KeyFun),
<a name="7654"/> 7654:               filltabstr(Tab, KeyRange),
<a name="7655"/> 7655:               ets:insert(Tab,{[],&quot;nasty NIL object&quot;}),
<a name="7656"/> 7656:               [] = ets:match(Tab,{'_',nomatch}) %% Will hang if bug not fixed
<a name="7657"/> 7657:       end),
<a name="otp_8732-last_expr"/><a name="7658"/> 7658:     ok.
<a name="7659"/> 7659: 
<a name="7660"/> 7660: 
<a name="7661"/> 7661: <i>%% Run concurrent select_delete (and inserts) on same table.</i>
<a name="smp_select_delete-1"/><a name="7662"/> 7662: <b>smp_select_delete</b>(Config) when is_list(Config) -&gt;
<a name="smp_select_delete-last_expr"/><a name="7663"/> 7663: <b>    repeat_for_opts</b>(fun smp_select_delete_do/1,
<a name="7664"/> 7664:                     [[set,ordered_set,stim_cat_ord_set],
<a name="7665"/> 7665:                      read_concurrency, compressed]).
<a name="7666"/> 7666: 
<a name="smp_select_delete_do-1"/><a name="7667"/> 7667: <b>smp_select_delete_do</b>(Opts) -&gt;
<a name="7668"/> 7668:     KeyRange = 10000,
<a name="7669"/> 7669:     begin % indentation
<a name="7670"/> 7670:               T = ets_new(smp_select_delete,[named_table,public,{write_concurrency,true}|Opts],
<a name="7671"/> 7671:                           KeyRange),
<a name="7672"/> 7672:               Mod = 17,
<a name="7673"/> 7673:               Zeros = erlang:make_tuple(Mod,0),
<a name="7674"/> 7674:               InitF = fun(_) -&gt; Zeros end,
<a name="7675"/> 7675:               ExecF = fun(Diffs0) -&gt;
<a name="7676"/> 7676:                               case rand:uniform(20) of
<a name="7677"/> 7677:                                   1 -&gt;
<a name="7678"/> 7678:                                       Mod = 17,
<a name="7679"/> 7679:                                       Eq = rand:uniform(Mod) - 1,
<a name="7680"/> 7680:                                       Deleted = ets:select_delete(T,
<a name="7681"/> 7681:                                                                   [{{'_', '$1'},
<a name="7682"/> 7682:                                                                     [{'=:=', {'rem', '$1', Mod}, Eq}],
<a name="7683"/> 7683:                                                                     [true]}]),
<a name="7684"/> 7684:                                       Diffs1 = setelement(Eq+1, Diffs0,
<a name="7685"/> 7685:                                                           element(Eq+1,Diffs0) - Deleted),
<a name="7686"/> 7686:                                       Diffs1;
<a name="7687"/> 7687:                                   _ -&gt;
<a name="7688"/> 7688:                                       Key = rand:uniform(KeyRange),
<a name="7689"/> 7689:                                       Eq = Key rem Mod,
<a name="7690"/> 7690:                                       case ets:insert_new(T,{Key,Key}) of
<a name="7691"/> 7691:                                           true -&gt;
<a name="7692"/> 7692:                                               Diffs1 = setelement(Eq+1, Diffs0,
<a name="7693"/> 7693:                                                                   element(Eq+1,Diffs0)+1),
<a name="7694"/> 7694:                                               Diffs1;
<a name="7695"/> 7695:                                           false -&gt; Diffs0
<a name="7696"/> 7696:                                       end
<a name="7697"/> 7697:                               end
<a name="7698"/> 7698:                       end,
<a name="7699"/> 7699:               FiniF = fun(Result) -&gt; Result end,
<a name="7700"/> 7700:               Results = run_sched_workers(InitF,ExecF,FiniF,20000),
<a name="7701"/> 7701:               TotCnts = lists:foldl(fun(Diffs, Sum) -&gt; add_lists(Sum,tuple_to_list(Diffs)) end,
<a name="7702"/> 7702:                                     lists:duplicate(Mod, 0), Results),
<a name="7703"/> 7703:               io:format(&quot;TotCnts = ~p\n&quot;,[TotCnts]),
<a name="7704"/> 7704:               LeftInTab = lists:foldl(fun(N,Sum) -&gt; Sum+N end,
<a name="7705"/> 7705:                                       0, TotCnts),
<a name="7706"/> 7706:               io:format(&quot;LeftInTab = ~p\n&quot;,[LeftInTab]),
<a name="7707"/> 7707:               LeftInTab = ets:info(T,size),
<a name="7708"/> 7708:               lists:foldl(fun(Cnt,Eq) -&gt;
<a name="7709"/> 7709:                                   WasCnt = ets:select_count(T,
<a name="7710"/> 7710:                                                             [{{'_', '$1'},
<a name="7711"/> 7711:                                                               [{'=:=', {'rem', '$1', Mod}, Eq}],
<a name="7712"/> 7712:                                                               [true]}]),
<a name="7713"/> 7713:                                   io:format(&quot;~p: ~p =?= ~p\n&quot;,[Eq,Cnt,WasCnt]),
<a name="7714"/> 7714:                                   Cnt = WasCnt,
<a name="7715"/> 7715:                                   Eq+1
<a name="7716"/> 7716:                           end,
<a name="7717"/> 7717:                           0, TotCnts),
<a name="7718"/> 7718:               %% May fail as select_delete does not shrink table (enough)
<a name="7719"/> 7719:               %%verify_table_load(T),
<a name="7720"/> 7720:               LeftInTab = ets:select_delete(T, [{{'$1','$1'}, [], [true]}]),
<a name="7721"/> 7721:               0 = ets:info(T,size),
<a name="7722"/> 7722:               false = ets:info(T,fixed),
<a name="7723"/> 7723:               ets:delete(T)
<a name="7724"/> 7724:     end, % indentation
<a name="smp_select_delete_do-last_expr"/><a name="7725"/> 7725:     ok.
<a name="7726"/> 7726: 
<a name="smp_select_replace-1"/><a name="7727"/> 7727: <b>smp_select_replace</b>(Config) when is_list(Config) -&gt;
<a name="smp_select_replace-last_expr"/><a name="7728"/> 7728: <b>    repeat_for_opts</b>(fun smp_select_replace_do/1,
<a name="7729"/> 7729:                     [[set,ordered_set,stim_cat_ord_set,duplicate_bag],
<a name="7730"/> 7730:                      compressed]).
<a name="7731"/> 7731: 
<a name="smp_select_replace_do-1"/><a name="7732"/> 7732: <b>smp_select_replace_do</b>(Opts) -&gt;
<a name="7733"/> 7733:     KeyRange = 20,
<a name="7734"/> 7734:     T = ets_new(smp_select_replace,
<a name="7735"/> 7735:                 [public, {write_concurrency, true} | Opts],
<a name="7736"/> 7736:                 KeyRange),
<a name="7737"/> 7737:     InitF = fun (_) -&gt; 0 end,
<a name="7738"/> 7738:     ExecF = fun (Cnt0) -&gt;
<a name="7739"/> 7739:                     CounterId = rand:uniform(KeyRange),
<a name="7740"/> 7740:                     Match = [{{'$1', '$2'},
<a name="7741"/> 7741:                               [{'=:=', '$1', CounterId}],
<a name="7742"/> 7742:                               [{{'$1', {'+', '$2', 1}}}]}],
<a name="7743"/> 7743:                     Cnt1 = case ets:select_replace(T, Match) of
<a name="7744"/> 7744:                                1 -&gt; Cnt0+1;
<a name="7745"/> 7745:                                0 -&gt;
<a name="7746"/> 7746:                                    ets:insert_new(T, {CounterId, 0}),
<a name="7747"/> 7747:                                    Cnt0
<a name="7748"/> 7748:                            end,
<a name="7749"/> 7749:                     receive stop -&gt;
<a name="7750"/> 7750:                             [end_of_work | Cnt1]
<a name="7751"/> 7751:                     after 0 -&gt;
<a name="7752"/> 7752:                             Cnt1
<a name="7753"/> 7753:                     end
<a name="7754"/> 7754:             end,
<a name="7755"/> 7755:     FiniF = fun (Cnt) -&gt; Cnt end,
<a name="7756"/> 7756:     Pids = run_sched_workers(InitF, ExecF, FiniF, infinite),
<a name="7757"/> 7757:     receive after 3*1000 -&gt; ok end,
<a name="7758"/> 7758:     [P ! stop || P &lt;- Pids],
<a name="7759"/> 7759:     Results = wait_pids(Pids),
<a name="7760"/> 7760:     FinalCounts = ets:select(T, [{{'_', '$1'}, [], ['$1']}]),
<a name="7761"/> 7761:     Total = lists:sum(FinalCounts),
<a name="7762"/> 7762:     Total = lists:sum(Results),
<a name="7763"/> 7763:     KeyRange = ets:select_delete(T, [{{'_', '_'}, [], [true]}]),
<a name="7764"/> 7764:     0 = ets:info(T, size),
<a name="7765"/> 7765:     true = ets:delete(T),
<a name="smp_select_replace_do-last_expr"/><a name="7766"/> 7766:     ok.
<a name="7767"/> 7767: 
<a name="7768"/> 7768: <i>%% Iterate ordered_set with write_concurrency</i>
<a name="7769"/> 7769: <i>%% and make sure we hit all &quot;stable&quot; long lived keys</i>
<a name="7770"/> 7770: <i>%% while &quot;volatile&quot; objects are randomly inserted and deleted.</i>
<a name="smp_ordered_iteration-1"/><a name="7771"/> 7771: <b>smp_ordered_iteration</b>(Config) when is_list(Config) -&gt;
<a name="smp_ordered_iteration-last_expr"/><a name="7772"/> 7772: <b>    repeat_for_opts</b>(fun smp_ordered_iteration_do/1,
<a name="7773"/> 7773:                     [[cat_ord_set,stim_cat_ord_set]]).
<a name="7774"/> 7774: 
<a name="7775"/> 7775: 
<a name="smp_ordered_iteration_do-1"/><a name="7776"/> 7776: <b>smp_ordered_iteration_do</b>(Opts) -&gt;
<a name="7777"/> 7777:     KeyRange = 1000,
<a name="7778"/> 7778:     OffHeap = erts_test_utils:mk_ext_pid({a@b,1}, 4711, 1),
<a name="7779"/> 7779:     KeyFun = fun(K, Type) -&gt;
<a name="7780"/> 7780:                      {K div 10, K rem 10, Type, OffHeap}
<a name="7781"/> 7781:              end,
<a name="7782"/> 7782:     StimKeyFun = fun(K) -&gt;
<a name="7783"/> 7783:                          KeyFun(K, element(rand:uniform(3),
<a name="7784"/> 7784:                                            {stable, other, volatile}))
<a name="7785"/> 7785:                  end,
<a name="7786"/> 7786:     T = ets_new(smp_ordered_iteration, [public, {write_concurrency,true} | Opts],
<a name="7787"/> 7787:                 KeyRange, StimKeyFun),
<a name="7788"/> 7788:     NStable = KeyRange div 4,
<a name="7789"/> 7789:     prefill_table(T, KeyRange, NStable, fun(K) -&gt; {KeyFun(K, stable), 0} end),
<a name="7790"/> 7790:     NStable = ets:info(T, size),
<a name="7791"/> 7791:     NVolatile = KeyRange div 2,
<a name="7792"/> 7792:     prefill_table(T, KeyRange, NVolatile, fun(K) -&gt; {KeyFun(K, volatile), 0} end),
<a name="7793"/> 7793: 
<a name="7794"/> 7794:     InitF = fun (_) -&gt; #{insert =&gt; 0, delete =&gt; 0,
<a name="7795"/> 7795:                          select_delete_bk =&gt; 0, select_delete_pbk =&gt; 0,
<a name="7796"/> 7796:                          select_replace_bk =&gt; 0, select_replace_pbk =&gt; 0}
<a name="7797"/> 7797:             end,
<a name="7798"/> 7798:     ExecF = fun (Counters) -&gt;
<a name="7799"/> 7799:                     K = rand:uniform(KeyRange),
<a name="7800"/> 7800:                     Key = KeyFun(K, volatile),
<a name="7801"/> 7801:                     Acc = case rand:uniform(22) of
<a name="7802"/> 7802:                               R when R =&lt; 10 -&gt;
<a name="7803"/> 7803:                                   ets:insert(T, {Key}),
<a name="7804"/> 7804:                                   incr_counter(insert, Counters);
<a name="7805"/> 7805:                               R when R =&lt; 15 -&gt;
<a name="7806"/> 7806:                                   ets:delete(T, Key),
<a name="7807"/> 7807:                                   incr_counter(delete, Counters);
<a name="7808"/> 7808:                               R when R =&lt; 19 -&gt;
<a name="7809"/> 7809:                                   %% Delete bound key
<a name="7810"/> 7810:                                   ets:select_delete(T, [{{Key, '_'}, [], [true]}]),
<a name="7811"/> 7811:                                   incr_counter(select_delete_bk, Counters);
<a name="7812"/> 7812:                               R when R =&lt; 20 -&gt;
<a name="7813"/> 7813:                                   %% Delete partially bound key
<a name="7814"/> 7814:                                   ets:select_delete(T, [{{{K div 10, '_', volatile, '_'}, '_'}, [], [true]}]),
<a name="7815"/> 7815:                                   incr_counter(select_delete_pbk, Counters);
<a name="7816"/> 7816:                               R when R =&lt; 21 -&gt;
<a name="7817"/> 7817:                                   %% Replace bound key
<a name="7818"/> 7818:                                   ets:select_replace(T, [{{Key, '$1'}, [],
<a name="7819"/> 7819:                                                           [{{{const,Key}, {'+','$1',1}}}]}]),
<a name="7820"/> 7820:                                   incr_counter(select_replace_bk, Counters);
<a name="7821"/> 7821:                               _ -&gt;
<a name="7822"/> 7822:                                   %% Replace partially bound key
<a name="7823"/> 7823:                                   ets:select_replace(T, [{{{K div 10, '_', volatile, '_'}, '$1'}, [],
<a name="7824"/> 7824:                                                           [{{{element,1,'$_'}, {'+','$1',1}}}]}]),
<a name="7825"/> 7825:                                   incr_counter(select_replace_pbk, Counters)
<a name="7826"/> 7826:                     end,
<a name="7827"/> 7827:                     receive stop -&gt;
<a name="7828"/> 7828:                             [end_of_work | Acc]
<a name="7829"/> 7829:                     after 0 -&gt;
<a name="7830"/> 7830:                             Acc
<a name="7831"/> 7831:                     end
<a name="7832"/> 7832:             end,
<a name="7833"/> 7833:     FiniF = fun (Acc) -&gt; Acc end,
<a name="7834"/> 7834:     Pids = run_sched_workers(InitF, ExecF, FiniF, infinite),
<a name="7835"/> 7835:     timer:send_after(1000, stop),
<a name="7836"/> 7836: 
<a name="7837"/> 7837:     Log2ChunkMax = math:log2(NStable*2),
<a name="7838"/> 7838:     Rounds = fun Loop(N) -&gt;
<a name="7839"/> 7839:                      MS = [{{{'_', '_', stable, '_'}, '_'}, [], [true]}],
<a name="7840"/> 7840:                      NStable = ets:select_count(T, MS),
<a name="7841"/> 7841:                      NStable = count_stable(T, next, ets:first(T), 0),
<a name="7842"/> 7842:                      NStable = count_stable(T, prev, ets:last(T), 0),
<a name="7843"/> 7843:                      NStable = length(ets:select(T, MS)),
<a name="7844"/> 7844:                      NStable = length(ets:select_reverse(T, MS)),
<a name="7845"/> 7845:                      Chunk = round(math:pow(2, rand:uniform()*Log2ChunkMax)),
<a name="7846"/> 7846:                      NStable = ets_select_chunks_count(T, MS, Chunk),
<a name="7847"/> 7847:                      receive stop -&gt; N
<a name="7848"/> 7848:                      after 0 -&gt; Loop(N+1)
<a name="7849"/> 7849:                      end
<a name="7850"/> 7850:              end (1),
<a name="7851"/> 7851:     [P ! stop || P &lt;- Pids],
<a name="7852"/> 7852:     Results = wait_pids(Pids),
<a name="7853"/> 7853:     io:format(&quot;Ops = ~p\n&quot;, [maps_sum(Results)]),
<a name="7854"/> 7854:     io:format(&quot;Diff = ~p\n&quot;, [ets:info(T,size) - NStable - NVolatile]),
<a name="7855"/> 7855:     io:format(&quot;Stats = ~p\n&quot;, [ets:info(T,stats)]),
<a name="7856"/> 7856:     io:format(&quot;Rounds = ~p\n&quot;, [Rounds]),
<a name="7857"/> 7857:     true = ets:delete(T),
<a name="7858"/> 7858: 
<a name="7859"/> 7859:     %% Verify no leakage of offheap key data
<a name="7860"/> 7860:     ok = erts_test_utils:check_node_dist(),
<a name="smp_ordered_iteration_do-last_expr"/><a name="7861"/> 7861:     ok.
<a name="7862"/> 7862: 
<a name="incr_counter-2"/><a name="7863"/> 7863: <b>incr_counter</b>(Name, Counters) -&gt;
<a name="incr_counter-last_expr"/><a name="7864"/> 7864: <b>    Counters#{Name =&gt; maps:get</b>(Name, Counters, 0) + 1}.
<a name="7865"/> 7865: 
<a name="count_stable-4"/><a name="7866"/> 7866: <b>count_stable</b>(T, Next, {_, _, stable, _}=Key, N) -&gt;
<a name="7867"/> 7867:     count_stable(T, Next, ets:Next(T, Key), N+1);
<a name="7868"/> 7868: <b>count_stable</b>(T, Next, {_, _, volatile, _}=Key, N) -&gt;
<a name="7869"/> 7869:     count_stable(T, Next, ets:Next(T, Key), N);
<a name="7870"/> 7870: <b>count_stable</b>(_, _, '$end_of_table', N) -&gt;
<a name="count_stable-last_expr"/><a name="7871"/> 7871:     N.
<a name="7872"/> 7872: 
<a name="ets_select_chunks_count-3"/><a name="7873"/> 7873: <b>ets_select_chunks_count</b>(T, MS, Chunk) -&gt;
<a name="ets_select_chunks_count-last_expr"/><a name="7874"/> 7874: <b>    ets_select_chunks_count</b>(ets:select(T, MS, Chunk), 0).
<a name="7875"/> 7875: 
<a name="ets_select_chunks_count-2"/><a name="7876"/> 7876: <b>ets_select_chunks_count</b>('$end_of_table', N) -&gt;
<a name="7877"/> 7877:     N;
<a name="7878"/> 7878: <b>ets_select_chunks_count</b>({List, Continuation}, N) -&gt;
<a name="ets_select_chunks_count-last_expr"/><a name="7879"/> 7879: <b>    ets_select_chunks_count</b>(ets:select(Continuation),
<a name="7880"/> 7880:                            length(List) + N).
<a name="7881"/> 7881: 
<a name="maps_sum-1"/><a name="7882"/> 7882: <b>maps_sum</b>([Ma | Tail]) when is_map(Ma) -&gt;
<a name="7883"/> 7883:     maps_sum([lists:sort(maps:to_list(Ma)) | Tail]);
<a name="7884"/> 7884: <b>maps_sum</b>([La, Mb | Tail]) -&gt;
<a name="7885"/> 7885:     Lab = lists:zipwith(fun({K,Va}, {K,Vb}) -&gt; {K,Va+Vb} end,
<a name="7886"/> 7886:                         La,
<a name="7887"/> 7887:                         lists:sort(maps:to_list(Mb))),
<a name="7888"/> 7888:     maps_sum([Lab | Tail]);
<a name="7889"/> 7889: <b>maps_sum</b>([L]) -&gt;
<a name="maps_sum-last_expr"/><a name="7890"/> 7890:     L.
<a name="7891"/> 7891: 
<a name="7892"/> 7892: 
<a name="7893"/> 7893: 
<a name="7894"/> 7894: 
<a name="7895"/> 7895: <i>%% Test different types.</i>
<a name="types-1"/><a name="7896"/> 7896: <b>types</b>(Config) when is_list(Config) -&gt;
<a name="7897"/> 7897:     init_externals(),
<a name="types-last_expr"/><a name="7898"/> 7898: <b>    repeat_for_opts</b>(fun types_do/1, [repeat_for_opts_atom2list(set_types),
<a name="7899"/> 7899:                                      compressed]).
<a name="7900"/> 7900: 
<a name="types_do-1"/><a name="7901"/> 7901: <b>types_do</b>(Opts) -&gt;
<a name="7902"/> 7902:     EtsMem = etsmem(),
<a name="7903"/> 7903:     T = ets_new(xxx,Opts),
<a name="7904"/> 7904:     Fun = fun(Term) -&gt;
<a name="7905"/> 7905: 		  ets:insert(T,{Term}),
<a name="7906"/> 7906: 		  [{Term}] = ets:lookup(T,Term),
<a name="7907"/> 7907: 		  ets:insert(T,{Term,xxx}),
<a name="7908"/> 7908: 		  [{Term,xxx}] = ets:lookup(T,Term),
<a name="7909"/> 7909: 		  ets:insert(T,{Term,&quot;xxx&quot;}),
<a name="7910"/> 7910: 		  [{Term,&quot;xxx&quot;}] = ets:lookup(T,Term),
<a name="7911"/> 7911: 		  ets:insert(T,{xxx,Term}),
<a name="7912"/> 7912: 		  [{xxx,Term}] = ets:lookup(T,xxx),
<a name="7913"/> 7913: 		  ets:insert(T,{&quot;xxx&quot;,Term}),
<a name="7914"/> 7914: 		  [{&quot;xxx&quot;,Term}] = ets:lookup(T,&quot;xxx&quot;),
<a name="7915"/> 7915: 		  ets:delete_all_objects(T),
<a name="7916"/> 7916: 		  0 = ets:info(T,size)
<a name="7917"/> 7917:           end,
<a name="7918"/> 7918:     test_terms(Fun, strict),
<a name="7919"/> 7919:     ets:delete(T),
<a name="types_do-last_expr"/><a name="7920"/> 7920: <b>    verify_etsmem</b>(EtsMem).
<a name="7921"/> 7921: 
<a name="7922"/> 7922: 
<a name="7923"/> 7923: <i>%% OTP-9932: Memory overwrite when inserting large integers in compressed bag.</i>
<a name="7924"/> 7924: <i>%% Will crash with segv on 64-bit opt if not fixed.</i>
<a name="otp_9932-1"/><a name="7925"/> 7925: <b>otp_9932</b>(Config) when is_list(Config) -&gt;
<a name="7926"/> 7926:     T = ets_new(xxx, [bag, compressed]),
<a name="7927"/> 7927:     Fun = fun(N) -&gt;
<a name="7928"/> 7928: 		  Key = {1316110174588445 bsl N,1316110174588583 bsl N},
<a name="7929"/> 7929: 		  S = {Key, Key},
<a name="7930"/> 7930: 		  true = ets:insert(T, S),
<a name="7931"/> 7931: 		  [S] = ets:lookup(T, Key),
<a name="7932"/> 7932: 		  true = ets:insert(T, S),
<a name="7933"/> 7933: 		  [S] = ets:lookup(T, Key)
<a name="7934"/> 7934: 	  end,
<a name="7935"/> 7935:     lists:foreach(Fun, lists:seq(0, 16)),
<a name="otp_9932-last_expr"/><a name="7936"/> 7936: <b>    ets:delete</b>(T).
<a name="7937"/> 7937: 
<a name="7938"/> 7938: 
<a name="7939"/> 7939: <i>%% vm-deadlock caused by race between ets:delete and others on</i>
<a name="7940"/> 7940: <i>%% write_concurrency table.</i>
<a name="otp_9423-1"/><a name="7941"/> 7941: <b>otp_9423</b>(Config) when is_list(Config) -&gt;
<a name="otp_9423-last_expr"/><a name="7942"/> 7942: <b>    repeat_for_all_non_stim_set_table_types</b>(
<a name="7943"/> 7943:       fun(Opts) -&gt;
<a name="7944"/> 7944:               InitF = fun(_) -&gt; {0,0} end,
<a name="7945"/> 7945:               ExecF = fun({S,F}) -&gt;
<a name="7946"/> 7946:                               receive
<a name="7947"/> 7947:                                   stop -&gt;
<a name="7948"/> 7948:                                       io:format(&quot;~p got stop\n&quot;, [self()]),
<a name="7949"/> 7949:                                       [end_of_work | {&quot;Succeded=&quot;,S,&quot;Failed=&quot;,F}]
<a name="7950"/> 7950:                               after 0 -&gt;
<a name="7951"/> 7951:                                       %%io:format(&quot;~p (~p) doing lookup\n&quot;, [self(), {S,F}]),
<a name="7952"/> 7952:                                       try ets:lookup(otp_9423, key) of
<a name="7953"/> 7953:                                           [] -&gt; {S+1,F}
<a name="7954"/> 7954:                                       catch
<a name="7955"/> 7955:                                           error:badarg -&gt; {S,F+1}
<a name="7956"/> 7956:                                       end
<a name="7957"/> 7957:                               end
<a name="7958"/> 7958:                       end,
<a name="7959"/> 7959:               FiniF = fun(R) -&gt; R end,
<a name="7960"/> 7960:               case run_smp_workers(InitF, ExecF, FiniF, infinite, 1) of
<a name="7961"/> 7961:                   Pids when is_list(Pids) -&gt;
<a name="7962"/> 7962:                       %%[P ! start || P &lt;- Pids],
<a name="7963"/> 7963:                       repeat(fun() -&gt; ets_new(otp_9423, [named_table, public,
<a name="7964"/> 7964:                                                          {write_concurrency,true}|Opts]),
<a name="7965"/> 7965:                                       ets:delete(otp_9423)
<a name="7966"/> 7966:                              end, 10000),
<a name="7967"/> 7967:                       [P ! stop || P &lt;- Pids],
<a name="7968"/> 7968:                       wait_pids(Pids),
<a name="7969"/> 7969:                       ok;
<a name="7970"/> 7970: 
<a name="7971"/> 7971:                   Skipped -&gt; Skipped
<a name="7972"/> 7972:               end
<a name="7973"/> 7973:       end).
<a name="7974"/> 7974: 
<a name="7975"/> 7975: 
<a name="7976"/> 7976: 
<a name="7977"/> 7977: <i>%% Corrupted binary in compressed table</i>
<a name="otp_10182-1"/><a name="7978"/> 7978: <b>otp_10182</b>(Config) when is_list(Config) -&gt;
<a name="otp_10182-last_expr"/><a name="7979"/> 7979: <b>    repeat_for_opts_all_table_types</b>(
<a name="7980"/> 7980:       fun(Opts) -&gt;
<a name="7981"/> 7981:               Bin = &lt;&lt;&quot;aHR0cDovL2hvb3RzdWl0ZS5jb20vYy9wcm8tYWRyb2xsLWFi&quot;&gt;&gt;,
<a name="7982"/> 7982:               Key = {test, Bin},
<a name="7983"/> 7983:               Value = base64:decode(Bin),
<a name="7984"/> 7984:               In = {Key,Value},
<a name="7985"/> 7985:               Db = ets_new(undefined, Opts),
<a name="7986"/> 7986:               ets:insert(Db, In),
<a name="7987"/> 7987:               [Out] = ets:lookup(Db, Key),
<a name="7988"/> 7988:               io:format(&quot;In :  ~p\nOut: ~p\n&quot;, [In,Out]),
<a name="7989"/> 7989:               ets:delete(Db),
<a name="7990"/> 7990:               In = Out
<a name="7991"/> 7991:       end).
<a name="7992"/> 7992: 
<a name="7993"/> 7993: <i>%% Verify magic refs in compressed table are reference counted correctly</i>
<a name="compress_magic_ref-1"/><a name="7994"/> 7994: <b>compress_magic_ref</b>(Config) when is_list(Config)-&gt;
<a name="7995"/> 7995:     F = fun(Opts) -&gt;
<a name="7996"/> 7996:                 T = ets:new(banana, Opts),
<a name="7997"/> 7997:                 ets:insert(T, {key, atomics:new(2, [])}),
<a name="7998"/> 7998:                 erlang:garbage_collect(),  % make really sure no ref on heap
<a name="7999"/> 7999:                 [{_, Ref}] = ets:lookup(T, key),
<a name="8000"/> 8000:                 #{size := 2} = atomics:info(Ref), % Still alive!
<a name="8001"/> 8001: 
<a name="8002"/> 8002:                 %% Now test ets:delete will deallocate if last ref
<a name="8003"/> 8003:                 WeakRef = term_to_binary(Ref),
<a name="8004"/> 8004:                 erlang:garbage_collect(),  % make sure no Ref on heap
<a name="8005"/> 8005:                 ets:delete(T, key),
<a name="8006"/> 8006:                 StaleRef = binary_to_term(WeakRef),
<a name="8007"/> 8007:                 badarg = try atomics:info(StaleRef)
<a name="8008"/> 8008:                          catch error:badarg -&gt; badarg end,
<a name="8009"/> 8009:                 ets:delete(T),
<a name="8010"/> 8010:                 ok
<a name="8011"/> 8011:           end,
<a name="8012"/> 8012:     repeat_for_opts(F, [[set, ordered_set], compressed]),
<a name="compress_magic_ref-last_expr"/><a name="8013"/> 8013:     ok.
<a name="8014"/> 8014: 
<a name="8015"/> 8015: <i>%% Test that ets:all include/exclude tables that we know are created/deleted</i>
<a name="ets_all-1"/><a name="8016"/> 8016: <b>ets_all</b>(Config) when is_list(Config) -&gt;
<a name="8017"/> 8017:     Pids = [spawn_link(fun() -&gt; ets_all_run() end) || _ &lt;- [1,2]],
<a name="8018"/> 8018:     receive after 3*1000 -&gt; ok end,
<a name="8019"/> 8019:     [begin unlink(P), exit(P,kill) end || P &lt;- Pids],
<a name="ets_all-last_expr"/><a name="8020"/> 8020:     ok.
<a name="8021"/> 8021: 
<a name="ets_all_run-0"/><a name="8022"/> 8022: <b>ets_all_run</b>() -&gt;
<a name="8023"/> 8023:     Table = ets:new(undefined, []),
<a name="8024"/> 8024:     true = lists:member(Table, ets:all()),
<a name="8025"/> 8025:     ets:delete(Table),
<a name="8026"/> 8026:     false = lists:member(Table, ets:all()),
<a name="ets_all_run-last_expr"/><a name="8027"/> 8027: <b>    ets_all_run</b>().
<a name="8028"/> 8028: 
<a name="create_tables-1"/><a name="8029"/> 8029: <b>create_tables</b>(N) -&gt;
<a name="create_tables-last_expr"/><a name="8030"/> 8030: <b>    create_tables</b>(N, []).
<a name="8031"/> 8031: 
<a name="create_tables-2"/><a name="8032"/> 8032: <b>create_tables</b>(0, Ts) -&gt;
<a name="8033"/> 8033:     Ts;
<a name="8034"/> 8034: <b>create_tables</b>(N, Ts) -&gt;
<a name="create_tables-last_expr"/><a name="8035"/> 8035: <b>    create_tables</b>(N-1, [ets:new(tjo, [])|Ts]).
<a name="8036"/> 8036: 
<a name="massive_ets_all-1"/><a name="8037"/> 8037: <b>massive_ets_all</b>(Config) when is_list(Config) -&gt;
<a name="8038"/> 8038:     Me = self(),
<a name="8039"/> 8039:     InitTables = lists:sort(ets:all()),
<a name="8040"/> 8040:     io:format(&quot;InitTables=~p~n&quot;, [InitTables]),
<a name="8041"/> 8041:     PMs0 = lists:map(fun (Sid) -&gt;
<a name="8042"/> 8042:                              my_spawn_opt(fun () -&gt;
<a name="8043"/> 8043:                                                   Ts = create_tables(250),
<a name="8044"/> 8044:                                                   Me ! {self(), up, Ts},
<a name="8045"/> 8045:                                                   receive {Me, die} -&gt; ok end
<a name="8046"/> 8046:                                           end,
<a name="8047"/> 8047:                                           [link, monitor, {scheduler, Sid}])
<a name="8048"/> 8048:                      end,
<a name="8049"/> 8049:                      lists:seq(1, erlang:system_info(schedulers_online))),
<a name="8050"/> 8050:     AllRes = lists:sort(lists:foldl(fun ({P, _M}, Ts) -&gt;
<a name="8051"/> 8051:                                             receive
<a name="8052"/> 8052:                                                 {P, up, PTs} -&gt;
<a name="8053"/> 8053:                                                     PTs ++ Ts
<a name="8054"/> 8054:                                             end
<a name="8055"/> 8055:                                     end,
<a name="8056"/> 8056:                                     InitTables,
<a name="8057"/> 8057:                                     PMs0)),
<a name="8058"/> 8058:     AllRes = lists:sort(ets:all()),
<a name="8059"/> 8059:     PMs1 = lists:map(fun (_) -&gt;
<a name="8060"/> 8060:                              my_spawn_opt(fun () -&gt;
<a name="8061"/> 8061:                                                   AllRes = lists:sort(ets:all())
<a name="8062"/> 8062:                                           end,
<a name="8063"/> 8063:                                           [link, monitor])
<a name="8064"/> 8064:                      end, lists:seq(1, 50)),
<a name="8065"/> 8065:     lists:foreach(fun ({P, M}) -&gt;
<a name="8066"/> 8066:                           receive
<a name="8067"/> 8067:                               {'DOWN', M, process, P, _} -&gt;
<a name="8068"/> 8068:                                   ok
<a name="8069"/> 8069:                           end
<a name="8070"/> 8070:                   end, PMs1),
<a name="8071"/> 8071:     PMs2 = lists:map(fun (_) -&gt;
<a name="8072"/> 8072:                              my_spawn_opt(fun () -&gt;
<a name="8073"/> 8073:                                                   _ = ets:all()
<a name="8074"/> 8074:                                           end,
<a name="8075"/> 8075:                                           [link, monitor])
<a name="8076"/> 8076:                      end, lists:seq(1, 50)),
<a name="8077"/> 8077:     lists:foreach(fun ({P, _M}) -&gt;
<a name="8078"/> 8078:                           P ! {Me, die}
<a name="8079"/> 8079:                   end, PMs0),
<a name="8080"/> 8080:     lists:foreach(fun ({P, M}) -&gt;
<a name="8081"/> 8081:                           receive
<a name="8082"/> 8082:                               {'DOWN', M, process, P, _} -&gt;
<a name="8083"/> 8083:                                   ok
<a name="8084"/> 8084:                           end
<a name="8085"/> 8085:                   end, PMs0 ++ PMs2),
<a name="8086"/> 8086:     EndTables = lists:sort(ets:all()),
<a name="8087"/> 8087:     io:format(&quot;EndTables=~p~n&quot;, [EndTables]),
<a name="8088"/> 8088:     InitTables = EndTables,
<a name="massive_ets_all-last_expr"/><a name="8089"/> 8089:     ok.
<a name="8090"/> 8090: 
<a name="8091"/> 8091: 
<a name="take-1"/><a name="8092"/> 8092: <b>take</b>(Config) when is_list(Config) -&gt;
<a name="8093"/> 8093:     %% Simple test for set tables.
<a name="8094"/> 8094:     T1 = ets_new(a, [set]),
<a name="8095"/> 8095:     [] = ets:take(T1, foo),
<a name="8096"/> 8096:     ets:insert(T1, {foo,bar}),
<a name="8097"/> 8097:     [] = ets:take(T1, bar),
<a name="8098"/> 8098:     [{foo,bar}] = ets:take(T1, foo),
<a name="8099"/> 8099:     [] = ets:tab2list(T1),
<a name="8100"/> 8100:     %% Non-immediate key.
<a name="8101"/> 8101:     ets:insert(T1, {{'not',&lt;&lt;&quot;immediate&quot;&gt;&gt;},ok}),
<a name="8102"/> 8102:     [{{'not',&lt;&lt;&quot;immediate&quot;&gt;&gt;},ok}] = ets:take(T1, {'not',&lt;&lt;&quot;immediate&quot;&gt;&gt;}),
<a name="8103"/> 8103:     %% Same with ordered tables.
<a name="8104"/> 8104:     repeat_for_all_ord_set_table_types(
<a name="8105"/> 8105:       fun(Opts) -&gt;
<a name="8106"/> 8106:               T2 = ets_new(b, Opts),
<a name="8107"/> 8107:               [] = ets:take(T2, foo),
<a name="8108"/> 8108:               ets:insert(T2, {foo,bar}),
<a name="8109"/> 8109:               [] = ets:take(T2, bar),
<a name="8110"/> 8110:               [{foo,bar}] = ets:take(T2, foo),
<a name="8111"/> 8111:               [] = ets:tab2list(T2),
<a name="8112"/> 8112:               ets:insert(T2, {{'not',&lt;&lt;&quot;immediate&quot;&gt;&gt;},ok}),
<a name="8113"/> 8113:               [{{'not',&lt;&lt;&quot;immediate&quot;&gt;&gt;},ok}] = ets:take(T2, {'not',&lt;&lt;&quot;immediate&quot;&gt;&gt;}),
<a name="8114"/> 8114:               %% Arithmetically-equal keys.
<a name="8115"/> 8115:               ets:insert(T2, [{1.0,float},{2,integer}]),
<a name="8116"/> 8116:               [{1.0,float}] = ets:take(T2, 1),
<a name="8117"/> 8117:               [{2,integer}] = ets:take(T2, 2.0),
<a name="8118"/> 8118:               [] = ets:tab2list(T2),
<a name="8119"/> 8119:               ets:delete(T2)
<a name="8120"/> 8120:       end),
<a name="8121"/> 8121:     %% Same with bag.
<a name="8122"/> 8122:     T3 = ets_new(c, [bag]),
<a name="8123"/> 8123:     ets:insert(T3, [{1,1},{1,2},{3,3}]),
<a name="8124"/> 8124:     R = lists:sort([{1,1},{1,2}]),
<a name="8125"/> 8125:     R = lists:sort(ets:take(T3, 1)),
<a name="8126"/> 8126:     [{3,3}] = ets:take(T3, 3),
<a name="8127"/> 8127:     [] = ets:tab2list(T3),
<a name="8128"/> 8128:     ets:delete(T1),
<a name="8129"/> 8129:     ets:delete(T3),
<a name="take-last_expr"/><a name="8130"/> 8130:     ok.
<a name="8131"/> 8131: 
<a name="whereis_table-1"/><a name="8132"/> 8132: <b>whereis_table</b>(Config) when is_list(Config) -&gt;
<a name="8133"/> 8133:     %% Do we return 'undefined' when the named table doesn't exist?
<a name="8134"/> 8134:     undefined = ets:whereis(whereis_test),
<a name="8135"/> 8135: 
<a name="8136"/> 8136:     %% Does the tid() refer to the same table as the name?
<a name="8137"/> 8137:     whereis_test = ets:new(whereis_test, [named_table]),
<a name="8138"/> 8138:     Tid = ets:whereis(whereis_test),
<a name="8139"/> 8139: 
<a name="8140"/> 8140:     ets:insert(whereis_test, [{hello}, {there}]),
<a name="8141"/> 8141:     CheckMatch =
<a name="8142"/> 8142:         fun(MatchRes) -&gt;
<a name="8143"/> 8143:                 case MatchRes of
<a name="8144"/> 8144:                     [[{there}],[{hello}]] -&gt; ok;
<a name="8145"/> 8145:                     [[{hello}],[{there}]] -&gt; ok
<a name="8146"/> 8146:                 end
<a name="8147"/> 8147:         end,
<a name="8148"/> 8148:     CheckMatch(ets:match(whereis_test, '$1')),
<a name="8149"/> 8149:     CheckMatch(ets:match(Tid, '$1')),
<a name="8150"/> 8150: 
<a name="8151"/> 8151:     true = ets:delete_all_objects(Tid),
<a name="8152"/> 8152: 
<a name="8153"/> 8153:     [] = ets:match(whereis_test, '$1'),
<a name="8154"/> 8154:     [] = ets:match(Tid, '$1'),
<a name="8155"/> 8155: 
<a name="8156"/> 8156:     %% Does the name disappear when deleted through the tid()?
<a name="8157"/> 8157:     true = ets:delete(Tid),
<a name="8158"/> 8158:     undefined = ets:info(whereis_test),
<a name="8159"/> 8159:     {'EXIT',{badarg, _}} = (catch ets:match(whereis_test, '$1')),
<a name="8160"/> 8160: 
<a name="8161"/> 8161:     %% Is the old tid() broken when the table is re-created with the same
<a name="8162"/> 8162:     %% name?
<a name="8163"/> 8163:     whereis_test = ets:new(whereis_test, [named_table]),
<a name="8164"/> 8164:     [] = ets:match(whereis_test, '$1'),
<a name="8165"/> 8165:     {'EXIT',{badarg, _}} = (catch ets:match(Tid, '$1')),
<a name="8166"/> 8166: 
<a name="whereis_table-last_expr"/><a name="8167"/> 8167:     ok.
<a name="8168"/> 8168: 
<a name="ms_excessive_nesting-1"/><a name="8169"/> 8169: <b>ms_excessive_nesting</b>(Config) when is_list(Config) -&gt;
<a name="8170"/> 8170:     MkMSCond = fun (_Fun, N) when N &lt; 0 -&gt; true;
<a name="8171"/> 8171:                    (Fun, N) -&gt; {'orelse', {'==', N, '$1'}, Fun(Fun, N-1)}
<a name="8172"/> 8172:                end,
<a name="8173"/> 8173:     %% Ensure it compiles with substantial but reasonable
<a name="8174"/> 8174:     %% (hmm...) nesting
<a name="8175"/> 8175:     MS = [{{'$1', '$2'}, [MkMSCond(MkMSCond, 100)], [{{'$1', blipp}}]}],
<a name="8176"/> 8176:     io:format(&quot;~p~n&quot;, [erlang:match_spec_test({1, blupp}, MS, table)]),
<a name="8177"/> 8177:     _ = ets:match_spec_compile(MS),
<a name="8178"/> 8178:     %% Now test match_spec_compile() and select_replace()
<a name="8179"/> 8179:     %% with tree and hash using excessive nesting. These
<a name="8180"/> 8180:     %% used to seg-fault the emulator due to recursion
<a name="8181"/> 8181:     %% beyond the end of the C-stack.
<a name="8182"/> 8182:     %%
<a name="8183"/> 8183:     %% We expect to get a system_limit error, but don't
<a name="8184"/> 8184:     %% fail if it compiles (someone must have rewritten
<a name="8185"/> 8185:     %% compilation of match specs to use an explicit
<a name="8186"/> 8186:     %% stack instead of using recursion).
<a name="8187"/> 8187:     ENMS = [{{'$1', '$2'}, [MkMSCond(MkMSCond, 1000000)], [{{'$1', blipp}}]}],
<a name="8188"/> 8188:     io:format(&quot;~p~n&quot;, [erlang:match_spec_test({1, blupp}, ENMS, table)]),
<a name="8189"/> 8189:     ENMSC = try
<a name="8190"/> 8190:                 ets:match_spec_compile(ENMS),
<a name="8191"/> 8191:                 &quot;compiled&quot;
<a name="8192"/> 8192:             catch
<a name="8193"/> 8193:                 error:system_limit -&gt;
<a name="8194"/> 8194:                     &quot;got system_limit&quot;
<a name="8195"/> 8195:             end,
<a name="8196"/> 8196:     Tree = ets:new(tree, [ordered_set]),
<a name="8197"/> 8197:     SRT = try
<a name="8198"/> 8198:               ets:select_replace(Tree, ENMS),
<a name="8199"/> 8199:               &quot;compiled&quot;
<a name="8200"/> 8200:           catch
<a name="8201"/> 8201:               error:system_limit -&gt;
<a name="8202"/> 8202:                   &quot;got system_limit&quot;
<a name="8203"/> 8203:           end,
<a name="8204"/> 8204:     Hash = ets:new(hash, [set]),
<a name="8205"/> 8205:     SRH = try
<a name="8206"/> 8206:               ets:select_replace(Hash, ENMS),
<a name="8207"/> 8207:               &quot;compiled&quot;
<a name="8208"/> 8208:           catch
<a name="8209"/> 8209:               error:system_limit -&gt;
<a name="8210"/> 8210:                   &quot;got system_limit&quot;
<a name="8211"/> 8211:           end,
<a name="ms_excessive_nesting-last_expr"/><a name="8212"/> 8212: <b>    {comment, &quot;match_spec_compile</b>() &quot;++ENMSC++&quot;; select_replace(_,[ordered_set]) &quot;++SRT++&quot;; select_replace(_,[set]) &quot;++SRH}.
<a name="8213"/> 8213: 
<a name="8214"/> 8214: <i>%% The following help functions are used by</i>
<a name="8215"/> 8215: <i>%% throughput_benchmark. They are declared on the top level beacuse</i>
<a name="8216"/> 8216: <i>%% declaring them as function local funs cause a scalability issue.</i>
<a name="get_op-2"/><a name="8217"/> 8217: <b>get_op</b>([{_,O}], _RandNum) -&gt;
<a name="8218"/> 8218:     O;
<a name="8219"/> 8219: <b>get_op</b>([{Prob,O}|Rest], RandNum) -&gt;
<a name="get_op-last_expr"/><a name="8220"/> 8220:     case RandNum &lt; Prob of
<a name="8221"/> 8221:         true -&gt; O;
<a name="8222"/> 8222:         false -&gt; get_op(Rest, RandNum)
<a name="8223"/> 8223:     end.
<a name="do_op-4"/><a name="8224"/> 8224: <b>do_op</b>(Table, ProbHelpTab, Range, Operations) -&gt;
<a name="8225"/> 8225:     RandNum = rand:uniform(),
<a name="8226"/> 8226:     Op = get_op(ProbHelpTab, RandNum),
<a name="8227"/> 8227:     #{ Op := TheOp} = Operations,
<a name="do_op-last_expr"/><a name="8228"/> 8228: <b>    TheOp</b>(Table, Range).
<a name="do_work-5"/><a name="8229"/> 8229: <b>do_work</b>(WorksDoneSoFar, Table, ProbHelpTab, Range, Operations) -&gt;
<a name="do_work-last_expr"/><a name="8230"/> 8230:     receive
<a name="8231"/> 8231:         stop -&gt; WorksDoneSoFar
<a name="8232"/> 8232:     after
<a name="8233"/> 8233:         0 -&gt; do_op(Table, ProbHelpTab, Range, Operations),
<a name="8234"/> 8234:              do_work(WorksDoneSoFar + 1, Table, ProbHelpTab, Range, Operations)
<a name="8235"/> 8235:     end.
<a name="8236"/> 8236: 
<a name="prefill_table-4"/><a name="8237"/> 8237: <b>prefill_table</b>(T, KeyRange, Num, ObjFun) -&gt;
<a name="8238"/> 8238:     Parent = self(),
<a name="8239"/> 8239:     spawn_link(fun() -&gt;
<a name="8240"/> 8240:                        prefill_table_helper(T, KeyRange, Num, ObjFun),
<a name="8241"/> 8241:                        Parent ! done
<a name="8242"/> 8242:                end),
<a name="prefill_table-last_expr"/><a name="8243"/> 8243:     receive done -&gt; ok end.
<a name="8244"/> 8244: 
<a name="prefill_table_helper-4"/><a name="8245"/> 8245: <b>prefill_table_helper</b>(T, KeyRange, Num, ObjFun) -&gt;
<a name="8246"/> 8246:     Seed = rand:uniform(KeyRange),
<a name="8247"/> 8247:     %%io:format(&quot;prefill_table: Seed = ~p\n&quot;, [Seed]),
<a name="8248"/> 8248:     RState = unique_rand_start(KeyRange, Seed),
<a name="prefill_table_helper-last_expr"/><a name="8249"/> 8249: <b>    prefill_table_loop</b>(T, RState, Num, ObjFun).
<a name="8250"/> 8250: 
<a name="prefill_table_loop-4"/><a name="8251"/> 8251: <b>prefill_table_loop</b>(_, _, 0, _) -&gt;
<a name="8252"/> 8252:     ok;
<a name="8253"/> 8253: <b>prefill_table_loop</b>(T, RS0, N, ObjFun) -&gt;
<a name="8254"/> 8254:     {Key, RS1} = unique_rand_next(RS0),
<a name="8255"/> 8255:     ets:insert(T, ObjFun(Key)),
<a name="prefill_table_loop-last_expr"/><a name="8256"/> 8256: <b>    prefill_table_loop</b>(T, RS1, N-1, ObjFun).
<a name="8257"/> 8257: 
<a name="inserter_proc_starter-3"/><a name="8258"/> 8258: <b>inserter_proc_starter</b>(T, ToInsert, Parent) -&gt;
<a name="8259"/> 8259:     receive
<a name="8260"/> 8260:         start -&gt; ok
<a name="8261"/> 8261:     end,
<a name="inserter_proc_starter-last_expr"/><a name="8262"/> 8262: <b>    inserter_proc</b>(T, ToInsert, [], Parent, false).
<a name="8263"/> 8263: 
<a name="inserter_proc-5"/><a name="8264"/> 8264: <b>inserter_proc</b>(T, [], Inserted, Parent, _) -&gt;
<a name="8265"/> 8265:     inserter_proc(T, Inserted, [], Parent, true);
<a name="8266"/> 8266: <b>inserter_proc</b>(T, [I | ToInsert], Inserted, Parent, CanStop) -&gt;
<a name="8267"/> 8267:     Stop =
<a name="8268"/> 8268:         case CanStop of
<a name="8269"/> 8269:             true -&gt;
<a name="8270"/> 8270:                 receive
<a name="8271"/> 8271:                     stop -&gt; Parent ! stopped
<a name="8272"/> 8272:                 after 0 -&gt; no_stop
<a name="8273"/> 8273:                 end;
<a name="8274"/> 8274:             false -&gt; no_stop
<a name="8275"/> 8275:         end,
<a name="inserter_proc-last_expr"/><a name="8276"/> 8276:     case Stop of
<a name="8277"/> 8277:         no_stop -&gt;
<a name="8278"/> 8278:             ets:insert(T, I),
<a name="8279"/> 8279:             inserter_proc(T, ToInsert, [I | Inserted], Parent, CanStop);
<a name="8280"/> 8280:         _ -&gt; ok
<a name="8281"/> 8281:     end.
<a name="8282"/> 8282: 
<a name="prefill_table_parallel-4"/><a name="8283"/> 8283: <b>prefill_table_parallel</b>(T, KeyRange, Num, ObjFun) -&gt;
<a name="8284"/> 8284:     Parent = self(),
<a name="8285"/> 8285:     spawn_link(fun() -&gt;
<a name="8286"/> 8286:                        prefill_table_parallel_helper(T, KeyRange, Num, ObjFun),
<a name="8287"/> 8287:                        Parent ! done
<a name="8288"/> 8288:                end),
<a name="prefill_table_parallel-last_expr"/><a name="8289"/> 8289:     receive done -&gt; ok end.
<a name="8290"/> 8290: 
<a name="prefill_table_parallel_helper-4"/><a name="8291"/> 8291: <b>prefill_table_parallel_helper</b>(T, KeyRange, Num, ObjFun) -&gt;
<a name="8292"/> 8292:     NrOfSchedulers = erlang:system_info(schedulers),
<a name="8293"/> 8293:     Seed = rand:uniform(KeyRange),
<a name="8294"/> 8294:     %%io:format(&quot;prefill_table: Seed = ~p\n&quot;, [Seed]),
<a name="8295"/> 8295:     RState = unique_rand_start(KeyRange, Seed),
<a name="8296"/> 8296:     InsertMap = prefill_insert_map_loop(T, RState, Num, ObjFun, #{}, NrOfSchedulers),
<a name="8297"/> 8297:     Self = self(),
<a name="8298"/> 8298:     Pids = [
<a name="8299"/> 8299:         begin
<a name="8300"/> 8300:             InserterFun =
<a name="8301"/> 8301:                 fun() -&gt;
<a name="8302"/> 8302:                     inserter_proc_starter(T, ToInsert, Self)
<a name="8303"/> 8303:                 end,
<a name="8304"/> 8304:             spawn_link(InserterFun)
<a name="8305"/> 8305:         end
<a name="8306"/> 8306:         || ToInsert &lt;- maps:values(InsertMap)],
<a name="8307"/> 8307:     [Pid ! start || Pid &lt;- Pids],
<a name="8308"/> 8308:     timer:sleep(1000),
<a name="8309"/> 8309:     [Pid ! stop || Pid &lt;- Pids],
<a name="prefill_table_parallel_helper-last_expr"/><a name="8310"/> 8310:     [receive stopped -&gt; ok end || _Pid &lt;- Pids].
<a name="8311"/> 8311: 
<a name="prefill_insert_map_loop-6"/><a name="8312"/> 8312: <b>prefill_insert_map_loop</b>(_, _, 0, _, InsertMap, _NrOfSchedulers) -&gt;
<a name="8313"/> 8313:     InsertMap;
<a name="8314"/> 8314: <b>prefill_insert_map_loop</b>(T, RS0, N, ObjFun, InsertMap, NrOfSchedulers) -&gt;
<a name="8315"/> 8315:     {Key, RS1} = unique_rand_next(RS0),
<a name="8316"/> 8316:     Sched = N rem NrOfSchedulers,
<a name="8317"/> 8317:     PrevInserts = maps:get(Sched, InsertMap, []),
<a name="8318"/> 8318:     NewPrevInserts = [ObjFun(Key) | PrevInserts],
<a name="8319"/> 8319:     NewInsertMap = maps:put(Sched, NewPrevInserts, InsertMap),
<a name="prefill_insert_map_loop-last_expr"/><a name="8320"/> 8320: <b>    prefill_insert_map_loop</b>(T, RS1, N-1, ObjFun, NewInsertMap, NrOfSchedulers).
<a name="8321"/> 8321: 
<a name="8322"/> 8322: <b>-record</b>(ets_throughput_bench_config,
<a name="8323"/> 8323:         {benchmark_duration_ms = 3000,
<a name="8324"/> 8324:          recover_time_ms = 1000,
<a name="8325"/> 8325:          thread_counts = not_set,
<a name="8326"/> 8326:          key_ranges = [1000000],
<a name="8327"/> 8327:          init_functions = [fun prefill_table/4],
<a name="8328"/> 8328:          nr_of_repeats = 1,
<a name="8329"/> 8329:          scenarios =
<a name="8330"/> 8330:              [
<a name="8331"/> 8331:               [
<a name="8332"/> 8332:                {0.5, insert},
<a name="8333"/> 8333:                {0.5, delete}
<a name="8334"/> 8334:               ],
<a name="8335"/> 8335:               [
<a name="8336"/> 8336:                {0.1, insert},
<a name="8337"/> 8337:                {0.1, delete},
<a name="8338"/> 8338:                {0.8, lookup}
<a name="8339"/> 8339:               ],
<a name="8340"/> 8340:               [
<a name="8341"/> 8341:                {0.01, insert},
<a name="8342"/> 8342:                {0.01, delete},
<a name="8343"/> 8343:                {0.98, lookup}
<a name="8344"/> 8344:               ],
<a name="8345"/> 8345:               [
<a name="8346"/> 8346:                {1.0, lookup}
<a name="8347"/> 8347:               ],
<a name="8348"/> 8348:               [
<a name="8349"/> 8349:                {0.1, insert},
<a name="8350"/> 8350:                {0.1, delete},
<a name="8351"/> 8351:                {0.4, lookup},
<a name="8352"/> 8352:                {0.4, nextseq10}
<a name="8353"/> 8353:               ],
<a name="8354"/> 8354:               [
<a name="8355"/> 8355:                {0.1, insert},
<a name="8356"/> 8356:                {0.1, delete},
<a name="8357"/> 8357:                {0.4, lookup},
<a name="8358"/> 8358:                {0.4, nextseq100}
<a name="8359"/> 8359:               ],
<a name="8360"/> 8360:               [
<a name="8361"/> 8361:                {0.1, insert},
<a name="8362"/> 8362:                {0.1, delete},
<a name="8363"/> 8363:                {0.4, lookup},
<a name="8364"/> 8364:                {0.4, nextseq1000}
<a name="8365"/> 8365:               ],
<a name="8366"/> 8366:               [
<a name="8367"/> 8367:                {1.0, nextseq1000}
<a name="8368"/> 8368:               ],
<a name="8369"/> 8369:               [
<a name="8370"/> 8370:                {0.1, insert},
<a name="8371"/> 8371:                {0.1, delete},
<a name="8372"/> 8372:                {0.79, lookup},
<a name="8373"/> 8373:                {0.01, selectAll}
<a name="8374"/> 8374:               ],
<a name="8375"/> 8375:               [
<a name="8376"/> 8376:                {0.1, insert},
<a name="8377"/> 8377:                {0.1, delete},
<a name="8378"/> 8378:                {0.7999, lookup},
<a name="8379"/> 8379:                {0.0001, selectAll}
<a name="8380"/> 8380:               ],
<a name="8381"/> 8381:               [
<a name="8382"/> 8382:                {0.1, insert},
<a name="8383"/> 8383:                {0.1, delete},
<a name="8384"/> 8384:                {0.799999, lookup},
<a name="8385"/> 8385:                {0.000001, selectAll}
<a name="8386"/> 8386:               ],
<a name="8387"/> 8387:               [
<a name="8388"/> 8388:                {0.1, insert},
<a name="8389"/> 8389:                {0.1, delete},
<a name="8390"/> 8390:                {0.79, lookup},
<a name="8391"/> 8391:                {0.01, partial_select1000}
<a name="8392"/> 8392:               ],
<a name="8393"/> 8393:               [
<a name="8394"/> 8394:                {0.1, insert},
<a name="8395"/> 8395:                {0.1, delete},
<a name="8396"/> 8396:                {0.7999, lookup},
<a name="8397"/> 8397:                {0.0001, partial_select1000}
<a name="8398"/> 8398:               ],
<a name="8399"/> 8399:               [
<a name="8400"/> 8400:                {0.1, insert},
<a name="8401"/> 8401:                {0.1, delete},
<a name="8402"/> 8402:                {0.799999, lookup},
<a name="8403"/> 8403:                {0.000001, partial_select1000}
<a name="8404"/> 8404:               ]
<a name="8405"/> 8405:              ],
<a name="8406"/> 8406:          table_types =
<a name="8407"/> 8407:              [
<a name="8408"/> 8408:               [ordered_set, public],
<a name="8409"/> 8409:               [ordered_set, public, {write_concurrency, true}],
<a name="8410"/> 8410:               [ordered_set, public, {read_concurrency, true}],
<a name="8411"/> 8411:               [ordered_set, public, {write_concurrency, true}, {read_concurrency, true}],
<a name="8412"/> 8412:               [set, public],
<a name="8413"/> 8413:               [set, public, {write_concurrency, true}],
<a name="8414"/> 8414:               [set, public, {read_concurrency, true}],
<a name="8415"/> 8415:               [set, public, {write_concurrency, true}, {read_concurrency, true}],
<a name="8416"/> 8416:               [set, public, {write_concurrency, auto}, {read_concurrency, true}],
<a name="8417"/> 8417:               [set, public, {write_concurrency, {debug_hash_fixed_number_of_locks, 16384}}]
<a name="8418"/> 8418:              ],
<a name="8419"/> 8419:          etsmem_fun = fun() -&gt; ok end,
<a name="8420"/> 8420:          verify_etsmem_fun = fun(_) -&gt; true end,
<a name="8421"/> 8421:          notify_res_fun = fun(_Name, _Throughput) -&gt; ok end,
<a name="8422"/> 8422:          print_result_paths_fun =
<a name="8423"/> 8423:              fun(ResultPath, _LatestResultPath) -&gt;
<a name="8424"/> 8424:                      Comment =
<a name="8425"/> 8425:                          io_lib:format(&quot;&lt;a href=\&quot;file:///~s\&quot;&gt;Result visualization&lt;/a&gt;&quot;,[ResultPath]),
<a name="8426"/> 8426:                      {comment, Comment}
<a name="8427"/> 8427:              end
<a name="8428"/> 8428:        }).
<a name="8429"/> 8429: 
<a name="stdout_notify_res-2"/><a name="8430"/> 8430: <b>stdout_notify_res</b>(ResultPath, LatestResultPath) -&gt;
<a name="8431"/> 8431:     io:format(&quot;Result Location: /~s~n&quot;, [ResultPath]),
<a name="stdout_notify_res-last_expr"/><a name="8432"/> 8432: <b>    io:format</b>(&quot;Latest Result Location: ~s~n&quot;, [LatestResultPath]).
<a name="8433"/> 8433: 
<a name="throughput_benchmark-0"/><a name="8434"/> 8434: <b>throughput_benchmark</b>() -&gt;
<a name="throughput_benchmark-last_expr"/><a name="8435"/> 8435: <b>    throughput_benchmark</b>(
<a name="8436"/> 8436:       #ets_throughput_bench_config{
<a name="8437"/> 8437:          print_result_paths_fun = fun stdout_notify_res/2}).
<a name="8438"/> 8438: 
<a name="throughput_benchmark-1"/><a name="8439"/> 8439: <b>throughput_benchmark</b>(
<a name="8440"/> 8440:   #ets_throughput_bench_config{
<a name="8441"/> 8441:      benchmark_duration_ms  = BenchmarkDurationMs,
<a name="8442"/> 8442:      recover_time_ms        = RecoverTimeMs,
<a name="8443"/> 8443:      thread_counts          = ThreadCountsOpt,
<a name="8444"/> 8444:      key_ranges             = KeyRanges,
<a name="8445"/> 8445:      init_functions         = InitFuns,
<a name="8446"/> 8446:      nr_of_repeats          = NrOfRepeats,
<a name="8447"/> 8447:      scenarios              = Scenarios,
<a name="8448"/> 8448:      table_types            = TableTypes,
<a name="8449"/> 8449:      etsmem_fun             = ETSMemFun,
<a name="8450"/> 8450:      verify_etsmem_fun      = VerifyETSMemFun,
<a name="8451"/> 8451:      notify_res_fun         = NotifyResFun,
<a name="8452"/> 8452:      print_result_paths_fun = PrintResultPathsFun}) -&gt;
<a name="8453"/> 8453:     NrOfSchedulers = erlang:system_info(schedulers),
<a name="8454"/> 8454:     %% Definitions of operations that are supported by the benchmark
<a name="8455"/> 8455:     NextSeqOp =
<a name="8456"/> 8456:         fun (T, KeyRange, SeqSize) -&gt;
<a name="8457"/> 8457:                 Start = rand:uniform(KeyRange),
<a name="8458"/> 8458:                 Last =
<a name="8459"/> 8459:                     lists:foldl(
<a name="8460"/> 8460:                       fun(_, Prev) -&gt;
<a name="8461"/> 8461:                               case Prev of
<a name="8462"/> 8462:                                   '$end_of_table'-&gt; ok;
<a name="8463"/> 8463:                                   _ -&gt;
<a name="8464"/> 8464:                                       try ets:next(T, Prev) of
<a name="8465"/> 8465:                                            Normal -&gt; Normal
<a name="8466"/> 8466:                                        catch
<a name="8467"/> 8467:                                            error:badarg -&gt;
<a name="8468"/> 8468:                                                % sets (not ordered_sets) cannot handle when the argument
<a name="8469"/> 8469:                                                % to next is not in the set
<a name="8470"/> 8470:                                                rand:uniform(KeyRange)
<a name="8471"/> 8471:                                        end
<a name="8472"/> 8472:                               end
<a name="8473"/> 8473:                       end,
<a name="8474"/> 8474:                       Start,
<a name="8475"/> 8475:                       lists:seq(1, SeqSize)),
<a name="8476"/> 8476:                 case Last =:= -1 of
<a name="8477"/> 8477:                     true -&gt; io:format(&quot;Will never be printed&quot;);
<a name="8478"/> 8478:                     false -&gt; ok
<a name="8479"/> 8479:                 end
<a name="8480"/> 8480:         end,
<a name="8481"/> 8481:     PartialSelectOp =
<a name="8482"/> 8482:         fun (T, KeyRange, SeqSize) -&gt;
<a name="8483"/> 8483:                 Start = rand:uniform(KeyRange),
<a name="8484"/> 8484:                 Last = Start + SeqSize,
<a name="8485"/> 8485:                 case -1 =:= ets:select_count(T,
<a name="8486"/> 8486:                                              ets:fun2ms(fun({X}) when X &gt; Start andalso X =&lt; Last  -&gt; true end)) of
<a name="8487"/> 8487:                     true -&gt; io:format(&quot;Will never be printed&quot;);
<a name="8488"/> 8488:                     false -&gt; ok
<a name="8489"/> 8489:                 end
<a name="8490"/> 8490: 
<a name="8491"/> 8491:         end,
<a name="8492"/> 8492:     %% Mapping benchmark operation names to their corresponding functions that do them
<a name="8493"/> 8493:     Operations =
<a name="8494"/> 8494:         #{insert =&gt;
<a name="8495"/> 8495:               fun(T,KeyRange) -&gt;
<a name="8496"/> 8496:                       Num = rand:uniform(KeyRange),
<a name="8497"/> 8497:                       ets:insert(T, {Num})
<a name="8498"/> 8498:               end,
<a name="8499"/> 8499:           delete =&gt;
<a name="8500"/> 8500:               fun(T,KeyRange) -&gt;
<a name="8501"/> 8501:                       Num = rand:uniform(KeyRange),
<a name="8502"/> 8502:                       ets:delete(T, Num)
<a name="8503"/> 8503:               end,
<a name="8504"/> 8504:           lookup =&gt;
<a name="8505"/> 8505:               fun(T,KeyRange) -&gt;
<a name="8506"/> 8506:                       Num = rand:uniform(KeyRange),
<a name="8507"/> 8507:                       ets:lookup(T, Num)
<a name="8508"/> 8508:               end,
<a name="8509"/> 8509:           nextseq10 =&gt;
<a name="8510"/> 8510:               fun(T,KeyRange) -&gt; NextSeqOp(T,KeyRange,10) end,
<a name="8511"/> 8511:           nextseq100 =&gt;
<a name="8512"/> 8512:               fun(T,KeyRange) -&gt; NextSeqOp(T,KeyRange,100) end,
<a name="8513"/> 8513:           nextseq1000 =&gt;
<a name="8514"/> 8514:               fun(T,KeyRange) -&gt; NextSeqOp(T,KeyRange,1000) end,
<a name="8515"/> 8515:           selectAll =&gt;
<a name="8516"/> 8516:               fun(T,_KeyRange) -&gt;
<a name="8517"/> 8517:                       case -1 =:= ets:select_count(T, ets:fun2ms(fun(_X) -&gt; true end)) of
<a name="8518"/> 8518:                           true -&gt; io:format(&quot;Will never be printed&quot;);
<a name="8519"/> 8519:                           false -&gt; ok
<a name="8520"/> 8520:                       end
<a name="8521"/> 8521:               end,
<a name="8522"/> 8522:           partial_select1000 =&gt;
<a name="8523"/> 8523:               fun(T,KeyRange) -&gt; PartialSelectOp(T,KeyRange,1000) end
<a name="8524"/> 8524:          },
<a name="8525"/> 8525:     %% Helper functions
<a name="8526"/> 8526:     CalculateThreadCounts = fun Calculate([Count|Rest]) -&gt;
<a name="8527"/> 8527:                                     case Count &gt; NrOfSchedulers of
<a name="8528"/> 8528:                                         true -&gt; lists:reverse(Rest);
<a name="8529"/> 8529:                                         false -&gt; Calculate([Count*2,Count|Rest])
<a name="8530"/> 8530:                                     end
<a name="8531"/> 8531:                             end,
<a name="8532"/> 8532:     CalculateOpsProbHelpTab =
<a name="8533"/> 8533:         fun Calculate([{_, OpName}], _) -&gt;
<a name="8534"/> 8534:                 [{1.0, OpName}];
<a name="8535"/> 8535:             Calculate([{OpPropability, OpName}|Res], Current) -&gt;
<a name="8536"/> 8536:                 NewCurrent = Current + OpPropability,
<a name="8537"/> 8537:                 [{NewCurrent, OpName}| Calculate(Res, NewCurrent)]
<a name="8538"/> 8538:         end,
<a name="8539"/> 8539:     RenderScenario =
<a name="8540"/> 8540:         fun R([], StringSoFar) -&gt;
<a name="8541"/> 8541:                 StringSoFar;
<a name="8542"/> 8542:             R([{Fraction, Operation}], StringSoFar) -&gt;
<a name="8543"/> 8543:                 io_lib:format(&quot;~s ~f% ~p&quot;,[StringSoFar, Fraction * 100.0, Operation]);
<a name="8544"/> 8544:             R([{Fraction, Operation}|Rest], StringSoFar) -&gt;
<a name="8545"/> 8545:                 R(Rest,
<a name="8546"/> 8546:                   io_lib:format(&quot;~s ~f% ~p, &quot;,[StringSoFar, Fraction * 100.0, Operation]))
<a name="8547"/> 8547:         end,
<a name="8548"/> 8548:     SafeFixTableIfRequired =
<a name="8549"/> 8549:         fun(Table, Scenario, On) -&gt;
<a name="8550"/> 8550:                 case set =:= ets:info(Table, type) of
<a name="8551"/> 8551:                     true -&gt;
<a name="8552"/> 8552:                         HasNotRequiringOp  =
<a name="8553"/> 8553:                             lists:search(
<a name="8554"/> 8554:                               fun({_,nextseq10}) -&gt; true;
<a name="8555"/> 8555:                                  ({_,nextseq100}) -&gt; true;
<a name="8556"/> 8556:                                  ({_,nextseq1000}) -&gt; true;
<a name="8557"/> 8557:                                  (_) -&gt; false
<a name="8558"/> 8558:                               end, Scenario),
<a name="8559"/> 8559:                         case HasNotRequiringOp of
<a name="8560"/> 8560:                             false -&gt; ok;
<a name="8561"/> 8561:                             _ -&gt; ets:safe_fixtable(Table, On)
<a name="8562"/> 8562:                         end;
<a name="8563"/> 8563:                     false -&gt; ok
<a name="8564"/> 8564:                 end
<a name="8565"/> 8565:         end,
<a name="8566"/> 8566:     DataHolder =
<a name="8567"/> 8567:         fun DataHolderFun(Data)-&gt;
<a name="8568"/> 8568:                 receive
<a name="8569"/> 8569:                     {get_data, Pid} -&gt; Pid ! {ets_bench_data, Data};
<a name="8570"/> 8570:                     D -&gt; DataHolderFun([Data,D])
<a name="8571"/> 8571:                 end
<a name="8572"/> 8572:         end,
<a name="8573"/> 8573:     DataHolderPid = spawn_link(fun()-&gt; DataHolder([]) end),
<a name="8574"/> 8574:     PrintData =
<a name="8575"/> 8575:         fun (Str, List) -&gt;
<a name="8576"/> 8576:                 io:format(Str, List),
<a name="8577"/> 8577:                 DataHolderPid ! io_lib:format(Str, List)
<a name="8578"/> 8578:         end,
<a name="8579"/> 8579:     GetData =
<a name="8580"/> 8580:         fun () -&gt;
<a name="8581"/> 8581:                 DataHolderPid ! {get_data, self()},
<a name="8582"/> 8582:                 receive {ets_bench_data, Data} -&gt; Data end
<a name="8583"/> 8583:         end,
<a name="8584"/> 8584:     %% Function that runs a benchmark instance and returns the number
<a name="8585"/> 8585:     %% of operations that were performed
<a name="8586"/> 8586:     RunBenchmark =
<a name="8587"/> 8587:         fun({NrOfProcs, TableConfig, Scenario, Range, Duration, InitFun}) -&gt;
<a name="8588"/> 8588:                 ProbHelpTab = CalculateOpsProbHelpTab(Scenario, 0),
<a name="8589"/> 8589:                 Table = ets:new(t, TableConfig),
<a name="8590"/> 8590:                 Nobj = Range div 2,
<a name="8591"/> 8591:                 case InitFun of
<a name="8592"/> 8592:                     not_set -&gt; prefill_table(Table, Range, Nobj, fun(K) -&gt; {K} end);
<a name="8593"/> 8593:                     _ -&gt; InitFun(Table, Range, Nobj, fun(K) -&gt; {K} end)
<a name="8594"/> 8594:                 end,
<a name="8595"/> 8595:                 Nobj = ets:info(Table, size),
<a name="8596"/> 8596:                 SafeFixTableIfRequired(Table, Scenario, true),
<a name="8597"/> 8597:                 ParentPid = self(),
<a name="8598"/> 8598:                 Worker =
<a name="8599"/> 8599:                     fun() -&gt;
<a name="8600"/> 8600:                             receive start -&gt; ok end,
<a name="8601"/> 8601:                             WorksDone =
<a name="8602"/> 8602:                                 do_work(0, Table, ProbHelpTab, Range, Operations),
<a name="8603"/> 8603:                             ParentPid ! WorksDone
<a name="8604"/> 8604:                     end,
<a name="8605"/> 8605:                 ChildPids =
<a name="8606"/> 8606:                     lists:map(fun(_N) -&gt;spawn_link(Worker)end, lists:seq(1, NrOfProcs)),
<a name="8607"/> 8607:                 erlang:garbage_collect(),
<a name="8608"/> 8608:                 timer:sleep(RecoverTimeMs),
<a name="8609"/> 8609:                 lists:foreach(fun(Pid) -&gt; Pid ! start end, ChildPids),
<a name="8610"/> 8610:                 timer:sleep(Duration),
<a name="8611"/> 8611:                 lists:foreach(fun(Pid) -&gt; Pid ! stop end, ChildPids),
<a name="8612"/> 8612:                 TotalWorksDone = lists:foldl(
<a name="8613"/> 8613:                                    fun(_, Sum) -&gt;
<a name="8614"/> 8614:                                            receive
<a name="8615"/> 8615:                                                Count -&gt; Sum + Count
<a name="8616"/> 8616:                                            end
<a name="8617"/> 8617:                                    end, 0, ChildPids),
<a name="8618"/> 8618:                 SafeFixTableIfRequired(Table, Scenario, false),
<a name="8619"/> 8619:                 ets:delete(Table),
<a name="8620"/> 8620:                 TotalWorksDone
<a name="8621"/> 8621:         end,
<a name="8622"/> 8622:     RunBenchmarkInSepProcess =
<a name="8623"/> 8623:         fun(ParameterTuple) -&gt;
<a name="8624"/> 8624:                 P = self(),
<a name="8625"/> 8625:                 Results =
<a name="8626"/> 8626:                     [begin
<a name="8627"/> 8627:                          spawn_link(fun()-&gt; P ! {bench_result, RunBenchmark(ParameterTuple)} end),
<a name="8628"/> 8628:                          receive {bench_result, Res} -&gt; Res end
<a name="8629"/> 8629:                      end || _ &lt;- lists:seq(1, NrOfRepeats)],
<a name="8630"/> 8630:                 lists:sum(Results) / NrOfRepeats
<a name="8631"/> 8631:         end,
<a name="8632"/> 8632:     RunBenchmarkAndReport =
<a name="8633"/> 8633:         fun(ThreadCount,
<a name="8634"/> 8634:             TableType,
<a name="8635"/> 8635:             Scenario,
<a name="8636"/> 8636:             KeyRange,
<a name="8637"/> 8637:             Duration,
<a name="8638"/> 8638:             InitFunName,
<a name="8639"/> 8639:             InitFun) -&gt;
<a name="8640"/> 8640:                 Result = RunBenchmarkInSepProcess({ThreadCount,
<a name="8641"/> 8641:                                                    TableType,
<a name="8642"/> 8642:                                                    Scenario,
<a name="8643"/> 8643:                                                    KeyRange,
<a name="8644"/> 8644:                                                    Duration,
<a name="8645"/> 8645:                                                    InitFun}),
<a name="8646"/> 8646:                 Throughput = Result/(Duration/1000.0),
<a name="8647"/> 8647:                 PrintData(&quot;; ~f&quot;,[Throughput]),
<a name="8648"/> 8648:                 Name = io_lib:format(&quot;Scenario: ~s, ~w, Key Range Size: ~w, &quot;
<a name="8649"/> 8649:                                      &quot;# of Processes: ~w, Table Type: ~w&quot;,
<a name="8650"/> 8650:                                      [InitFunName, Scenario, KeyRange, ThreadCount, TableType]),
<a name="8651"/> 8651:                 NotifyResFun(Name, Throughput)
<a name="8652"/> 8652:         end,
<a name="8653"/> 8653:     ThreadCounts =
<a name="8654"/> 8654:         case ThreadCountsOpt of
<a name="8655"/> 8655:             not_set -&gt;
<a name="8656"/> 8656:                 CalculateThreadCounts([1]);
<a name="8657"/> 8657:             _ -&gt; ThreadCountsOpt
<a name="8658"/> 8658:         end,
<a name="8659"/> 8659:     %% Run the benchmark
<a name="8660"/> 8660:     PrintData(&quot;# Each instance of the benchmark runs for ~w seconds:~n&quot;, [BenchmarkDurationMs/1000]),
<a name="8661"/> 8661:     PrintData(&quot;# The result of a benchmark instance is presented as a number representing~n&quot;,[]),
<a name="8662"/> 8662:     PrintData(&quot;# the number of operations performed per second:~n~n~n&quot;,[]),
<a name="8663"/> 8663:     PrintData(&quot;# To plot graphs for the results below:~n&quot;,[]),
<a name="8664"/> 8664:     PrintData(&quot;# 1. Open \&quot;$ERL_TOP/lib/stdlib/test/ets_SUITE_data/visualize_throughput.html\&quot; in a web browser~n&quot;,[]),
<a name="8665"/> 8665:     PrintData(&quot;# 2. Copy the lines between \&quot;#BENCHMARK STARTED$\&quot; and \&quot;#BENCHMARK ENDED$\&quot; below~n&quot;,[]),
<a name="8666"/> 8666:     PrintData(&quot;# 3. Paste the lines copied in step 2 to the text box in the browser window opened in~n&quot;,[]),
<a name="8667"/> 8667:     PrintData(&quot;#    step 1 and press the Render button~n~n&quot;,[]),
<a name="8668"/> 8668:     PrintData(&quot;#BENCHMARK STARTED$~n&quot;,[]),
<a name="8669"/> 8669:     EtsMem = ETSMemFun(),
<a name="8670"/> 8670:     %% The following loop runs all benchmark scenarios and prints the results (i.e, operations/second)
<a name="8671"/> 8671:     lists:foreach(
<a name="8672"/> 8672:       fun(KeyRange) -&gt;
<a name="8673"/> 8673:               lists:foreach(
<a name="8674"/> 8674:                 fun(Scenario) -&gt;
<a name="8675"/> 8675:                         PrintData(&quot;Scenario: ~s | Key Range Size: ~w$~n&quot;,
<a name="8676"/> 8676:                                   [RenderScenario(Scenario, &quot;&quot;), KeyRange]),
<a name="8677"/> 8677:                         lists:foreach(
<a name="8678"/> 8678:                           fun(ThreadCount) -&gt;
<a name="8679"/> 8679:                                   PrintData(&quot;; ~w&quot;,[ThreadCount])
<a name="8680"/> 8680:                           end,
<a name="8681"/> 8681:                           ThreadCounts),
<a name="8682"/> 8682:                         PrintData(&quot;$~n&quot;,[]),
<a name="8683"/> 8683:                         lists:foreach(
<a name="8684"/> 8684:                           fun(TableType) -&gt;
<a name="8685"/> 8685:                                   lists:foreach(
<a name="8686"/> 8686:                                     fun(InitFunArg) -&gt;
<a name="8687"/> 8687:                                             {InitFunName, InitFun} =
<a name="8688"/> 8688:                                                 case InitFunArg of
<a name="8689"/> 8689:                                                     {FunName, Fun} -&gt; {FunName, Fun};
<a name="8690"/> 8690:                                                     Fun -&gt; {&quot;&quot;, Fun}
<a name="8691"/> 8691:                                                 end,
<a name="8692"/> 8692:                                             PrintData(&quot;~s,~w &quot;,[InitFunName,TableType]),
<a name="8693"/> 8693:                                             lists:foreach(
<a name="8694"/> 8694:                                               fun(ThreadCount) -&gt;
<a name="8695"/> 8695:                                                       RunBenchmarkAndReport(ThreadCount,
<a name="8696"/> 8696:                                                                             TableType,
<a name="8697"/> 8697:                                                                             Scenario,
<a name="8698"/> 8698:                                                                             KeyRange,
<a name="8699"/> 8699:                                                                             BenchmarkDurationMs,
<a name="8700"/> 8700:                                                                             InitFunName,
<a name="8701"/> 8701:                                                                             InitFun)
<a name="8702"/> 8702:                                               end,
<a name="8703"/> 8703:                                               ThreadCounts),
<a name="8704"/> 8704:                                             PrintData(&quot;$~n&quot;,[])
<a name="8705"/> 8705:                                     end,
<a name="8706"/> 8706:                                     InitFuns)
<a name="8707"/> 8707: 
<a name="8708"/> 8708:                           end,
<a name="8709"/> 8709:                           TableTypes)
<a name="8710"/> 8710:                 end,
<a name="8711"/> 8711:                 Scenarios)
<a name="8712"/> 8712:       end,
<a name="8713"/> 8713:       KeyRanges),
<a name="8714"/> 8714:     PrintData(&quot;~n#BENCHMARK ENDED$~n~n&quot;,[]),
<a name="8715"/> 8715:     VerifyETSMemFun(EtsMem),
<a name="8716"/> 8716:     DataDir = filename:join(filename:dirname(code:which(?MODULE)), &quot;ets_SUITE_data&quot;),
<a name="8717"/> 8717:     TemplatePath = filename:join(DataDir, &quot;visualize_throughput.html&quot;),
<a name="8718"/> 8718:     {ok, Template} = file:read_file(TemplatePath),
<a name="8719"/> 8719:     OutputData = string:replace(Template, &quot;#bench_data_placeholder&quot;, GetData()),
<a name="8720"/> 8720:     OutputPath1 = filename:join(DataDir, &quot;ets_bench_result.html&quot;),
<a name="8721"/> 8721:     {{Year, Month, Day}, {Hour, Minute, Second}} = calendar:now_to_datetime(erlang:timestamp()),
<a name="8722"/> 8722:     StrTime = lists:flatten(io_lib:format(&quot;~4..0w-~2..0w-~2..0wT~2..0w:~2..0w:~2..0w&quot;,[Year,Month,Day,Hour,Minute,Second])),
<a name="8723"/> 8723:     OutputPath2 = filename:join(DataDir, io_lib:format(&quot;ets_bench_result_~s.html&quot;, [StrTime])),
<a name="8724"/> 8724:     file:write_file(OutputPath1, OutputData),
<a name="8725"/> 8725:     file:write_file(OutputPath2, OutputData),
<a name="throughput_benchmark-last_expr"/><a name="8726"/> 8726: <b>    PrintResultPathsFun</b>(OutputPath2, OutputPath1).
<a name="8727"/> 8727: 
<a name="test_throughput_benchmark-1"/><a name="8728"/> 8728: <b>test_throughput_benchmark</b>(Config) when is_list(Config) -&gt;
<a name="test_throughput_benchmark-last_expr"/><a name="8729"/> 8729: <b>    throughput_benchmark</b>(
<a name="8730"/> 8730:       #ets_throughput_bench_config{
<a name="8731"/> 8731:          benchmark_duration_ms = 100,
<a name="8732"/> 8732:          recover_time_ms = 0,
<a name="8733"/> 8733:          thread_counts = [1, erlang:system_info(schedulers)],
<a name="8734"/> 8734:          key_ranges = [50000],
<a name="8735"/> 8735:          etsmem_fun = fun etsmem/0,
<a name="8736"/> 8736:          verify_etsmem_fun = fun verify_etsmem/1}).
<a name="8737"/> 8737: 
<a name="long_throughput_benchmark-1"/><a name="8738"/> 8738: <b>long_throughput_benchmark</b>(Config) when is_list(Config) -&gt;
<a name="8739"/> 8739:     N = erlang:system_info(schedulers),
<a name="long_throughput_benchmark-last_expr"/><a name="8740"/> 8740: <b>    throughput_benchmark</b>(
<a name="8741"/> 8741:       #ets_throughput_bench_config{
<a name="8742"/> 8742:          benchmark_duration_ms = 3000,
<a name="8743"/> 8743:          recover_time_ms = 1000,
<a name="8744"/> 8744:          thread_counts = [1, N div 2, N],
<a name="8745"/> 8745:          key_ranges = [1000000],
<a name="8746"/> 8746:          scenarios =
<a name="8747"/> 8747:              [
<a name="8748"/> 8748:               [
<a name="8749"/> 8749:                {0.5, insert},
<a name="8750"/> 8750:                {0.5, delete}
<a name="8751"/> 8751:               ],
<a name="8752"/> 8752:               [
<a name="8753"/> 8753:                {0.1, insert},
<a name="8754"/> 8754:                {0.1, delete},
<a name="8755"/> 8755:                {0.8, lookup}
<a name="8756"/> 8756:               ],
<a name="8757"/> 8757:               [
<a name="8758"/> 8758:                {0.01, insert},
<a name="8759"/> 8759:                {0.01, delete},
<a name="8760"/> 8760:                {0.98, lookup}
<a name="8761"/> 8761:               ],
<a name="8762"/> 8762:               [
<a name="8763"/> 8763:                {0.1, insert},
<a name="8764"/> 8764:                {0.1, delete},
<a name="8765"/> 8765:                {0.4, lookup},
<a name="8766"/> 8766:                {0.4, nextseq100}
<a name="8767"/> 8767:               ],
<a name="8768"/> 8768:               [
<a name="8769"/> 8769:                {0.1, insert},
<a name="8770"/> 8770:                {0.1, delete},
<a name="8771"/> 8771:                {0.79, lookup},
<a name="8772"/> 8772:                {0.01, selectAll}
<a name="8773"/> 8773:               ],
<a name="8774"/> 8774:               [
<a name="8775"/> 8775:                {0.1, insert},
<a name="8776"/> 8776:                {0.1, delete},
<a name="8777"/> 8777:                {0.79, lookup},
<a name="8778"/> 8778:                {0.01, partial_select1000}
<a name="8779"/> 8779:               ]
<a name="8780"/> 8780:              ],
<a name="8781"/> 8781:          table_types =
<a name="8782"/> 8782:              ([
<a name="8783"/> 8783:                [ordered_set, public, {write_concurrency, true}, {read_concurrency, true}],
<a name="8784"/> 8784:                [set, public, {write_concurrency, true}, {read_concurrency, true}]
<a name="8785"/> 8785:               ] ++
<a name="8786"/> 8786:                   case catch list_to_integer(erlang:system_info(otp_release)) of
<a name="8787"/> 8787:                       Recent when is_integer(Recent), Recent &gt;= 25 -&gt;
<a name="8788"/> 8788:                           [[set, public, {write_concurrency, auto}, {read_concurrency, true}]];
<a name="8789"/> 8789:                       _Old -&gt; []
<a name="8790"/> 8790:                   end),
<a name="8791"/> 8791:          etsmem_fun = fun etsmem/0,
<a name="8792"/> 8792:          verify_etsmem_fun = fun verify_etsmem/1,
<a name="8793"/> 8793:          notify_res_fun =
<a name="8794"/> 8794:              fun(Name, Throughput) -&gt;
<a name="8795"/> 8795:                      SummaryTable =
<a name="8796"/> 8796:                          proplists:get_value(ets_benchmark_result_summary_tab, Config),
<a name="8797"/> 8797:                      AddToSummaryCounter =
<a name="8798"/> 8798:                          case SummaryTable of
<a name="8799"/> 8799:                              undefined -&gt;
<a name="8800"/> 8800:                                  fun(_, _) -&gt;
<a name="8801"/> 8801:                                          ok
<a name="8802"/> 8802:                                  end;
<a name="8803"/> 8803:                              Tab -&gt;
<a name="8804"/> 8804:                                  fun(CounterName, ToAdd) -&gt;
<a name="8805"/> 8805:                                          OldVal = ets:lookup_element(Tab, CounterName, 2),
<a name="8806"/> 8806:                                          NewVal = OldVal + ToAdd,
<a name="8807"/> 8807:                                          ets:insert(Tab, {CounterName, NewVal})
<a name="8808"/> 8808:                                  end
<a name="8809"/> 8809:                          end,
<a name="8810"/> 8810:                      Record =
<a name="8811"/> 8811:                          fun(NoOfBenchsCtr, TotThrputCtr) -&gt;
<a name="8812"/> 8812:                                  AddToSummaryCounter(NoOfBenchsCtr, 1),
<a name="8813"/> 8813:                                  AddToSummaryCounter(TotThrputCtr, Throughput)
<a name="8814"/> 8814:                          end,
<a name="8815"/> 8815:                      Record(nr_of_benchmarks, total_throughput),
<a name="8816"/> 8816:                      case string:find(Name, &quot;ordered_set&quot;) of
<a name="8817"/> 8817:                          nomatch -&gt;
<a name="8818"/> 8818:                              Record(nr_of_set_benchmarks, total_throughput_set);
<a name="8819"/> 8819:                          _ -&gt;
<a name="8820"/> 8820:                              Record(nr_of_ordered_set_benchmarks,
<a name="8821"/> 8821:                                     total_throughput_ordered_set)
<a name="8822"/> 8822:                      end,
<a name="8823"/> 8823:                      ct_event:notify(
<a name="8824"/> 8824:                           #event{name = benchmark_data,
<a name="8825"/> 8825:                                  data = [{suite,&quot;ets_bench&quot;},
<a name="8826"/> 8826:                                          {name, Name},
<a name="8827"/> 8827:                                          {value,Throughput}]})
<a name="8828"/> 8828:              end
<a name="8829"/> 8829:         }).
<a name="8830"/> 8830: 
<a name="8831"/> 8831: <i>%% This function compares the lookup operation's performance for</i>
<a name="8832"/> 8832: <i>%% ordered_set ETS tables with and without write_concurrency enabled</i>
<a name="8833"/> 8833: <i>%% when the data structures have been populated in parallel and</i>
<a name="8834"/> 8834: <i>%% sequentially.</i>
<a name="8835"/> 8835: <i>%%</i>
<a name="8836"/> 8836: <i>%% The main purpose of this function is to check that the</i>
<a name="8837"/> 8837: <i>%% implementation of ordered_set with write_concurrency (CA tree)</i>
<a name="8838"/> 8838: <i>%% adapts its structure to contention even when only lookup operations</i>
<a name="8839"/> 8839: <i>%% are used.</i>
<a name="lookup_catree_par_vs_seq_init_benchmark-0"/><a name="8840"/> 8840: <b>lookup_catree_par_vs_seq_init_benchmark</b>() -&gt;
<a name="8841"/> 8841:     N = erlang:system_info(schedulers),
<a name="lookup_catree_par_vs_seq_init_benchmark-last_expr"/><a name="8842"/> 8842: <b>    throughput_benchmark</b>(
<a name="8843"/> 8843:       #ets_throughput_bench_config{
<a name="8844"/> 8844:          benchmark_duration_ms = 600000,
<a name="8845"/> 8845:          recover_time_ms = 1000,
<a name="8846"/> 8846:          thread_counts = [1, N div 2, N],
<a name="8847"/> 8847:          key_ranges = [1000000],
<a name="8848"/> 8848:          init_functions = [{&quot;seq_init&quot;, fun prefill_table/4},
<a name="8849"/> 8849:                            {&quot;par_init&quot;, fun prefill_table_parallel/4}],
<a name="8850"/> 8850:          nr_of_repeats = 1,
<a name="8851"/> 8851:          scenarios =
<a name="8852"/> 8852:              [
<a name="8853"/> 8853:               [
<a name="8854"/> 8854:                {1.0, lookup}
<a name="8855"/> 8855:               ]
<a name="8856"/> 8856:              ],
<a name="8857"/> 8857:          table_types =
<a name="8858"/> 8858:              [
<a name="8859"/> 8859:               [ordered_set, public, {write_concurrency, true}],
<a name="8860"/> 8860:               [ordered_set, public]
<a name="8861"/> 8861:              ],
<a name="8862"/> 8862:           print_result_paths_fun = fun stdout_notify_res/2
<a name="8863"/> 8863:         }).
<a name="8864"/> 8864: 
<a name="add_lists-2"/><a name="8865"/> 8865: <b>add_lists</b>(L1,L2) -&gt;
<a name="add_lists-last_expr"/><a name="8866"/> 8866: <b>    add_lists</b>(L1,L2,[]).
<a name="add_lists-3"/><a name="8867"/> 8867: <b>add_lists</b>([],[],Acc) -&gt;
<a name="8868"/> 8868:     lists:reverse(Acc);
<a name="8869"/> 8869: <b>add_lists</b>([E1|T1], [E2|T2], Acc) -&gt;
<a name="add_lists-last_expr"/><a name="8870"/> 8870: <b>    add_lists</b>(T1, T2, [E1+E2 | Acc]).
<a name="8871"/> 8871: 
<a name="run_smp_workers-4"/><a name="8872"/> 8872: <b>run_smp_workers</b>(InitF,ExecF,FiniF,Laps) -&gt;
<a name="run_smp_workers-last_expr"/><a name="8873"/> 8873: <b>    run_smp_workers</b>(InitF,ExecF,FiniF,Laps, 0).
<a name="run_smp_workers-5"/><a name="8874"/> 8874: <b>run_smp_workers</b>(InitF,ExecF,FiniF,Laps, Exclude) -&gt;
<a name="run_smp_workers-last_expr"/><a name="8875"/> 8875: <b>    case erlang:system_info</b>(schedulers_online) of
<a name="8876"/> 8876:         N when N &gt; Exclude -&gt;
<a name="8877"/> 8877:             run_workers_do(InitF,ExecF,FiniF,Laps, N - Exclude);
<a name="8878"/> 8878:         _ -&gt;
<a name="8879"/> 8879:             {skipped, &quot;Too few schedulers online&quot;}
<a name="8880"/> 8880:     end.
<a name="8881"/> 8881: 
<a name="run_sched_workers-4"/><a name="8882"/> 8882: <b>run_sched_workers</b>(InitF,ExecF,FiniF,Laps) -&gt;
<a name="run_sched_workers-last_expr"/><a name="8883"/> 8883: <b>    run_workers_do</b>(InitF,ExecF,FiniF,Laps,
<a name="8884"/> 8884:                    erlang:system_info(schedulers)).
<a name="8885"/> 8885: 
<a name="run_workers_do-5"/><a name="8886"/> 8886: <b>run_workers_do</b>(InitF,ExecF,FiniF,Laps, NumOfProcs) -&gt;
<a name="8887"/> 8887:     io:format(&quot;starting ~p workers\n&quot;,[NumOfProcs]),
<a name="8888"/> 8888:     Seeds = [{ProcN,rand:uniform(9999)} || ProcN &lt;- lists:seq(1,NumOfProcs)],
<a name="8889"/> 8889:     Parent = self(),
<a name="8890"/> 8890:     Pids = [my_spawn_link(fun()-&gt; worker(Seed,InitF,ExecF,FiniF,Laps,Parent,NumOfProcs) end)
<a name="8891"/> 8891: 	    || Seed &lt;- Seeds],
<a name="run_workers_do-last_expr"/><a name="8892"/> 8892:     case Laps of
<a name="8893"/> 8893: 	infinite -&gt; Pids;
<a name="8894"/> 8894: 	_ -&gt; wait_pids(Pids)
<a name="8895"/> 8895:     end.
<a name="8896"/> 8896: 
<a name="worker-7"/><a name="8897"/> 8897: <b>worker</b>({ProcN,Seed}, InitF, ExecF, FiniF, Laps, Parent, NumOfProcs) -&gt;
<a name="8898"/> 8898:     io:format(&quot;smp worker ~p, seed=~p~n&quot;,[self(),Seed]),
<a name="8899"/> 8899:     rand:seed(default, {Seed,Seed,Seed}),
<a name="8900"/> 8900:     State1 = InitF([ProcN, NumOfProcs]),
<a name="8901"/> 8901:     State2 = worker_loop(Laps, ExecF, State1),
<a name="8902"/> 8902:     Result = FiniF(State2),
<a name="8903"/> 8903:     io:format(&quot;worker ~p done\n&quot;,[self()]),
<a name="worker-last_expr"/><a name="8904"/> 8904: <b>    Parent ! {self</b>(), Result}.
<a name="8905"/> 8905: 
<a name="worker_loop-3"/><a name="8906"/> 8906: <b>worker_loop</b>(0, _, State) -&gt;
<a name="8907"/> 8907:     State;
<a name="8908"/> 8908: <b>worker_loop</b>(_, _, [end_of_work|State]) -&gt;
<a name="8909"/> 8909:     State;
<a name="8910"/> 8910: <b>worker_loop</b>(infinite, ExecF, State) -&gt;
<a name="8911"/> 8911:     worker_loop(infinite,ExecF,ExecF(State));
<a name="8912"/> 8912: <b>worker_loop</b>(N, ExecF, State) -&gt;
<a name="worker_loop-last_expr"/><a name="8913"/> 8913: <b>    worker_loop</b>(N-1,ExecF,ExecF(State)).
<a name="8914"/> 8914: 
<a name="wait_pids-1"/><a name="8915"/> 8915: <b>wait_pids</b>(Pids) -&gt;
<a name="wait_pids-last_expr"/><a name="8916"/> 8916: <b>    wait_pids</b>(Pids,[]).
<a name="wait_pids-2"/><a name="8917"/> 8917: <b>wait_pids</b>([],Acc) -&gt;
<a name="8918"/> 8918:     Acc;
<a name="8919"/> 8919: <b>wait_pids</b>(Pids, Acc) -&gt;
<a name="wait_pids-last_expr"/><a name="8920"/> 8920:     receive
<a name="8921"/> 8921: 	{Pid,Result} -&gt;
<a name="8922"/> 8922: 	    true = lists:member(Pid,Pids),
<a name="8923"/> 8923: 	    Others = lists:delete(Pid,Pids),
<a name="8924"/> 8924: 	    %%io:format(&quot;wait_pid got ~p from ~p\n&quot;,[Result,Pid]),
<a name="8925"/> 8925: 	    wait_pids(Others,[Result | Acc])
<a name="8926"/> 8926:     after 60*1000 -&gt;
<a name="8927"/> 8927: 	    io:format(&quot;Still waiting for workers ~p\n&quot;,[Pids]),
<a name="8928"/> 8928:             wait_pids(Pids, Acc)
<a name="8929"/> 8929:     end.
<a name="8930"/> 8930: 
<a name="8931"/> 8931: 
<a name="8932"/> 8932: 
<a name="8933"/> 8933: 
<a name="my_tab_to_list-1"/><a name="8934"/> 8934: <b>my_tab_to_list</b>(Ts) -&gt;
<a name="8935"/> 8935:     Key = ets:first(Ts),
<a name="my_tab_to_list-last_expr"/><a name="8936"/> 8936: <b>    my_tab_to_list</b>(Ts,ets:next(Ts,Key),[ets:lookup(Ts, Key)]).
<a name="8937"/> 8937: 
<a name="my_tab_to_list-3"/><a name="8938"/> 8938: <b>my_tab_to_list</b>(_Ts,'$end_of_table', Acc) -&gt; lists:reverse(Acc);
<a name="8939"/> 8939: <b>my_tab_to_list</b>(Ts,Key, Acc) -&gt;
<a name="my_tab_to_list-last_expr"/><a name="8940"/> 8940: <b>    my_tab_to_list</b>(Ts,ets:next(Ts,Key),[ets:lookup(Ts, Key)| Acc]).
<a name="8941"/> 8941: 
<a name="8942"/> 8942: 
<a name="wait_for_memory_deallocations-0"/><a name="8943"/> 8943: <b>wait_for_memory_deallocations</b>() -&gt;
<a name="wait_for_memory_deallocations-last_expr"/><a name="8944"/> 8944:     try
<a name="8945"/> 8945: 	erts_debug:set_internal_state(wait, thread_progress),
<a name="8946"/> 8946: 	erts_debug:set_internal_state(wait, deallocations)
<a name="8947"/> 8947:     catch
<a name="8948"/> 8948: 	error:undef -&gt;
<a name="8949"/> 8949: 	    erts_debug:set_internal_state(available_internal_state, true),
<a name="8950"/> 8950: 	    wait_for_memory_deallocations();
<a name="8951"/> 8951:         error:badarg -&gt;
<a name="8952"/> 8952:             %% The emulator we run on does not have the wait internal state
<a name="8953"/> 8953:             %% so we just sleep some time instead...
<a name="8954"/> 8954:             timer:sleep(100)
<a name="8955"/> 8955:     end.
<a name="8956"/> 8956: 
<a name="etsmem-0"/><a name="8957"/> 8957: <b>etsmem</b>() -&gt;
<a name="etsmem-last_expr"/><a name="8958"/> 8958: <b>    etsmem</b>(get_etsmem(), 1).
<a name="8959"/> 8959: 
<a name="etsmem-2"/><a name="8960"/> 8960: <b>etsmem</b>(PrevEtsMem, Try) when Try &lt; 10 -&gt;
<a name="8961"/> 8961:     case get_etsmem() of
<a name="8962"/> 8962:         PrevEtsMem -&gt;
<a name="8963"/> 8963:             PrevEtsMem;
<a name="8964"/> 8964:         EtsMem -&gt;
<a name="8965"/> 8965:             io:format(&quot;etsmem(): Change in attempt ~p~n~nbefore:~n~p~n~nafter:~n~p~n~n&quot;,
<a name="8966"/> 8966:                       [Try, PrevEtsMem, EtsMem]),
<a name="8967"/> 8967:             etsmem(EtsMem, Try+1)
<a name="8968"/> 8968:     end;
<a name="8969"/> 8969: <b>etsmem</b>(_, _) -&gt;
<a name="etsmem-last_expr"/><a name="8970"/> 8970: <b>    ct:fail</b>(&quot;Failed to get a stable/consistent memory snapshot&quot;).
<a name="8971"/> 8971: 
<a name="get_etsmem-0"/><a name="8972"/> 8972: <b>get_etsmem</b>() -&gt;
<a name="8973"/> 8973:     AllTabsExceptions = [logger, code],
<a name="8974"/> 8974:     %% The logger table is excluded from the AllTabs list
<a name="8975"/> 8975:     %% below because it uses decentralized counters to keep
<a name="8976"/> 8976:     %% track of the size and the memory counters. This cause
<a name="8977"/> 8977:     %% ets:info(T,size) and ets:info(T,memory) to trigger
<a name="8978"/> 8978:     %% allocations and frees that may change the amount of
<a name="8979"/> 8979:     %% memory that is allocated for ETS.
<a name="8980"/> 8980:     %%
<a name="8981"/> 8981:     %% The code table is excluded from the list below
<a name="8982"/> 8982:     %% because the amount of memory allocated for it may
<a name="8983"/> 8983:     %% change if the tested code loads a new module.
<a name="8984"/> 8984:     AllTabs =
<a name="8985"/> 8985:         lists:sort(
<a name="8986"/> 8986:           [begin
<a name="8987"/> 8987:                try ets:info(T, decentralized_counters) of
<a name="8988"/> 8988:                    true -&gt;
<a name="8989"/> 8989:                        ct:fail(&quot;Background ETS table (~p) that &quot;
<a name="8990"/> 8990:                                &quot;uses decentralized counters (Add exception?)&quot;,
<a name="8991"/> 8991:                                [ets:info(T,name)]);
<a name="8992"/> 8992:                    _ -&gt; ok
<a name="8993"/> 8993:                catch _:_ -&gt;
<a name="8994"/> 8994:                        ok
<a name="8995"/> 8995:                end,
<a name="8996"/> 8996:                {T,
<a name="8997"/> 8997:                 ets:info(T,name),
<a name="8998"/> 8998:                 ets:info(T,size),
<a name="8999"/> 8999:                 ets:info(T,memory),
<a name="9000"/> 9000:                 ets:info(T,type)}
<a name="9001"/> 9001:            end
<a name="9002"/> 9002:            || T &lt;- ets:all(),
<a name="9003"/> 9003:               not lists:member(ets:info(T, name), AllTabsExceptions)]),
<a name="9004"/> 9004:     wait_for_memory_deallocations(),
<a name="9005"/> 9005:     EtsAllocSize = erts_debug:alloc_blocks_size(ets_alloc),
<a name="9006"/> 9006:     ErlangMemoryEts = try erlang:memory(ets)
<a name="9007"/> 9007:                       catch error:notsup -&gt; notsup end,
<a name="9008"/> 9008:     FlxCtrMemUsage = try erts_debug:get_internal_state(flxctr_memory_usage)
<a name="9009"/> 9009:                      catch error:badarg -&gt; notsup end,
<a name="9010"/> 9010:     Mem = {ErlangMemoryEts, EtsAllocSize, FlxCtrMemUsage},
<a name="get_etsmem-last_expr"/><a name="9011"/> 9011:     {Mem, AllTabs}.
<a name="9012"/> 9012: 
<a name="verify_etsmem-1"/><a name="9013"/> 9013: <b>verify_etsmem</b>(MI) -&gt;
<a name="9014"/> 9014:     wait_for_test_procs(),
<a name="verify_etsmem-last_expr"/><a name="9015"/> 9015: <b>    verify_etsmem</b>(MI, 1).
<a name="9016"/> 9016: 
<a name="verify_etsmem-2"/><a name="9017"/> 9017: <b>verify_etsmem</b>({MemInfo,AllTabs}, Try) -&gt;
<a name="verify_etsmem-last_expr"/><a name="9018"/> 9018: <b>    case etsmem</b>() of
<a name="9019"/> 9019: 	{MemInfo,_} -&gt;
<a name="9020"/> 9020: 	    io:format(&quot;Ets mem info: ~p&quot;, [MemInfo]),
<a name="9021"/> 9021: 	    case {MemInfo, Try} of
<a name="9022"/> 9022: 		{{ErlMem,EtsAlloc},_} when ErlMem == notsup; EtsAlloc == undefined -&gt;
<a name="9023"/> 9023: 		    %% Use 'erl +Mea max' to do more complete memory leak testing.
<a name="9024"/> 9024: 		    {comment,&quot;Incomplete or no mem leak testing&quot;};
<a name="9025"/> 9025: 		{_, 1} -&gt;
<a name="9026"/> 9026:                     ok;
<a name="9027"/> 9027:                 _ -&gt;
<a name="9028"/> 9028:                     {comment, &quot;Transient memory discrepancy&quot;}
<a name="9029"/> 9029: 	    end;
<a name="9030"/> 9030: 
<a name="9031"/> 9031: 	{MemInfo2, AllTabs2} -&gt;
<a name="9032"/> 9032: 	    io:format(&quot;#Expected: ~p&quot;, [MemInfo]),
<a name="9033"/> 9033: 	    io:format(&quot;#Actual:   ~p&quot;, [MemInfo2]),
<a name="9034"/> 9034: 	    io:format(&quot;#Changed tables before: ~p\n&quot;,[AllTabs -- AllTabs2]),
<a name="9035"/> 9035: 	    io:format(&quot;#Changed tables after: ~p\n&quot;, [AllTabs2 -- AllTabs]),
<a name="9036"/> 9036:             case Try &lt; 2 of
<a name="9037"/> 9037:                 true -&gt;
<a name="9038"/> 9038:                     io:format(&quot;\n#This discrepancy could be caused by an &quot;
<a name="9039"/> 9039:                               &quot;inconsistent memory \&quot;snapshot\&quot;&quot;
<a name="9040"/> 9040:                               &quot;\n#Try again...\n&quot;, []),
<a name="9041"/> 9041:                     verify_etsmem({MemInfo, AllTabs}, Try+1);
<a name="9042"/> 9042:                 false -&gt;
<a name="9043"/> 9043:                     ct:fail(&quot;Failed memory check&quot;)
<a name="9044"/> 9044:             end
<a name="9045"/> 9045:     end.
<a name="9046"/> 9046: 
<a name="9047"/> 9047: 
<a name="start_loopers-4"/><a name="9048"/> 9048: <b>start_loopers</b>(N, Prio, Fun, State) -&gt;
<a name="start_loopers-last_expr"/><a name="9049"/> 9049: <b>    lists:map</b>(fun (_) -&gt;
<a name="9050"/> 9050: 		      my_spawn_opt(fun () -&gt; looper(Fun, State) end,
<a name="9051"/> 9051: 				   [{priority, Prio}, link])
<a name="9052"/> 9052: 	      end,
<a name="9053"/> 9053: 	      lists:seq(1, N)).
<a name="9054"/> 9054: 
<a name="stop_loopers-1"/><a name="9055"/> 9055: <b>stop_loopers</b>(Loopers) -&gt;
<a name="9056"/> 9056:     lists:foreach(fun (P) -&gt;
<a name="9057"/> 9057: 			  unlink(P),
<a name="9058"/> 9058: 			  exit(P, bang)
<a name="9059"/> 9059: 		  end,
<a name="9060"/> 9060: 		  Loopers),
<a name="stop_loopers-last_expr"/><a name="9061"/> 9061:     ok.
<a name="9062"/> 9062: 
<a name="looper-2"/><a name="9063"/> 9063: <b>looper</b>(Fun, State) -&gt;
<a name="looper-last_expr"/><a name="9064"/> 9064: <b>    looper</b>(Fun, Fun(State)).
<a name="9065"/> 9065: 
<a name="spawn_logger-1"/><a name="9066"/> 9066: <b>spawn_logger</b>(Procs) -&gt;
<a name="spawn_logger-last_expr"/><a name="9067"/> 9067:     receive
<a name="9068"/> 9068: 	{new_test_proc, Proc} -&gt;
<a name="9069"/> 9069: 	    spawn_logger([Proc|Procs]);
<a name="9070"/> 9070: 	{sync_test_procs, Kill, From} -&gt;
<a name="9071"/> 9071: 	    lists:foreach(fun (Proc) when From == Proc -&gt;
<a name="9072"/> 9072: 				  ok;
<a name="9073"/> 9073: 			      (Proc) -&gt;
<a name="9074"/> 9074: 				  Mon = erlang:monitor(process, Proc),
<a name="9075"/> 9075: 				  ok = receive
<a name="9076"/> 9076: 				      {'DOWN', Mon, _, _, _} -&gt;
<a name="9077"/> 9077: 					  ok
<a name="9078"/> 9078: 				  after 0 -&gt;
<a name="9079"/> 9079: 					  case Kill of
<a name="9080"/> 9080: 					      true -&gt; exit(Proc, kill);
<a name="9081"/> 9081: 					      _ -&gt; ok
<a name="9082"/> 9082: 					  end,
<a name="9083"/> 9083: 					  receive
<a name="9084"/> 9084: 					      {'DOWN', Mon, _, _, _} -&gt;
<a name="9085"/> 9085: 						  ok
<a name="9086"/> 9086:                                           after 5000 -&gt;
<a name="9087"/> 9087: 						  io:format(&quot;Waiting for 'DOWN' from ~w, status=~w\n&quot;
<a name="9088"/> 9088:                                                             &quot;info = ~p\n&quot;, [Proc,
<a name="9089"/> 9089:                                                                             pid_status(Proc),
<a name="9090"/> 9090:                                                                             process_info(Proc)]),
<a name="9091"/> 9091:                                                   timeout
<a name="9092"/> 9092: 					  end
<a name="9093"/> 9093: 				  end
<a name="9094"/> 9094: 			  end, Procs),
<a name="9095"/> 9095: 	    From ! test_procs_synced,
<a name="9096"/> 9096: 	    spawn_logger([From])
<a name="9097"/> 9097:     end.
<a name="9098"/> 9098: 
<a name="pid_status-1"/><a name="9099"/> 9099: <b>pid_status</b>(Pid) -&gt;
<a name="pid_status-last_expr"/><a name="9100"/> 9100:     try
<a name="9101"/> 9101: 	erts_debug:get_internal_state({process_status, Pid})
<a name="9102"/> 9102:     catch
<a name="9103"/> 9103: 	error:undef -&gt;
<a name="9104"/> 9104: 	    erts_debug:set_internal_state(available_internal_state, true),
<a name="9105"/> 9105: 	    pid_status(Pid)
<a name="9106"/> 9106:     end.
<a name="9107"/> 9107: 
<a name="start_spawn_logger-0"/><a name="9108"/> 9108: <b>start_spawn_logger</b>() -&gt;
<a name="start_spawn_logger-last_expr"/><a name="9109"/> 9109: <b>    case whereis</b>(ets_test_spawn_logger) of
<a name="9110"/> 9110: 	Pid when is_pid(Pid) -&gt; true;
<a name="9111"/> 9111: 	_ -&gt; register(ets_test_spawn_logger,
<a name="9112"/> 9112: 		      spawn_opt(fun () -&gt; spawn_logger([]) end,
<a name="9113"/> 9113: 				[{priority, max}]))
<a name="9114"/> 9114:     end.
<a name="9115"/> 9115: 
<a name="9116"/> 9116: <i>%% restart_spawn_logger() -&gt;</i>
<a name="9117"/> 9117: <i>%%     stop_spawn_logger(),</i>
<a name="9118"/> 9118: <i>%%     start_spawn_logger().</i>
<a name="9119"/> 9119: 
<a name="stop_spawn_logger-0"/><a name="9120"/> 9120: <b>stop_spawn_logger</b>() -&gt;
<a name="9121"/> 9121:     Mon = erlang:monitor(process, ets_test_spawn_logger),
<a name="9122"/> 9122:     (catch exit(whereis(ets_test_spawn_logger), kill)),
<a name="stop_spawn_logger-last_expr"/><a name="9123"/> 9123:     receive {'DOWN', Mon, _, _, _} -&gt; ok end.
<a name="9124"/> 9124: 
<a name="wait_for_test_procs-0"/><a name="9125"/> 9125: <b>wait_for_test_procs</b>() -&gt;
<a name="wait_for_test_procs-last_expr"/><a name="9126"/> 9126: <b>    wait_for_test_procs</b>(false).
<a name="9127"/> 9127: 
<a name="wait_for_test_procs-1"/><a name="9128"/> 9128: <b>wait_for_test_procs</b>(Kill) -&gt;
<a name="9129"/> 9129:     ets_test_spawn_logger ! {sync_test_procs, Kill, self()},
<a name="wait_for_test_procs-last_expr"/><a name="9130"/> 9130:     receive test_procs_synced -&gt; ok end.
<a name="9131"/> 9131: 
<a name="log_test_proc-1"/><a name="9132"/> 9132: <b>log_test_proc</b>(Proc) when is_pid(Proc) -&gt;
<a name="9133"/> 9133:     ets_test_spawn_logger ! {new_test_proc, Proc},
<a name="log_test_proc-last_expr"/><a name="9134"/> 9134:     Proc.
<a name="9135"/> 9135: 
<a name="my_spawn-1"/><a name="my_spawn-last_expr"/><a name="9136"/> 9136: <b>my_spawn</b>(Fun) -&gt; log_test_proc(spawn(Fun)).
<a name="9137"/> 9137: 
<a name="my_spawn_link-1"/><a name="my_spawn_link-last_expr"/><a name="9138"/> 9138: <b>my_spawn_link</b>(Fun) -&gt; log_test_proc(spawn_link(Fun)).
<a name="9139"/> 9139: 
<a name="my_spawn_opt-2"/><a name="9140"/> 9140: <b>my_spawn_opt</b>(Fun,Opts) -&gt;
<a name="my_spawn_opt-last_expr"/><a name="9141"/> 9141: <b>    case spawn_opt</b>(Fun,Opts) of
<a name="9142"/> 9142: 	Pid when is_pid(Pid) -&gt; log_test_proc(Pid);
<a name="9143"/> 9143: 	{Pid, _} = Res when is_pid(Pid) -&gt; log_test_proc(Pid), Res
<a name="9144"/> 9144:     end.
<a name="9145"/> 9145: 
<a name="my_spawn_monitor-1"/><a name="9146"/> 9146: <b>my_spawn_monitor</b>(Fun) -&gt;
<a name="9147"/> 9147:     Res = spawn_monitor(Fun),
<a name="9148"/> 9148:     {Pid, _} = Res,
<a name="9149"/> 9149:     log_test_proc(Pid),
<a name="my_spawn_monitor-last_expr"/><a name="9150"/> 9150:     Res.
<a name="9151"/> 9151: 
<a name="repeat-2"/><a name="9152"/> 9152: <b>repeat</b>(_Fun, 0) -&gt;
<a name="9153"/> 9153:     ok;
<a name="9154"/> 9154: <b>repeat</b>(Fun, N) -&gt;
<a name="9155"/> 9155:     Fun(),
<a name="repeat-last_expr"/><a name="9156"/> 9156: <b>    repeat</b>(Fun, N-1).
<a name="9157"/> 9157: 
<a name="repeat_while-1"/><a name="9158"/> 9158: <b>repeat_while</b>(Fun) -&gt;
<a name="repeat_while-last_expr"/><a name="9159"/> 9159: <b>    case Fun</b>() of
<a name="9160"/> 9160: 	true -&gt; repeat_while(Fun);
<a name="9161"/> 9161: 	false -&gt; false
<a name="9162"/> 9162:     end.
<a name="9163"/> 9163: 
<a name="repeat_while-2"/><a name="9164"/> 9164: <b>repeat_while</b>(Fun, Arg0) -&gt;
<a name="repeat_while-last_expr"/><a name="9165"/> 9165: <b>    case Fun</b>(Arg0) of
<a name="9166"/> 9166: 	{true,Arg1} -&gt; repeat_while(Fun,Arg1);
<a name="9167"/> 9167: 	{false,Ret} -&gt; Ret
<a name="9168"/> 9168:     end.
<a name="9169"/> 9169: 
<a name="9170"/> 9170: <i>%% Some (but not all) permutations of List</i>
<a name="repeat_for_permutations-2"/><a name="9171"/> 9171: <b>repeat_for_permutations</b>(Fun, List) -&gt;
<a name="repeat_for_permutations-last_expr"/><a name="9172"/> 9172: <b>    repeat_for_permutations</b>(Fun, List, length(List)-1).
<a name="repeat_for_permutations-3"/><a name="9173"/> 9173: <b>repeat_for_permutations</b>(Fun, List, 0) -&gt;
<a name="9174"/> 9174:     Fun(List);
<a name="9175"/> 9175: <b>repeat_for_permutations</b>(Fun, List, N) -&gt;
<a name="9176"/> 9176:     {A,B} = lists:split(N, List),
<a name="9177"/> 9177:     L1 = B++A,
<a name="9178"/> 9178:     L2 = lists:reverse(L1),
<a name="9179"/> 9179:     L3 = B++lists:reverse(A),
<a name="9180"/> 9180:     L4 = lists:reverse(B)++A,
<a name="9181"/> 9181:     Fun(L1), Fun(L2), Fun(L3), Fun(L4),
<a name="repeat_for_permutations-last_expr"/><a name="9182"/> 9182: <b>    repeat_for_permutations</b>(Fun, List, N-1).
<a name="9183"/> 9183: 
<a name="receive_any-0"/><a name="9184"/> 9184: <b>receive_any</b>() -&gt;
<a name="receive_any-last_expr"/><a name="9185"/> 9185:     receive M -&gt;
<a name="9186"/> 9186: 	    %%io:format(&quot;Process ~p got msg ~p\n&quot;, [self(),M]),
<a name="9187"/> 9187: 	    M
<a name="9188"/> 9188:     end.
<a name="9189"/> 9189: 
<a name="receive_any_spinning-0"/><a name="9190"/> 9190: <b>receive_any_spinning</b>() -&gt;
<a name="receive_any_spinning-last_expr"/><a name="9191"/> 9191: <b>    receive_any_spinning</b>(1000000).
<a name="receive_any_spinning-1"/><a name="9192"/> 9192: <b>receive_any_spinning</b>(Loops) -&gt;
<a name="receive_any_spinning-last_expr"/><a name="9193"/> 9193: <b>    receive_any_spinning</b>(Loops,Loops,1).
<a name="receive_any_spinning-3"/><a name="9194"/> 9194: <b>receive_any_spinning</b>(Loops,0,Tries) -&gt;
<a name="9195"/> 9195:     receive M -&gt;
<a name="9196"/> 9196: 	    io:format(&quot;Spinning process ~p got msg ~p after ~p tries\n&quot;, [self(),M,Tries]),
<a name="9197"/> 9197: 	    M
<a name="9198"/> 9198:     after 0 -&gt;
<a name="9199"/> 9199: 	    receive_any_spinning(Loops, Loops, Tries+1)
<a name="9200"/> 9200:     end;
<a name="9201"/> 9201: <b>receive_any_spinning</b>(Loops, N, Tries) when N&gt;0 -&gt;
<a name="receive_any_spinning-last_expr"/><a name="9202"/> 9202: <b>    receive_any_spinning</b>(Loops, N-1, Tries).
<a name="9203"/> 9203: 
<a name="9204"/> 9204: 
<a name="9205"/> 9205: 
<a name="spawn_monitor_with_pid-2"/><a name="9206"/> 9206: <b>spawn_monitor_with_pid</b>(Pid, Fun) when is_pid(Pid) -&gt;
<a name="spawn_monitor_with_pid-last_expr"/><a name="9207"/> 9207: <b>    spawn_monitor_with_pid</b>(Pid, Fun, 10).
<a name="9208"/> 9208: 
<a name="spawn_monitor_with_pid-3"/><a name="9209"/> 9209: <b>spawn_monitor_with_pid</b>(_, _, 0) -&gt;
<a name="9210"/> 9210:     failed;
<a name="9211"/> 9211: <b>spawn_monitor_with_pid</b>(Pid, Fun, N) -&gt;
<a name="spawn_monitor_with_pid-last_expr"/><a name="9212"/> 9212: <b>    case my_spawn</b>(fun()-&gt; case self() of
<a name="9213"/> 9213: 			      Pid -&gt; Fun();
<a name="9214"/> 9214: 			      _ -&gt; die
<a name="9215"/> 9215: 			  end
<a name="9216"/> 9216: 		  end) of
<a name="9217"/> 9217: 	Pid -&gt;
<a name="9218"/> 9218: 	    {Pid, erlang:monitor(process, Pid)};
<a name="9219"/> 9219: 	_Other -&gt;
<a name="9220"/> 9220: 	    spawn_monitor_with_pid(Pid,Fun,N-1)
<a name="9221"/> 9221:     end.
<a name="9222"/> 9222: 
<a name="9223"/> 9223: 
<a name="only_if_smp-1"/><a name="9224"/> 9224: <b>only_if_smp</b>(Func) -&gt;
<a name="only_if_smp-last_expr"/><a name="9225"/> 9225: <b>    only_if_smp</b>(2, Func).
<a name="only_if_smp-2"/><a name="9226"/> 9226: <b>only_if_smp</b>(Schedulers, Func) -&gt;
<a name="only_if_smp-last_expr"/><a name="9227"/> 9227: <b>    case erlang:system_info</b>(schedulers_online) of
<a name="9228"/> 9228: 	N when N &lt; Schedulers -&gt; {skip,&quot;Too few schedulers online&quot;};
<a name="9229"/> 9229: 	_ -&gt; Func()
<a name="9230"/> 9230:     end.
<a name="9231"/> 9231: 
<a name="9232"/> 9232: <i>%% Copy-paste from emulator/test/binary_SUITE.erl</i>
<a name="test_terms-2"/><a name="9233"/> 9233: <b>test_terms</b>(Test_Func, Mode) -&gt;
<a name="9234"/> 9234:     garbage_collect(),
<a name="9235"/> 9235:     Pib0 = process_info(self(),binary),
<a name="9236"/> 9236: 
<a name="9237"/> 9237:     Test_Func(atom),
<a name="9238"/> 9238:     Test_Func(''),
<a name="9239"/> 9239:     Test_Func('a'),
<a name="9240"/> 9240:     Test_Func('ab'),
<a name="9241"/> 9241:     Test_Func('abc'),
<a name="9242"/> 9242:     Test_Func('abcd'),
<a name="9243"/> 9243:     Test_Func('abcde'),
<a name="9244"/> 9244:     Test_Func('abcdef'),
<a name="9245"/> 9245:     Test_Func('abcdefg'),
<a name="9246"/> 9246:     Test_Func('abcdefgh'),
<a name="9247"/> 9247: 
<a name="9248"/> 9248:     Test_Func(fun() -&gt; ok end),
<a name="9249"/> 9249:     X = id([a,{b,c},c]),
<a name="9250"/> 9250:     Y = id({x,y,z}),
<a name="9251"/> 9251:     Z = id(1 bsl 8*257),
<a name="9252"/> 9252:     Test_Func(fun() -&gt; X end),
<a name="9253"/> 9253:     Test_Func(fun() -&gt; {X,Y} end),
<a name="9254"/> 9254:     Test_Func([fun() -&gt; {X,Y,Z} end,
<a name="9255"/> 9255: 	       fun() -&gt; {Z,X,Y} end,
<a name="9256"/> 9256: 	       fun() -&gt; {Y,Z,X} end]),
<a name="9257"/> 9257: 
<a name="9258"/> 9258:     Test_Func({trace_ts,{even_bigger,{some_data,fun() -&gt; ok end}},{1,2,3}}),
<a name="9259"/> 9259:     Test_Func({trace_ts,{even_bigger,{some_data,&lt;&lt;1,2,3,4,5,6,7,8,9,10&gt;&gt;}},
<a name="9260"/> 9260: 	       {1,2,3}}),
<a name="9261"/> 9261: 
<a name="9262"/> 9262:     Test_Func(1),
<a name="9263"/> 9263:     Test_Func(42),
<a name="9264"/> 9264:     Test_Func(-23),
<a name="9265"/> 9265:     Test_Func(256),
<a name="9266"/> 9266:     Test_Func(25555),
<a name="9267"/> 9267:     Test_Func(-3333),
<a name="9268"/> 9268: 
<a name="9269"/> 9269:     Test_Func(1.0),
<a name="9270"/> 9270: 
<a name="9271"/> 9271:     Test_Func(183749783987483978498378478393874),
<a name="9272"/> 9272:     Test_Func(-37894183749783987483978498378478393874),
<a name="9273"/> 9273:     Very_Big = very_big_num(),
<a name="9274"/> 9274:     Test_Func(Very_Big),
<a name="9275"/> 9275:     Test_Func(-Very_Big+1),
<a name="9276"/> 9276: 
<a name="9277"/> 9277:     Test_Func([]),
<a name="9278"/> 9278:     Test_Func(&quot;abcdef&quot;),
<a name="9279"/> 9279:     Test_Func([a, b, 1, 2]),
<a name="9280"/> 9280:     Test_Func([a|b]),
<a name="9281"/> 9281: 
<a name="9282"/> 9282:     Test_Func({}),
<a name="9283"/> 9283:     Test_Func({1}),
<a name="9284"/> 9284:     Test_Func({a, b}),
<a name="9285"/> 9285:     Test_Func({a, b, c}),
<a name="9286"/> 9286:     Test_Func(list_to_tuple(lists:seq(0, 255))),
<a name="9287"/> 9287:     Test_Func(list_to_tuple(lists:seq(0, 256))),
<a name="9288"/> 9288: 
<a name="9289"/> 9289:     Test_Func(make_ref()),
<a name="9290"/> 9290:     Test_Func([make_ref(), make_ref()]),
<a name="9291"/> 9291: 
<a name="9292"/> 9292:     Test_Func(make_port()),
<a name="9293"/> 9293: 
<a name="9294"/> 9294:     Test_Func(make_pid()),
<a name="9295"/> 9295:     Test_Func(make_ext_pid()),
<a name="9296"/> 9296:     Test_Func(make_ext_port()),
<a name="9297"/> 9297:     Test_Func(make_ext_ref()),
<a name="9298"/> 9298: 
<a name="9299"/> 9299:     Bin0 = list_to_binary(lists:seq(0, 14)),
<a name="9300"/> 9300:     Test_Func(Bin0),
<a name="9301"/> 9301:     Bin1 = list_to_binary(lists:seq(0, ?heap_binary_size)),
<a name="9302"/> 9302:     Test_Func(Bin1),
<a name="9303"/> 9303:     Bin2 = list_to_binary(lists:seq(0, ?heap_binary_size+1)),
<a name="9304"/> 9304:     Test_Func(Bin2),
<a name="9305"/> 9305:     Bin3 = list_to_binary(lists:seq(0, 255)),
<a name="9306"/> 9306:     garbage_collect(),
<a name="9307"/> 9307:     Pib = process_info(self(),binary),
<a name="9308"/> 9308:     Test_Func(Bin3),
<a name="9309"/> 9309:     garbage_collect(),
<a name="9310"/> 9310:     case Mode of
<a name="9311"/> 9311: 	strict -&gt; Pib = process_info(self(),binary);
<a name="9312"/> 9312: 	skip_refc_check -&gt; ok
<a name="9313"/> 9313:     end,
<a name="9314"/> 9314: 
<a name="9315"/> 9315:     Test_Func(make_unaligned_sub_binary(Bin0)),
<a name="9316"/> 9316:     Test_Func(make_unaligned_sub_binary(Bin1)),
<a name="9317"/> 9317:     Test_Func(make_unaligned_sub_binary(Bin2)),
<a name="9318"/> 9318:     Test_Func(make_unaligned_sub_binary(Bin3)),
<a name="9319"/> 9319: 
<a name="9320"/> 9320:     Test_Func(make_sub_binary(lists:seq(42, 43))),
<a name="9321"/> 9321:     Test_Func(make_sub_binary([42,43,44])),
<a name="9322"/> 9322:     Test_Func(make_sub_binary([42,43,44,45])),
<a name="9323"/> 9323:     Test_Func(make_sub_binary([42,43,44,45,46])),
<a name="9324"/> 9324:     Test_Func(make_sub_binary([42,43,44,45,46,47])),
<a name="9325"/> 9325:     Test_Func(make_sub_binary([42,43,44,45,46,47,48])),
<a name="9326"/> 9326:     Test_Func(make_sub_binary(lists:seq(42, 49))),
<a name="9327"/> 9327:     Test_Func(make_sub_binary(lists:seq(0, 14))),
<a name="9328"/> 9328:     Test_Func(make_sub_binary(lists:seq(0, ?heap_binary_size))),
<a name="9329"/> 9329:     Test_Func(make_sub_binary(lists:seq(0, ?heap_binary_size+1))),
<a name="9330"/> 9330:     Test_Func(make_sub_binary(lists:seq(0, 255))),
<a name="9331"/> 9331: 
<a name="9332"/> 9332:     Test_Func(make_unaligned_sub_binary(lists:seq(42, 43))),
<a name="9333"/> 9333:     Test_Func(make_unaligned_sub_binary([42,43,44])),
<a name="9334"/> 9334:     Test_Func(make_unaligned_sub_binary([42,43,44,45])),
<a name="9335"/> 9335:     Test_Func(make_unaligned_sub_binary([42,43,44,45,46])),
<a name="9336"/> 9336:     Test_Func(make_unaligned_sub_binary([42,43,44,45,46,47])),
<a name="9337"/> 9337:     Test_Func(make_unaligned_sub_binary([42,43,44,45,46,47,48])),
<a name="9338"/> 9338:     Test_Func(make_unaligned_sub_binary(lists:seq(42, 49))),
<a name="9339"/> 9339:     Test_Func(make_unaligned_sub_binary(lists:seq(0, 14))),
<a name="9340"/> 9340:     Test_Func(make_unaligned_sub_binary(lists:seq(0, ?heap_binary_size))),
<a name="9341"/> 9341:     Test_Func(make_unaligned_sub_binary(lists:seq(0, ?heap_binary_size+1))),
<a name="9342"/> 9342:     Test_Func(make_unaligned_sub_binary(lists:seq(0, 255))),
<a name="9343"/> 9343: 
<a name="9344"/> 9344:     %% Bit level binaries.
<a name="9345"/> 9345:     Test_Func(&lt;&lt;1:1&gt;&gt;),
<a name="9346"/> 9346:     Test_Func(&lt;&lt;2:2&gt;&gt;),
<a name="9347"/> 9347:     Test_Func(&lt;&lt;42:10&gt;&gt;),
<a name="9348"/> 9348:     Test_Func(list_to_bitstring([&lt;&lt;5:6&gt;&gt;|lists:seq(0, 255)])),
<a name="9349"/> 9349: 
<a name="9350"/> 9350:     Test_Func(F = fun(A) -&gt; 42*A end),
<a name="9351"/> 9351:     Test_Func(lists:duplicate(32, F)),
<a name="9352"/> 9352: 
<a name="9353"/> 9353:     Test_Func(FF = fun binary_SUITE:all/1),
<a name="9354"/> 9354:     Test_Func(lists:duplicate(32, FF)),
<a name="9355"/> 9355: 
<a name="9356"/> 9356:     garbage_collect(),
<a name="9357"/> 9357:     case Mode of
<a name="9358"/> 9358: 	strict -&gt; Pib0 = process_info(self(),binary);
<a name="9359"/> 9359: 	skip_refc_check -&gt; ok
<a name="9360"/> 9360:     end,
<a name="test_terms-last_expr"/><a name="9361"/> 9361:     ok.
<a name="9362"/> 9362: 
<a name="error_info-1"/><a name="9363"/> 9363: <b>error_info</b>(_Config) -&gt;
<a name="9364"/> 9364:     Ms = [{{'$1','$2','$3'},[],['$$']}],
<a name="9365"/> 9365:     BagTab = fun(_Type) -&gt; ets:new(table, [set,bag,private]) end,
<a name="9366"/> 9366:     OneKeyTab = fun(Type) -&gt;
<a name="9367"/> 9367:                         T = ets:new(table, [Type, private]),
<a name="9368"/> 9368:                         true = ets:insert(T, {one,two,3}),
<a name="9369"/> 9369:                         T
<a name="9370"/> 9370:                 end,
<a name="9371"/> 9371:     Set = fun(_Type) -&gt; ets:new(table, [set, private]) end,
<a name="9372"/> 9372:     OrderedSet = fun(_Type) -&gt; ets:new(table, [ordered_set, private]) end,
<a name="9373"/> 9373:     NamedTable = fun(Type) -&gt; ets:new('$named_table', [Type, named_table, private]) end,
<a name="9374"/> 9374:     UnownedTable = fun(Type) -&gt;
<a name="9375"/> 9375:                            Parent = self(),
<a name="9376"/> 9376:                            spawn_link(fun() -&gt;
<a name="9377"/> 9377:                                               T = ets:new(table, [Type, public]),
<a name="9378"/> 9378:                                               Parent ! T,
<a name="9379"/> 9379:                                               receive ok -&gt; ok end
<a name="9380"/> 9380:                                       end),
<a name="9381"/> 9381:                            receive T -&gt; T end
<a name="9382"/> 9382:                    end,
<a name="9383"/> 9383:     _ = ets:new(name_already_exists, [named_table]),
<a name="9384"/> 9384: 
<a name="9385"/> 9385:     L = [{delete, ['$Tab']},
<a name="9386"/> 9386:          {delete, ['$Tab', no_key], [no_fail]},
<a name="9387"/> 9387:          {delete_all_objects, ['$Tab'], [renamed]},
<a name="9388"/> 9388:          {delete_object, ['$Tab', bad_object]},
<a name="9389"/> 9389:          {delete_object, ['$Tab', {tag,non_existing}], [no_fail]},
<a name="9390"/> 9390: 
<a name="9391"/> 9391:          {file2tab, 1},                          %Not BIF.
<a name="9392"/> 9392:          {file2tab, 2},                          %Not BIF.
<a name="9393"/> 9393: 
<a name="9394"/> 9394:          {first, ['$Tab']},
<a name="9395"/> 9395:          {first_lookup, ['$Tab']},
<a name="9396"/> 9396: 
<a name="9397"/> 9397:          {foldl, 3},                            %Not BIF.
<a name="9398"/> 9398:          {foldr, 3},                            %Not BIF.
<a name="9399"/> 9399: 
<a name="9400"/> 9400:          {from_dets, 2},                        %Not BIF.
<a name="9401"/> 9401: 
<a name="9402"/> 9402:          {fun2ms, 1},                           %Not BIF.
<a name="9403"/> 9403: 
<a name="9404"/> 9404:          {give_away, ['$Tab', not_a_pid, bad_pid]},
<a name="9405"/> 9405:          {give_away, ['$Tab', '$Self', already_owner], [{error_term,owner}]},
<a name="9406"/> 9406:          {give_away, ['$Tab', '$Living', living_process], [only_bad_table]},
<a name="9407"/> 9407:          {give_away, ['$Tab', '$Dead', dead_process]},
<a name="9408"/> 9408: 
<a name="9409"/> 9409:          {give_away, [UnownedTable, '$Living', gift_data], [{error_term,not_owner}]},
<a name="9410"/> 9410: 
<a name="9411"/> 9411:          {i, 1},                                %Not BIF.
<a name="9412"/> 9412:          {i, 2},                                %Not BIF.
<a name="9413"/> 9413:          {i, 3},                                %Not BIF.
<a name="9414"/> 9414: 
<a name="9415"/> 9415:          {info, ['$Tab']},
<a name="9416"/> 9416:          {info, ['$Tab', invalid_item]},
<a name="9417"/> 9417: 
<a name="9418"/> 9418:          {init_table, 2},                       %Not BIF.
<a name="9419"/> 9419: 
<a name="9420"/> 9420:          {insert, ['$Tab', bad_object]},
<a name="9421"/> 9421:          {insert, ['$Tab', {}]},
<a name="9422"/> 9422:          {insert, ['$Tab', [a,{a,b,c}]]},
<a name="9423"/> 9423:          {insert, ['$Tab', [a|b]]},
<a name="9424"/> 9424:          {insert, ['$Tab', {a,b,c}], [no_fail]},
<a name="9425"/> 9425:          {insert, ['$Tab', [{a,b,c}]], [no_fail]},
<a name="9426"/> 9426:          {insert, ['$Tab', [{a,b,c},{d,e,f}]], [no_fail]},
<a name="9427"/> 9427:          {insert, ['$Tab', [{I,b,c} || I &lt;- lists:seq(1,10_000)]], [no_fail]},
<a name="9428"/> 9428: 
<a name="9429"/> 9429:          {insert_new, ['$Tab', bad_object]},
<a name="9430"/> 9430:          {insert_new, ['$Tab', {a,b,c}], [no_fail]},
<a name="9431"/> 9431:          {insert_new, ['$Tab', [a,{a,b,c}]]},
<a name="9432"/> 9432:          {insert_new, ['$Tab', [a|b]]},
<a name="9433"/> 9433: 
<a name="9434"/> 9434:          {internal_delete_all, 2},              %Internal function.
<a name="9435"/> 9435:          {internal_select_delete, 2},           %Internal function.
<a name="9436"/> 9436: 
<a name="9437"/> 9437:          {is_compiled_ms, [bad_ms], [no_fail, no_table]},
<a name="9438"/> 9438: 
<a name="9439"/> 9439:          {last, ['$Tab']},
<a name="9440"/> 9440:          {last_lookup, ['$Tab']},
<a name="9441"/> 9441: 
<a name="9442"/> 9442:          {lookup, ['$Tab', no_key], [no_fail]},
<a name="9443"/> 9443: 
<a name="9444"/> 9444:          {lookup_element, ['$Tab', no_key, 0]},
<a name="9445"/> 9445:          {lookup_element, ['$Tab', no_key, 1], [{error_term,badkey}]},
<a name="9446"/> 9446:          {lookup_element, ['$Tab', no_key, bad_pos]},
<a name="9447"/> 9447: 
<a name="9448"/> 9448:          {lookup_element, [OneKeyTab, one, 4]},
<a name="9449"/> 9449: 
<a name="9450"/> 9450:          {lookup_element, ['$Tab', no_key, 1, default_value], [no_fail]},
<a name="9451"/> 9451:          {lookup_element, [OneKeyTab, one, 4, default_value]},
<a name="9452"/> 9452: 
<a name="9453"/> 9453:          {match, [bad_continuation], [no_table]},
<a name="9454"/> 9454: 
<a name="9455"/> 9455:          {match, ['$Tab', &lt;&lt;1,2,3&gt;&gt;], [no_fail]},
<a name="9456"/> 9456:          {match, ['$Tab', &lt;&lt;1,2,3&gt;&gt;, 0]},
<a name="9457"/> 9457:          {match, ['$Tab', &lt;&lt;1,2,3&gt;&gt;, bad_limit]},
<a name="9458"/> 9458:          {match_delete, ['$Tab', &lt;&lt;1,2,3&gt;&gt;], [no_fail,renamed]},
<a name="9459"/> 9459: 
<a name="9460"/> 9460:          {match_object, [bad_continuation], [no_table]},
<a name="9461"/> 9461: 
<a name="9462"/> 9462:          {match_object, ['$Tab', &lt;&lt;1,2,3&gt;&gt;], [no_fail]},
<a name="9463"/> 9463:          {match_object, ['$Tab', &lt;&lt;1,2,3&gt;&gt;, bad_limit]},
<a name="9464"/> 9464: 
<a name="9465"/> 9465:          {match_spec_compile, [bad_match_spec], [no_table]},
<a name="9466"/> 9466:          {match_spec_run, 2},                   %Not BIF.
<a name="9467"/> 9467:          {match_spec_run_r, 3},                 %Internal BIF.
<a name="9468"/> 9468: 
<a name="9469"/> 9469:          {member, ['$Tab', no_key], [no_fail]},
<a name="9470"/> 9470: 
<a name="9471"/> 9471:          {new, [name, not_list], [no_table]},
<a name="9472"/> 9472:          {new, [name, [a|b]], [no_table]},
<a name="9473"/> 9473:          {new, [name, [a,b]], [no_table]},
<a name="9474"/> 9474:          {new, [{bad,name}, [a,b]], [no_table]},
<a name="9475"/> 9475:          {new, [name_already_exists, [named_table]], [no_table,
<a name="9476"/> 9476:                                                       {error_term,already_exists}]},
<a name="9477"/> 9477: 
<a name="9478"/> 9478:          %% For a set, ets:next/2 and ets:prev/2 fails if the key does
<a name="9479"/> 9479:          %% not exist.
<a name="9480"/> 9480:          {next, [Set, no_key]},
<a name="9481"/> 9481:          {prev, [Set, no_key]},
<a name="9482"/> 9482:          {next_lookup, [Set, no_key]},
<a name="9483"/> 9483:          {prev_lookup, [Set, no_key]},
<a name="9484"/> 9484: 
<a name="9485"/> 9485:          % For an ordered set, ets:next/2 and ets:prev/2 succeeds
<a name="9486"/> 9486:          % even if the key does not exist.
<a name="9487"/> 9487:          {next, [OrderedSet, no_key], [no_fail]},
<a name="9488"/> 9488:          {prev, [OrderedSet, no_key], [no_fail]},
<a name="9489"/> 9489:          {next_lookup, [OrderedSet, no_key], [no_fail]},
<a name="9490"/> 9490:          {prev_lookup, [OrderedSet, no_key], [no_fail]},
<a name="9491"/> 9491: 
<a name="9492"/> 9492:          {rename, ['$Tab', {bad,name}]},
<a name="9493"/> 9493:          {rename, [NamedTable, '$named_table']},
<a name="9494"/> 9494:          {rename, [NamedTable, {bad,name}]},
<a name="9495"/> 9495: 
<a name="9496"/> 9496:          {repair_continuation, 2},              %Not BIF.
<a name="9497"/> 9497: 
<a name="9498"/> 9498:          {safe_fixtable, ['$Tab', true], [no_fail]},
<a name="9499"/> 9499:          {safe_fixtable, ['$Tab', not_boolean]},
<a name="9500"/> 9500: 
<a name="9501"/> 9501:          {select, [bad_continuation], [no_table]},
<a name="9502"/> 9502: 
<a name="9503"/> 9503:          {select, ['$Tab', Ms], [no_fail]},
<a name="9504"/> 9504:          {select, ['$Tab', bad_match_spec]},
<a name="9505"/> 9505:          {select, ['$Tab', Ms, bad_limit]},
<a name="9506"/> 9506:          {select, ['$Tab', Ms, 0]},
<a name="9507"/> 9507:          {select, ['$Tab', bad_match_spec, bad_limit]},
<a name="9508"/> 9508:          {select, ['$Tab', bad_match_spec, 1]},
<a name="9509"/> 9509: 
<a name="9510"/> 9510:          {select_count, ['$Tab', Ms], [no_fail]},
<a name="9511"/> 9511:          {select_count, ['$Tab', bad_match_spec]},
<a name="9512"/> 9512: 
<a name="9513"/> 9513:          {select_delete, ['$Tab', Ms], [no_fail,renamed]},
<a name="9514"/> 9514:          {select_delete, ['$Tab', bad_match_spec], [renamed]},
<a name="9515"/> 9515: 
<a name="9516"/> 9516:          {select_replace, ['$Tab', [{{'$1','$2','$3'},[],[{{'$1','$3','$2'}}]}]], [no_fail]},
<a name="9517"/> 9517:          {select_replace, ['$Tab', [{{'$1','$2','$3'},[],[{{'key_destroyed'}}]}]]},
<a name="9518"/> 9518:          {select_replace, ['$Tab', bad_match_spec]},
<a name="9519"/> 9519: 
<a name="9520"/> 9520:          {select_replace, [BagTab, [{{'$1','$2','$3'},[],[{{'$1','$3','$2'}}]}]], [{error_term,table_type}]},
<a name="9521"/> 9521: 
<a name="9522"/> 9522:          {select_reverse, [bad_continuation], [no_table]},
<a name="9523"/> 9523: 
<a name="9524"/> 9524:          {select_reverse, ['$Tab', Ms], [no_fail]},
<a name="9525"/> 9525:          {select_reverse, ['$Tab', bad_match_spec]},
<a name="9526"/> 9526: 
<a name="9527"/> 9527:          {select_reverse, ['$Tab', Ms, 0]},
<a name="9528"/> 9528:          {select_reverse, ['$Tab', Ms, bad_limit]},
<a name="9529"/> 9529:          {select_reverse, ['$Tab', bad_match_spec, bad_limit]},
<a name="9530"/> 9530: 
<a name="9531"/> 9531:          {setopts, ['$Tab', bad_opts]},
<a name="9532"/> 9532: 
<a name="9533"/> 9533:          {slot, ['$Tab', -1]},
<a name="9534"/> 9534:          {slot, ['$Tab', not_an_integer]},
<a name="9535"/> 9535: 
<a name="9536"/> 9536:          {tab2file, 2},                         %Not BIF.
<a name="9537"/> 9537:          {tab2file, 3},                         %Not BIF.
<a name="9538"/> 9538:          {tab2list, 1},                         %Not BIF.
<a name="9539"/> 9539:          {tabfile_info, 1},                     %Not BIF.
<a name="9540"/> 9540:          {table, 1},                            %Not BIF.
<a name="9541"/> 9541:          {table, 2},                            %Not BIF.
<a name="9542"/> 9542: 
<a name="9543"/> 9543:          {take, ['$Tab', no_key], [no_fail]},
<a name="9544"/> 9544: 
<a name="9545"/> 9545:          {test_ms, 2},                          %Not BIF.
<a name="9546"/> 9546:          {to_dets, 2},                          %Not BIF.
<a name="9547"/> 9547: 
<a name="9548"/> 9548:          {update_counter, ['$Tab', no_key, 1], [{error_term,badkey}]},
<a name="9549"/> 9549:          {update_counter, ['$Tab', no_key, bad_increment], [{error_term,badkey}]},
<a name="9550"/> 9550:          {update_counter, ['$Tab', no_key, {1, 42}], [{error_term,badkey}]},
<a name="9551"/> 9551:          {update_counter, ['$Tab', no_key, {1, bad_increment}], [{error_term,badkey}]},
<a name="9552"/> 9552: 
<a name="9553"/> 9553:          {update_counter, [OneKeyTab, one, {2, 1}]},
<a name="9554"/> 9554:          {update_counter, [OneKeyTab, one, {2, bad_increment}]},
<a name="9555"/> 9555:          {update_counter, [OneKeyTab, one, {3, bad_increment}]},
<a name="9556"/> 9556:          {update_counter, [OneKeyTab, one, {4, 1}], [{error_term,position}]},
<a name="9557"/> 9557:          {update_counter, [OneKeyTab, one, {4, bad_increment}]},
<a name="9558"/> 9558: 
<a name="9559"/> 9559:          {update_counter, [BagTab, bag_key, 1], [{error_term,table_type}]},
<a name="9560"/> 9560:          {update_counter, [BagTab, bag_key, bad_increment], [{error_term,table_type}]},
<a name="9561"/> 9561: 
<a name="9562"/> 9562:          {update_counter, ['$Tab', key, 2, {key,0}], [no_fail]},
<a name="9563"/> 9563:          {update_counter, ['$Tab', key, {1,42}, {key,0}], [{error_term,keypos}]},
<a name="9564"/> 9564:          {update_counter, ['$Tab', key, 2, {key,not_integer}]},
<a name="9565"/> 9565:          {update_counter, ['$Tab', key, 3, {key,whatever}]},
<a name="9566"/> 9566: 
<a name="9567"/> 9567:          {update_counter, ['$Tab', no_key, 1, default]},
<a name="9568"/> 9568:          {update_counter, ['$Tab', no_key, bad_increment, {tag,0}]},
<a name="9569"/> 9569:          {update_counter, ['$Tab', no_key, {1, bad_increment}, {tag,0}]},
<a name="9570"/> 9570:          {update_counter, ['$Tab', no_key, {1, 42}, {tag,0}], [{error_term,keypos}]},
<a name="9571"/> 9571:          {update_counter, ['$Tab', no_key, {2, 42}, {tag,not_integer}]},
<a name="9572"/> 9572:          {update_counter, ['$Tab', no_key, {3, 42}, {tag,not_integer}], [{error_term,position}]},
<a name="9573"/> 9573: 
<a name="9574"/> 9574:          {update_counter, [OneKeyTab, one, {2, 1}, {tag,val}]},
<a name="9575"/> 9575:          {update_counter, [OneKeyTab, one, {2, bad_increment}, {tag,val}]},
<a name="9576"/> 9576:          {update_counter, [OneKeyTab, one, {3, bad_increment}, {tag,val}]},
<a name="9577"/> 9577:          {update_counter, [OneKeyTab, one, {4, 1}, {tag,val}], [{error_term,position}]},
<a name="9578"/> 9578:          {update_counter, [OneKeyTab, one, {4, bad_increment}, {tag,val}]},
<a name="9579"/> 9579: 
<a name="9580"/> 9580:          {update_element, ['$Tab', no_key, {2, new}], [no_fail]},
<a name="9581"/> 9581:          {update_element, [BagTab, no_key, {2, bagged}]},
<a name="9582"/> 9582:          {update_element, [OneKeyTab, one, not_tuple]},
<a name="9583"/> 9583:          {update_element, [OneKeyTab, one, {0, new}], [{error_term, position}]},
<a name="9584"/> 9584:          {update_element, [OneKeyTab, one, {1, new}], [{error_term,keypos}]},
<a name="9585"/> 9585:          {update_element, [OneKeyTab, one, {4, new}], [{error_term, position}]},
<a name="9586"/> 9586: 
<a name="9587"/> 9587: 	 {update_element, ['$Tab', no_key, {2, new}, {no_key, old}], [no_fail]},
<a name="9588"/> 9588: 	 {update_element, ['$Tab', no_key, {0, new}, {no_key, old}], [{error_term, position}]},
<a name="9589"/> 9589: 	 {update_element, ['$Tab', no_key, {1, new}, {no_key, old}], [{error_term, keypos}]},
<a name="9590"/> 9590: 	 {update_element, ['$Tab', no_key, {4, new}, {no_key, old}], [{error_term, position}]},
<a name="9591"/> 9591: 	 {update_element, ['$Tab', no_key, {4, new}, not_tuple]},
<a name="9592"/> 9592: 	 {update_element, [BagTab, no_key, {1, bagged}, {no_key, old}], []},
<a name="9593"/> 9593: 	 {update_element, [OneKeyTab, no_key, {0, new}, {no_key, old}], [{error_term, position}]},
<a name="9594"/> 9594: 	 {update_element, [OneKeyTab, no_key, {1, new}, {no_key, old}], [{error_term, keypos}]},
<a name="9595"/> 9595: 	 {update_element, [OneKeyTab, no_key, {4, new}, {no_key, old}], [{error_term, position}]},
<a name="9596"/> 9596: 	 {update_element, [OneKeyTab, no_key, {4, new}, not_tuple]},
<a name="9597"/> 9597: 
<a name="9598"/> 9598:          {whereis, [{bad,name}], [no_table]}
<a name="9599"/> 9599:         ],
<a name="9600"/> 9600:     put(errors, []),
<a name="9601"/> 9601:     eval_ets_bif_errors(L),
<a name="9602"/> 9602:     io:nl(),
<a name="error_info-last_expr"/><a name="9603"/> 9603: <b>    case lists:sort</b>(get(errors)) of
<a name="9604"/> 9604:         [] -&gt;
<a name="9605"/> 9605:             ok;
<a name="9606"/> 9606:         [_|_]=Errors -&gt;
<a name="9607"/> 9607:             io:format(&quot;~P\n&quot;, [Errors, 100]),
<a name="9608"/> 9608:             ct:fail({length(Errors),errors})
<a name="9609"/> 9609:     end.
<a name="9610"/> 9610: 
<a name="eval_ets_bif_errors-1"/><a name="9611"/> 9611: <b>eval_ets_bif_errors</b>(L0) -&gt;
<a name="9612"/> 9612:     L1 = lists:foldl(fun({_,A}, Acc) when is_integer(A) -&gt; Acc;
<a name="9613"/> 9613:                         ({F,A}, Acc) -&gt; [{F,A,[]}|Acc];
<a name="9614"/> 9614:                         ({F,A,Opts}, Acc) -&gt; [{F,A,Opts}|Acc]
<a name="9615"/> 9615:                      end, [], L0),
<a name="9616"/> 9616:     Tests = ordsets:from_list([{F,length(A)} || {F,A,_} &lt;- L1] ++
<a name="9617"/> 9617:                                   [{F,A} || {F,A} &lt;- L0, is_integer(A)]),
<a name="9618"/> 9618:     Bifs0 = [{F,A} || {F,A} &lt;- ets:module_info(exports),
<a name="9619"/> 9619:                       A =/= 0,
<a name="9620"/> 9620:                       F =/= module_info],
<a name="9621"/> 9621:     Bifs = ordsets:from_list(Bifs0),
<a name="9622"/> 9622:     NYI = [{F,lists:duplicate(A, '*'),nyi} || {F,A} &lt;- Bifs -- Tests],
<a name="9623"/> 9623:     L = lists:sort(NYI ++ L1),
<a name="9624"/> 9624: 
<a name="9625"/> 9625:     spawn(fun() -&gt;
<a name="9626"/> 9626:                   true = register(living, self()),
<a name="9627"/> 9627:                   Ref = make_ref(),
<a name="9628"/> 9628:                   receive
<a name="9629"/> 9629:                       Ref -&gt;
<a name="9630"/> 9630:                           ok
<a name="9631"/> 9631:                   end
<a name="9632"/> 9632:           end),
<a name="9633"/> 9633: 
<a name="eval_ets_bif_errors-last_expr"/><a name="9634"/> 9634: <b>    do_eval_ets_bif_errors</b>(L).
<a name="9635"/> 9635: 
<a name="do_eval_ets_bif_errors-1"/><a name="9636"/> 9636: <b>do_eval_ets_bif_errors</b>([H|T]) -&gt;
<a name="9637"/> 9637:     case H of
<a name="9638"/> 9638:         {F, Args} -&gt;
<a name="9639"/> 9639:             eval_ets_bif_errors(F, Args, []);
<a name="9640"/> 9640:         {_, Args, nyi} -&gt;
<a name="9641"/> 9641:             case lists:all(fun(A) -&gt; A =:= '*' end, Args) of
<a name="9642"/> 9642:                 true -&gt;
<a name="9643"/> 9643:                     store_error(nyi, H, error);
<a name="9644"/> 9644:                 false -&gt;
<a name="9645"/> 9645:                     store_error(bad_nyi, H, error)
<a name="9646"/> 9646:             end;
<a name="9647"/> 9647:         {F, Args, Opts} when is_list(Opts) -&gt;
<a name="9648"/> 9648:             case lists:member(no_table, Opts) of
<a name="9649"/> 9649:                 true -&gt;
<a name="9650"/> 9650:                     ets_eval_bif_errors_once(F, Args, Opts);
<a name="9651"/> 9651:                 false -&gt;
<a name="9652"/> 9652:                     eval_ets_bif_errors(F, Args, Opts)
<a name="9653"/> 9653:             end
<a name="9654"/> 9654:     end,
<a name="9655"/> 9655:     do_eval_ets_bif_errors(T);
<a name="9656"/> 9656: <b>do_eval_ets_bif_errors</b>([]) -&gt;
<a name="do_eval_ets_bif_errors-last_expr"/><a name="9657"/> 9657:     ok.
<a name="9658"/> 9658: 
<a name="ets_eval_bif_errors_once-3"/><a name="9659"/> 9659: <b>ets_eval_bif_errors_once</b>(F, Args, Opts) -&gt;
<a name="9660"/> 9660:     MFA = {ets,F,Args},
<a name="9661"/> 9661:     io:format(&quot;\n\n*** ets:~p/~p&quot;, [F,length(Args)]),
<a name="9662"/> 9662: 
<a name="9663"/> 9663:     NoFail = lists:member(no_fail, Opts),
<a name="9664"/> 9664:     ErrorTerm = proplists:get_value(error_term, Opts, none),
<a name="ets_eval_bif_errors_once-last_expr"/><a name="9665"/> 9665: <b>    case ets_apply</b>(F, Args, Opts) of
<a name="9666"/> 9666:         {error,ErrorTerm} when not NoFail -&gt;
<a name="9667"/> 9667:             ok;
<a name="9668"/> 9668:         {error,Info} -&gt;
<a name="9669"/> 9669:             store_error(wrong_failure_reason, MFA, Info);
<a name="9670"/> 9670:         ok when NoFail -&gt;
<a name="9671"/> 9671:             ok;
<a name="9672"/> 9672:         ok when not NoFail -&gt;
<a name="9673"/> 9673:             %% This ETS function was supposed to fail.
<a name="9674"/> 9674:             store_error(expected_failure, MFA, ok)
<a name="9675"/> 9675:     end.
<a name="9676"/> 9676: 
<a name="eval_ets_bif_errors-3"/><a name="9677"/> 9677: <b>eval_ets_bif_errors</b>(F, Args0, Opts) -&gt;
<a name="9678"/> 9678:     MFA = {ets,F,Args0},
<a name="9679"/> 9679:     io:format(&quot;\n\n*** ets:~p/~p&quot;, [F,length(Args0)]),
<a name="9680"/> 9680: 
<a name="9681"/> 9681:     %% Test the ETS function with a valid table argument.
<a name="9682"/> 9682:     %% Test both for sets and ordered sets.
<a name="9683"/> 9683:     _ = eval_ets_valid_tid(F, Args0, Opts, set),
<a name="9684"/> 9684:     Args = eval_ets_valid_tid(F, Args0, Opts, ordered_set),
<a name="9685"/> 9685: 
<a name="9686"/> 9686:     %% Replace the table id with a plain ref to provoke a type error.
<a name="9687"/> 9687:     BadArgs = eval_expand_bad_args(Args),
<a name="eval_ets_bif_errors-last_expr"/><a name="9688"/> 9688: <b>    case ets_apply</b>(F, BadArgs, Opts) of
<a name="9689"/> 9689:         {error,type} -&gt;
<a name="9690"/> 9690:             ok;
<a name="9691"/> 9691:         BadIdResult -&gt;
<a name="9692"/> 9692:             store_error(bad_table_id, MFA, BadIdResult)
<a name="9693"/> 9693:     end.
<a name="9694"/> 9694: 
<a name="eval_ets_valid_tid-4"/><a name="9695"/> 9695: <b>eval_ets_valid_tid</b>(F, Args0, Opts, Type) -&gt;
<a name="9696"/> 9696:     MFA = {ets,F,Args0},
<a name="9697"/> 9697:     Args = eval_expand_args(Args0, Type),
<a name="9698"/> 9698:     case should_apply(Args, Opts) of
<a name="9699"/> 9699:         false -&gt;
<a name="9700"/> 9700:             %% Applying this function will never fail.
<a name="9701"/> 9701:             ok;
<a name="9702"/> 9702:         true -&gt;
<a name="9703"/> 9703:             NoFail = lists:member(no_fail, Opts),
<a name="9704"/> 9704:             ErrorTerm = proplists:get_value(error_term, Opts, none),
<a name="9705"/> 9705:             case ets_apply(F, Args, Opts) of
<a name="9706"/> 9706:                 {error,ErrorTerm} when not NoFail -&gt;
<a name="9707"/> 9707:                     ok;
<a name="9708"/> 9708:                 {error,Info} when not NoFail -&gt;
<a name="9709"/> 9709:                     store_error(wrong_failure_reason, MFA, Info);
<a name="9710"/> 9710:                 {error,Info} when NoFail -&gt;
<a name="9711"/> 9711:                     store_error(expected_success, MFA, Info);
<a name="9712"/> 9712:                 ok when NoFail -&gt;
<a name="9713"/> 9713:                     ok;
<a name="9714"/> 9714:                 ok when not NoFail -&gt;
<a name="9715"/> 9715:                     %% This ETS function was supposed to fail.
<a name="9716"/> 9716:                     store_error(expected_failure, MFA, ok)
<a name="9717"/> 9717:             end
<a name="9718"/> 9718:     end,
<a name="9719"/> 9719: 
<a name="9720"/> 9720:     %% Test the ETS function from another process to provoke an error
<a name="9721"/> 9721:     %% because of missing access rights. (The table is private.)
<a name="9722"/> 9722:     {Pid,Ref} = spawn_monitor(fun() -&gt; exit(ets_apply(F, Args, Opts)) end),
<a name="9723"/> 9723:     receive
<a name="9724"/> 9724:         {'DOWN',Ref,process,Pid,Result} -&gt;
<a name="9725"/> 9725:             case Result of
<a name="9726"/> 9726:                 {error,access} -&gt;
<a name="9727"/> 9727:                     ok;
<a name="9728"/> 9728:                 {error,not_owner} when F =:= give_away -&gt;
<a name="9729"/> 9729:                     ok;
<a name="9730"/> 9730:                 {error,none} when F =:= info -&gt;
<a name="9731"/> 9731:                     ok;
<a name="9732"/> 9732:                 ok when F =:= info -&gt;
<a name="9733"/> 9733:                     ok;
<a name="9734"/> 9734:                 Other -&gt;
<a name="9735"/> 9735:                     store_error(access, MFA, Other)
<a name="9736"/> 9736:             end
<a name="9737"/> 9737:     end,
<a name="9738"/> 9738: 
<a name="9739"/> 9739:     %% Delete the ETS table.
<a name="9740"/> 9740:     eval_delete_tab(Args),
<a name="9741"/> 9741:     case ets_apply(F, Args, Opts) of
<a name="9742"/> 9742:         {error,id} -&gt;
<a name="9743"/> 9743:             ok;
<a name="9744"/> 9744:         ok when F =:= info -&gt;
<a name="9745"/> 9745:             %% ets:info/1,2 returns `undefined` instead of failing if the
<a name="9746"/> 9746:             %% table has been deleted.
<a name="9747"/> 9747:             ok;
<a name="9748"/> 9748:         DeadTableResult -&gt;
<a name="9749"/> 9749:             store_error(dead_table, MFA, DeadTableResult)
<a name="9750"/> 9750:     end,
<a name="9751"/> 9751: 
<a name="eval_ets_valid_tid-last_expr"/><a name="9752"/> 9752:     Args.
<a name="9753"/> 9753: 
<a name="should_apply-2"/><a name="9754"/> 9754: <b>should_apply</b>([_], _Opts) -&gt;
<a name="9755"/> 9755:     %% An ETS function with a single argument can't fail if
<a name="9756"/> 9756:     %% the argument is valid.
<a name="9757"/> 9757:     false;
<a name="9758"/> 9758: <b>should_apply</b>([_,_|_], Opts) -&gt;
<a name="9759"/> 9759:     %% Applying the function on a valid table would have side effects
<a name="9760"/> 9760:     %% that would cause problems down the line (e.g. successfully
<a name="9761"/> 9761:     %% giving away a table).
<a name="should_apply-last_expr"/><a name="9762"/> 9762: <b>    not lists:member</b>(only_bad_table, Opts).
<a name="9763"/> 9763: 
<a name="store_error-3"/><a name="9764"/> 9764: <b>store_error</b>(What, MFA, Wrong) -&gt;
<a name="store_error-last_expr"/><a name="9765"/> 9765: <b>    put</b>(errors, [{What,MFA,Wrong}|get(errors)]).
<a name="9766"/> 9766: 
<a name="eval_expand_args-2"/><a name="9767"/> 9767: <b>eval_expand_args</b>(Args, Type) -&gt;
<a name="eval_expand_args-last_expr"/><a name="9768"/> 9768: <b>    [expand_arg</b>(A, Type) || A &lt;- Args].
<a name="9769"/> 9769: 
<a name="expand_arg-2"/><a name="9770"/> 9770: <b>expand_arg</b>('$Tab', Type) -&gt; ets:new(table, [Type, private]);
<a name="9771"/> 9771: <b>expand_arg</b>('$Self', _Type) -&gt; self();
<a name="9772"/> 9772: <b>expand_arg</b>('$Living', _Type) -&gt; whereis(living);
<a name="9773"/> 9773: <b>expand_arg</b>('$Dead', _Type) -&gt;
<a name="9774"/> 9774:     {Pid,Ref} = spawn_monitor(fun() -&gt; ok end),
<a name="9775"/> 9775:     receive
<a name="9776"/> 9776:         {'DOWN',Ref,process,Pid,normal} -&gt; Pid
<a name="9777"/> 9777:     end;
<a name="9778"/> 9778: <b>expand_arg</b>(Fun, Type) when is_function(Fun, 1) -&gt; Fun(Type);
<a name="expand_arg-last_expr"/><a name="9779"/> 9779: <b>expand_arg</b>(Arg, _Type) -&gt; Arg.
<a name="9780"/> 9780: 
<a name="eval_delete_tab-1"/><a name="9781"/> 9781: <b>eval_delete_tab</b>(['$named_table'=H|_]) -&gt;
<a name="9782"/> 9782:     ets:delete(H);
<a name="9783"/> 9783: <b>eval_delete_tab</b>([H|_]) when is_reference(H) -&gt;
<a name="9784"/> 9784:     ets:delete(H);
<a name="9785"/> 9785: <b>eval_delete_tab</b>([_|T]) -&gt;
<a name="eval_delete_tab-last_expr"/><a name="9786"/> 9786: <b>    eval_delete_tab</b>(T).
<a name="9787"/> 9787: 
<a name="eval_expand_bad_args-1"/><a name="9788"/> 9788: <b>eval_expand_bad_args</b>(['$named_table'|T]) -&gt;
<a name="9789"/> 9789:     [make_ref()|T];
<a name="9790"/> 9790: <b>eval_expand_bad_args</b>([H|T]) when is_reference(H) -&gt;
<a name="9791"/> 9791:     [make_ref()|T];
<a name="9792"/> 9792: <b>eval_expand_bad_args</b>([H|T]) -&gt;
<a name="eval_expand_bad_args-last_expr"/><a name="9793"/> 9793: <b>    [H|eval_expand_bad_args</b>(T)].
<a name="9794"/> 9794: 
<a name="ets_apply-3"/><a name="9795"/> 9795: <b>ets_apply</b>(F, Args, Opts) -&gt;
<a name="ets_apply-last_expr"/><a name="9796"/> 9796:     try
<a name="9797"/> 9797:         apply(ets, F, Args),
<a name="9798"/> 9798:         io:format(&quot;\nets:~p(~s) succeeded&quot;, [F,ets_format_args(Args)])
<a name="9799"/> 9799:     catch
<a name="9800"/> 9800:         C:R:Stk -&gt;
<a name="9801"/> 9801:             SF = fun(Mod, _, _) -&gt; Mod =:= test_server end,
<a name="9802"/> 9802:             Str = erl_error:format_exception(C, R, Stk, #{stack_trim_fun =&gt; SF}),
<a name="9803"/> 9803:             BinStr = iolist_to_binary(Str),
<a name="9804"/> 9804:             io:format(&quot;\nets:~p(~s)\n~ts&quot;, [F,ets_format_args(Args),BinStr]),
<a name="9805"/> 9805: 
<a name="9806"/> 9806:             {ets,ActualF,ActualArgs,Info} = hd(Stk),
<a name="9807"/> 9807: 
<a name="9808"/> 9808:             RE = &lt;&lt;&quot;[*][*][*] argument \\d+:&quot;&gt;&gt;,
<a name="9809"/> 9809:             case re:run(BinStr, RE, [{capture, none}]) of
<a name="9810"/> 9810:                 match -&gt;
<a name="9811"/> 9811:                     ok;
<a name="9812"/> 9812:                 nomatch -&gt;
<a name="9813"/> 9813:                     store_error(no_explanation, {ets,F,Args}, Info)
<a name="9814"/> 9814:             end,
<a name="9815"/> 9815: 
<a name="9816"/> 9816:             case {ActualF,ActualArgs} of
<a name="9817"/> 9817:                 {F,Args} -&gt;
<a name="9818"/> 9818:                     ok;
<a name="9819"/> 9819:                 _ -&gt;
<a name="9820"/> 9820:                     case lists:member(renamed, Opts) of
<a name="9821"/> 9821:                         true -&gt;
<a name="9822"/> 9822:                             ok;
<a name="9823"/> 9823:                         false -&gt;
<a name="9824"/> 9824:                             store_error(renamed, {ets,F,length(Args)}, {ActualF,ActualArgs})
<a name="9825"/> 9825:                     end
<a name="9826"/> 9826:             end,
<a name="9827"/> 9827:             [{error_info, ErrorInfoMap}] = Info,
<a name="9828"/> 9828:             Cause = maps:get(cause, ErrorInfoMap, none),
<a name="9829"/> 9829:             {error,Cause}
<a name="9830"/> 9830:     end.
<a name="9831"/> 9831: 
<a name="ets_format_args-1"/><a name="9832"/> 9832: <b>ets_format_args</b>(Args) -&gt;
<a name="ets_format_args-last_expr"/><a name="9833"/> 9833: <b>    lists:join</b>(&quot;, &quot;, [io_lib:format(&quot;~P&quot;, [A,10]) || A &lt;- Args]).
<a name="9834"/> 9834: 
<a name="9835"/> 9835: <i>%%%</i>
<a name="9836"/> 9836: <i>%%% Common utility functions.</i>
<a name="9837"/> 9837: <i>%%%</i>
<a name="9838"/> 9838: 
<a name="id-1"/><a name="id-last_expr"/><a name="9839"/> 9839: <b>id</b>(I) -&gt; I.
<a name="9840"/> 9840: 
<a name="very_big_num-0"/><a name="9841"/> 9841: <b>very_big_num</b>() -&gt;
<a name="very_big_num-last_expr"/><a name="9842"/> 9842: <b>    very_big_num</b>(33, 1).
<a name="9843"/> 9843: 
<a name="very_big_num-2"/><a name="9844"/> 9844: <b>very_big_num</b>(Left, Result) when Left &gt; 0 -&gt;
<a name="9845"/> 9845:     very_big_num(Left-1, Result*256);
<a name="9846"/> 9846: <b>very_big_num</b>(0, Result) -&gt;
<a name="very_big_num-last_expr"/><a name="9847"/> 9847:     Result.
<a name="9848"/> 9848: 
<a name="make_port-0"/><a name="9849"/> 9849: <b>make_port</b>() -&gt;
<a name="make_port-last_expr"/><a name="9850"/> 9850: <b>    hd</b>(erlang:ports()).
<a name="9851"/> 9851: 
<a name="make_pid-0"/><a name="9852"/> 9852: <b>make_pid</b>() -&gt;
<a name="make_pid-last_expr"/><a name="9853"/> 9853: <b>    spawn_link</b>(fun sleeper/0).
<a name="9854"/> 9854: 
<a name="sleeper-0"/><a name="9855"/> 9855: <b>sleeper</b>() -&gt;
<a name="sleeper-last_expr"/><a name="9856"/> 9856:     receive after infinity -&gt; ok end.
<a name="9857"/> 9857: 
<a name="make_ext_pid-0"/><a name="9858"/> 9858: <b>make_ext_pid</b>() -&gt;
<a name="9859"/> 9859:     {Pid, _, _} = get(externals),
<a name="make_ext_pid-last_expr"/><a name="9860"/> 9860:     Pid.
<a name="9861"/> 9861: 
<a name="make_ext_port-0"/><a name="9862"/> 9862: <b>make_ext_port</b>() -&gt;
<a name="9863"/> 9863:     {_, Port, _} = get(externals),
<a name="make_ext_port-last_expr"/><a name="9864"/> 9864:     Port.
<a name="make_ext_ref-0"/><a name="9865"/> 9865: <b>make_ext_ref</b>() -&gt;
<a name="9866"/> 9866:     {_, _, Ref} = get(externals),
<a name="make_ext_ref-last_expr"/><a name="9867"/> 9867:     Ref.
<a name="9868"/> 9868: 
<a name="init_externals-0"/><a name="9869"/> 9869: <b>init_externals</b>() -&gt;
<a name="init_externals-last_expr"/><a name="9870"/> 9870: <b>    case get</b>(externals) of
<a name="9871"/> 9871: 	undefined -&gt;
<a name="9872"/> 9872: 	    OtherNode = {gurka@sallad, 1},
<a name="9873"/> 9873: 	    Res = {mk_pid(OtherNode, 7645, 8123),
<a name="9874"/> 9874: 		   mk_port(OtherNode, 187489773),
<a name="9875"/> 9875: 		   mk_ref(OtherNode, [262143, 1293964255, 3291964278])},
<a name="9876"/> 9876: 	    put(externals, Res);
<a name="9877"/> 9877: 
<a name="9878"/> 9878: 	{_,_,_} -&gt; ok
<a name="9879"/> 9879:     end.
<a name="9880"/> 9880: 
<a name="9881"/> 9881: <i>%%</i>
<a name="9882"/> 9882: <i>%% Node container constructor functions</i>
<a name="9883"/> 9883: <i>%%</i>
<a name="9884"/> 9884: 
<a name="9885"/> 9885: <b>-define</b>(VERSION_MAGIC,       131).
<a name="9886"/> 9886: <b>-define</b>(PORT_EXT,            102).
<a name="9887"/> 9887: <b>-define</b>(PID_EXT,             103).
<a name="9888"/> 9888: <b>-define</b>(NEW_REFERENCE_EXT,   114).
<a name="9889"/> 9889: 
<a name="uint32_be-1"/><a name="9890"/> 9890: <b>uint32_be</b>(Uint) when is_integer(Uint), 0 =&lt; Uint, Uint &lt; 1 bsl 32 -&gt;
<a name="9891"/> 9891:     [(Uint bsr 24) band 16#ff,
<a name="9892"/> 9892:      (Uint bsr 16) band 16#ff,
<a name="9893"/> 9893:      (Uint bsr 8) band 16#ff,
<a name="9894"/> 9894:      Uint band 16#ff];
<a name="9895"/> 9895: <b>uint32_be</b>(Uint) -&gt;
<a name="uint32_be-last_expr"/><a name="9896"/> 9896: <b>    exit</b>({badarg, uint32_be, [Uint]}).
<a name="9897"/> 9897: 
<a name="uint16_be-1"/><a name="9898"/> 9898: <b>uint16_be</b>(Uint) when is_integer(Uint), 0 =&lt; Uint, Uint &lt; 1 bsl 16 -&gt;
<a name="9899"/> 9899:     [(Uint bsr 8) band 16#ff,
<a name="9900"/> 9900:      Uint band 16#ff];
<a name="9901"/> 9901: <b>uint16_be</b>(Uint) -&gt;
<a name="uint16_be-last_expr"/><a name="9902"/> 9902: <b>    exit</b>({badarg, uint16_be, [Uint]}).
<a name="9903"/> 9903: 
<a name="uint8-1"/><a name="9904"/> 9904: <b>uint8</b>(Uint) when is_integer(Uint), 0 =&lt; Uint, Uint &lt; 1 bsl 8 -&gt;
<a name="9905"/> 9905:     Uint band 16#ff;
<a name="9906"/> 9906: <b>uint8</b>(Uint) -&gt;
<a name="uint8-last_expr"/><a name="9907"/> 9907: <b>    exit</b>({badarg, uint8, [Uint]}).
<a name="9908"/> 9908: 
<a name="mk_pid-3"/><a name="9909"/> 9909: <b>mk_pid</b>({NodeName, Creation}, Number, Serial) when is_atom(NodeName) -&gt;
<a name="9910"/> 9910:     &lt;&lt;?VERSION_MAGIC, NodeNameExt/binary&gt;&gt; = term_to_binary(NodeName),
<a name="9911"/> 9911:     mk_pid({NodeNameExt, Creation}, Number, Serial);
<a name="9912"/> 9912: <b>mk_pid</b>({NodeNameExt, Creation}, Number, Serial) -&gt;
<a name="mk_pid-last_expr"/><a name="9913"/> 9913: <b>    case catch binary_to_term</b>(list_to_binary([?VERSION_MAGIC,
<a name="9914"/> 9914: 					      ?PID_EXT,
<a name="9915"/> 9915: 					      NodeNameExt,
<a name="9916"/> 9916: 					      uint32_be(Number),
<a name="9917"/> 9917: 					      uint32_be(Serial),
<a name="9918"/> 9918: 					      uint8(Creation)])) of
<a name="9919"/> 9919: 	Pid when is_pid(Pid) -&gt;
<a name="9920"/> 9920: 	    Pid;
<a name="9921"/> 9921: 	{'EXIT', {badarg, _}} -&gt;
<a name="9922"/> 9922: 	    exit({badarg, mk_pid, [{NodeNameExt, Creation}, Number, Serial]});
<a name="9923"/> 9923: 	Other -&gt;
<a name="9924"/> 9924: 	    exit({unexpected_binary_to_term_result, Other})
<a name="9925"/> 9925:     end.
<a name="9926"/> 9926: 
<a name="mk_port-2"/><a name="9927"/> 9927: <b>mk_port</b>({NodeName, Creation}, Number) when is_atom(NodeName) -&gt;
<a name="9928"/> 9928:     &lt;&lt;?VERSION_MAGIC, NodeNameExt/binary&gt;&gt; = term_to_binary(NodeName),
<a name="9929"/> 9929:     mk_port({NodeNameExt, Creation}, Number);
<a name="9930"/> 9930: <b>mk_port</b>({NodeNameExt, Creation}, Number) -&gt;
<a name="mk_port-last_expr"/><a name="9931"/> 9931: <b>    case catch binary_to_term</b>(list_to_binary([?VERSION_MAGIC,
<a name="9932"/> 9932: 					      ?PORT_EXT,
<a name="9933"/> 9933: 					      NodeNameExt,
<a name="9934"/> 9934: 					      uint32_be(Number),
<a name="9935"/> 9935: 					      uint8(Creation)])) of
<a name="9936"/> 9936: 	Port when is_port(Port) -&gt;
<a name="9937"/> 9937: 	    Port;
<a name="9938"/> 9938: 	{'EXIT', {badarg, _}} -&gt;
<a name="9939"/> 9939: 	    exit({badarg, mk_port, [{NodeNameExt, Creation}, Number]});
<a name="9940"/> 9940: 	Other -&gt;
<a name="9941"/> 9941: 	    exit({unexpected_binary_to_term_result, Other})
<a name="9942"/> 9942:     end.
<a name="9943"/> 9943: 
<a name="mk_ref-2"/><a name="9944"/> 9944: <b>mk_ref</b>({NodeName, Creation}, Numbers) when is_atom(NodeName),
<a name="9945"/> 9945: 					   is_integer(Creation),
<a name="9946"/> 9946: 					   is_list(Numbers) -&gt;
<a name="9947"/> 9947:     &lt;&lt;?VERSION_MAGIC, NodeNameExt/binary&gt;&gt; = term_to_binary(NodeName),
<a name="9948"/> 9948:     mk_ref({NodeNameExt, Creation}, Numbers);
<a name="9949"/> 9949: <b>mk_ref</b>({NodeNameExt, Creation}, Numbers) when is_binary(NodeNameExt),
<a name="9950"/> 9950: 					      is_integer(Creation),
<a name="9951"/> 9951: 					      is_list(Numbers) -&gt;
<a name="mk_ref-last_expr"/><a name="9952"/> 9952: <b>    case catch binary_to_term</b>(list_to_binary([?VERSION_MAGIC,
<a name="9953"/> 9953: 					      ?NEW_REFERENCE_EXT,
<a name="9954"/> 9954: 					      uint16_be(length(Numbers)),
<a name="9955"/> 9955: 					      NodeNameExt,
<a name="9956"/> 9956: 					      uint8(Creation),
<a name="9957"/> 9957: 					      lists:map(fun (N) -&gt;
<a name="9958"/> 9958: 								uint32_be(N)
<a name="9959"/> 9959: 							end,
<a name="9960"/> 9960: 							Numbers)])) of
<a name="9961"/> 9961: 	Ref when is_reference(Ref) -&gt;
<a name="9962"/> 9962: 	    Ref;
<a name="9963"/> 9963: 	{'EXIT', {badarg, _}} -&gt;
<a name="9964"/> 9964: 	    exit({badarg, mk_ref, [{NodeNameExt, Creation}, Numbers]});
<a name="9965"/> 9965: 	Other -&gt;
<a name="9966"/> 9966: 	    exit({unexpected_binary_to_term_result, Other})
<a name="9967"/> 9967:     end.
<a name="9968"/> 9968: 
<a name="9969"/> 9969: 
<a name="make_sub_binary-1"/><a name="9970"/> 9970: <b>make_sub_binary</b>(Bin) when is_binary(Bin) -&gt;
<a name="9971"/> 9971:     {_,B} = split_binary(list_to_binary([0,1,3,Bin]), 3),
<a name="9972"/> 9972:     B;
<a name="9973"/> 9973: <b>make_sub_binary</b>(List) -&gt;
<a name="make_sub_binary-last_expr"/><a name="9974"/> 9974: <b>    make_sub_binary</b>(list_to_binary(List)).
<a name="9975"/> 9975: 
<a name="make_unaligned_sub_binary-1"/><a name="9976"/> 9976: <b>make_unaligned_sub_binary</b>(Bin0) when is_binary(Bin0) -&gt;
<a name="9977"/> 9977:     Bin1 = &lt;&lt;0:3,Bin0/binary,31:5&gt;&gt;,
<a name="9978"/> 9978:     Sz = size(Bin0),
<a name="9979"/> 9979:     &lt;&lt;0:3,Bin:Sz/binary,31:5&gt;&gt; = id(Bin1),
<a name="9980"/> 9980:     Bin;
<a name="9981"/> 9981: <b>make_unaligned_sub_binary</b>(List) -&gt;
<a name="make_unaligned_sub_binary-last_expr"/><a name="9982"/> 9982: <b>    make_unaligned_sub_binary</b>(list_to_binary(List)).
<a name="9983"/> 9983: 
<a name="replace_dbg_hash_fixed_nr_of_locks-1"/><a name="9984"/> 9984: <b>replace_dbg_hash_fixed_nr_of_locks</b>(Opts) -&gt;
<a name="replace_dbg_hash_fixed_nr_of_locks-last_expr"/><a name="9985"/> 9985:     [case X of
<a name="9986"/> 9986:          {write_concurrency, {debug_hash_fixed_number_of_locks, _}} -&gt;
<a name="9987"/> 9987:              {write_concurrency, true};
<a name="9988"/> 9988:          _ -&gt; X
<a name="9989"/> 9989:      end || X &lt;- Opts].
<a name="9990"/> 9990: 
<a name="9991"/> 9991: <i>%% Repeat test function with different combination of table options</i>
<a name="9992"/> 9992: <i>%%</i>
<a name="repeat_for_opts_extra_opt-2"/><a name="9993"/> 9993: <b>repeat_for_opts_extra_opt</b>(F, Extra) -&gt;
<a name="repeat_for_opts_extra_opt-last_expr"/><a name="9994"/> 9994: <b>    repeat_for_opts</b>(
<a name="9995"/> 9995:       fun(Opts) -&gt;
<a name="9996"/> 9996:               WithExtra =
<a name="9997"/> 9997:                   case erlang:is_list(Extra) of
<a name="9998"/> 9998:                       true -&gt; Extra ++ Opts;
<a name="9999"/> 9999:                       false -&gt;[Extra | Opts]
<a name="10000"/>10000:                   end,
<a name="10001"/>10001:               case is_invalid_opts_combo(WithExtra) of
<a name="10002"/>10002:                   true -&gt; ok;
<a name="10003"/>10003:                   false -&gt; F(WithExtra)
<a name="10004"/>10004:               end
<a name="10005"/>10005:       end,
<a name="10006"/>10006:       [write_concurrency, read_concurrency, compressed]).
<a name="10007"/>10007: 
<a name="repeat_for_opts-1"/><a name="10008"/>10008: <b>repeat_for_opts</b>(F) -&gt;
<a name="repeat_for_opts-last_expr"/><a name="10009"/>10009: <b>    repeat_for_opts</b>(F, [write_concurrency, read_concurrency, compressed]).
<a name="10010"/>10010: 
<a name="repeat_for_opts_all_table_types-1"/><a name="10011"/>10011: <b>repeat_for_opts_all_table_types</b>(F) -&gt;
<a name="repeat_for_opts_all_table_types-last_expr"/><a name="10012"/>10012: <b>    repeat_for_opts</b>(F, [all_types, write_concurrency, read_concurrency, compressed]).
<a name="10013"/>10013: 
<a name="repeat_for_opts_all_non_stim_table_types-1"/><a name="10014"/>10014: <b>repeat_for_opts_all_non_stim_table_types</b>(F) -&gt;
<a name="repeat_for_opts_all_non_stim_table_types-last_expr"/><a name="10015"/>10015: <b>    repeat_for_opts</b>(F, [all_non_stim_types, write_concurrency, read_concurrency, compressed]).
<a name="10016"/>10016: 
<a name="repeat_for_opts_all_set_table_types-1"/><a name="10017"/>10017: <b>repeat_for_opts_all_set_table_types</b>(F) -&gt;
<a name="repeat_for_opts_all_set_table_types-last_expr"/><a name="10018"/>10018: <b>    repeat_for_opts</b>(F, [set_types, write_concurrency, read_concurrency, compressed]).
<a name="10019"/>10019: 
<a name="repeat_for_all_set_table_types-1"/><a name="10020"/>10020: <b>repeat_for_all_set_table_types</b>(F) -&gt;
<a name="repeat_for_all_set_table_types-last_expr"/><a name="10021"/>10021: <b>    repeat_for_opts</b>(F, [set_types]).
<a name="10022"/>10022: 
<a name="repeat_for_all_ord_set_table_types-1"/><a name="10023"/>10023: <b>repeat_for_all_ord_set_table_types</b>(F) -&gt;
<a name="repeat_for_all_ord_set_table_types-last_expr"/><a name="10024"/>10024: <b>    repeat_for_opts</b>(F, [ord_set_types]).
<a name="10025"/>10025: 
<a name="repeat_for_all_non_stim_set_table_types-1"/><a name="10026"/>10026: <b>repeat_for_all_non_stim_set_table_types</b>(F) -&gt;
<a name="repeat_for_all_non_stim_set_table_types-last_expr"/><a name="10027"/>10027: <b>    repeat_for_opts</b>(F, [all_non_stim_set_types]).
<a name="10028"/>10028: 
<a name="repeat_for_opts_all_ord_set_table_types-1"/><a name="10029"/>10029: <b>repeat_for_opts_all_ord_set_table_types</b>(F) -&gt;
<a name="repeat_for_opts_all_ord_set_table_types-last_expr"/><a name="10030"/>10030: <b>    repeat_for_opts</b>(F, [ord_set_types, write_concurrency, read_concurrency, compressed]).
<a name="10031"/>10031: 
<a name="repeat_for_opts-2"/><a name="10032"/>10032: <b>repeat_for_opts</b>(F, OptGenList) when is_function(F, 1) -&gt;
<a name="repeat_for_opts-last_expr"/><a name="10033"/>10033: <b>    repeat_for_opts</b>(F, OptGenList, []).
<a name="10034"/>10034: 
<a name="repeat_for_opts-3"/><a name="10035"/>10035: <b>repeat_for_opts</b>(F, [], Acc) -&gt;
<a name="10036"/>10036:     lists:foldl(fun(Opts, RV_Acc) -&gt;
<a name="10037"/>10037: 			OptList = lists:filter(fun(E) -&gt; E =/= void end, Opts),
<a name="10038"/>10038:                         case is_redundant_opts_combo(OptList) of
<a name="10039"/>10039:                             true -&gt;
<a name="10040"/>10040:                                 %%io:format(&quot;Ignoring redundant options ~p\n&quot;,[OptList]),
<a name="10041"/>10041:                                 ok;
<a name="10042"/>10042:                             false -&gt;
<a name="10043"/>10043:                                 io:format(&quot;Calling with options ~p\n&quot;,[OptList]),
<a name="10044"/>10044:                                 RV = F(OptList),
<a name="10045"/>10045:                                 case RV_Acc of
<a name="10046"/>10046:                                     {comment,_} -&gt; RV_Acc;
<a name="10047"/>10047:                                     _ -&gt; case RV of
<a name="10048"/>10048:                                              {comment,_} -&gt; RV;
<a name="10049"/>10049:                                              _ -&gt; [RV | RV_Acc]
<a name="10050"/>10050:                                          end
<a name="10051"/>10051:                                 end
<a name="10052"/>10052:                         end
<a name="10053"/>10053:                 end, [], Acc);
<a name="10054"/>10054: <b>repeat_for_opts</b>(F, [OptList | Tail], []) when is_list(OptList) -&gt;
<a name="10055"/>10055:     repeat_for_opts(F, Tail, [[Opt] || Opt &lt;- OptList]);
<a name="10056"/>10056: <b>repeat_for_opts</b>(F, [OptList | Tail], AccList) when is_list(OptList) -&gt;
<a name="10057"/>10057:     repeat_for_opts(F, Tail, [[Opt|Acc] || Opt &lt;- OptList, Acc &lt;- AccList]);
<a name="10058"/>10058: <b>repeat_for_opts</b>(F, [Atom | Tail], AccList) when is_atom(Atom) -&gt;
<a name="repeat_for_opts-last_expr"/><a name="10059"/>10059: <b>    repeat_for_opts</b>(F, [repeat_for_opts_atom2list(Atom) | Tail ], AccList).
<a name="10060"/>10060: 
<a name="repeat_for_opts_atom2list-1"/><a name="10061"/>10061: <b>repeat_for_opts_atom2list</b>(set_types) -&gt; [set,ordered_set,stim_cat_ord_set,cat_ord_set];
<a name="10062"/>10062: <b>repeat_for_opts_atom2list</b>(hash_types) -&gt; [set,bag,duplicate_bag];
<a name="10063"/>10063: <b>repeat_for_opts_atom2list</b>(ord_set_types) -&gt; [ordered_set,stim_cat_ord_set,cat_ord_set];
<a name="10064"/>10064: <b>repeat_for_opts_atom2list</b>(all_types) -&gt; [set,ordered_set,stim_cat_ord_set,cat_ord_set,bag,duplicate_bag];
<a name="10065"/>10065: <b>repeat_for_opts_atom2list</b>(all_non_stim_types) -&gt; [set,ordered_set,cat_ord_set,bag,duplicate_bag];
<a name="10066"/>10066: <b>repeat_for_opts_atom2list</b>(all_non_stim_set_types) -&gt; [set,ordered_set,cat_ord_set];
<a name="10067"/>10067: <b>repeat_for_opts_atom2list</b>(write_concurrency) -&gt; [{write_concurrency,false},
<a name="10068"/>10068:                                                  {write_concurrency,true},
<a name="10069"/>10069:                                                  {write_concurrency, {debug_hash_fixed_number_of_locks, 2048}},
<a name="10070"/>10070:                                                  {write_concurrency,auto}];
<a name="10071"/>10071: <b>repeat_for_opts_atom2list</b>(read_concurrency) -&gt; [{read_concurrency,false},{read_concurrency,true}];
<a name="repeat_for_opts_atom2list-last_expr"/><a name="10072"/>10072: <b>repeat_for_opts_atom2list</b>(compressed) -&gt; [void,compressed].
<a name="10073"/>10073: 
<a name="has_fixed_number_of_locks-1"/><a name="10074"/>10074: <b>has_fixed_number_of_locks</b>(Opts) -&gt;
<a name="has_fixed_number_of_locks-last_expr"/><a name="10075"/>10075: <b>    lists:any</b>(
<a name="10076"/>10076:       fun({write_concurrency, {debug_hash_fixed_number_of_locks, _}}) -&gt;
<a name="10077"/>10077:               true;
<a name="10078"/>10078:          (_) -&gt;
<a name="10079"/>10079:               false
<a name="10080"/>10080:       end,
<a name="10081"/>10081:       Opts).
<a name="10082"/>10082: 
<a name="is_invalid_opts_combo-1"/><a name="10083"/>10083: <b>is_invalid_opts_combo</b>(Opts) -&gt;
<a name="10084"/>10084:     OrderedSet = lists:member(ordered_set, Opts) orelse
<a name="10085"/>10085:                  lists:member(stim_cat_ord_set, Opts) orelse
<a name="10086"/>10086:                  lists:member(cat_ord_set, Opts),
<a name="is_invalid_opts_combo-last_expr"/><a name="10087"/>10087: <b>    OrderedSet andalso has_fixed_number_of_locks</b>(Opts).
<a name="10088"/>10088: 
<a name="run_if_valid_opts-2"/><a name="10089"/>10089: <b>run_if_valid_opts</b>(Opts, F) -&gt;
<a name="run_if_valid_opts-last_expr"/><a name="10090"/>10090: <b>    case is_invalid_opts_combo</b>(Opts) of
<a name="10091"/>10091:         true -&gt; ignore;
<a name="10092"/>10092:         false -&gt; F(Opts)
<a name="10093"/>10093:     end.
<a name="10094"/>10094: 
<a name="is_redundant_opts_combo-1"/><a name="10095"/>10095: <b>is_redundant_opts_combo</b>(Opts) -&gt;
<a name="10096"/>10096:     IsRed1 =
<a name="10097"/>10097:         ((lists:member(stim_cat_ord_set, Opts) orelse
<a name="10098"/>10098:           lists:member(cat_ord_set, Opts))
<a name="10099"/>10099:          andalso
<a name="10100"/>10100:            (lists:member({write_concurrency, false}, Opts) orelse
<a name="10101"/>10101:             lists:member(private, Opts) orelse
<a name="10102"/>10102:             lists:member(protected, Opts))),
<a name="10103"/>10103:     IsRed2 = is_invalid_opts_combo(Opts),
<a name="is_redundant_opts_combo-last_expr"/><a name="10104"/>10104:     IsRed1 orelse IsRed2.
<a name="10105"/>10105: 
<a name="10106"/>10106: <i>%% Add fake table option with info about key range.</i>
<a name="10107"/>10107: <i>%% Will be consumed by ets_new and used for stim_cat_ord_set.</i>
<a name="key_range-2"/><a name="10108"/>10108: <b>key_range</b>(Opts, KeyRange) -&gt;
<a name="key_range-last_expr"/><a name="10109"/>10109:     [{key_range, KeyRange} | Opts].
<a name="10110"/>10110: 
<a name="ets_new-2"/><a name="10111"/>10111: <b>ets_new</b>(Name, Opts0) -&gt;
<a name="10112"/>10112:     {KeyRange, Opts1} = case lists:keytake(key_range, 1, Opts0) of
<a name="10113"/>10113:                             {value, {key_range, KR}, Rest1} -&gt;
<a name="10114"/>10114:                                 {KR, Rest1};
<a name="10115"/>10115:                             false -&gt;
<a name="10116"/>10116:                                 {1000*1000, Opts0}
<a name="10117"/>10117:                         end,
<a name="ets_new-last_expr"/><a name="10118"/>10118: <b>    ets_new</b>(Name, Opts1, KeyRange).
<a name="10119"/>10119: 
<a name="ets_new-3"/><a name="10120"/>10120: <b>ets_new</b>(Name, Opts, KeyRange) -&gt;
<a name="ets_new-last_expr"/><a name="10121"/>10121: <b>    ets_new</b>(Name, Opts, KeyRange, fun id/1).
<a name="10122"/>10122: 
<a name="ets_new-4"/><a name="10123"/>10123: <b>ets_new</b>(Name, Opts0, KeyRange, KeyFun) -&gt;
<a name="10124"/>10124:     {_Smp, CATree, Stimulate, RevOpts} =
<a name="10125"/>10125:         lists:foldl(fun(cat_ord_set, {Smp, false, false, Lacc}) -&gt;
<a name="10126"/>10126:                             {Smp, Smp, false, [ordered_set | Lacc]};
<a name="10127"/>10127:                        (stim_cat_ord_set, {Smp, false, false, Lacc}) -&gt;
<a name="10128"/>10128:                             {Smp, Smp, Smp, [ordered_set | Lacc]};
<a name="10129"/>10129:                        (Other, {Smp, CAT, STIM, Lacc}) -&gt;
<a name="10130"/>10130:                             {Smp, CAT, STIM, [Other | Lacc]}
<a name="10131"/>10131:                     end,
<a name="10132"/>10132:                     {erlang:system_info(schedulers) &gt; 1,false, false, []},
<a name="10133"/>10133:                     Opts0),
<a name="10134"/>10134:     Opts = lists:reverse(RevOpts),
<a name="10135"/>10135:     EtsNewHelper =
<a name="10136"/>10136:         fun (UseOpts) -&gt;
<a name="10137"/>10137:                 case get(ets_new_opts) of
<a name="10138"/>10138:                     UseOpts -&gt;
<a name="10139"/>10139:                         silence; %% suppress identical table opts spam
<a name="10140"/>10140:                     _ -&gt;
<a name="10141"/>10141:                         put(ets_new_opts, UseOpts),
<a name="10142"/>10142:                         io:format(&quot;ets:new(~p, ~p)~n&quot;, [Name, UseOpts])
<a name="10143"/>10143:                 end,
<a name="10144"/>10144:                 ets:new(Name, UseOpts)
<a name="10145"/>10145:         end,
<a name="ets_new-last_expr"/><a name="10146"/>10146:     case CATree andalso
<a name="10147"/>10147:         (not lists:member({write_concurrency, false}, Opts)) andalso
<a name="10148"/>10148:         (not lists:member(private, Opts)) andalso
<a name="10149"/>10149:         (not lists:member(protected, Opts)) of
<a name="10150"/>10150:         true -&gt;
<a name="10151"/>10151:             NewOpts1 =
<a name="10152"/>10152:                 case lists:member({write_concurrency, true}, Opts) of
<a name="10153"/>10153:                     true -&gt; Opts;
<a name="10154"/>10154:                     false -&gt; [{write_concurrency, true}|Opts]
<a name="10155"/>10155:                 end,
<a name="10156"/>10156:             NewOpts2 =
<a name="10157"/>10157:                 case lists:member(public, NewOpts1) of
<a name="10158"/>10158:                     true -&gt; NewOpts1;
<a name="10159"/>10159:                     false -&gt; [public|NewOpts1]
<a name="10160"/>10160:                 end,
<a name="10161"/>10161:             T = EtsNewHelper(NewOpts2),
<a name="10162"/>10162:             case Stimulate of
<a name="10163"/>10163:                 false -&gt; ok;
<a name="10164"/>10164:                 true -&gt; stimulate_contention(T, KeyRange, KeyFun)
<a name="10165"/>10165:             end,
<a name="10166"/>10166:             T;
<a name="10167"/>10167:         false -&gt;
<a name="10168"/>10168:             EtsNewHelper(Opts)
<a name="10169"/>10169:     end.
<a name="10170"/>10170: 
<a name="10171"/>10171: <i>% The purpose of this function is to stimulate fine grained locking in</i>
<a name="10172"/>10172: <i>% tables of types ordered_set with the write_concurrency options</i>
<a name="10173"/>10173: <i>% turned on. The erts_debug feature 'ets_force_split' is used to easier</i>
<a name="10174"/>10174: <i>% generate a routing tree with fine grained locking without having to</i>
<a name="10175"/>10175: <i>% provoke lots of actual lock contentions.</i>
<a name="stimulate_contention-3"/><a name="10176"/>10176: <b>stimulate_contention</b>(Tid, KeyRange, KeyFun) -&gt;
<a name="10177"/>10177:     T = case Tid of
<a name="10178"/>10178:             A when is_atom(A) -&gt; ets:whereis(A);
<a name="10179"/>10179:             _ -&gt; Tid
<a name="10180"/>10180:         end,
<a name="10181"/>10181:     erts_debug:set_internal_state(ets_force_split, {T, true}),
<a name="10182"/>10182:     Num = case KeyRange &gt; 50 of
<a name="10183"/>10183:               true -&gt; 50;
<a name="10184"/>10184:               false -&gt; KeyRange
<a name="10185"/>10185:           end,
<a name="10186"/>10186:     Seed = rand:uniform(KeyRange),
<a name="10187"/>10187:     %%io:format(&quot;prefill_table: Seed = ~p\n&quot;, [Seed]),
<a name="10188"/>10188:     RState = unique_rand_start(KeyRange, Seed),
<a name="10189"/>10189:     stim_inserter_loop(T, RState, Num, KeyFun),
<a name="10190"/>10190:     Num = ets:info(T, size),
<a name="10191"/>10191:     ets:match_delete(T, {'$1','$1','$1'}),
<a name="10192"/>10192:     0 = ets:info(T, size),
<a name="10193"/>10193:     erts_debug:set_internal_state(ets_force_split, {T, false}),
<a name="stimulate_contention-last_expr"/><a name="10194"/>10194: <b>    case ets:info</b>(T,stats) of
<a name="10195"/>10195:         {0, _, _} -&gt;
<a name="10196"/>10196:             io:format(&quot;No routing nodes in table?\n&quot;
<a name="10197"/>10197:                       &quot;Debug feature 'ets_force_split' does not seem to work.\n&quot;, []),
<a name="10198"/>10198:             ct:fail(&quot;No ets_force_split?&quot;);
<a name="10199"/>10199:         Stats -&gt;
<a name="10200"/>10200:             io:format(&quot;stimulated ordered_set: ~p\n&quot;, [Stats])
<a name="10201"/>10201:     end.
<a name="10202"/>10202: 
<a name="stim_inserter_loop-4"/><a name="10203"/>10203: <b>stim_inserter_loop</b>(_, _, 0, _) -&gt;
<a name="10204"/>10204:     ok;
<a name="10205"/>10205: <b>stim_inserter_loop</b>(T, RS0, N, KeyFun) -&gt;
<a name="10206"/>10206:     {K, RS1} = unique_rand_next(RS0),
<a name="10207"/>10207:     Key = KeyFun(K),
<a name="10208"/>10208:     ets:insert(T, {Key, Key, Key}),
<a name="stim_inserter_loop-last_expr"/><a name="10209"/>10209: <b>    stim_inserter_loop</b>(T, RS1, N-1, KeyFun).
<a name="10210"/>10210: 
<a name="do_tc-2"/><a name="10211"/>10211: <b>do_tc</b>(Do, Report) -&gt;
<a name="10212"/>10212:     T1 = erlang:monotonic_time(),
<a name="10213"/>10213:     Do(),
<a name="10214"/>10214:     T2 = erlang:monotonic_time(),
<a name="10215"/>10215:     Elapsed = erlang:convert_time_unit(T2 - T1, native, millisecond),
<a name="do_tc-last_expr"/><a name="10216"/>10216: <b>    Report</b>(Elapsed).
<a name="10217"/>10217: 
<a name="syrup_factor-0"/><a name="10218"/>10218: <b>syrup_factor</b>() -&gt;
<a name="syrup_factor-last_expr"/><a name="10219"/>10219: <b>    case erlang:system_info</b>(build_type) of
<a name="10220"/>10220:         valgrind -&gt; 20;
<a name="10221"/>10221:         _ -&gt; 1
<a name="10222"/>10222:     end.
<a name="10223"/>10223: 
<a name="10224"/>10224: 
<a name="10225"/>10225: <i>%%</i>
<a name="10226"/>10226: <i>%% This is a pseudo random number generator for UNIQUE integers.</i>
<a name="10227"/>10227: <i>%% All integers between 1 and Max will be generated before it repeat itself.</i>
<a name="10228"/>10228: <i>%% It's a variant of this one using quadratic residues by Jeff Preshing:</i>
<a name="10229"/>10229: <i>%% http://preshing.com/20121224/how-to-generate-a-sequence-of-unique-random-integers/</i>
<a name="10230"/>10230: <i>%%</i>
<a name="unique_rand_start-2"/><a name="10231"/>10231: <b>unique_rand_start</b>(Max, Seed) -&gt;
<a name="10232"/>10232:     L = lists:dropwhile(fun(P) -&gt; P &lt; Max end,
<a name="10233"/>10233:                         primes_3mod4()),
<a name="10234"/>10234:     [P | _] = case L of
<a name="10235"/>10235:                       [] -&gt;
<a name="10236"/>10236:                           error(&quot;Random range too large&quot;);
<a name="10237"/>10237:                       _ -&gt;
<a name="10238"/>10238:                           L
<a name="10239"/>10239:                   end,
<a name="10240"/>10240:     3 = P rem 4,
<a name="unique_rand_start-last_expr"/><a name="10241"/>10241:     {0, {Max, P, Seed}}.
<a name="10242"/>10242: 
<a name="unique_rand_next-1"/><a name="10243"/>10243: <b>unique_rand_next</b>({N, {Max, P, Seed}=Const}) -&gt;
<a name="unique_rand_next-last_expr"/><a name="10244"/>10244: <b>    case dquad</b>(P, N, Seed) + 1 of
<a name="10245"/>10245:         RND when RND &gt; Max -&gt;  % Too large, skip
<a name="10246"/>10246:             unique_rand_next({N+1, Const});
<a name="10247"/>10247:         RND -&gt;
<a name="10248"/>10248:             {RND, {N+1, Const}}
<a name="10249"/>10249:     end.
<a name="10250"/>10250: 
<a name="10251"/>10251: <i>%% A one-to-one relation between all integers 0 =&lt; X &lt; Prime</i>
<a name="10252"/>10252: <i>%% if Prime rem 4 == 3.</i>
<a name="quad-2"/><a name="10253"/>10253: <b>quad</b>(Prime, X) -&gt;
<a name="10254"/>10254:     Rem = X*X rem Prime,
<a name="quad-last_expr"/><a name="10255"/>10255:     case 2*X &lt; Prime of
<a name="10256"/>10256:         true -&gt;
<a name="10257"/>10257:             Rem;
<a name="10258"/>10258:         false -&gt;
<a name="10259"/>10259:             Prime - Rem
<a name="10260"/>10260:     end.
<a name="10261"/>10261: 
<a name="dquad-3"/><a name="10262"/>10262: <b>dquad</b>(Prime, X, Seed) -&gt;
<a name="dquad-last_expr"/><a name="10263"/>10263: <b>    quad</b>(Prime, (quad(Prime, X) + Seed) rem Prime).
<a name="10264"/>10264: 
<a name="10265"/>10265: <i>%% Primes where P rem 4 == 3.</i>
<a name="primes_3mod4-0"/><a name="10266"/>10266: <b>primes_3mod4</b>() -&gt;
<a name="primes_3mod4-last_expr"/><a name="10267"/>10267:     [103, 211, 503, 1019, 2003, 5003, 10007, 20011, 50023,
<a name="10268"/>10268:      100003, 200003, 500083, 1000003, 2000003, 5000011,
<a name="10269"/>10269:      10000019, 20000003, 50000047, 100000007].
</pre>
<script>
var hash = window.location.hash.substring(1);
var anchor = document.getElementsByName(hash);
anchor[0].style.backgroundColor="orange";
</script>
</body>
</html>
