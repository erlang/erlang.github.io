<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/erts/emulator/make_test_dir/emulator_test/guard_no_opt_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%</i>
<a name="2"/>    2: <i>%% %CopyrightBegin%</i>
<a name="3"/>    3: <i>%%</i>
<a name="4"/>    4: <i>%% Copyright Ericsson AB 1997-2025. All Rights Reserved.</i>
<a name="5"/>    5: <i>%%</i>
<a name="6"/>    6: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="7"/>    7: <i>%% you may not use this file except in compliance with the License.</i>
<a name="8"/>    8: <i>%% You may obtain a copy of the License at</i>
<a name="9"/>    9: <i>%%</i>
<a name="10"/>   10: <i>%%     http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="11"/>   11: <i>%%</i>
<a name="12"/>   12: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="13"/>   13: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="14"/>   14: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="15"/>   15: <i>%% See the License for the specific language governing permissions and</i>
<a name="16"/>   16: <i>%% limitations under the License.</i>
<a name="17"/>   17: <i>%%</i>
<a name="18"/>   18: <i>%% %CopyrightEnd%</i>
<a name="19"/>   19: <i>%%</i>
<a name="20"/>   20: 
<a name="21"/>   21: <b>-module</b>(guard_no_opt_SUITE).
<a name="22"/>   22: 
<a name="23"/>   23: <b>-export</b>([all/0, suite/0,
<a name="24"/>   24:          bad_arith/1, bad_tuple/1,
<a name="25"/>   25: 	 test_heap_guards/1, guard_bifs/1,
<a name="26"/>   26: 	 type_tests/1,guard_bif_binary_part/1]).
<a name="27"/>   27: 
<a name="28"/>   28: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="29"/>   29: <b>-include_lib</b>(&quot;stdlib/include/assert.hrl&quot;).
<a name="30"/>   30: 
<a name="31"/>   31: <b>-export</b>([init/3]).
<a name="32"/>   32: <b>-import</b>(lists, [member/2]).
<a name="33"/>   33: 
<a name="suite-0"/><a name="suite-last_expr"/><a name="34"/>   34: <b>suite</b>() -&gt; [{ct_hooks,[ts_install_cth]}].
<a name="35"/>   35: 
<a name="all-0"/><a name="36"/>   36: <b>all</b>() -&gt; 
<a name="all-last_expr"/><a name="37"/>   37:     [bad_arith, bad_tuple, test_heap_guards, guard_bifs,
<a name="38"/>   38:      type_tests, guard_bif_binary_part].
<a name="39"/>   39: 
<a name="40"/>   40: 
<a name="41"/>   41: <i>%% Test that a bad arithmetic operation in a guard works correctly.</i>
<a name="bad_arith-1"/><a name="42"/>   42: <b>bad_arith</b>(Config) when is_list(Config) -&gt;
<a name="43"/>   43:     5 = bad_arith1(2, 3),
<a name="44"/>   44:     10 = bad_arith1(1, infinity),
<a name="45"/>   45:     10 = bad_arith1(infinity, 1),
<a name="bad_arith-last_expr"/><a name="46"/>   46:     ok.
<a name="47"/>   47: 
<a name="bad_arith1-2"/><a name="48"/>   48: <b>bad_arith1</b>(T1, T2) when T1+T2 &lt; 10 -&gt;
<a name="49"/>   49:     T1+T2;
<a name="50"/>   50: <b>bad_arith1</b>(_, _) -&gt;
<a name="bad_arith1-last_expr"/><a name="51"/>   51:     10.
<a name="52"/>   52: 
<a name="53"/>   53: <i>%% Test that bad arguments to element/2 are handled correctly.</i>
<a name="bad_tuple-1"/><a name="54"/>   54: <b>bad_tuple</b>(Config) when is_list(Config) -&gt;
<a name="55"/>   55:     error = bad_tuple1(a),
<a name="56"/>   56:     error = bad_tuple1({a, b}),
<a name="57"/>   57:     x = bad_tuple1({x, b}),
<a name="58"/>   58:     y = bad_tuple1({a, b, y}),
<a name="59"/>   59: 
<a name="60"/>   60:     ?assertError(badarg, int_to_atom_1(-1)),
<a name="61"/>   61:     ?assertError(badarg, int_to_atom_1(0)),
<a name="62"/>   62:     ?assertError(badarg, int_to_atom_1(4)),
<a name="63"/>   63:     ?assertError(badarg, int_to_atom_1(4.2)),
<a name="64"/>   64:     ?assertError(badarg, int_to_atom_1(x)),
<a name="65"/>   65: 
<a name="66"/>   66:     ?assertError(badarg, int_to_atom_2(-1)),
<a name="67"/>   67:     ?assertError(badarg, int_to_atom_2(0)),
<a name="68"/>   68:     ?assertError(badarg, int_to_atom_2(4)),
<a name="69"/>   69:     ?assertError(badarg, int_to_atom_2(3.0)),
<a name="70"/>   70:     ?assertError(badarg, int_to_atom_2(x)),
<a name="71"/>   71: 
<a name="bad_tuple-last_expr"/><a name="72"/>   72:     ok.
<a name="73"/>   73: 
<a name="bad_tuple1-1"/><a name="74"/>   74: <b>bad_tuple1</b>(T) when element(1, T) == x -&gt;
<a name="75"/>   75:     x;
<a name="76"/>   76: <b>bad_tuple1</b>(T) when element(3, T) == y -&gt;
<a name="77"/>   77:     y;
<a name="78"/>   78: <b>bad_tuple1</b>(_) -&gt;
<a name="bad_tuple1-last_expr"/><a name="79"/>   79:     error.
<a name="80"/>   80: 
<a name="int_to_atom_1-1"/><a name="81"/>   81: <b>int_to_atom_1</b>(N) -&gt;
<a name="int_to_atom_1-last_expr"/><a name="82"/>   82:     if
<a name="83"/>   83:         is_integer(N) -&gt;
<a name="84"/>   84:             element(N, {a,b,c});
<a name="85"/>   85:         true -&gt;
<a name="86"/>   86:             element(N, {a,b,c})
<a name="87"/>   87:     end.
<a name="88"/>   88: 
<a name="int_to_atom_2-1"/><a name="89"/>   89: <b>int_to_atom_2</b>(N0) -&gt;
<a name="int_to_atom_2-last_expr"/><a name="90"/>   90: <b>    case id</b>(N0) of
<a name="91"/>   91:         N when is_integer(N) -&gt;
<a name="92"/>   92:             element(N, {a,b,c});
<a name="93"/>   93:         Other -&gt;
<a name="94"/>   94:             element(Other, {a,b,c})
<a name="95"/>   95:     end.
<a name="96"/>   96: 
<a name="test_heap_guards-1"/><a name="97"/>   97: <b>test_heap_guards</b>(Config) when is_list(Config) -&gt;
<a name="98"/>   98:     ct:timetrap({minutes, 2}),
<a name="99"/>   99:     
<a name="100"/>  100:     process_flag(trap_exit, true),
<a name="101"/>  101:     Tuple = {a, tuple, is, built, here, xxx},
<a name="102"/>  102:     List = [a, list, is, built, here],
<a name="103"/>  103: 
<a name="104"/>  104:     'try'(fun a_case/1, [Tuple], [Tuple]),
<a name="105"/>  105:     'try'(fun a_case/1, [List], [List, List]),
<a name="106"/>  106:     'try'(fun a_case/1, [a], [a]),
<a name="107"/>  107: 
<a name="108"/>  108:     'try'(fun an_if/1, [Tuple], [Tuple]),
<a name="109"/>  109:     'try'(fun an_if/1, [List], [List, List]),
<a name="110"/>  110:     'try'(fun an_if/1, [a], [a]),
<a name="111"/>  111: 
<a name="112"/>  112:     'try'(fun receive_test/1, [Tuple], [Tuple]),
<a name="113"/>  113:     'try'(fun receive_test/1, [List], [List, List]),
<a name="114"/>  114:     'try'(fun receive_test/1, [a], [a]),
<a name="test_heap_guards-last_expr"/><a name="115"/>  115:     ok.
<a name="116"/>  116: 
<a name="a_case-1"/><a name="117"/>  117: <b>a_case</b>(V) -&gt;
<a name="a_case-last_expr"/><a name="118"/>  118:     case V of
<a name="119"/>  119: 	T when T == {a, tuple, is, built, here, xxx} -&gt;
<a name="120"/>  120: 	    [T];
<a name="121"/>  121: 	L when L == [a, list, is, built, here] -&gt;
<a name="122"/>  122: 	    [L, L];
<a name="123"/>  123: 	a -&gt;
<a name="124"/>  124: 	    [a]
<a name="125"/>  125:     end.
<a name="126"/>  126: 
<a name="an_if-1"/><a name="127"/>  127: <b>an_if</b>(V) -&gt;
<a name="an_if-last_expr"/><a name="128"/>  128:     if
<a name="129"/>  129: 	V == {a, tuple, is, built, here, xxx} -&gt;
<a name="130"/>  130: 	    [V];
<a name="131"/>  131: 	V == [a, list, is, built, here] -&gt;
<a name="132"/>  132: 	    [V, V];
<a name="133"/>  133: 	V == a -&gt;
<a name="134"/>  134: 	    [a]
<a name="135"/>  135:     end.
<a name="136"/>  136: 
<a name="receive_test-1"/><a name="137"/>  137: <b>receive_test</b>(V) -&gt;
<a name="138"/>  138:     self() ! V,
<a name="receive_test-last_expr"/><a name="139"/>  139: <b>    a_receive</b>().
<a name="140"/>  140: 
<a name="a_receive-0"/><a name="141"/>  141: <b>a_receive</b>() -&gt;
<a name="a_receive-last_expr"/><a name="142"/>  142:     receive
<a name="143"/>  143: 	T when T == {a, tuple, is, built, here, xxx} -&gt;
<a name="144"/>  144: 	    [T];
<a name="145"/>  145: 	L when L == [a, list, is, built, here] -&gt;
<a name="146"/>  146: 	    [L, L];
<a name="147"/>  147: 	a -&gt;
<a name="148"/>  148: 	    [a]
<a name="149"/>  149:     end.
<a name="150"/>  150: 
<a name="try-3"/><a name="151"/>  151: <b>'try'</b>(Fun, Args, Result) -&gt;
<a name="try-last_expr"/><a name="152"/>  152: <b>    'try'</b>(512, Fun, Args, Result, []).
<a name="153"/>  153: 
<a name="try-5"/><a name="154"/>  154: <b>'try'</b>(0, _, _, _, _) -&gt;
<a name="155"/>  155:     ok;
<a name="156"/>  156: <b>'try'</b>(Iter, Fun, Args, Result, Filler) -&gt;
<a name="157"/>  157:     Pid = spawn_link(?MODULE, init, [Fun,Args,list_to_tuple(Filler)]),
<a name="try-last_expr"/><a name="158"/>  158:     receive
<a name="159"/>  159: 	{'EXIT', Pid, {result, Result}} -&gt;
<a name="160"/>  160: 	    'try'(Iter-1, Fun, Args, Result, [0|Filler]);
<a name="161"/>  161: 	{result, Other} -&gt;
<a name="162"/>  162: 	    ct:fail(&quot;Expected ~p; got ~p~n&quot;, [Result, Other]);
<a name="163"/>  163: 	Other -&gt;
<a name="164"/>  164: 	    ct:fail({unexpected_message, Other})
<a name="165"/>  165:     end.
<a name="166"/>  166: 
<a name="init-3"/><a name="167"/>  167: <b>init</b>(Fun, Args, Filler) -&gt;
<a name="168"/>  168:     Result = {result,apply(Fun, Args)},
<a name="169"/>  169:     dummy(Filler),
<a name="init-last_expr"/><a name="170"/>  170: <b>    exit</b>(Result).
<a name="171"/>  171: 
<a name="dummy-1"/><a name="172"/>  172: <b>dummy</b>(_) -&gt;
<a name="dummy-last_expr"/><a name="173"/>  173:     ok.
<a name="174"/>  174: 
<a name="175"/>  175: <b>-define</b>(MASK_ERROR(EXPR),mask_error((catch (EXPR)))).
<a name="mask_error-1"/><a name="176"/>  176: <b>mask_error</b>({'EXIT',{Err,_}}) -&gt;
<a name="177"/>  177:     Err;
<a name="178"/>  178: <b>mask_error</b>(Else) -&gt;
<a name="mask_error-last_expr"/><a name="179"/>  179:     Else.
<a name="180"/>  180: 
<a name="181"/>  181: <i>%% Test the binary_part/2,3 guard BIF's extensively</i>
<a name="guard_bif_binary_part-1"/><a name="182"/>  182: <b>guard_bif_binary_part</b>(Config) when is_list(Config) -&gt;
<a name="183"/>  183:     %% Overflow tests that need to be unoptimized
<a name="184"/>  184:     badarg =
<a name="185"/>  185: 	?MASK_ERROR(
<a name="186"/>  186: 	   binary_part(&lt;&lt;1,2,3&gt;&gt;,{16#FFFFFFFFFFFFFFFF,
<a name="187"/>  187: 				 -16#7FFFFFFFFFFFFFFF-1})),
<a name="188"/>  188:     badarg =
<a name="189"/>  189: 	?MASK_ERROR(
<a name="190"/>  190: 	   binary_part(&lt;&lt;1,2,3&gt;&gt;,{16#FFFFFFFFFFFFFFFF,
<a name="191"/>  191: 				 16#7FFFFFFFFFFFFFFF})),
<a name="192"/>  192:     F = fun(X) -&gt;
<a name="193"/>  193: 		Master = self(),
<a name="194"/>  194: 		{Pid,Ref} = spawn_monitor( fun() -&gt;
<a name="195"/>  195: 					     A = lists:duplicate(X,a),
<a name="196"/>  196: 					     B = [do_binary_part_guard() | A],
<a name="197"/>  197: 					     Master ! {self(),hd(B)},
<a name="198"/>  198: 					     ok
<a name="199"/>  199: 				     end),
<a name="200"/>  200: 		receive
<a name="201"/>  201: 		    {Pid,ok} -&gt;
<a name="202"/>  202: 			erlang:demonitor(Ref,[flush]),
<a name="203"/>  203: 			ok;
<a name="204"/>  204: 		    Error -&gt;
<a name="205"/>  205: 			Error
<a name="206"/>  206: 		end
<a name="207"/>  207: 	end,
<a name="208"/>  208:     [ ok = F(N) || N &lt;- lists:seq(1,10000) ],
<a name="guard_bif_binary_part-last_expr"/><a name="209"/>  209:     ok.
<a name="210"/>  210: 
<a name="211"/>  211: 
<a name="do_binary_part_guard-0"/><a name="212"/>  212: <b>do_binary_part_guard</b>() -&gt;
<a name="213"/>  213:     1 = bptest(&lt;&lt;1,2,3&gt;&gt;),
<a name="214"/>  214:     2 = bptest(&lt;&lt;2,1,3&gt;&gt;),
<a name="215"/>  215:     error = bptest(&lt;&lt;1&gt;&gt;),
<a name="216"/>  216:     error = bptest(&lt;&lt;&gt;&gt;),
<a name="217"/>  217:     error = bptest(apa),
<a name="218"/>  218:     3 = bptest(&lt;&lt;2,3,3&gt;&gt;),
<a name="219"/>  219:     % With one variable (pos)
<a name="220"/>  220:     1 = bptest(&lt;&lt;1,2,3&gt;&gt;,1),
<a name="221"/>  221:     2 = bptest(&lt;&lt;2,1,3&gt;&gt;,1),
<a name="222"/>  222:     error = bptest(&lt;&lt;1&gt;&gt;,1),
<a name="223"/>  223:     error = bptest(&lt;&lt;&gt;&gt;,1),
<a name="224"/>  224:     error = bptest(apa,1),
<a name="225"/>  225:     3 = bptest(&lt;&lt;2,3,3&gt;&gt;,1),
<a name="226"/>  226:     % With one variable (length)
<a name="227"/>  227:     1 = bptesty(&lt;&lt;1,2,3&gt;&gt;,1),
<a name="228"/>  228:     2 = bptesty(&lt;&lt;2,1,3&gt;&gt;,1),
<a name="229"/>  229:     error = bptesty(&lt;&lt;1&gt;&gt;,1),
<a name="230"/>  230:     error = bptesty(&lt;&lt;&gt;&gt;,1),
<a name="231"/>  231:     error = bptesty(apa,1),
<a name="232"/>  232:     3 = bptesty(&lt;&lt;2,3,3&gt;&gt;,2),
<a name="233"/>  233:     % With one variable (whole tuple)
<a name="234"/>  234:     1 = bptestx(&lt;&lt;1,2,3&gt;&gt;,{1,1}),
<a name="235"/>  235:     2 = bptestx(&lt;&lt;2,1,3&gt;&gt;,{1,1}),
<a name="236"/>  236:     error = bptestx(&lt;&lt;1&gt;&gt;,{1,1}),
<a name="237"/>  237:     error = bptestx(&lt;&lt;&gt;&gt;,{1,1}),
<a name="238"/>  238:     error = bptestx(apa,{1,1}),
<a name="239"/>  239:     3 = bptestx(&lt;&lt;2,3,3&gt;&gt;,{1,2}),
<a name="240"/>  240:     % With two variables
<a name="241"/>  241:     1 = bptest(&lt;&lt;1,2,3&gt;&gt;,1,1),
<a name="242"/>  242:     2 = bptest(&lt;&lt;2,1,3&gt;&gt;,1,1),
<a name="243"/>  243:     error = bptest(&lt;&lt;1&gt;&gt;,1,1),
<a name="244"/>  244:     error = bptest(&lt;&lt;&gt;&gt;,1,1),
<a name="245"/>  245:     error = bptest(apa,1,1),
<a name="246"/>  246:     3 = bptest(&lt;&lt;2,3,3&gt;&gt;,1,2),
<a name="247"/>  247:     % Direct (autoimported) call, these will be evaluated by the compiler...
<a name="248"/>  248:     &lt;&lt;2&gt;&gt; = binary_part(&lt;&lt;1,2,3&gt;&gt;,1,1),
<a name="249"/>  249:     &lt;&lt;1&gt;&gt; = binary_part(&lt;&lt;2,1,3&gt;&gt;,1,1),
<a name="250"/>  250:     % Compiler warnings due to constant evaluation expected (3)
<a name="251"/>  251:     badarg = ?MASK_ERROR(binary_part(&lt;&lt;1&gt;&gt;,1,1)),
<a name="252"/>  252:     badarg = ?MASK_ERROR(binary_part(&lt;&lt;&gt;&gt;,1,1)),
<a name="253"/>  253:     badarg = ?MASK_ERROR(binary_part(apa,1,1)),
<a name="254"/>  254:     &lt;&lt;3,3&gt;&gt; = binary_part(&lt;&lt;2,3,3&gt;&gt;,1,2),
<a name="255"/>  255:     % Direct call through apply
<a name="256"/>  256:     &lt;&lt;2&gt;&gt; = apply(erlang,binary_part,[&lt;&lt;1,2,3&gt;&gt;,1,1]),
<a name="257"/>  257:     &lt;&lt;1&gt;&gt; = apply(erlang,binary_part,[&lt;&lt;2,1,3&gt;&gt;,1,1]),
<a name="258"/>  258:     % Compiler warnings due to constant evaluation expected (3)
<a name="259"/>  259:     badarg = ?MASK_ERROR(apply(erlang,binary_part,[&lt;&lt;1&gt;&gt;,1,1])),
<a name="260"/>  260:     badarg = ?MASK_ERROR(apply(erlang,binary_part,[&lt;&lt;&gt;&gt;,1,1])),
<a name="261"/>  261:     badarg = ?MASK_ERROR(apply(erlang,binary_part,[apa,1,1])),
<a name="262"/>  262:     &lt;&lt;3,3&gt;&gt; = apply(erlang,binary_part,[&lt;&lt;2,3,3&gt;&gt;,1,2]),
<a name="263"/>  263:     % Constant propagation
<a name="264"/>  264:      Bin = &lt;&lt;1,2,3&gt;&gt;,
<a name="265"/>  265:      ok = if
<a name="266"/>  266: 		    binary_part(Bin,1,1) =:= &lt;&lt;2&gt;&gt; -&gt;
<a name="267"/>  267: 			ok;
<a name="268"/>  268: 		    %% Compiler warning, clause cannot match (expected)
<a name="269"/>  269: 		    true -&gt;
<a name="270"/>  270: 			error
<a name="271"/>  271: 		end,
<a name="272"/>  272:      ok = if
<a name="273"/>  273: 		    binary_part(Bin,{1,1}) =:= &lt;&lt;2&gt;&gt; -&gt;
<a name="274"/>  274: 			ok;
<a name="275"/>  275: 		    %% Compiler warning, clause cannot match (expected)
<a name="276"/>  276: 		    true -&gt;
<a name="277"/>  277: 			error
<a name="278"/>  278: 		end,
<a name="do_binary_part_guard-last_expr"/><a name="279"/>  279:     ok.
<a name="280"/>  280: 
<a name="281"/>  281: 
<a name="bptest-1"/><a name="282"/>  282: <b>bptest</b>(B) when length(B) =:= 1337 -&gt;
<a name="283"/>  283:     1;
<a name="284"/>  284: <b>bptest</b>(B) when binary_part(B,{1,1}) =:= &lt;&lt;2&gt;&gt; -&gt;
<a name="285"/>  285:     1;
<a name="286"/>  286: <b>bptest</b>(B) when erlang:binary_part(B,1,1) =:= &lt;&lt;1&gt;&gt; -&gt;
<a name="287"/>  287:     2;
<a name="288"/>  288: <b>bptest</b>(B)  when erlang:binary_part(B,{1,2}) =:= &lt;&lt;3,3&gt;&gt; -&gt;
<a name="289"/>  289:     3;
<a name="290"/>  290: <b>bptest</b>(_) -&gt;
<a name="bptest-last_expr"/><a name="291"/>  291:     error.
<a name="292"/>  292: 
<a name="bptest-2"/><a name="293"/>  293: <b>bptest</b>(B,A) when length(B) =:= A -&gt;
<a name="294"/>  294:     1;
<a name="295"/>  295: <b>bptest</b>(B,A) when binary_part(B,{A,1}) =:= &lt;&lt;2&gt;&gt; -&gt;
<a name="296"/>  296:     1;
<a name="297"/>  297: <b>bptest</b>(B,A) when erlang:binary_part(B,A,1) =:= &lt;&lt;1&gt;&gt; -&gt;
<a name="298"/>  298:     2;
<a name="299"/>  299: <b>bptest</b>(B,A)  when erlang:binary_part(B,{A,2}) =:= &lt;&lt;3,3&gt;&gt; -&gt;
<a name="300"/>  300:     3;
<a name="301"/>  301: <b>bptest</b>(_,_) -&gt;
<a name="bptest-last_expr"/><a name="302"/>  302:     error.
<a name="303"/>  303: 
<a name="bptestx-2"/><a name="304"/>  304: <b>bptestx</b>(B,A) when length(B) =:= A -&gt;
<a name="305"/>  305:     1;
<a name="306"/>  306: <b>bptestx</b>(B,A) when binary_part(B,A) =:= &lt;&lt;2&gt;&gt; -&gt;
<a name="307"/>  307:     1;
<a name="308"/>  308: <b>bptestx</b>(B,A) when erlang:binary_part(B,A) =:= &lt;&lt;1&gt;&gt; -&gt;
<a name="309"/>  309:     2;
<a name="310"/>  310: <b>bptestx</b>(B,A)  when erlang:binary_part(B,A) =:= &lt;&lt;3,3&gt;&gt; -&gt;
<a name="311"/>  311:     3;
<a name="312"/>  312: <b>bptestx</b>(_,_) -&gt;
<a name="bptestx-last_expr"/><a name="313"/>  313:     error.
<a name="314"/>  314: 
<a name="bptesty-2"/><a name="315"/>  315: <b>bptesty</b>(B,A) when length(B) =:= A -&gt;
<a name="316"/>  316:     1;
<a name="317"/>  317: <b>bptesty</b>(B,A) when binary_part(B,{1,A}) =:= &lt;&lt;2&gt;&gt; -&gt;
<a name="318"/>  318:     1;
<a name="319"/>  319: <b>bptesty</b>(B,A) when erlang:binary_part(B,1,A) =:= &lt;&lt;1&gt;&gt; -&gt;
<a name="320"/>  320:     2;
<a name="321"/>  321: <b>bptesty</b>(B,A)  when erlang:binary_part(B,{1,A}) =:= &lt;&lt;3,3&gt;&gt; -&gt;
<a name="322"/>  322:     3;
<a name="323"/>  323: <b>bptesty</b>(_,_) -&gt;
<a name="bptesty-last_expr"/><a name="324"/>  324:     error.
<a name="325"/>  325: 
<a name="bptest-3"/><a name="326"/>  326: <b>bptest</b>(B,A,_C) when length(B) =:= A -&gt;
<a name="327"/>  327:     1;
<a name="328"/>  328: <b>bptest</b>(B,A,C) when binary_part(B,{A,C}) =:= &lt;&lt;2&gt;&gt; -&gt;
<a name="329"/>  329:     1;
<a name="330"/>  330: <b>bptest</b>(B,A,C) when erlang:binary_part(B,A,C) =:= &lt;&lt;1&gt;&gt; -&gt;
<a name="331"/>  331:     2;
<a name="332"/>  332: <b>bptest</b>(B,A,C)  when erlang:binary_part(B,{A,C}) =:= &lt;&lt;3,3&gt;&gt; -&gt;
<a name="333"/>  333:     3;
<a name="334"/>  334: <b>bptest</b>(_,_,_) -&gt;
<a name="bptest-last_expr"/><a name="335"/>  335:     error.
<a name="336"/>  336: 
<a name="337"/>  337: 
<a name="338"/>  338: <i>%% Test all guard bifs with nasty (but legal arguments).</i>
<a name="guard_bifs-1"/><a name="339"/>  339: <b>guard_bifs</b>(Config) when is_list(Config) -&gt;
<a name="340"/>  340:     Big = -237849247829874297658726487367328971246284736473821617265433,
<a name="341"/>  341:     Float = 387924.874,
<a name="342"/>  342: 
<a name="343"/>  343:     %% Succeeding use of guard bifs.
<a name="344"/>  344: 
<a name="345"/>  345:     try_gbif('abs/1', Big, -Big),
<a name="346"/>  346:     try_gbif('float/1', Big, float(Big)),
<a name="347"/>  347:     try_gbif('float/1', Big, float(id(Big))),
<a name="348"/>  348:     try_gbif('trunc/1', Float, 387924.0),
<a name="349"/>  349:     try_gbif('round/1', Float, 387925.0),
<a name="350"/>  350:     try_gbif('round/1', 6209607916799025.0, 6209607916799025),
<a name="351"/>  351:     try_gbif('length/1', [], 0),
<a name="352"/>  352: 
<a name="353"/>  353:     try_gbif('length/1', [a], 1),
<a name="354"/>  354:     try_gbif('length/1', [a, b], 2),
<a name="355"/>  355:     try_gbif('length/1', lists:seq(0, 31), 32),
<a name="356"/>  356: 
<a name="357"/>  357:     try_gbif('hd/1', [a], a),
<a name="358"/>  358:     try_gbif('hd/1', [a, b], a),
<a name="359"/>  359: 
<a name="360"/>  360:     try_gbif('tl/1', [a], []),
<a name="361"/>  361:     try_gbif('tl/1', [a, b], [b]),
<a name="362"/>  362:     try_gbif('tl/1', [a, b, c], [b, c]),
<a name="363"/>  363: 
<a name="364"/>  364:     try_gbif('size/1', {}, 0),
<a name="365"/>  365:     try_gbif('size/1', {a}, 1),
<a name="366"/>  366:     try_gbif('size/1', {a, b}, 2),
<a name="367"/>  367:     try_gbif('size/1', {a, b, c}, 3),
<a name="368"/>  368:     try_gbif('size/1', list_to_binary([]), 0),
<a name="369"/>  369:     try_gbif('size/1', list_to_binary([1]), 1),
<a name="370"/>  370:     try_gbif('size/1', list_to_binary([1, 2]), 2),
<a name="371"/>  371:     try_gbif('size/1', list_to_binary([1, 2, 3]), 3),
<a name="372"/>  372: 
<a name="373"/>  373:     try_gbif('bit_size/1', &lt;&lt;0:7&gt;&gt;, 7),
<a name="374"/>  374: 
<a name="375"/>  375:     try_gbif('element/2', {x}, {1, x}),
<a name="376"/>  376:     try_gbif('element/2', {x, y}, {1, x}),
<a name="377"/>  377:     try_gbif('element/2', {x, y}, {2, y}),
<a name="378"/>  378: 
<a name="379"/>  379:     try_gbif('self/0', 0, self()),
<a name="380"/>  380:     try_gbif('node/0', 0, node()),
<a name="381"/>  381:     try_gbif('node/1', self(), node()),
<a name="382"/>  382: 
<a name="383"/>  383:     %% Failing use of guard bifs.
<a name="384"/>  384: 
<a name="385"/>  385:     try_fail_gbif('abs/1', Big, 1),
<a name="386"/>  386:     try_fail_gbif('abs/1', [], 1),
<a name="387"/>  387: 
<a name="388"/>  388:     try_fail_gbif('float/1', Big, 42),
<a name="389"/>  389:     try_fail_gbif('float/1', [], 42),
<a name="390"/>  390: 
<a name="391"/>  391:     try_fail_gbif('trunc/1', Float, 0.0),
<a name="392"/>  392:     try_fail_gbif('trunc/1', [], 0.0),
<a name="393"/>  393: 
<a name="394"/>  394:     try_fail_gbif('round/1', Float, 1.0),
<a name="395"/>  395:     try_fail_gbif('round/1', [], a),
<a name="396"/>  396: 
<a name="397"/>  397:     try_fail_gbif('length/1', [], 1),
<a name="398"/>  398:     try_fail_gbif('length/1', [a], 0),
<a name="399"/>  399:     try_fail_gbif('length/1', a, 0),
<a name="400"/>  400:     try_fail_gbif('length/1', {a}, 0),
<a name="401"/>  401: 
<a name="402"/>  402:     try_fail_gbif('hd/1', [], 0),
<a name="403"/>  403:     try_fail_gbif('hd/1', [a], x),
<a name="404"/>  404:     try_fail_gbif('hd/1', x, x),
<a name="405"/>  405: 
<a name="406"/>  406:     try_fail_gbif('tl/1', [], 0),
<a name="407"/>  407:     try_fail_gbif('tl/1', [a], x),
<a name="408"/>  408:     try_fail_gbif('tl/1', x, x),
<a name="409"/>  409: 
<a name="410"/>  410:     try_fail_gbif('size/1', {}, 1),
<a name="411"/>  411:     try_fail_gbif('size/1', [], 0),
<a name="412"/>  412:     try_fail_gbif('size/1', [a], 1),
<a name="413"/>  413:     try_fail_gbif('size/1', fun() -&gt; 1 end, 0),
<a name="414"/>  414:     try_fail_gbif('size/1', fun() -&gt; 1 end, 1),
<a name="415"/>  415: 
<a name="416"/>  416:     try_fail_gbif('element/2', {}, {1, x}),
<a name="417"/>  417:     try_fail_gbif('element/2', {x}, {1, y}),
<a name="418"/>  418:     try_fail_gbif('element/2', [], {1, z}),
<a name="419"/>  419: 
<a name="420"/>  420:     try_fail_gbif('self/0', 0, list_to_pid(&quot;&lt;0.0.0&gt;&quot;)),
<a name="421"/>  421:     try_fail_gbif('node/0', 0, xxxx),
<a name="422"/>  422:     try_fail_gbif('node/1', self(), xxx),
<a name="423"/>  423:     try_fail_gbif('node/1', yyy, xxx),
<a name="424"/>  424: 
<a name="425"/>  425:     {'EXIT', {function_clause, _}} = catch gh_6634({a,b}),
<a name="426"/>  426:     {'EXIT', {function_clause, _}} = catch gh_6634(42),
<a name="427"/>  427: 
<a name="guard_bifs-last_expr"/><a name="428"/>  428:     ok.
<a name="429"/>  429: 
<a name="gh_6634-1"/><a name="430"/>  430: <b>gh_6634</b>(X) when is_tuple(X) andalso not ok -&gt;
<a name="431"/>  431:     %% `not ok` would be translated to an is_eq_exact instruction,
<a name="432"/>  432:     %% which the JIT would not handle correctly because it had two
<a name="433"/>  433:     %% immediate operands. In a release build incorrect code would be
<a name="434"/>  434:     %% generated, which might crash the runtime system; in a debug
<a name="435"/>  435:     %% build an assertion would fire at load time.
<a name="gh_6634-last_expr"/><a name="436"/>  436:     ok.
<a name="437"/>  437: 
<a name="try_gbif-3"/><a name="438"/>  438: <b>try_gbif</b>(Id, X, Y) -&gt;
<a name="try_gbif-last_expr"/><a name="439"/>  439: <b>    case guard_bif</b>(Id, X, Y) of
<a name="440"/>  440: 	{Id, X, Y} -&gt;
<a name="441"/>  441: 	    io:format(&quot;guard_bif(~p, ~p, ~p) -- ok&quot;, [Id, X, Y]);
<a name="442"/>  442: 	Other -&gt;
<a name="443"/>  443:             ct:fail(&quot;guard_bif(~p, ~p, ~p) -- bad result: ~p\n&quot;, [Id, X, Y, Other])
<a name="444"/>  444:     end.
<a name="445"/>  445: 
<a name="try_fail_gbif-3"/><a name="446"/>  446: <b>try_fail_gbif</b>(Id, X, Y) -&gt;
<a name="try_fail_gbif-last_expr"/><a name="447"/>  447: <b>    case catch guard_bif</b>(Id, X, Y) of
<a name="448"/>  448: 	{'EXIT',{function_clause,[{?MODULE,guard_bif,[Id,X,Y],_}|_]}} -&gt;
<a name="449"/>  449: 	    io:format(&quot;guard_bif(~p, ~p, ~p) -- ok&quot;, [Id,X,Y]);
<a name="450"/>  450: 	Other -&gt;
<a name="451"/>  451:             ct:fail(&quot;guard_bif(~p, ~p, ~p) -- bad result: ~p\n&quot;, [Id, X, Y, Other])
<a name="452"/>  452:     end.
<a name="453"/>  453: 
<a name="guard_bif-3"/><a name="454"/>  454: <b>guard_bif</b>('abs/1', X, Y) when abs(X) == Y -&gt;
<a name="455"/>  455:     {'abs/1', X, Y};
<a name="456"/>  456: <b>guard_bif</b>('float/1', X, Y) when float(X) == Y -&gt;
<a name="457"/>  457:     {'float/1', X, Y};
<a name="458"/>  458: <b>guard_bif</b>('trunc/1', X, Y) when trunc(X) == Y -&gt;
<a name="459"/>  459:     {'trunc/1', X, Y};
<a name="460"/>  460: <b>guard_bif</b>('round/1', X, Y) when round(X) == Y -&gt;
<a name="461"/>  461:     {'round/1', X, Y};
<a name="462"/>  462: <b>guard_bif</b>('length/1', X, Y) when length(X) == Y -&gt;
<a name="463"/>  463:     {'length/1', X, Y};
<a name="464"/>  464: <b>guard_bif</b>('hd/1', X, Y) when hd(X) == Y -&gt;
<a name="465"/>  465:     {'hd/1', X, Y};
<a name="466"/>  466: <b>guard_bif</b>('tl/1', X, Y) when tl(X) == Y -&gt;
<a name="467"/>  467:     {'tl/1', X, Y};
<a name="468"/>  468: <b>guard_bif</b>('size/1', X, Y) when size(X) == Y -&gt;
<a name="469"/>  469:     {'size/1', X, Y};
<a name="470"/>  470: <b>guard_bif</b>('bit_size/1', X, Y) when bit_size(X) == Y -&gt;
<a name="471"/>  471:     {'bit_size/1', X, Y};
<a name="472"/>  472: <b>guard_bif</b>('element/2', X, {Pos, Expected}) when element(Pos, X) == Expected -&gt;
<a name="473"/>  473:     {'element/2', X, {Pos, Expected}};
<a name="474"/>  474: <b>guard_bif</b>('self/0', X, Y) when self() == Y -&gt;
<a name="475"/>  475:     {'self/0', X, Y};
<a name="476"/>  476: <b>guard_bif</b>('node/0', X, Y) when node() == Y -&gt;
<a name="477"/>  477:     {'node/0', X, Y};
<a name="478"/>  478: <b>guard_bif</b>('node/1', X, Y) when node(X) == Y -&gt;
<a name="guard_bif-last_expr"/><a name="479"/>  479:     {'node/1', X, Y}.
<a name="480"/>  480: 
<a name="481"/>  481: <i>%% Test the type tests.</i>
<a name="type_tests-1"/><a name="482"/>  482: <b>type_tests</b>(Config) when is_list(Config) -&gt;
<a name="483"/>  483:     Types = all_types(),
<a name="484"/>  484:     Tests = type_test_desc(),
<a name="485"/>  485:     put(errors, 0),
<a name="486"/>  486:     put(violations, 0),
<a name="487"/>  487:     type_tests(Tests, Types),
<a name="type_tests-last_expr"/><a name="488"/>  488: <b>    case {get</b>(errors), get(violations)} of
<a name="489"/>  489: 	      {0, 0} -&gt;
<a name="490"/>  490: 		  ok;
<a name="491"/>  491: 	      {0, N} -&gt;
<a name="492"/>  492: 		  {comment, integer_to_list(N) ++ &quot; standard violation(s)&quot;};
<a name="493"/>  493: 	      {Errors, Violations} -&gt;
<a name="494"/>  494: 		  ct:fail(&quot;~p sub test(s) failed, ~p violation(s)&quot;, [Errors, Violations])
<a name="495"/>  495: 	  end.
<a name="496"/>  496: 
<a name="type_tests-2"/><a name="497"/>  497: <b>type_tests</b>([{Test, AllowedTypes}| T], AllTypes) -&gt;
<a name="498"/>  498:     type_tests(Test, AllTypes, AllowedTypes),
<a name="499"/>  499:     type_tests(T, AllTypes);
<a name="500"/>  500: <b>type_tests</b>([], _) -&gt;
<a name="type_tests-last_expr"/><a name="501"/>  501:     ok.
<a name="502"/>  502: 
<a name="type_tests-3"/><a name="503"/>  503: <b>type_tests</b>(Test, [Type|T], Allowed) -&gt;
<a name="504"/>  504:     {TypeTag, Value} = Type,
<a name="505"/>  505:     case member(TypeTag, Allowed) of
<a name="506"/>  506: 	true -&gt;
<a name="507"/>  507: 	    case catch type_test(Test, Value) of
<a name="508"/>  508: 		Test -&gt;
<a name="509"/>  509: 		    ok;
<a name="510"/>  510: 		_Other -&gt;
<a name="511"/>  511: 		    io:format(&quot;Test ~p(~p) failed&quot;, [Test, Value]),
<a name="512"/>  512: 		    put(errors, get(errors) + 1)
<a name="513"/>  513: 	    end;
<a name="514"/>  514: 	false -&gt;
<a name="515"/>  515: 	    case catch type_test(Test, Value) of
<a name="516"/>  516: 		{'EXIT',{function_clause,
<a name="517"/>  517: 			 [{?MODULE,type_test,[Test,Value],Loc}|_]}}
<a name="518"/>  518: 		when is_list(Loc) -&gt;
<a name="519"/>  519: 		    ok;
<a name="520"/>  520: 		{'EXIT',Other} -&gt;
<a name="521"/>  521: 		    ct:fail({unexpected_error_reason,Other});
<a name="522"/>  522: 		tuple when is_function(Value) -&gt;
<a name="523"/>  523: 		    io:format(&quot;Standard violation: Test ~p(~p) should fail&quot;,
<a name="524"/>  524: 			      [Test, Value]),
<a name="525"/>  525: 		    put(violations, get(violations) + 1);
<a name="526"/>  526: 		_Other -&gt;
<a name="527"/>  527: 		    io:format(&quot;Test ~p(~p) succeeded (should fail)&quot;, [Test, Value]),
<a name="528"/>  528: 		    put(errors, get(errors) + 1)
<a name="529"/>  529: 	    end
<a name="530"/>  530:     end,
<a name="531"/>  531:     type_tests(Test, T, Allowed);
<a name="532"/>  532: <b>type_tests</b>(_, [], _) -&gt;
<a name="type_tests-last_expr"/><a name="533"/>  533:     ok.
<a name="534"/>  534: 
<a name="all_types-0"/><a name="535"/>  535: <b>all_types</b>() -&gt;
<a name="all_types-last_expr"/><a name="536"/>  536:     [{small, 42},
<a name="537"/>  537:      {big, 392742928742947293873938792874019287447829874290742},
<a name="538"/>  538:      {float, 3.14156},
<a name="539"/>  539:      {nil, []},
<a name="540"/>  540:      {cons, [a]},
<a name="541"/>  541:      {tuple, {a, b}},
<a name="542"/>  542:      {atom, xxxx},
<a name="543"/>  543:      {ref, make_ref()},
<a name="544"/>  544:      {pid, self()},
<a name="545"/>  545:      {port, make_port()},
<a name="546"/>  546:      {function, fun(_) -&gt; &quot;&quot; end},
<a name="547"/>  547:      {function, fun erlang:abs/1},
<a name="548"/>  548:      {binary, list_to_binary([])},
<a name="549"/>  549:      {bitstring, &lt;&lt;0:7&gt;&gt;}].
<a name="550"/>  550: 
<a name="type_test_desc-0"/><a name="551"/>  551: <b>type_test_desc</b>() -&gt;
<a name="type_test_desc-last_expr"/><a name="552"/>  552:     [{binary, [binary]},
<a name="553"/>  553:      {bitstring, [binary, bitstring]},
<a name="554"/>  554:      {integer, [small, big]},
<a name="555"/>  555:      {float, [float]},
<a name="556"/>  556:      {number, [small, big, float]},
<a name="557"/>  557:      {atom, [atom]},
<a name="558"/>  558:      {list, [cons, nil]},
<a name="559"/>  559:      {nonempty_list, [cons]},
<a name="560"/>  560:      {nil, [nil]},
<a name="561"/>  561:      {tuple, [tuple]},
<a name="562"/>  562:      {pid, [pid]},
<a name="563"/>  563:      {port, [port]},
<a name="564"/>  564:      {reference, [ref]},
<a name="565"/>  565:      {function, [function]}].
<a name="566"/>  566: 
<a name="type_test-2"/><a name="567"/>  567: <b>type_test</b>(integer, X) when is_integer(X) -&gt;
<a name="568"/>  568:     integer;
<a name="569"/>  569: <b>type_test</b>(float, X) when is_float(X) -&gt;
<a name="570"/>  570:     float;
<a name="571"/>  571: <b>type_test</b>(number, X) when is_number(X) -&gt;
<a name="572"/>  572:     number;
<a name="573"/>  573: <b>type_test</b>(atom, X) when is_atom(X) -&gt;
<a name="574"/>  574:     atom;
<a name="575"/>  575: <b>type_test</b>(list, X) when is_list(X) -&gt;
<a name="576"/>  576:     list;
<a name="577"/>  577: <b>type_test</b>(nonempty_list, [_]) -&gt;
<a name="578"/>  578:     nonempty_list;
<a name="579"/>  579: <b>type_test</b>(nil, []) -&gt;
<a name="580"/>  580:     nil;
<a name="581"/>  581: <b>type_test</b>(tuple, X) when is_tuple(X) -&gt;
<a name="582"/>  582:     tuple;
<a name="583"/>  583: <b>type_test</b>(pid, X) when is_pid(X) -&gt;
<a name="584"/>  584:     pid;
<a name="585"/>  585: <b>type_test</b>(reference, X) when is_reference(X) -&gt;
<a name="586"/>  586:     reference;
<a name="587"/>  587: <b>type_test</b>(port, X) when is_port(X) -&gt;
<a name="588"/>  588:     port;
<a name="589"/>  589: <b>type_test</b>(binary, X) when is_binary(X) -&gt;
<a name="590"/>  590:     binary;
<a name="591"/>  591: <b>type_test</b>(bitstring, X) when is_bitstring(X) -&gt;
<a name="592"/>  592:     bitstring;
<a name="593"/>  593: <b>type_test</b>(function, X) when is_function(X) -&gt;
<a name="type_test-last_expr"/><a name="594"/>  594:     function.
<a name="595"/>  595: 
<a name="make_port-0"/><a name="596"/>  596: <b>make_port</b>() -&gt;
<a name="make_port-last_expr"/><a name="597"/>  597: <b>    hd</b>(erlang:ports()).
<a name="598"/>  598: 
<a name="id-1"/><a name="id-last_expr"/><a name="599"/>  599: <b>id</b>(I) -&gt; I.
</pre>
<script>
var hash = window.location.hash.substring(1);
var anchor = document.getElementsByName(hash);
anchor[0].style.backgroundColor="orange";
</script>
</body>
</html>
