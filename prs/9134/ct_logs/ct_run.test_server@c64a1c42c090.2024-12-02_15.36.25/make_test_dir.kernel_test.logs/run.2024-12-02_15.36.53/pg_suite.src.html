<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/></meta>
<title>/buildroot/otp/lib/kernel/make_test_dir/kernel_test/pg_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%</i>
<a name="2"/>    2: <i>%%</i>
<a name="3"/>    3: <i>%% Copyright WhatsApp Inc. and its affiliates. All rights reserved.</i>
<a name="4"/>    4: <i>%%</i>
<a name="5"/>    5: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="6"/>    6: <i>%% you may not use this file except in compliance with the License.</i>
<a name="7"/>    7: <i>%% You may obtain a copy of the License at</i>
<a name="8"/>    8: <i>%%</i>
<a name="9"/>    9: <i>%%     http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="10"/>   10: <i>%%</i>
<a name="11"/>   11: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="12"/>   12: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="13"/>   13: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="14"/>   14: <i>%% See the License for the specific language governing permissions and</i>
<a name="15"/>   15: <i>%% limitations under the License.</i>
<a name="16"/>   16: <i>%%</i>
<a name="17"/>   17: <i>%%-------------------------------------------------------------------</i>
<a name="18"/>   18: <i>%% @author Maxim Fedorov &lt;maximfca@gmail.com&gt;</i>
<a name="19"/>   19: <i>%%     Process Groups smoke test.</i>
<a name="20"/>   20: <b>-module</b>(pg_SUITE).
<a name="21"/>   21: <b>-author</b>(&quot;maximfca@gmail.com&quot;).
<a name="22"/>   22: 
<a name="23"/>   23: <i>%% Test server callbacks</i>
<a name="24"/>   24: <b>-export</b>([
<a name="25"/>   25:     suite/0,
<a name="26"/>   26:     all/0,
<a name="27"/>   27:     groups/0,
<a name="28"/>   28:     init_per_testcase/2,
<a name="29"/>   29:     end_per_testcase/2,
<a name="30"/>   30:     init_per_group/2,
<a name="31"/>   31:     end_per_group/2,
<a name="32"/>   32:     stop_proc/1,
<a name="33"/>   33:     ensure_peers_info/2
<a name="34"/>   34: ]).
<a name="35"/>   35: 
<a name="36"/>   36: <i>%% Test cases exports</i>
<a name="37"/>   37: <b>-export</b>([
<a name="38"/>   38:     pg/0, pg/1,
<a name="39"/>   39:     errors/0, errors/1,
<a name="40"/>   40:     leave_exit_race/0, leave_exit_race/1,
<a name="41"/>   41:     dyn_distribution/0, dyn_distribution/1,
<a name="42"/>   42:     process_owner_check/0, process_owner_check/1,
<a name="43"/>   43:     overlay_missing/0, overlay_missing/1,
<a name="44"/>   44:     single/0, single/1,
<a name="45"/>   45:     two/1,
<a name="46"/>   46:     empty_group_by_remote_leave/0, empty_group_by_remote_leave/1,
<a name="47"/>   47:     thundering_herd/0, thundering_herd/1,
<a name="48"/>   48:     initial/1,
<a name="49"/>   49:     netsplit/1,
<a name="50"/>   50:     trisplit/1,
<a name="51"/>   51:     foursplit/1,
<a name="52"/>   52:     exchange/1,
<a name="53"/>   53:     nolocal/1,
<a name="54"/>   54:     double/1,
<a name="55"/>   55:     scope_restart/1,
<a name="56"/>   56:     missing_scope_join/1,
<a name="57"/>   57:     disconnected_start/1,
<a name="58"/>   58:     forced_sync/0, forced_sync/1,
<a name="59"/>   59:     group_leave/1,
<a name="60"/>   60:     monitor_nonempty_scope/0, monitor_nonempty_scope/1,
<a name="61"/>   61:     monitor_scope/0, monitor_scope/1,
<a name="62"/>   62:     monitor/1,
<a name="63"/>   63:     monitor_self/1,
<a name="64"/>   64:     multi_monitor/1,
<a name="65"/>   65:     protocol_upgrade/1
<a name="66"/>   66: ]).
<a name="67"/>   67: 
<a name="68"/>   68: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="69"/>   69: <b>-include_lib</b>(&quot;stdlib/include/assert.hrl&quot;).
<a name="70"/>   70: 
<a name="suite-0"/><a name="71"/>   71: <b>suite</b>() -&gt;
<a name="suite-last_expr"/><a name="72"/>   72:     [{timetrap, {seconds, 60}}].
<a name="73"/>   73: 
<a name="init_per_testcase-2"/><a name="74"/>   74: <b>init_per_testcase</b>(TestCase, Config) -&gt;
<a name="75"/>   75:     {ok, Pid} = pg:start_link(TestCase),
<a name="init_per_testcase-last_expr"/><a name="76"/>   76: <b>    trace_start</b>(TestCase, Config, Pid).
<a name="77"/>   77: 
<a name="end_per_testcase-2"/><a name="78"/>   78: <b>end_per_testcase</b>(TestCase, Config) -&gt;
<a name="79"/>   79:     gen_server:stop(TestCase),
<a name="80"/>   80:     trace_end(Config),
<a name="end_per_testcase-last_expr"/><a name="81"/>   81:     ok.
<a name="82"/>   82: 
<a name="all-0"/><a name="83"/>   83: <b>all</b>() -&gt;
<a name="all-last_expr"/><a name="84"/>   84:     [dyn_distribution,
<a name="85"/>   85:      {group, basic},
<a name="86"/>   86:      {group, cluster},
<a name="87"/>   87:      {group, performance},
<a name="88"/>   88:      {group, monitor},
<a name="89"/>   89:      {group, old_release}].
<a name="90"/>   90: 
<a name="groups-0"/><a name="91"/>   91: <b>groups</b>() -&gt;
<a name="groups-last_expr"/><a name="92"/>   92:     [
<a name="93"/>   93:         {basic, [parallel], [errors, pg, leave_exit_race, single, overlay_missing,
<a name="94"/>   94:                              protocol_upgrade, monitor_self, multi_monitor]},
<a name="95"/>   95:         {performance, [], [thundering_herd]},
<a name="96"/>   96:         {cluster, [parallel], [process_owner_check, two, initial, netsplit, trisplit, foursplit,
<a name="97"/>   97:             exchange, nolocal, double, scope_restart, missing_scope_join, empty_group_by_remote_leave,
<a name="98"/>   98:             disconnected_start, forced_sync, group_leave]},
<a name="99"/>   99:         {monitor, [parallel], [monitor_nonempty_scope, monitor_scope, monitor]},
<a name="100"/>  100:         {old_release, [parallel], [process_owner_check, two, overlay_missing,
<a name="101"/>  101:                                    empty_group_by_remote_leave, initial, netsplit,
<a name="102"/>  102:                                    nolocal]}
<a name="103"/>  103:     ].
<a name="104"/>  104: 
<a name="init_per_group-2"/><a name="105"/>  105: <b>init_per_group</b>(old_release, Config) -&gt;
<a name="106"/>  106:     PrevRel = integer_to_list(list_to_integer(erlang:system_info(otp_release)) - 1),
<a name="107"/>  107:     case test_server:is_release_available(PrevRel) of
<a name="108"/>  108:         true -&gt;
<a name="109"/>  109:             [{otp_release, PrevRel} | Config];
<a name="110"/>  110:         false -&gt;
<a name="111"/>  111:             {skip, &quot;No OTP &quot;++PrevRel++&quot; release found&quot;}
<a name="112"/>  112:     end;
<a name="113"/>  113: <b>init_per_group</b>(_, Config) -&gt;
<a name="init_per_group-last_expr"/><a name="114"/>  114:     Config.
<a name="115"/>  115: 
<a name="end_per_group-2"/><a name="end_per_group-last_expr"/><a name="116"/>  116: <b>end_per_group</b>(_,_) -&gt; ok.
<a name="117"/>  117: 
<a name="118"/>  118: 
<a name="119"/>  119: <i>%%--------------------------------------------------------------------</i>
<a name="120"/>  120: <i>%% TEST CASES</i>
<a name="121"/>  121: 
<a name="pg-0"/><a name="122"/>  122: <b>pg</b>() -&gt;
<a name="pg-last_expr"/><a name="123"/>  123:     [{doc, &quot;This test must be names pg, to stay inline with default scope&quot;}].
<a name="124"/>  124: 
<a name="pg-1"/><a name="125"/>  125: <b>pg</b>(_Config) -&gt;
<a name="126"/>  126:     ?assertNotEqual(undefined, whereis(?FUNCTION_NAME)), %% ensure scope was started
<a name="127"/>  127:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, self())),
<a name="128"/>  128:     ?assertEqual([self()], pg:get_local_members(?FUNCTION_NAME)),
<a name="129"/>  129:     ?assertEqual([?FUNCTION_NAME], pg:which_groups()),
<a name="130"/>  130:     ?assertEqual([?FUNCTION_NAME], pg:which_local_groups()),
<a name="131"/>  131:     ?assertEqual(ok, pg:leave(?FUNCTION_NAME, self())),
<a name="132"/>  132:     ?assertEqual([], pg:get_members(?FUNCTION_NAME)),
<a name="133"/>  133:     ?assertEqual([], pg:which_groups(?FUNCTION_NAME)),
<a name="pg-last_expr"/><a name="134"/>  134: <b>    ?assertEqual</b>([], pg:which_local_groups(?FUNCTION_NAME)).
<a name="135"/>  135: 
<a name="errors-0"/><a name="136"/>  136: <b>errors</b>() -&gt;
<a name="errors-last_expr"/><a name="137"/>  137:     [{doc, &quot;Tests that errors are handled as expected, for example pg server crashes when it needs to&quot;}].
<a name="138"/>  138: 
<a name="errors-1"/><a name="139"/>  139: <b>errors</b>(_Config) -&gt;
<a name="140"/>  140:     %% kill with 'info' and 'cast'
<a name="141"/>  141:     ?assertException(error, badarg, pg:handle_info(garbage, garbage)),
<a name="142"/>  142:     ?assertException(error, badarg, pg:handle_cast(garbage, garbage)),
<a name="143"/>  143:     %% kill with call
<a name="144"/>  144:     {ok, _Pid} = pg:start(second),
<a name="errors-last_expr"/><a name="145"/>  145: <b>    ?assertException</b>(exit, {{badarg, _}, _}, gen_server:call(second, garbage, infinity)).
<a name="146"/>  146: 
<a name="leave_exit_race-0"/><a name="147"/>  147: <b>leave_exit_race</b>() -&gt;
<a name="leave_exit_race-last_expr"/><a name="148"/>  148:     [{doc, &quot;Tests that pg correctly handles situation when leave and 'DOWN' messages are both in pg queue&quot;}].
<a name="149"/>  149: 
<a name="leave_exit_race-1"/><a name="150"/>  150: <b>leave_exit_race</b>(Config) when is_list(Config) -&gt;
<a name="151"/>  151:     process_flag(priority, high),
<a name="leave_exit_race-last_expr"/><a name="152"/>  152:     [
<a name="153"/>  153:         begin
<a name="154"/>  154:             Pid = spawn(fun () -&gt; ok end),
<a name="155"/>  155:             pg:join(leave_exit_race, test, Pid),
<a name="156"/>  156:             pg:leave(leave_exit_race, test, Pid)
<a name="157"/>  157:         end
<a name="158"/>  158:         || _ &lt;- lists:seq(1, 100)].
<a name="159"/>  159: 
<a name="single-0"/><a name="160"/>  160: <b>single</b>() -&gt;
<a name="single-last_expr"/><a name="161"/>  161:     [{doc, &quot;Tests single node groups&quot;}, {timetrap, {seconds, 5}}].
<a name="162"/>  162: 
<a name="single-1"/><a name="163"/>  163: <b>single</b>(Config) when is_list(Config) -&gt;
<a name="164"/>  164:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, self())),
<a name="165"/>  165:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [self(), self()])),
<a name="166"/>  166:     ?assertEqual([self(), self(), self()], pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="167"/>  167:     ?assertEqual([self(), self(), self()], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="168"/>  168:     ?assertEqual(not_joined, pg:leave(?FUNCTION_NAME, '$missing$', self())),
<a name="169"/>  169:     ?assertEqual(ok, pg:leave(?FUNCTION_NAME, ?FUNCTION_NAME, [self(), self()])),
<a name="170"/>  170:     ?assertEqual(ok, pg:leave(?FUNCTION_NAME, ?FUNCTION_NAME, self())),
<a name="171"/>  171:     ?assertEqual([], pg:which_groups(?FUNCTION_NAME)),
<a name="172"/>  172:     ?assertEqual([], pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="173"/>  173:     ?assertEqual([], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="174"/>  174:     %% double
<a name="175"/>  175:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, self())),
<a name="176"/>  176:     Pid = erlang:spawn(forever()),
<a name="177"/>  177:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, Pid)),
<a name="178"/>  178:     Expected = lists:sort([Pid, self()]),
<a name="179"/>  179:     ?assertEqual(Expected, lists:sort(pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="180"/>  180:     ?assertEqual(Expected, lists:sort(pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="181"/>  181: 
<a name="182"/>  182:     stop_proc(Pid),
<a name="183"/>  183:     sync(?FUNCTION_NAME),
<a name="184"/>  184:     ?assertEqual([self()], pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="185"/>  185:     ?assertEqual(ok, pg:leave(?FUNCTION_NAME, ?FUNCTION_NAME, self())),
<a name="single-last_expr"/><a name="186"/>  186:     ok.
<a name="187"/>  187: 
<a name="dyn_distribution-0"/><a name="188"/>  188: <b>dyn_distribution</b>() -&gt;
<a name="dyn_distribution-last_expr"/><a name="189"/>  189:     [{doc, &quot;Tests that local node when distribution is started dynamically is not treated as remote node&quot;}].
<a name="190"/>  190: 
<a name="dyn_distribution-1"/><a name="191"/>  191: <b>dyn_distribution</b>(Config) when is_list(Config) -&gt;
<a name="192"/>  192:     %% When distribution is started or stopped dynamically,
<a name="193"/>  193:     %%  there is a nodeup/nodedown message delivered to pg
<a name="194"/>  194:     %% It is possible but non-trivial to simulate this
<a name="195"/>  195:     %%  behaviour with starting slave nodes being not
<a name="196"/>  196:     %%  distributed, and calling net_kernel:start/1, however
<a name="197"/>  197:     %%  the effect is still the same as simply sending nodeup,
<a name="198"/>  198:     %%  which is also documented.
<a name="199"/>  199:     ?FUNCTION_NAME ! {nodeup, node()},
<a name="200"/>  200:     %%
<a name="201"/>  201:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, self())),
<a name="202"/>  202:     ?assertEqual([self()], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="dyn_distribution-last_expr"/><a name="203"/>  203:     ok.
<a name="204"/>  204: 
<a name="process_owner_check-0"/><a name="205"/>  205: <b>process_owner_check</b>() -&gt;
<a name="process_owner_check-last_expr"/><a name="206"/>  206:     [{doc, &quot;Tests that process owner is local node&quot;}].
<a name="207"/>  207: 
<a name="process_owner_check-1"/><a name="208"/>  208: <b>process_owner_check</b>(Config) when is_list(Config) -&gt;
<a name="209"/>  209:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="210"/>  210:     %% spawn remote process
<a name="211"/>  211:     LocalPid = erlang:spawn(forever()),
<a name="212"/>  212:     RemotePid = spawn_sleeper_at(Node),
<a name="213"/>  213:     %% check they can't be joined locally
<a name="214"/>  214:     ?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid)),
<a name="215"/>  215:     ?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [RemotePid, RemotePid])),
<a name="216"/>  216:     ?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [LocalPid, RemotePid])),
<a name="217"/>  217:     %% check that non-pid also triggers error
<a name="218"/>  218:     ?assertException(error, function_clause, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, undefined)),
<a name="219"/>  219:     ?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [undefined])),
<a name="220"/>  220:     %% stop the peer
<a name="221"/>  221:     peer:stop(Peer),
<a name="process_owner_check-last_expr"/><a name="222"/>  222:     ok.
<a name="223"/>  223: 
<a name="overlay_missing-0"/><a name="224"/>  224: <b>overlay_missing</b>() -&gt;
<a name="overlay_missing-last_expr"/><a name="225"/>  225:     [{doc, &quot;Tests that scope process that is not a part of overlay network does not change state&quot;}].
<a name="226"/>  226: 
<a name="overlay_missing-1"/><a name="227"/>  227: <b>overlay_missing</b>(Config) -&gt;
<a name="228"/>  228:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="229"/>  229:     %% join self (sanity check)
<a name="230"/>  230:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, group, self())),
<a name="231"/>  231:     %% remember pid from remote
<a name="232"/>  232:     PgPid = rpc:call(Node, erlang, whereis, [?FUNCTION_NAME]),
<a name="233"/>  233:     RemotePid = spawn_sleeper_at(Node),
<a name="234"/>  234:     %% stop remote scope
<a name="235"/>  235:     gen_server:stop(PgPid),
<a name="236"/>  236:     %% craft white-box request: ensure it's rejected
<a name="237"/>  237:     ?FUNCTION_NAME ! {join, PgPid, group, RemotePid},
<a name="238"/>  238:     %% rejected!
<a name="239"/>  239:     ?assertEqual([self()], pg:get_members(?FUNCTION_NAME, group)),
<a name="240"/>  240:     %% ... reject leave too
<a name="241"/>  241:     ?FUNCTION_NAME ! {leave, PgPid, RemotePid, [group]},
<a name="242"/>  242:     ?assertEqual([self()], pg:get_members(?FUNCTION_NAME, group)),
<a name="243"/>  243:     %% join many times on remote
<a name="244"/>  244:     %RemotePids = [erlang:spawn(TwoPeer, forever()) || _ &lt;- lists:seq(1, 1024)],
<a name="245"/>  245:     %?assertEqual(ok, rpc:call(TwoPeer, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, Pid2])),
<a name="246"/>  246:     %% check they can't be joined locally
<a name="247"/>  247:     %?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid)),
<a name="248"/>  248:     %?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [RemotePid, RemotePid])),
<a name="249"/>  249:     %?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [LocalPid, RemotePid])),
<a name="250"/>  250:     %% check that non-pid also triggers error
<a name="251"/>  251:     %?assertException(error, function_clause, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, undefined)),
<a name="252"/>  252:     %?assertException(error, {nolocal, _}, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [undefined])),
<a name="253"/>  253:     %% stop the peer
<a name="overlay_missing-last_expr"/><a name="254"/>  254: <b>    peer:stop</b>(Peer).
<a name="255"/>  255: 
<a name="256"/>  256: 
<a name="two-1"/><a name="257"/>  257: <b>two</b>(Config) when is_list(Config) -&gt;
<a name="258"/>  258:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="259"/>  259:     Pid = erlang:spawn(forever()),
<a name="260"/>  260:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, Pid)),
<a name="261"/>  261:     ?assertEqual([Pid], pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="262"/>  262:     %% first RPC must be serialised 3 times
<a name="263"/>  263:     sync({?FUNCTION_NAME, Node}),
<a name="264"/>  264:     sync(?FUNCTION_NAME),
<a name="265"/>  265:     sync({?FUNCTION_NAME, Node}),
<a name="266"/>  266:     ?assertEqual([Pid], rpc:call(Node, pg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
<a name="267"/>  267:     ?assertEqual([], rpc:call(Node, pg, get_local_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
<a name="268"/>  268:     stop_proc(Pid),
<a name="269"/>  269:     %% again, must be serialised
<a name="270"/>  270:     sync(?FUNCTION_NAME),
<a name="271"/>  271:     sync({?FUNCTION_NAME, Node}),
<a name="272"/>  272:     ?assertEqual([], pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="273"/>  273:     ?assertEqual([], rpc:call(Node, pg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
<a name="274"/>  274: 
<a name="275"/>  275:     Pid2 = spawn_sleeper_at(Node),
<a name="276"/>  276:     Pid3 = spawn_sleeper_at(Node),
<a name="277"/>  277:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, Pid2])),
<a name="278"/>  278:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, Pid3])),
<a name="279"/>  279:     %% serialise through the *other* node
<a name="280"/>  280:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="281"/>  281:     ?assertEqual(lists:sort([Pid2, Pid3]),
<a name="282"/>  282:         lists:sort(pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="283"/>  283:     %% stop the peer
<a name="284"/>  284:     peer:stop(Peer),
<a name="285"/>  285:     %% hope that 'nodedown' comes before we route our request
<a name="286"/>  286:     sync(?FUNCTION_NAME),
<a name="two-last_expr"/><a name="287"/>  287:     ok.
<a name="288"/>  288: 
<a name="empty_group_by_remote_leave-0"/><a name="289"/>  289: <b>empty_group_by_remote_leave</b>() -&gt;
<a name="empty_group_by_remote_leave-last_expr"/><a name="290"/>  290:     [{doc, &quot;Empty group should be deleted from nodes.&quot;}].
<a name="291"/>  291: 
<a name="empty_group_by_remote_leave-1"/><a name="292"/>  292: <b>empty_group_by_remote_leave</b>(Config) when is_list(Config) -&gt;
<a name="293"/>  293:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="294"/>  294:     RemoteNode = rpc:call(Node, erlang, whereis, [?FUNCTION_NAME]),
<a name="295"/>  295:     RemotePid = spawn_sleeper_at(Node),
<a name="296"/>  296:     % remote join
<a name="297"/>  297:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
<a name="298"/>  298:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="299"/>  299:     ?assertEqual([RemotePid], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="300"/>  300:     % inspecting internal state is not best practice, but there's no other way to check if the state is correct.
<a name="301"/>  301:     {_, RemoteMap} = maps:get(RemoteNode, element(4, sys:get_state(?FUNCTION_NAME))),
<a name="302"/>  302:     ?assertEqual(#{?FUNCTION_NAME =&gt; [RemotePid]}, RemoteMap),
<a name="303"/>  303:     % remote leave
<a name="304"/>  304:     ?assertEqual(ok, rpc:call(Node, pg, leave, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
<a name="305"/>  305:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="306"/>  306:     ?assertEqual([], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="307"/>  307:     {_, NewRemoteMap} = maps:get(RemoteNode, element(4, sys:get_state(?FUNCTION_NAME))),
<a name="308"/>  308:     % empty group should be deleted.
<a name="309"/>  309:     ?assertEqual(#{}, NewRemoteMap),
<a name="310"/>  310: 
<a name="311"/>  311:     %% another variant of emptying a group remotely: join([Pi1, Pid2]) and leave ([Pid2, Pid1])
<a name="312"/>  312:     RemotePid2 = spawn_sleeper_at(Node),
<a name="313"/>  313:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, [RemotePid, RemotePid2]])),
<a name="314"/>  314:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="315"/>  315:     ?assertEqual([RemotePid, RemotePid2], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="316"/>  316:     %% now leave
<a name="317"/>  317:     ?assertEqual(ok, rpc:call(Node, pg, leave, [?FUNCTION_NAME, ?FUNCTION_NAME, [RemotePid2, RemotePid]])),
<a name="318"/>  318:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="319"/>  319:     ?assertEqual([], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="320"/>  320:     {_, NewRemoteMap} = maps:get(RemoteNode, element(4, sys:get_state(?FUNCTION_NAME))),
<a name="321"/>  321:     peer:stop(Peer),
<a name="empty_group_by_remote_leave-last_expr"/><a name="322"/>  322:     ok.
<a name="323"/>  323: 
<a name="thundering_herd-0"/><a name="324"/>  324: <b>thundering_herd</b>() -&gt;
<a name="thundering_herd-last_expr"/><a name="325"/>  325:     [{doc, &quot;Thousands of overlay network nodes sending sync to us, and we time out!&quot;}, {timetrap, {seconds, 5}}].
<a name="326"/>  326: 
<a name="thundering_herd-1"/><a name="327"/>  327: <b>thundering_herd</b>(Config) when is_list(Config) -&gt;
<a name="328"/>  328:     GroupCount = 10000,
<a name="329"/>  329:     SyncCount = 2000,
<a name="330"/>  330:     %% make up a large amount of groups
<a name="331"/>  331:     [pg:join(?FUNCTION_NAME, {group, Seq}, self()) || Seq &lt;- lists:seq(1, GroupCount)],
<a name="332"/>  332:     %% initiate a few syncs - and those are really slow...
<a name="333"/>  333:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="334"/>  334:     PeerPid = erlang:spawn(Node, forever()),
<a name="335"/>  335:     PeerPg = rpc:call(Node, erlang, whereis, [?FUNCTION_NAME], 1000),
<a name="336"/>  336:     %% WARNING: code below acts for white-box! %% WARNING
<a name="337"/>  337:     FakeSync = [{{group, 1}, [PeerPid, PeerPid]}],
<a name="338"/>  338:     [gen_server:cast(?FUNCTION_NAME, {sync, PeerPg, FakeSync}) || _ &lt;- lists:seq(1, SyncCount)],
<a name="339"/>  339:     %% next call must not timetrap, otherwise test fails
<a name="340"/>  340:     pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, self()),
<a name="thundering_herd-last_expr"/><a name="341"/>  341: <b>    peer:stop</b>(Peer).
<a name="342"/>  342: 
<a name="initial-1"/><a name="343"/>  343: <b>initial</b>(Config) when is_list(Config) -&gt;
<a name="344"/>  344:     Pid = erlang:spawn(forever()),
<a name="345"/>  345:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, Pid)),
<a name="346"/>  346:     ?assertEqual([Pid], pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="347"/>  347:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="348"/>  348:     %% first sync makes the peer node to process 'nodeup' (and send discover)
<a name="349"/>  349:     sync({?FUNCTION_NAME, Node}),
<a name="350"/>  350:     %% second sync makes origin node pg to reply to discover'
<a name="351"/>  351:     sync(?FUNCTION_NAME),
<a name="352"/>  352:     %% third sync makes peer node to finish processing 'exchange'
<a name="353"/>  353:     sync({?FUNCTION_NAME, Node}),
<a name="354"/>  354:     ?assertEqual([Pid], rpc:call(Node, pg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
<a name="355"/>  355: 
<a name="356"/>  356:     ?assertEqual([], rpc:call(Node, pg, get_local_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
<a name="357"/>  357:     stop_proc(Pid),
<a name="358"/>  358:     sync({?FUNCTION_NAME, Node}),
<a name="359"/>  359:     ?assertEqual([], rpc:call(Node, pg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
<a name="360"/>  360:     peer:stop(Peer),
<a name="initial-last_expr"/><a name="361"/>  361:     ok.
<a name="362"/>  362: 
<a name="netsplit-1"/><a name="363"/>  363: <b>netsplit</b>(Config) when is_list(Config) -&gt;
<a name="364"/>  364:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="365"/>  365:     ?assertEqual(Node, peer:call(Peer, erlang, node, [])), %% just to test RPC
<a name="366"/>  366:     RemoteOldPid = spawn_sleeper_at(Node),
<a name="367"/>  367:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, '$invisible', RemoteOldPid])),
<a name="368"/>  368:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="369"/>  369:     ?assertEqual([RemoteOldPid], pg:get_members(?FUNCTION_NAME, '$invisible')),
<a name="370"/>  370: 
<a name="371"/>  371:     %% hohoho, partition!
<a name="372"/>  372:     disconnect_nodes([Node]),
<a name="373"/>  373:     ?assertEqual(Node, peer:call(Peer, erlang, node, [])), %% just to ensure RPC still works
<a name="374"/>  374:     RemotePid = peer:call(Peer, erlang, spawn, sleeper_mfa()),
<a name="375"/>  375:     ?assertEqual([], peer:call(Peer, erlang, nodes, [])),
<a name="376"/>  376:     ?assertNot(lists:member(Node, nodes())), %% should be no nodes in the cluster
<a name="377"/>  377:     ?assertEqual(ok, peer:call(Peer, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])), %% join - in a partition!
<a name="378"/>  378: 
<a name="379"/>  379:     ?assertEqual(ok, peer:call(Peer, pg, leave, [?FUNCTION_NAME, '$invisible', RemoteOldPid])),
<a name="380"/>  380:     ?assertEqual(ok, peer:call(Peer, pg, join, [?FUNCTION_NAME, '$visible', RemoteOldPid])),
<a name="381"/>  381:     ?assertEqual([RemoteOldPid], peer:call(Peer, pg, get_local_members, [?FUNCTION_NAME, '$visible'])),
<a name="382"/>  382:     %% join locally too
<a name="383"/>  383:     LocalPid = erlang:spawn(forever()),
<a name="384"/>  384:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, LocalPid)),
<a name="385"/>  385: 
<a name="386"/>  386:     ?assertNot(lists:member(Node, nodes())), %% should be no nodes in the cluster
<a name="387"/>  387: 
<a name="388"/>  388:     PgPid = whereis(?FUNCTION_NAME),
<a name="389"/>  389:     1 = erlang:trace(PgPid, true, ['receive']),
<a name="390"/>  390:     pong = net_adm:ping(Node),
<a name="391"/>  391:     receive
<a name="392"/>  392:         {trace, PgPid, 'receive', {nodeup, Node}} -&gt; ok
<a name="393"/>  393:     end,
<a name="394"/>  394:     1 = erlang:trace(PgPid, false, ['receive']),
<a name="395"/>  395: 
<a name="396"/>  396:     %% now ensure sync happened
<a name="397"/>  397:     sync_via(?FUNCTION_NAME, {?FUNCTION_NAME, Node}),
<a name="398"/>  398:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="399"/>  399:     ?assertEqual(lists:sort([RemotePid, LocalPid]),
<a name="400"/>  400:                  lists:sort(rpc:call(Node, pg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME]))),
<a name="401"/>  401:     ?assertEqual([RemoteOldPid], pg:get_members(?FUNCTION_NAME, '$visible')),
<a name="402"/>  402:     peer:stop(Peer),
<a name="netsplit-last_expr"/><a name="403"/>  403:     ok.
<a name="404"/>  404: 
<a name="trisplit-1"/><a name="405"/>  405: <b>trisplit</b>(Config) when is_list(Config) -&gt;
<a name="406"/>  406:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="407"/>  407:     _PeerPid1 = spawn_sleeper_at(Node),
<a name="408"/>  408:     PeerPid2 = spawn_sleeper_at(Node),
<a name="409"/>  409:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, three, PeerPid2])),
<a name="410"/>  410:     disconnect_nodes([Node]),
<a name="411"/>  411:     ?assertEqual(true, net_kernel:connect_node(Node)),
<a name="412"/>  412:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, one, PeerPid2])),
<a name="413"/>  413:     %% now ensure sync happened
<a name="414"/>  414:     {Peer2, Node2} = spawn_node(?FUNCTION_NAME, Config),
<a name="415"/>  415:     ?assertEqual(true, rpc:call(Node2, net_kernel, connect_node, [Node])),
<a name="416"/>  416:     ?assertEqual(lists:sort([node(), Node]), lists:sort(rpc:call(Node2, erlang, nodes, []))),
<a name="417"/>  417:     ok = rpc:call(Node2, ?MODULE, ensure_peers_info, [?FUNCTION_NAME, [node(), Node]]),
<a name="418"/>  418:     ?assertEqual([PeerPid2], rpc:call(Node2, pg, get_members, [?FUNCTION_NAME, one])),
<a name="419"/>  419:     peer:stop(Peer),
<a name="420"/>  420:     peer:stop(Peer2),
<a name="trisplit-last_expr"/><a name="421"/>  421:     ok.
<a name="422"/>  422: 
<a name="foursplit-1"/><a name="423"/>  423: <b>foursplit</b>(Config) when is_list(Config) -&gt;
<a name="424"/>  424:     Pid = erlang:spawn(forever()),
<a name="425"/>  425:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="426"/>  426:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, one, Pid)),
<a name="427"/>  427:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, two, Pid)),
<a name="428"/>  428:     PeerPid1 = erlang:spawn(Node, forever()),
<a name="429"/>  429:     ?assertEqual(ok, pg:leave(?FUNCTION_NAME, one, Pid)),
<a name="430"/>  430:     ?assertEqual(not_joined, pg:leave(?FUNCTION_NAME, three, Pid)),
<a name="431"/>  431:     disconnect_nodes([Node]),
<a name="432"/>  432:     ?assertEqual(ok, peer:call(Peer, ?MODULE, stop_proc, [PeerPid1])),
<a name="433"/>  433:     ?assertEqual(not_joined, pg:leave(?FUNCTION_NAME, three, Pid)),
<a name="434"/>  434:     ?assertEqual(true, net_kernel:connect_node(Node)),
<a name="435"/>  435:     ?assertEqual([], pg:get_members(?FUNCTION_NAME, one)),
<a name="436"/>  436:     ?assertEqual([], peer:call(Peer, pg, get_members, [?FUNCTION_NAME, one])),
<a name="437"/>  437:     peer:stop(Peer),
<a name="foursplit-last_expr"/><a name="438"/>  438:     ok.
<a name="439"/>  439: 
<a name="exchange-1"/><a name="440"/>  440: <b>exchange</b>(Config) when is_list(Config) -&gt;
<a name="441"/>  441:     {Peer1, Node1} = spawn_node(?FUNCTION_NAME, Config),
<a name="442"/>  442:     {Peer2, Node2} = spawn_node(?FUNCTION_NAME, Config),
<a name="443"/>  443:     Pids10 = [peer:call(Peer1, erlang, spawn, [forever()]) || _ &lt;- lists:seq(1, 10)],
<a name="444"/>  444:     Pids2 = [peer:call(Peer2, erlang, spawn, [forever()]) || _ &lt;- lists:seq(1, 10)],
<a name="445"/>  445:     Pids11 = [peer:call(Peer1, erlang, spawn, [forever()]) || _ &lt;- lists:seq(1, 10)],
<a name="446"/>  446:     %% kill first 3 pids from node1
<a name="447"/>  447:     {PidsToKill, Pids1} = lists:split(3, Pids10),
<a name="448"/>  448: 
<a name="449"/>  449:     ?assertEqual(ok, peer:call(Peer1, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, Pids10])),
<a name="450"/>  450:     sync({?FUNCTION_NAME, Node1}), %% Join broadcast have reached local
<a name="451"/>  451:     sync(?FUNCTION_NAME), %% Join broadcast has been processed by local
<a name="452"/>  452:     ?assertEqual(lists:sort(Pids10), lists:sort(pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="453"/>  453:     [peer:call(Peer1, ?MODULE, stop_proc, [Pid]) || Pid &lt;- PidsToKill],
<a name="454"/>  454:     sync(?FUNCTION_NAME),
<a name="455"/>  455:     sync({?FUNCTION_NAME, Node1}),
<a name="456"/>  456: 
<a name="457"/>  457:     Pids = lists:sort(Pids1 ++ Pids2 ++ Pids11),
<a name="458"/>  458:     ?assert(lists:all(fun erlang:is_pid/1, Pids)),
<a name="459"/>  459: 
<a name="460"/>  460:     disconnect_nodes([Node1, Node2]),
<a name="461"/>  461: 
<a name="462"/>  462:     sync(?FUNCTION_NAME), %% Processed nodedowns...
<a name="463"/>  463:     ?assertEqual([], lists:sort(pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="464"/>  464: 
<a name="465"/>  465:     [?assertEqual(ok, peer:call(Peer2, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, Pid])) || Pid &lt;- Pids2],
<a name="466"/>  466:     [?assertEqual(ok, peer:call(Peer1, pg, join, [?FUNCTION_NAME, second, Pid])) || Pid &lt;- Pids11],
<a name="467"/>  467:     ?assertEqual(ok, peer:call(Peer1, pg, join, [?FUNCTION_NAME, third, Pids11])),
<a name="468"/>  468:     %% rejoin
<a name="469"/>  469:     ?assertEqual(true, net_kernel:connect_node(Node1)),
<a name="470"/>  470:     ?assertEqual(true, net_kernel:connect_node(Node2)),
<a name="471"/>  471:     %% need to sleep longer to ensure both nodes made the exchange
<a name="472"/>  472:     ensure_peers_info(?FUNCTION_NAME, [Node1, Node2]),
<a name="473"/>  473:     ?assertEqual(Pids, lists:sort(pg:get_members(?FUNCTION_NAME, second) ++ pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="474"/>  474:     ?assertEqual(lists:sort(Pids11), lists:sort(pg:get_members(?FUNCTION_NAME, third))),
<a name="475"/>  475: 
<a name="476"/>  476:     {Left, Stay} = lists:split(3, Pids11),
<a name="477"/>  477:     ?assertEqual(ok, peer:call(Peer1, pg, leave, [?FUNCTION_NAME, third, Left])),
<a name="478"/>  478:     sync({?FUNCTION_NAME, Node1}),
<a name="479"/>  479:     sync(?FUNCTION_NAME),
<a name="480"/>  480:     ?assertEqual(lists:sort(Stay), lists:sort(pg:get_members(?FUNCTION_NAME, third))),
<a name="481"/>  481:     ?assertEqual(not_joined, peer:call(Peer1, pg, leave, [?FUNCTION_NAME, left, Stay])),
<a name="482"/>  482:     ?assertEqual(ok, peer:call(Peer1, pg, leave, [?FUNCTION_NAME, third, Stay])),
<a name="483"/>  483:     sync({?FUNCTION_NAME, Node1}),
<a name="484"/>  484:     sync(?FUNCTION_NAME),
<a name="485"/>  485:     ?assertEqual([], lists:sort(pg:get_members(?FUNCTION_NAME, third))),
<a name="486"/>  486:     sync({?FUNCTION_NAME, Node1}),
<a name="487"/>  487:     sync(?FUNCTION_NAME),
<a name="488"/>  488: 
<a name="489"/>  489:     peer:stop(Peer1),
<a name="490"/>  490:     peer:stop(Peer2),
<a name="exchange-last_expr"/><a name="491"/>  491:     ok.
<a name="492"/>  492: 
<a name="nolocal-1"/><a name="493"/>  493: <b>nolocal</b>(Config) when is_list(Config) -&gt;
<a name="494"/>  494:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="495"/>  495:     RemotePid = spawn_sleeper_at(Node),
<a name="496"/>  496:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
<a name="497"/>  497:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
<a name="498"/>  498:     ?assertEqual([], pg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="499"/>  499:     peer:stop(Peer),
<a name="nolocal-last_expr"/><a name="500"/>  500:     ok.
<a name="501"/>  501: 
<a name="double-1"/><a name="502"/>  502: <b>double</b>(Config) when is_list(Config) -&gt;
<a name="503"/>  503:     Pid = erlang:spawn(forever()),
<a name="504"/>  504:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, Pid)),
<a name="505"/>  505:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="506"/>  506:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [Pid])),
<a name="507"/>  507:     ?assertEqual([Pid, Pid], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="508"/>  508:     sync({?FUNCTION_NAME, Node}),
<a name="509"/>  509:     sync_via(?FUNCTION_NAME, {?FUNCTION_NAME, Node}),
<a name="510"/>  510:     ?assertEqual([Pid, Pid], rpc:call(Node, pg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
<a name="511"/>  511:     peer:stop(Peer),
<a name="double-last_expr"/><a name="512"/>  512:     ok.
<a name="513"/>  513: 
<a name="scope_restart-1"/><a name="514"/>  514: <b>scope_restart</b>(Config) when is_list(Config) -&gt;
<a name="515"/>  515:     Pid = erlang:spawn(forever()),
<a name="516"/>  516:     ?assertEqual(ok, pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, [Pid, Pid])),
<a name="517"/>  517:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="518"/>  518:     RemotePid = erlang:spawn(Node, forever()),
<a name="519"/>  519:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
<a name="520"/>  520:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="521"/>  521:     ?assertEqual(lists:sort([RemotePid, Pid, Pid]), lists:sort(pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="522"/>  522:     %% stop scope locally, and restart
<a name="523"/>  523:     gen_server:stop(?FUNCTION_NAME),
<a name="524"/>  524:     pg:start(?FUNCTION_NAME),
<a name="525"/>  525:     %% ensure remote pids joined, local are missing
<a name="526"/>  526:     sync(?FUNCTION_NAME),
<a name="527"/>  527:     sync({?FUNCTION_NAME, Node}),
<a name="528"/>  528:     sync(?FUNCTION_NAME),
<a name="529"/>  529:     ?assertEqual([RemotePid], pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
<a name="530"/>  530:     peer:stop(Peer),
<a name="scope_restart-last_expr"/><a name="531"/>  531:     ok.
<a name="532"/>  532: 
<a name="missing_scope_join-1"/><a name="533"/>  533: <b>missing_scope_join</b>(Config) when is_list(Config) -&gt;
<a name="534"/>  534:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="535"/>  535:     ?assertEqual(ok, rpc:call(Node, gen_server, stop, [?FUNCTION_NAME])),
<a name="536"/>  536:     RemotePid = erlang:spawn(Node, forever()),
<a name="537"/>  537:     ?assertMatch({badrpc, {'EXIT', {noproc, _}}}, rpc:call(Node, pg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
<a name="538"/>  538:     ?assertMatch({badrpc, {'EXIT', {noproc, _}}}, rpc:call(Node, pg, leave, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
<a name="539"/>  539:     peer:stop(Peer),
<a name="missing_scope_join-last_expr"/><a name="540"/>  540:     ok.
<a name="541"/>  541: 
<a name="disconnected_start-1"/><a name="542"/>  542: <b>disconnected_start</b>(Config) when is_list(Config) -&gt;
<a name="disconnected_start-last_expr"/><a name="543"/>  543: <b>    case test_server:is_cover</b>() of
<a name="544"/>  544:         true -&gt;
<a name="545"/>  545:             {skip, &quot;Cover is running&quot;};
<a name="546"/>  546:         false -&gt;
<a name="547"/>  547:             disconnected_start_test(Config)
<a name="548"/>  548:     end.
<a name="549"/>  549: 
<a name="disconnected_start_test-1"/><a name="550"/>  550: <b>disconnected_start_test</b>(Config) when is_list(Config) -&gt;
<a name="551"/>  551:     {Peer, Node} = spawn_disconnected_node(?FUNCTION_NAME, ?FUNCTION_NAME, Config),
<a name="552"/>  552:     ?assertNot(lists:member(Node, nodes())),
<a name="553"/>  553:     ?assertEqual(ok, peer:call(Peer, gen_server, stop, [?FUNCTION_NAME])),
<a name="554"/>  554:     ?assertMatch({ok, _Pid}, peer:call(Peer, pg, start,[?FUNCTION_NAME])),
<a name="555"/>  555:     ?assertEqual(ok, peer:call(Peer, gen_server, stop, [?FUNCTION_NAME])),
<a name="556"/>  556:     RemotePid = peer:call(Peer, erlang, spawn, [forever()]),
<a name="557"/>  557:     ?assert(is_pid(RemotePid)),
<a name="558"/>  558:     peer:stop(Peer),
<a name="disconnected_start_test-last_expr"/><a name="559"/>  559:     ok.
<a name="560"/>  560: 
<a name="forced_sync-0"/><a name="561"/>  561: <b>forced_sync</b>() -&gt;
<a name="forced_sync-last_expr"/><a name="562"/>  562:     [{doc, &quot;This test was added when lookup_element was erroneously used instead of lookup, crashing pg with badmatch, and it tests rare out-of-order sync operations&quot;}].
<a name="563"/>  563: 
<a name="forced_sync-1"/><a name="564"/>  564: <b>forced_sync</b>(Config) when is_list(Config) -&gt;
<a name="565"/>  565:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="566"/>  566:     Pid = erlang:spawn(forever()),
<a name="567"/>  567:     RemotePid = erlang:spawn(Node, forever()),
<a name="568"/>  568:     Expected = lists:sort([Pid, RemotePid]),
<a name="569"/>  569:     pg:join(?FUNCTION_NAME, one, Pid),
<a name="570"/>  570: 
<a name="571"/>  571:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, one, RemotePid])),
<a name="572"/>  572:     RemoteScopePid = rpc:call(Node, erlang, whereis, [?FUNCTION_NAME]),
<a name="573"/>  573:     ?assert(is_pid(RemoteScopePid)),
<a name="574"/>  574:     %% hohoho, partition!
<a name="575"/>  575:     disconnect_nodes([Node]),
<a name="576"/>  576:     ?assertEqual(true, net_kernel:connect_node(Node)),
<a name="577"/>  577:     ensure_peers_info(?FUNCTION_NAME, [Node]),
<a name="578"/>  578:     ?assertEqual(Expected, lists:sort(pg:get_members(?FUNCTION_NAME, one))),
<a name="579"/>  579: 
<a name="580"/>  580:     %% Do extra sync to make sure any redundant sync message has arrived
<a name="581"/>  581:     %% before we send our fake sync message below.
<a name="582"/>  582:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="583"/>  583: 
<a name="584"/>  584:     %% WARNING: this code uses pg as white-box, exploiting internals,
<a name="585"/>  585:     %%  only to simulate broken 'sync'
<a name="586"/>  586:     %% Fake Groups: one should disappear, one should be replaced, one stays
<a name="587"/>  587:     %% This tests handle_sync function.
<a name="588"/>  588:     FakeGroups = [{one, [RemotePid, RemotePid]}, {?FUNCTION_NAME, [RemotePid, RemotePid]}],
<a name="589"/>  589:     gen_server:cast(?FUNCTION_NAME, {sync, RemoteScopePid, FakeGroups}),
<a name="590"/>  590:     %% ensure it is broken well enough
<a name="591"/>  591:     sync(?FUNCTION_NAME),
<a name="592"/>  592:     ?assertEqual(lists:sort([RemotePid, RemotePid]), lists:sort(pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="593"/>  593:     ?assertEqual(lists:sort([RemotePid, RemotePid, Pid]), lists:sort(pg:get_members(?FUNCTION_NAME, one))),
<a name="594"/>  594:     %% simulate force-sync via 'discover' - ask peer to send sync to us
<a name="595"/>  595:     {?FUNCTION_NAME, Node} ! {discover, whereis(?FUNCTION_NAME)},
<a name="596"/>  596:     sync({?FUNCTION_NAME, Node}),
<a name="597"/>  597:     sync(?FUNCTION_NAME),
<a name="598"/>  598:     ?assertEqual(Expected, lists:sort(pg:get_members(?FUNCTION_NAME, one))),
<a name="599"/>  599:     ?assertEqual([], lists:sort(pg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
<a name="600"/>  600:     %% and simulate extra sync
<a name="601"/>  601:     sync({?FUNCTION_NAME, Node}),
<a name="602"/>  602:     sync(?FUNCTION_NAME),
<a name="603"/>  603:     ?assertEqual(Expected, lists:sort(pg:get_members(?FUNCTION_NAME, one))),
<a name="604"/>  604: 
<a name="605"/>  605:     peer:stop(Peer),
<a name="forced_sync-last_expr"/><a name="606"/>  606:     ok.
<a name="607"/>  607: 
<a name="group_leave-1"/><a name="608"/>  608: <b>group_leave</b>(Config) when is_list(Config) -&gt;
<a name="609"/>  609:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="610"/>  610:     RemotePid = erlang:spawn(Node, forever()),
<a name="611"/>  611:     Total = lists:duplicate(16, RemotePid),
<a name="612"/>  612:     {Left, Remain} = lists:split(4, Total),
<a name="613"/>  613:     %% join 16 times!
<a name="614"/>  614:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, two, Total])),
<a name="615"/>  615:     ?assertEqual(ok, rpc:call(Node, pg, leave, [?FUNCTION_NAME, two, Left])),
<a name="616"/>  616: 
<a name="617"/>  617:     sync({?FUNCTION_NAME, Node}),
<a name="618"/>  618:     sync(?FUNCTION_NAME),
<a name="619"/>  619:     ?assertEqual(Remain, pg:get_members(?FUNCTION_NAME, two)),
<a name="620"/>  620: 
<a name="621"/>  621:     PgPid = whereis(?FUNCTION_NAME),
<a name="622"/>  622:     1 = erlang:trace(PgPid, true, ['receive']),
<a name="623"/>  623:     peer:stop(Peer),
<a name="624"/>  624:     receive
<a name="625"/>  625:         {trace, PgPid, 'receive', {nodedown, Node}} -&gt; ok
<a name="626"/>  626:     end,
<a name="627"/>  627:     1 = erlang:trace(PgPid, false, ['receive']),
<a name="628"/>  628:     sync(?FUNCTION_NAME),
<a name="629"/>  629:     ?assertEqual([], pg:get_members(?FUNCTION_NAME, two)),
<a name="group_leave-last_expr"/><a name="630"/>  630:     ok.
<a name="631"/>  631: 
<a name="monitor_nonempty_scope-0"/><a name="632"/>  632: <b>monitor_nonempty_scope</b>() -&gt;
<a name="monitor_nonempty_scope-last_expr"/><a name="633"/>  633:     [{doc, &quot;Ensure that monitor_scope returns full map of groups in the scope&quot;}].
<a name="634"/>  634: 
<a name="monitor_nonempty_scope-1"/><a name="635"/>  635: <b>monitor_nonempty_scope</b>(Config) when is_list(Config) -&gt;
<a name="636"/>  636:     {Peer, Node} = spawn_node(?FUNCTION_NAME, Config),
<a name="637"/>  637:     Pid = erlang:spawn_link(forever()),
<a name="638"/>  638:     RemotePid = erlang:spawn(Node, forever()),
<a name="639"/>  639:     Expected = lists:sort([Pid, RemotePid]),
<a name="640"/>  640:     pg:join(?FUNCTION_NAME, one, Pid),
<a name="641"/>  641:     ?assertEqual(ok, rpc:call(Node, pg, join, [?FUNCTION_NAME, one, RemotePid])),
<a name="642"/>  642:     %% Ensure that initial monitoring request returns current map of groups to pids
<a name="643"/>  643:     {Ref, #{one := Actual} = FullScope} = pg:monitor_scope(?FUNCTION_NAME),
<a name="644"/>  644:     ?assertEqual(Expected, Actual),
<a name="645"/>  645:     %% just in case - check there are no extra groups in that scope
<a name="646"/>  646:     ?assertEqual(1, map_size(FullScope)),
<a name="647"/>  647:     pg:demonitor(?FUNCTION_NAME, Ref),
<a name="648"/>  648:     %% re-check
<a name="649"/>  649:     {_Ref, FullScope} = pg:monitor_scope(?FUNCTION_NAME),
<a name="650"/>  650:     peer:stop(Peer),
<a name="monitor_nonempty_scope-last_expr"/><a name="651"/>  651: <b>    exit</b>(Pid, normal).
<a name="652"/>  652: 
<a name="monitor_scope-0"/><a name="653"/>  653: <b>monitor_scope</b>() -&gt;
<a name="monitor_scope-last_expr"/><a name="654"/>  654:     [{doc, &quot;Tests monitor_scope/1 and demonitor/2&quot;}].
<a name="655"/>  655: 
<a name="monitor_scope-1"/><a name="656"/>  656: <b>monitor_scope</b>(Config) when is_list(Config) -&gt;
<a name="657"/>  657:     %% ensure that demonitoring returns 'false' when monitor is not installed
<a name="658"/>  658:     ?assertEqual(false, pg:demonitor(?FUNCTION_NAME, erlang:make_ref())),
<a name="659"/>  659:     InitialMonitor = fun (Scope) -&gt; {Ref, #{}} = pg:monitor_scope(Scope), Ref end,
<a name="660"/>  660:     SecondMonitor = fun (Scope, Group, Control) -&gt; {Ref, #{Group := [Control]}} = pg:monitor_scope(Scope), Ref end,
<a name="661"/>  661:     %% WHITE BOX: knowing pg state internals - only the original monitor should stay
<a name="662"/>  662:     DownMonitor = fun (Scope, Ref, Self) -&gt;
<a name="663"/>  663:         {state, _, _, _, ScopeMonitors, _, _} = sys:get_state(Scope),
<a name="664"/>  664:         ?assertEqual(#{Ref =&gt; Self}, ScopeMonitors, &quot;pg did not remove DOWNed scope monitor&quot;)
<a name="665"/>  665:                   end,
<a name="monitor_scope-last_expr"/><a name="666"/>  666: <b>    monitor_test_impl</b>(Config, ?FUNCTION_NAME, ?FUNCTION_ARITY, InitialMonitor,
<a name="667"/>  667:                       SecondMonitor, DownMonitor).
<a name="668"/>  668: 
<a name="monitor-1"/><a name="669"/>  669: <b>monitor</b>(Config) when is_list(Config) -&gt;
<a name="670"/>  670:     ExpectedGroup = {?FUNCTION_NAME, ?FUNCTION_ARITY},
<a name="671"/>  671:     InitialMonitor = fun (Scope) -&gt; {Ref, []} = pg:monitor(Scope, ExpectedGroup), Ref end,
<a name="672"/>  672:     SecondMonitor = fun (Scope, Group, Control) -&gt;
<a name="673"/>  673:         {Ref, [Control]} = pg:monitor(Scope, Group), Ref end,
<a name="674"/>  674:     DownMonitor = fun (Scope, Ref, Self) -&gt;
<a name="675"/>  675:         {state, _, _, _, _, GM, MG} = sys:get_state(Scope),
<a name="676"/>  676:         ?assertEqual(#{Ref =&gt; {Self, ExpectedGroup}}, GM, &quot;pg did not remove DOWNed group monitor&quot;),
<a name="677"/>  677:         ?assertEqual(#{ExpectedGroup =&gt; [{Self, Ref}]}, MG, &quot;pg did not remove DOWNed group&quot;)
<a name="678"/>  678:                   end,
<a name="monitor-last_expr"/><a name="679"/>  679: <b>    monitor_test_impl</b>(Config, ?FUNCTION_NAME, ExpectedGroup, InitialMonitor,
<a name="680"/>  680:                       SecondMonitor, DownMonitor).
<a name="681"/>  681: 
<a name="monitor_test_impl-6"/><a name="682"/>  682: <b>monitor_test_impl</b>(Config, Scope, Group, InitialMonitor, SecondMonitor, DownMonitor) -&gt;
<a name="683"/>  683:     Self = self(),
<a name="684"/>  684:     Ref = InitialMonitor(Scope),
<a name="685"/>  685:     %% local join
<a name="686"/>  686:     ?assertEqual(ok, pg:join(Scope, Group, Self)),
<a name="687"/>  687:     wait_message(Ref, join, Group, [Self], &quot;Local&quot;),
<a name="688"/>  688:     %% start second monitor (which has 1 local pid at the start)
<a name="689"/>  689:     ExtraMonitor = spawn_link(fun() -&gt; second_monitor(Scope, Group, Self, SecondMonitor) end),
<a name="690"/>  690:     Ref2 = receive {ExtraMonitor, SecondRef} -&gt; SecondRef end,
<a name="691"/>  691:     %% start a remote node, and a remote monitor
<a name="692"/>  692:     {Peer, Node} = spawn_node(Scope, Config),
<a name="693"/>  693:     ScopePid = whereis(Scope),
<a name="694"/>  694:     %% do not care about the remote monitor, it is started only to check DOWN handling
<a name="695"/>  695:     ThirdMonitor = spawn_link(Node, fun() -&gt; second_monitor(ScopePid, Group, Self, SecondMonitor) end),
<a name="696"/>  696:     Ref3 = receive {ThirdMonitor, ThirdRef} -&gt; ThirdRef end,
<a name="697"/>  697:     %% remote join
<a name="698"/>  698:     RemotePid = erlang:spawn(Node, forever()),
<a name="699"/>  699:     ?assertEqual(ok, rpc:call(Node, pg, join, [Scope, Group, [RemotePid, RemotePid]])),
<a name="700"/>  700:     wait_message(Ref, join, Group, [RemotePid, RemotePid], &quot;Remote&quot;),
<a name="701"/>  701:     %% verify leave event
<a name="702"/>  702:     ?assertEqual([Self], pg:get_local_members(Scope, Group)),
<a name="703"/>  703:     ?assertEqual(ok, pg:leave(Scope, Group, self())),
<a name="704"/>  704:     wait_message(Ref, leave, Group, [Self], &quot;Local&quot;),
<a name="705"/>  705:     %% remote leave
<a name="706"/>  706:     ?assertEqual(ok, rpc:call(Node, pg, leave, [Scope, Group, RemotePid])),
<a name="707"/>  707:     %% flush the local pg scope via remote pg (to ensure local pg finished sending notifications)
<a name="708"/>  708:     sync_via({?FUNCTION_NAME, Node}, ?FUNCTION_NAME),
<a name="709"/>  709:     wait_message(Ref, leave, Group, [RemotePid], &quot;Remote&quot;),
<a name="710"/>  710:     %% drop the ExtraMonitor - this keeps original and remote monitors
<a name="711"/>  711:     SecondMonMsgs = gen_server:call(ExtraMonitor, flush),
<a name="712"/>  712:     %% inspect the queue, it should contain double remote join, then single local and single remove leave
<a name="713"/>  713:     ExpectedLocalMessages = [
<a name="714"/>  714:         {Ref2, join, Group, [RemotePid, RemotePid]},
<a name="715"/>  715:         {Ref2, leave, Group, [Self]},
<a name="716"/>  716:         {Ref2, leave, Group, [RemotePid]}],
<a name="717"/>  717:     ?assertEqual(ExpectedLocalMessages, SecondMonMsgs, &quot;Local monitor failed&quot;),
<a name="718"/>  718:     %% inspect remote monitor queue
<a name="719"/>  719:     ThirdMonMsgs = gen_server:call(ThirdMonitor, flush),
<a name="720"/>  720:     ExpectedRemoteMessages = [
<a name="721"/>  721:         {Ref3, join, Group, [RemotePid, RemotePid]},
<a name="722"/>  722:         {Ref3, leave, Group, [Self]},
<a name="723"/>  723:         {Ref3, leave, Group, [RemotePid]}],
<a name="724"/>  724:     ?assertEqual(ExpectedRemoteMessages, ThirdMonMsgs, &quot;Remote monitor failed&quot;),
<a name="725"/>  725:     %% remote leave via stop (causes remote monitor to go DOWN)
<a name="726"/>  726:     ok = peer:stop(Peer),
<a name="727"/>  727:     wait_message(Ref, leave, Group, [RemotePid], &quot;Remote stop&quot;),
<a name="728"/>  728:     DownMonitor(Scope, Ref, Self),
<a name="729"/>  729:     %% demonitor
<a name="730"/>  730:     ?assertEqual(ok, pg:demonitor(Scope, Ref)),
<a name="731"/>  731:     ?assertEqual(false, pg:demonitor(Scope, Ref)),
<a name="732"/>  732:     %% ensure messages don't come
<a name="733"/>  733:     ?assertEqual(ok, pg:join(Scope, Group, Self)),
<a name="734"/>  734:     sync(Scope),
<a name="735"/>  735:     %% join should not be here
<a name="monitor_test_impl-last_expr"/><a name="736"/>  736: <b>    receive {Ref, Action, Group, [Self]} -&gt; ?assert</b>(false, lists:concat([&quot;Unexpected &quot;, Action, &quot;event&quot;]))
<a name="737"/>  737:     after 0 -&gt; ok end.
<a name="738"/>  738: 
<a name="wait_message-5"/><a name="739"/>  739: <b>wait_message</b>(Ref, Action, Group, Pids, Msg) -&gt;
<a name="wait_message-last_expr"/><a name="740"/>  740:     receive
<a name="741"/>  741:         {Ref, Action, Group, Pids} -&gt;
<a name="742"/>  742:             ok
<a name="743"/>  743:     after 1000 -&gt;
<a name="744"/>  744:         {messages, Msgs} = process_info(self(), messages),
<a name="745"/>  745:         ct:pal(&quot;Message queue: ~0p&quot;, [Msgs]),
<a name="746"/>  746:         ?assert(false, lists:flatten(io_lib:format(&quot;Expected ~s ~s for ~p&quot;, [Msg, Action, Group])))
<a name="747"/>  747:     end.
<a name="748"/>  748: 
<a name="second_monitor-4"/><a name="749"/>  749: <b>second_monitor</b>(Scope, Group, Control, SecondMonitor) -&gt;
<a name="750"/>  750:     Ref = SecondMonitor(Scope, Group, Control),
<a name="751"/>  751:     Control ! {self(), Ref},
<a name="second_monitor-last_expr"/><a name="752"/>  752: <b>    second_monitor</b>([]).
<a name="753"/>  753: 
<a name="second_monitor-1"/><a name="754"/>  754: <b>second_monitor</b>(Msgs) -&gt;
<a name="second_monitor-last_expr"/><a name="755"/>  755:     receive
<a name="756"/>  756:         {'$gen_call', Reply, flush} -&gt;
<a name="757"/>  757:             gen:reply(Reply, lists:reverse(Msgs));
<a name="758"/>  758:         Msg -&gt;
<a name="759"/>  759:             second_monitor([Msg | Msgs])
<a name="760"/>  760:     end.
<a name="761"/>  761: 
<a name="762"/>  762: <i>%% Test for GH-7625: monitor process that joined a group</i>
<a name="monitor_self-1"/><a name="763"/>  763: <b>monitor_self</b>(Config) when is_list(Config) -&gt;
<a name="764"/>  764:     F = fun() -&gt;
<a name="765"/>  765:         %% spawned process both monitor and group-joined
<a name="766"/>  766:         pg:monitor(?FUNCTION_NAME, ?FUNCTION_NAME),
<a name="767"/>  767:         pg:join(?FUNCTION_NAME, ?FUNCTION_NAME, self())
<a name="768"/>  768:         end,
<a name="769"/>  769:     {Pid, Mon} = spawn_monitor(F),
<a name="770"/>  770:     receive
<a name="771"/>  771:         {'DOWN', Mon, process, Pid, Reason} -&gt;
<a name="772"/>  772:             ?assertEqual(normal, Reason)
<a name="773"/>  773:     end,
<a name="774"/>  774:     %% if pg crashes, next expression fails the test
<a name="monitor_self-last_expr"/><a name="775"/>  775: <b>    sync</b>(?FUNCTION_NAME).
<a name="776"/>  776: 
<a name="777"/>  777: <i>%% check same process monitoring several things at once,</i>
<a name="778"/>  778: <i>%% and also joining a few groups</i>
<a name="multi_monitor-1"/><a name="779"/>  779: <b>multi_monitor</b>(Config) when is_list(Config) -&gt;
<a name="780"/>  780:     F = fun() -&gt;
<a name="781"/>  781:         Self = self(),
<a name="782"/>  782:         %% spawned process both monitor and group-joined
<a name="783"/>  783:         {RefOne, []} = pg:monitor(?FUNCTION_NAME, one),
<a name="784"/>  784:         {RefTwo, []} = pg:monitor(?FUNCTION_NAME, two),
<a name="785"/>  785:         {RefScope, _} = pg:monitor_scope(?FUNCTION_NAME),
<a name="786"/>  786:         ok = pg:join(?FUNCTION_NAME, one, Self),
<a name="787"/>  787:         ok = pg:join(?FUNCTION_NAME, two, Self),
<a name="788"/>  788:         sync(?FUNCTION_NAME),
<a name="789"/>  789:         %% ensure receiving 4 messages: two per group this process
<a name="790"/>  790:         [wait_message(Ref, join, Group, [Self], &quot;Local&quot;) || {Ref, Group} &lt;-
<a name="791"/>  791:             [{RefOne, one}, {RefScope, one}, {RefTwo, two}, {RefScope, two}]]
<a name="792"/>  792:         end,
<a name="793"/>  793:     {Pid, Mon} = spawn_monitor(F),
<a name="794"/>  794:     receive
<a name="795"/>  795:         {'DOWN', Mon, process, Pid, Reason} -&gt;
<a name="796"/>  796:             ?assertEqual(normal, Reason)
<a name="797"/>  797:     end,
<a name="798"/>  798:     %% if pg crashes, next expression fails the test
<a name="799"/>  799:     sync(?FUNCTION_NAME),
<a name="800"/>  800:     %% white box: pg should not have any group or scope monitors
<a name="801"/>  801:     {state, _, _, _, SM, GM, _} = sys:get_state(?FUNCTION_NAME),
<a name="802"/>  802:     ?assertEqual(#{}, SM),
<a name="multi_monitor-last_expr"/><a name="803"/>  803: <b>    ?assertEqual</b>(#{}, GM).
<a name="804"/>  804: 
<a name="protocol_upgrade-1"/><a name="805"/>  805: <b>protocol_upgrade</b>(Config) when is_list(Config) -&gt;
<a name="806"/>  806:     Scope = ?FUNCTION_NAME,
<a name="807"/>  807:     Group = ?FUNCTION_NAME,
<a name="808"/>  808:     {Peer, Node} = spawn_node(Scope, Config),
<a name="809"/>  809:     PgPid = rpc:call(Node, erlang, whereis, [Scope]),
<a name="810"/>  810: 
<a name="811"/>  811:     RemotePid = erlang:spawn(Node, forever()),
<a name="812"/>  812:     ok = rpc:call(Node, pg, join, [Scope, Group, RemotePid]),
<a name="813"/>  813: 
<a name="814"/>  814:     %% OTP 26:
<a name="815"/>  815:     %% Just do a white-box test and verify that pg accepts
<a name="816"/>  816:     %% a &quot;future&quot; discover message and replies with a sync.
<a name="817"/>  817:     PgPid ! {discover, self(), &quot;Protocol version (ignore me)&quot;},
<a name="818"/>  818:     {'$gen_cast', {sync, PgPid, [{Group, [RemotePid]}]}} = receive_any(),
<a name="819"/>  819: 
<a name="820"/>  820:     %% stop the peer
<a name="821"/>  821:     peer:stop(Peer),
<a name="protocol_upgrade-last_expr"/><a name="822"/>  822:     ok.
<a name="823"/>  823: 
<a name="824"/>  824: 
<a name="825"/>  825: <i>%%--------------------------------------------------------------------</i>
<a name="826"/>  826: <i>%% Test Helpers - start/stop additional Erlang nodes</i>
<a name="827"/>  827: 
<a name="receive_any-0"/><a name="828"/>  828: <b>receive_any</b>() -&gt;
<a name="receive_any-last_expr"/><a name="829"/>  829:     receive M -&gt; M end.
<a name="830"/>  830: 
<a name="831"/>  831: <i>%% flushes GS (GenServer) queue, ensuring that all prior</i>
<a name="832"/>  832: <i>%%  messages have been processed</i>
<a name="sync-1"/><a name="833"/>  833: <b>sync</b>(GS) -&gt;
<a name="sync-last_expr"/><a name="834"/>  834: <b>    _ = sys:log</b>(GS, get).
<a name="835"/>  835: 
<a name="836"/>  836: <i>%% flushes GS queue from the point of view of a registered process RegName</i>
<a name="837"/>  837: <i>%%  running on the Node.</i>
<a name="sync_via-2"/><a name="838"/>  838: <b>sync_via</b>({RegName, Node}, GS) -&gt;
<a name="839"/>  839:     MyNode = node(),
<a name="840"/>  840:     rpc:call(Node, sys, replace_state,
<a name="841"/>  841:              [RegName, fun (S) -&gt; (catch sys:get_state({GS, MyNode})), S end]);
<a name="842"/>  842: 
<a name="843"/>  843: <i>%% flush remote GS queue from local process RegName</i>
<a name="844"/>  844: <b>sync_via</b>(RegName, {GS, Node}) -&gt;
<a name="sync_via-last_expr"/><a name="845"/>  845: <b>    sys:replace_state</b>(RegName,
<a name="846"/>  846:                       fun (S) -&gt; _R = (catch sys:get_state({GS, Node})),
<a name="847"/>  847:                                  %%io:format(&quot;sync_via: ~p -&gt; R = ~p\n&quot;, [{GS, Node},_R]),
<a name="848"/>  848:                                  S
<a name="849"/>  849:                       end).
<a name="850"/>  850: 
<a name="ensure_peers_info-2"/><a name="851"/>  851: <b>ensure_peers_info</b>(Scope, Nodes) -&gt;
<a name="852"/>  852:     %% Ensures that pg server on local node has gotten info from
<a name="853"/>  853:     %% pg servers on all Peer nodes passed as argument (assuming
<a name="854"/>  854:     %% no connection failures).
<a name="855"/>  855:     %% 
<a name="856"/>  856:     %% This function assumes that all nodeup messages has been
<a name="857"/>  857:     %% delivered to all local recipients (pg server) when called.
<a name="858"/>  858:     %%
<a name="859"/>  859:     %% Note that this relies on current ERTS implementation; not
<a name="860"/>  860:     %% language guarantees.
<a name="861"/>  861:     %%
<a name="862"/>  862: 
<a name="863"/>  863:     sync(Scope),
<a name="864"/>  864:     %% Known: nodeup handled and discover sent to Peer
<a name="865"/>  865: 
<a name="866"/>  866:     lists:foreach(fun (Node) -&gt; sync({Scope, Node}) end, Nodes),
<a name="867"/>  867:     %% Known: nodeup handled by Peers and discover sent to local
<a name="868"/>  868:     %% Known: discover received/handled by Peers and sync sent to local
<a name="869"/>  869:     %% Known: discover received from Peer
<a name="870"/>  870:     %% Known: sync received from Peer
<a name="871"/>  871: 
<a name="872"/>  872:     sync(Scope),
<a name="873"/>  873:     %% Known: discover handled from Peers and sync sent to Peers
<a name="874"/>  874:     %% Known: sync from Peers handled
<a name="ensure_peers_info-last_expr"/><a name="875"/>  875:     ok.
<a name="876"/>  876: 
<a name="877"/>  877: <b>-ifdef</b>(CURRENTLY_UNUSED_BUT_SERVES_AS_DOC).
<a name="878"/>  878: 
<a name="879"/>  879: ensure_synced(Scope, Nodes) -&gt;
<a name="880"/>  880:     %% Ensures that the pg server on local node have synced
<a name="881"/>  881:     %% with pg servers on all Peer nodes (assuming no connection
<a name="882"/>  882:     %% failures).
<a name="883"/>  883:     %% 
<a name="884"/>  884:     %% This function assumes that all nodeup messages has been
<a name="885"/>  885:     %% delivered to all local recipients (pg server) when called.
<a name="886"/>  886:     %%
<a name="887"/>  887:     %% Note that this relies on current ERTS implementation; not
<a name="888"/>  888:     %% language guarantees.
<a name="889"/>  889:     %%
<a name="890"/>  890:     ensure_peer_info(Scope, Node),
<a name="891"/>  891:     %% Known: local has gotten info from all Peers
<a name="892"/>  892:     %% Known: discover from Peers handled and sync sent to Peers
<a name="893"/>  893:     lists:foreach(fun (Node) -&gt; sync({Scope, Node}) end, Nodes),
<a name="894"/>  894:     %% Known: sync from local handled by Peers
<a name="895"/>  895:     ok.
<a name="896"/>  896: 
<a name="897"/>  897: -endif.
<a name="898"/>  898: 
<a name="disconnect_nodes-1"/><a name="899"/>  899: <b>disconnect_nodes</b>(Nodes) -&gt;
<a name="900"/>  900:     %% The following is not a language guarantee, but internal
<a name="901"/>  901:     %% knowledge about current implementation of ERTS and pg.
<a name="902"/>  902:     %%
<a name="903"/>  903:     %% The pg server reacts on 'DOWN's via process monitors of
<a name="904"/>  904:     %% its peers. These are delivered before 'nodedown's from
<a name="905"/>  905:     %% net_kernel:monitor_nodes(). That is, by waiting for
<a name="906"/>  906:     %% 'nodedown' from net_kernel:monitor_nodes() we know that
<a name="907"/>  907:     %% the 'DOWN' has been delivered to the pg server.
<a name="908"/>  908:     %%
<a name="909"/>  909:     %% We do this in a separate process to avoid stray
<a name="910"/>  910:     %% nodeup/nodedown messages in the test process after
<a name="911"/>  911:     %% the operation...
<a name="912"/>  912:     F = fun () -&gt;
<a name="913"/>  913:                 ok = net_kernel:monitor_nodes(true),
<a name="914"/>  914:                 lists:foreach(fun (Node) -&gt;
<a name="915"/>  915:                                       true = erlang:disconnect_node(Node)
<a name="916"/>  916:                               end,
<a name="917"/>  917:                               Nodes),
<a name="918"/>  918:                 lists:foreach(fun (Node) -&gt;
<a name="919"/>  919:                                       receive {nodedown, Node} -&gt; ok end
<a name="920"/>  920:                               end,
<a name="921"/>  921:                               Nodes)
<a name="922"/>  922:         end,
<a name="923"/>  923:     {Pid, Mon} = spawn_monitor(F),
<a name="924"/>  924:     receive
<a name="925"/>  925:         {'DOWN', Mon, process, Pid, Reason} -&gt;
<a name="926"/>  926:             ?assertEqual(normal, Reason)
<a name="927"/>  927:     end,
<a name="disconnect_nodes-last_expr"/><a name="928"/>  928:     ok.
<a name="929"/>  929: 
<a name="930"/>  930: <i>%% @doc Kills process Pid and waits for it to exit using monitor,</i>
<a name="931"/>  931: <i>%%      and yields after (for 1 ms).</i>
<a name="932"/>  932: <b>-spec stop_proc</b>(pid()) -&gt; ok.
<a name="stop_proc-1"/><a name="933"/>  933: <b>stop_proc</b>(Pid) -&gt;
<a name="934"/>  934:     monitor(process, Pid),
<a name="935"/>  935:     erlang:exit(Pid, kill),
<a name="stop_proc-last_expr"/><a name="936"/>  936:     receive
<a name="937"/>  937:         {'DOWN', _MRef, process, Pid, _Info} -&gt;
<a name="938"/>  938:             timer:sleep(1)
<a name="939"/>  939:     end.
<a name="940"/>  940: 
<a name="forever-0"/><a name="941"/>  941: <b>forever</b>() -&gt;
<a name="942"/>  942:     Parent = self(),
<a name="forever-last_expr"/><a name="943"/>  943: <b>    fun</b>() -&gt;
<a name="944"/>  944:             %% forever() is used both locally and on a remote node,
<a name="945"/>  945:             %% if used locally, we want to terminate when the
<a name="946"/>  946:             %% parent terminates in order to not leak process to
<a name="947"/>  947:             %% later test cases
<a name="948"/>  948:             Ref = monitor(process,Parent),
<a name="949"/>  949:             receive
<a name="950"/>  950:                 {'DOWN',Ref,_,_,_} when node() =:= node(Parent) -&gt;
<a name="951"/>  951:                     ok
<a name="952"/>  952:             end
<a name="953"/>  953:     end.
<a name="954"/>  954: 
<a name="955"/>  955: <i>%% Spawn a sleeping process on remote node.</i>
<a name="956"/>  956: <i>%% Works on older nodes also without having to run any specially compiled code.</i>
<a name="spawn_sleeper_at-1"/><a name="957"/>  957: <b>spawn_sleeper_at</b>(Node) when Node =/= node() -&gt;
<a name="spawn_sleeper_at-last_expr"/><a name="958"/>  958: <b>    spawn</b>(Node, erlang, hibernate, [?MODULE,dummy,[]]).
<a name="959"/>  959: 
<a name="sleeper_mfa-0"/><a name="960"/>  960: <b>sleeper_mfa</b>() -&gt;
<a name="sleeper_mfa-last_expr"/><a name="961"/>  961:     [erlang, hibernate, [?MODULE,dummy,[]]].
<a name="962"/>  962: 
<a name="spawn_node-2"/><a name="963"/>  963: <b>spawn_node</b>(TestCase, Config) -&gt;
<a name="964"/>  964:     {Peer, Node} = spawn_disconnected_node(TestCase, TestCase, Config),
<a name="965"/>  965:     true = net_kernel:connect_node(Node),
<a name="spawn_node-last_expr"/><a name="966"/>  966:     {Peer, Node}.
<a name="967"/>  967: 
<a name="spawn_disconnected_node-3"/><a name="968"/>  968: <b>spawn_disconnected_node</b>(Scope, TestCase, Config) -&gt;
<a name="969"/>  969:     Opts = #{name =&gt; ?CT_PEER_NAME(TestCase),
<a name="970"/>  970:              connection =&gt; 0,
<a name="971"/>  971:              args =&gt; [&quot;-connect_all&quot;, &quot;false&quot;,
<a name="972"/>  972:                       &quot;-kernel&quot;, &quot;dist_auto_connect&quot;, &quot;never&quot;]},
<a name="973"/>  973:     {ok, Peer, Node} =
<a name="974"/>  974:         case proplists:get_value(otp_release, Config) of
<a name="975"/>  975:             undefined -&gt;
<a name="976"/>  976:                 ?CT_PEER(Opts);
<a name="977"/>  977:             Release -&gt;
<a name="978"/>  978:                 TcPrivDir = filename:join(proplists:get_value(priv_dir, Config),
<a name="979"/>  979:                                           TestCase),
<a name="980"/>  980:                 ok = ensure_dir(TcPrivDir),
<a name="981"/>  981:                 ?CT_PEER_REL(Opts, Release, TcPrivDir)
<a name="982"/>  982:         end,
<a name="983"/>  983:     {ok, _Pid} = peer:call(Peer, pg, start, [Scope]),
<a name="spawn_disconnected_node-last_expr"/><a name="984"/>  984:     {Peer, Node}.
<a name="985"/>  985: 
<a name="ensure_dir-1"/><a name="986"/>  986: <b>ensure_dir</b>(Dir) -&gt;
<a name="ensure_dir-last_expr"/><a name="987"/>  987: <b>    case file:make_dir</b>(Dir) of
<a name="988"/>  988:         ok -&gt; ok;
<a name="989"/>  989:         {error, eexist} -&gt; ok;
<a name="990"/>  990:         E -&gt; E
<a name="991"/>  991:     end.
<a name="992"/>  992: 
<a name="993"/>  993: 
<a name="994"/>  994: <i>%%--------------------------------------------------------------------</i>
<a name="995"/>  995: <i>%% Debug Helpers</i>
<a name="996"/>  996: 
<a name="997"/>  997: <i>%% Add test cases here to enable 'receive' trace of the local pg process</i>
<a name="traced_testcases-0"/><a name="traced_testcases-last_expr"/><a name="998"/>  998: <b>traced_testcases</b>() -&gt; [].
<a name="999"/>  999: 
<a name="trace_start-3"/><a name="1000"/> 1000: <b>trace_start</b>(TestCase, Config, Tracee) -&gt;
<a name="trace_start-last_expr"/><a name="1001"/> 1001: <b>    case lists:member</b>(TestCase, traced_testcases()) of
<a name="1002"/> 1002:         true -&gt;
<a name="1003"/> 1003:             Tracer = spawn_link(fun() -&gt; tracer() end),
<a name="1004"/> 1004:             1 = erlang:trace(Tracee, true, ['receive', {tracer, Tracer}, timestamp]),
<a name="1005"/> 1005:             [{tracer, Tracer} | Config];
<a name="1006"/> 1006:         false -&gt;
<a name="1007"/> 1007:             Config
<a name="1008"/> 1008:     end.
<a name="1009"/> 1009: 
<a name="trace_end-1"/><a name="1010"/> 1010: <b>trace_end</b>(Config) -&gt;
<a name="trace_end-last_expr"/><a name="1011"/> 1011: <b>    case proplists:get_value</b>(tracer, Config) of
<a name="1012"/> 1012:         undefined -&gt; ok;
<a name="1013"/> 1013:         Tracer -&gt;
<a name="1014"/> 1014:             Mon = erlang:monitor(process, Tracer),
<a name="1015"/> 1015:             Tracer ! flush,
<a name="1016"/> 1016:             normal = receive
<a name="1017"/> 1017:                          {'DOWN', Mon, process, Tracer, R} -&gt; R
<a name="1018"/> 1018:                      end
<a name="1019"/> 1019:     end.
<a name="1020"/> 1020: 
<a name="tracer-0"/><a name="1021"/> 1021: <b>tracer</b>() -&gt;
<a name="1022"/> 1022:     receive flush -&gt; ok end,
<a name="1023"/> 1023:     io:format(&quot;Flush trace messages:\n&quot;),
<a name="tracer-last_expr"/><a name="1024"/> 1024: <b>    tracer_flush</b>().
<a name="1025"/> 1025: 
<a name="tracer_flush-0"/><a name="1026"/> 1026: <b>tracer_flush</b>() -&gt;
<a name="tracer_flush-last_expr"/><a name="1027"/> 1027:     receive M -&gt;
<a name="1028"/> 1028:             io:format(&quot;~p\n&quot;, [M]),
<a name="1029"/> 1029:             tracer_flush()
<a name="1030"/> 1030:     after 0 -&gt;
<a name="1031"/> 1031:             io:format(&quot;Flush done.\n&quot;)
<a name="1032"/> 1032:     end.
</pre>
<script>
var hash = window.location.hash.substring(1);
var anchor = document.getElementsByName(hash);
anchor[0].style.backgroundColor="orange";
</script>
</body>
</html>
